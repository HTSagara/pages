"use strict";(self.webpackChunkneo_mjs=self.webpackChunkneo_mjs||[]).push([[666,96],{96:(e,t,s)=>{s.r(t),s.d(t,{default:()=>o});var a=s(162);class r extends a.A{static config={className:"Neo.main.addon.Base",isMainThreadAddon:!0}}Neo.setupClass(r);const o=r},666:(e,t,s)=>{s.r(t),s.d(t,{default:()=>n});var a=s(96),r=s(160);class o extends a.default{static config={className:"Neo.main.addon.IntersectionObserver",remote:{app:["disconnect","observe","register"]}};cache={};map={};disconnect(e){this.map[e.id]?.disconnect()}findTopmostItem(e,t){let s,a,o,n,d=this;e.forEach((e=>{n=e.target,s=n.dataset&&{...n.dataset}||null,a=r.A.getPathFromElement(e.target).map((e=>r.A.getTargetData(e))),o=n.getBoundingClientRect(),o.y<200&&(e.isIntersecting,d.sendMessage({data:s,id:t.rootId,isIntersecting:!0,path:a,targetId:n.id}))}))}isVisible(e,t){let s,a,o,n=this;e.forEach((e=>{o=e.target,s=o.dataset&&{...o.dataset}||null,a=r.A.getPathFromElement(e.target).map((e=>r.A.getTargetData(e))),e.isIntersecting&&n.sendMessage({data:s,id:t.rootId,isIntersecting:!0,path:a,targetId:o.id})}))}observe(e){let t=this.cache,{id:s,observe:a}=e,r=this.map[e.id],o=[];return Neo.isArray(a)||(a=[a]),a.forEach((e=>{o.push(...document.querySelectorAll(e))})),r?(e.disconnect&&r.disconnect(),o.forEach((e=>{r.observe(e)}))):(t[s]||(t[s]=[]),t[s].push(e)),!!r}register(e){let t,s=this,{cache:a}=s,{id:r,observe:o}=e;s.map[r]=t=new IntersectionObserver(s[e.callback].bind(s),{root:document.querySelector(e.root),rootMargin:e.rootMargin||"0px",threshold:e.threshold||0}),t.rootId=e.id,o&&s.observe({id:r,observe:o}),a[r]&&(a[r].forEach((e=>s.observe(e))),delete a[r])}sendMessage(e){Neo.worker.Manager.sendMessage("app",{action:"domEvent",eventName:"intersect",data:e})}}Neo.setupClass(o);const n=o}}]);