"use strict";(self.webpackChunkneo_mjs=self.webpackChunkneo_mjs||[]).push([[735],{735:(e,t,s)=>{s.r(t),s.d(t,{default:()=>c});var r=s(703),i=s(583);class a extends i.A{static config={className:"Neo.util.Array"};static add(e,t){return Array.isArray(t)||(t=[t]),t.forEach((t=>{e.includes(t)||e.push(t)})),e}static difference(e=[],t=[]){return e.filter((e=>!t.includes(e)))}static hasItem(e,t){return e.includes(t)}static insert(e,t,s){Array.isArray(s)||(s=[s]);let r,i,a=s.length-1;for(;a>-1;a--)i=s[a],r=e.indexOf(i),t!==r&&(r>-1?this.move(e,r,t):e.splice(t,0,i));return e}static intersection(e=[],t=[]){return e.filter((e=>t.includes(e)))}static move(e,t,s){return t===s||(t>=e.length&&(t=e.length-1),e.splice(s,0,e.splice(t,1)[0])),e}static remove(e,t){let s;return Array.isArray(t)||(t=[t]),t.forEach((t=>{s=e.indexOf(t),s>-1&&e.splice(s,1)})),e}static removeAdd(e,t,s){return this.remove(e,t),this.add(e,s)}static toggle(e,t,s=!this.hasItem(e,t)){return this[s?"add":"remove"](e,t)}static union(){return[...new Set(Array.prototype.concat(...arguments))]}static unshift(e,t){return Array.isArray(t)||(t=[t]),t.forEach((t=>{e.includes(t)||e.unshift(t)})),e}}const n=Neo.setupClass(a);class o extends r.A{static config={className:"Neo.manager.rpc.Message",singleton:!0,sorters:[{direction:"ASC",property:"id"}]};endPointTimeouts=[];messageId=1;requestBuffer=20;socketConnections={};transactionId=1;onMessage(e){let t=Neo.manager.rpc.Api.get(`${e.service}.${e.method}`);return this[`onMessage${Neo.capitalize(t.type)}`](e,t)}onMessageAjax(e,t){return new Promise(((s,r)=>{let i=this,{url:a}=t;i.register({id:i.messageId,method:e.method,params:e.params,reject:r,resolve:s,service:e.service,transactionId:0,url:a}),i.messageId++,i.endPointTimeouts.includes(a)||(i.endPointTimeouts.push(a),i.timeout(i.requestBuffer).then((()=>{i.resolveBufferTimeout(a)})))}))}async onMessageWebsocket(e,t){let r=this,{url:i}=t,a=r.socketConnections[i];if(!a){let e=await s.e(827).then(s.bind(s,827));r.socketConnections[i]=a=Neo.create(e.default,{serverAddress:i})}return await a.promiseMessage(e)}async resolveBufferTimeout(e){let t,s=this,r=[],i=s.find({transactionId:0,url:e}),a=[],{transactionId:o}=s;i.forEach((e=>{e.transactionId=o,r.push(e.id),a.push({id:e.id,method:e.method,params:e.params,service:e.service})})),n.remove(s.endPointTimeouts,e),s.transactionId++,t=await Neo.Fetch.request(e,{},"post",JSON.stringify({tid:o,requests:a})),i.forEach((e=>{e.resolve()})),s.remove(r)}}const c=Neo.setupClass(o)}}]);