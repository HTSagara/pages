"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_addon_Stylesheet_mjs"],{

/***/ "./src/main/addon/Base.mjs":
/*!*********************************!*\
  !*** ./src/main/addon/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for main thread addons
 * @class Neo.main.addon.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.Base'
         * @protected
         */
        className: 'Neo.main.addon.Base',
        /**
         * An identifier for core.Base to get handled like singletons for remote method access
         * @member {Boolean} isMainThreadAddon=true
         * @protected
         */
        isMainThreadAddon: true
    }
}

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/main/addon/Stylesheet.mjs":
/*!***************************************!*\
  !*** ./src/main/addon/Stylesheet.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/main/addon/Base.mjs");


/**
 * Logic to work with stylesheets, e.g. apply & switch Neo based themes
 * main.addon.HighlightJS requires this file
 * @class Neo.main.addon.Stylesheet
 * @extends Neo.main.addon.Base
 */
class Stylesheet extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {String} dynamicStyleSheetId='neo-dynamic-stylesheet'
     * @protected
     */
    dynamicStyleSheetId = 'neo-dynamic-stylesheet';

    static config = {
        /**
         * @member {String} className='Neo.main.addon.Stylesheet'
         * @protected
         */
        className: 'Neo.main.addon.Stylesheet',
        /**
         * Remote method access for other workers
         * @member {Object} remote={app: [//...]}
         * @protected
         */
        remote: {
            app: [
                'addThemeFiles',
                'createStyleSheet',
                'deleteCssRules',
                'insertCssRules',
                'setCssVariable',
                'swapStyleSheet'
            ]
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let neoConfig = Neo.config,
            faPath;

        if (neoConfig.useFontAwesome) {
            if (neoConfig.environment === 'development') {
                faPath = neoConfig.basePath + 'node_modules/@fortawesome/fontawesome-free/css/all.min.css';
            } else {
                faPath = neoConfig.basePath.substr(6) + 'resources/fontawesome-free/css/all.min.css';
            }

            this.createStyleSheet(null, null, faPath);
        }

        if (neoConfig.themes.length > 0 && neoConfig.themes[0] !== '') {
            this.addGlobalCss();
        }
    }

    /**
     *
     */
    addGlobalCss() {
        let config   = Neo.config,
            themes   = config.themes,
            folders  = ['src', ...themes],
            env      = config.environment,
            path      = env.startsWith('dist/') ? '' : config.appPath.includes('docs') ? `../dist/${env}/` : `../../dist/${env}/`,
            rootPath = config.basePath.substr(6);

        document.body.classList.add(themes[0]);

        folders.forEach(folder => {
            if (folder.startsWith('neo-')) {
                folder = folder.substring(4);
            }

            this.createStyleSheet(
                null,
                null,
                `${rootPath}${path}css/${folder}/Global.css`
            );
        });
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {String} data.className
     * @param {String[]} data.folders
     */
    addThemeFiles(data) {
        let className = data.className,
            config    = Neo.config,
            env       = config.environment,
            path      = env.startsWith('dist/') ? '' : config.appPath.includes('docs') ? `../dist/${env}/` : `../../dist/${env}/`,
            rootPath  = config.basePath.substr(6);

        if (className.startsWith('Neo.')) {
            className = className.substring(4);
        }

        className = className.split('.').join('/');

        data.folders.forEach(folder => {
            if (folder === 'src' || folder.includes('theme-') && config.themes.includes(`neo-${folder}`)) {
                this.createStyleSheet(
                    null,
                    null,
                    `${rootPath}${path}css/${folder}/${className}.css`
                )
            }
        })
    }

    /**
     * Use either name for a neo theme (e.g. 'neo-theme-dark.css') or pass a href
     * @param {String} [name]
     * @param {String} [id]
     * @param {String} [href]
     */
    createStyleSheet(name, id, href) {
        if (!name && !href) {
            throw new Error('createStyleSheet: you need to either pass a name or a href');
        }

        const link = document.createElement('link'),
              env  = Neo.config.environment,
              path = env.startsWith('dist/') ? env : ('dist/' + env),
              url  = href ? href : Neo.config.basePath + path + '/' + name;

        Object.assign(link, {
            href: url,
            rel : 'stylesheet',
            type: 'text/css'
        });

        if (id) {
            link.id = id;
        }

        document.head.appendChild(link);
    }

    /**
     * @param {Object} data
     * @param {Array} data.rules
     * @protected
     */
    deleteCssRules(data) {
        let styleEl    = document.getElementById(this.dynamicStyleSheetId),
            styleSheet = styleEl.sheet,
            cssRules   = styleSheet.cssRules,
            i          = 0,
            len        = data.rules.length,
            j, rulesLen;

        for (; i < len; i++) {
            j        = 0;
            rulesLen = cssRules.length;

            for (; j < rulesLen; j++) {
                if (cssRules[j].selectorText === data.rules[i]) {
                    styleSheet.deleteRule(j);
                    break;
                }
            }
        }
    }

    /**
     * @param {String} token
     * @returns {Boolean}
     */
    hasStyleSheet(token) {
        let i   = 0,
            len = document.styleSheets.length,
            sheet;

        for (; i < len; i++) {
            sheet = document.styleSheets[i];
            if (sheet.href?.includes(token)) {
                return true;
            }
        }

        return false;
    }

    /**
     * @param {Object} data
     * @param {Array} data.rules
     * @protected
     */
    insertCssRules(data) {
        let styleEl = document.getElementById(this.dynamicStyleSheetId),
            i     = 0,
            len   = data.rules.length,
            styleSheet;

        if (!styleEl) {
            styleEl = document.createElement('style');

            styleEl.id = this.dynamicStyleSheetId;
            document.head.appendChild(styleEl);
        }

        styleSheet = styleEl.sheet;

        for (; i < len; i++) {
            styleSheet.insertRule(data.rules[i], styleSheet.cssRules.length);
        }
    }

    /**
     * @param {Object} opts
     * @param {String[]} opts.included
     * @param {String[]} opts.excluded
     */
    removeStyleSheets(opts) {
        let i        = 0,
            len      = document.styleSheets.length,
            included = opts.included || [],
            excluded = opts.included || [],
            sheet, removeSheet;

        for (; i < len; i++) {
            sheet = document.styleSheets[i];

            removeSheet = true;

            if (sheet.href) {
                excluded.forEach(name => {
                    if (sheet.href.includes(name)) {
                        removeSheet = false;
                    }
                });

                if (removeSheet) {
                    included.forEach(name => {
                        if (!sheet.href.includes(name)) {
                            removeSheet = false;
                        }
                    });

                    if (removeSheet) {
                        sheet.ownerNode.parentNode.removeChild(sheet.ownerNode);
                    }
                }
            }
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.key
     * @param {String} [data.priority] optionally pass 'important'
     * @param {String} data.theme
     * @param {String} data.value
     */
    setCssVariable(data) {
        let key = data.key,
            rule, sheet;

        if (!key.startsWith('--')) {
            key = '--' + key;
        }

        for (sheet of document.styleSheets) {
            if (sheet.href.includes(data.theme)) {
                for (rule of sheet.cssRules) {
                    if (Neo.typeOf(rule) === 'CSSStyleRule') {
                        if (rule.style.getPropertyValue(key) !== '') {
                            rule.style.setProperty(key, data.value, data.priority);
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    }

    /**
     * @param {Object} data
     * @param {String} data.href
     * @param {String} data.id
     */
    swapStyleSheet(data) {
        document.getElementById(data.id).setAttribute('href', data.href);
    }
}

Neo.setupClass(Stylesheet);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stylesheet);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fYWRkb25fU3R5bGVzaGVldF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQVE7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLElBQUksRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFJO0FBQzdCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csSUFBSSxtQkFBbUIsSUFBSTtBQUMvSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxFQUFFLEtBQUssTUFBTSxPQUFPO0FBQ2hEO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csSUFBSSxtQkFBbUIsSUFBSTtBQUMvSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrRkFBK0YsT0FBTztBQUN0RztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxFQUFFLEtBQUssTUFBTSxPQUFPLEdBQUcsVUFBVTtBQUNqRTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYWluL2FkZG9uL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9hZGRvbi9TdHlsZXNoZWV0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29yZUJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbWFpbiB0aHJlYWQgYWRkb25zXG4gKiBAY2xhc3MgTmVvLm1haW4uYWRkb24uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uYWRkb24uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpZGVudGlmaWVyIGZvciBjb3JlLkJhc2UgdG8gZ2V0IGhhbmRsZWQgbGlrZSBzaW5nbGV0b25zIGZvciByZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc01haW5UaHJlYWRBZGRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzTWFpblRocmVhZEFkZG9uOiB0cnVlXG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhCYXNlKTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIExvZ2ljIHRvIHdvcmsgd2l0aCBzdHlsZXNoZWV0cywgZS5nLiBhcHBseSAmIHN3aXRjaCBOZW8gYmFzZWQgdGhlbWVzXG4gKiBtYWluLmFkZG9uLkhpZ2hsaWdodEpTIHJlcXVpcmVzIHRoaXMgZmlsZVxuICogQGNsYXNzIE5lby5tYWluLmFkZG9uLlN0eWxlc2hlZXRcbiAqIEBleHRlbmRzIE5lby5tYWluLmFkZG9uLkJhc2VcbiAqL1xuY2xhc3MgU3R5bGVzaGVldCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gZHluYW1pY1N0eWxlU2hlZXRJZD0nbmVvLWR5bmFtaWMtc3R5bGVzaGVldCdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZHluYW1pY1N0eWxlU2hlZXRJZCA9ICduZW8tZHluYW1pYy1zdHlsZXNoZWV0JztcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgd29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZT17YXBwOiBbLy8uLi5dfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdhZGRUaGVtZUZpbGVzJyxcbiAgICAgICAgICAgICAgICAnY3JlYXRlU3R5bGVTaGVldCcsXG4gICAgICAgICAgICAgICAgJ2RlbGV0ZUNzc1J1bGVzJyxcbiAgICAgICAgICAgICAgICAnaW5zZXJ0Q3NzUnVsZXMnLFxuICAgICAgICAgICAgICAgICdzZXRDc3NWYXJpYWJsZScsXG4gICAgICAgICAgICAgICAgJ3N3YXBTdHlsZVNoZWV0J1xuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG5lb0NvbmZpZyA9IE5lby5jb25maWcsXG4gICAgICAgICAgICBmYVBhdGg7XG5cbiAgICAgICAgaWYgKG5lb0NvbmZpZy51c2VGb250QXdlc29tZSkge1xuICAgICAgICAgICAgaWYgKG5lb0NvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgIGZhUGF0aCA9IG5lb0NvbmZpZy5iYXNlUGF0aCArICdub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lLWZyZWUvY3NzL2FsbC5taW4uY3NzJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFQYXRoID0gbmVvQ29uZmlnLmJhc2VQYXRoLnN1YnN0cig2KSArICdyZXNvdXJjZXMvZm9udGF3ZXNvbWUtZnJlZS9jc3MvYWxsLm1pbi5jc3MnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVN0eWxlU2hlZXQobnVsbCwgbnVsbCwgZmFQYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZW9Db25maWcudGhlbWVzLmxlbmd0aCA+IDAgJiYgbmVvQ29uZmlnLnRoZW1lc1swXSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkR2xvYmFsQ3NzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEdsb2JhbENzcygpIHtcbiAgICAgICAgbGV0IGNvbmZpZyAgID0gTmVvLmNvbmZpZyxcbiAgICAgICAgICAgIHRoZW1lcyAgID0gY29uZmlnLnRoZW1lcyxcbiAgICAgICAgICAgIGZvbGRlcnMgID0gWydzcmMnLCAuLi50aGVtZXNdLFxuICAgICAgICAgICAgZW52ICAgICAgPSBjb25maWcuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBwYXRoICAgICAgPSBlbnYuc3RhcnRzV2l0aCgnZGlzdC8nKSA/ICcnIDogY29uZmlnLmFwcFBhdGguaW5jbHVkZXMoJ2RvY3MnKSA/IGAuLi9kaXN0LyR7ZW52fS9gIDogYC4uLy4uL2Rpc3QvJHtlbnZ9L2AsXG4gICAgICAgICAgICByb290UGF0aCA9IGNvbmZpZy5iYXNlUGF0aC5zdWJzdHIoNik7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKHRoZW1lc1swXSk7XG5cbiAgICAgICAgZm9sZGVycy5mb3JFYWNoKGZvbGRlciA9PiB7XG4gICAgICAgICAgICBpZiAoZm9sZGVyLnN0YXJ0c1dpdGgoJ25lby0nKSkge1xuICAgICAgICAgICAgICAgIGZvbGRlciA9IGZvbGRlci5zdWJzdHJpbmcoNCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3R5bGVTaGVldChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgYCR7cm9vdFBhdGh9JHtwYXRofWNzcy8ke2ZvbGRlcn0vR2xvYmFsLmNzc2BcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGRhdGEuZm9sZGVyc1xuICAgICAqL1xuICAgIGFkZFRoZW1lRmlsZXMoZGF0YSkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gZGF0YS5jbGFzc05hbWUsXG4gICAgICAgICAgICBjb25maWcgICAgPSBOZW8uY29uZmlnLFxuICAgICAgICAgICAgZW52ICAgICAgID0gY29uZmlnLmVudmlyb25tZW50LFxuICAgICAgICAgICAgcGF0aCAgICAgID0gZW52LnN0YXJ0c1dpdGgoJ2Rpc3QvJykgPyAnJyA6IGNvbmZpZy5hcHBQYXRoLmluY2x1ZGVzKCdkb2NzJykgPyBgLi4vZGlzdC8ke2Vudn0vYCA6IGAuLi8uLi9kaXN0LyR7ZW52fS9gLFxuICAgICAgICAgICAgcm9vdFBhdGggID0gY29uZmlnLmJhc2VQYXRoLnN1YnN0cig2KTtcblxuICAgICAgICBpZiAoY2xhc3NOYW1lLnN0YXJ0c1dpdGgoJ05lby4nKSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnN1YnN0cmluZyg0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5zcGxpdCgnLicpLmpvaW4oJy8nKTtcblxuICAgICAgICBkYXRhLmZvbGRlcnMuZm9yRWFjaChmb2xkZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGZvbGRlciA9PT0gJ3NyYycgfHwgZm9sZGVyLmluY2x1ZGVzKCd0aGVtZS0nKSAmJiBjb25maWcudGhlbWVzLmluY2x1ZGVzKGBuZW8tJHtmb2xkZXJ9YCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN0eWxlU2hlZXQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGAke3Jvb3RQYXRofSR7cGF0aH1jc3MvJHtmb2xkZXJ9LyR7Y2xhc3NOYW1lfS5jc3NgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBlaXRoZXIgbmFtZSBmb3IgYSBuZW8gdGhlbWUgKGUuZy4gJ25lby10aGVtZS1kYXJrLmNzcycpIG9yIHBhc3MgYSBocmVmXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbaWRdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtocmVmXVxuICAgICAqL1xuICAgIGNyZWF0ZVN0eWxlU2hlZXQobmFtZSwgaWQsIGhyZWYpIHtcbiAgICAgICAgaWYgKCFuYW1lICYmICFocmVmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVN0eWxlU2hlZXQ6IHlvdSBuZWVkIHRvIGVpdGhlciBwYXNzIGEgbmFtZSBvciBhIGhyZWYnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyksXG4gICAgICAgICAgICAgIGVudiAgPSBOZW8uY29uZmlnLmVudmlyb25tZW50LFxuICAgICAgICAgICAgICBwYXRoID0gZW52LnN0YXJ0c1dpdGgoJ2Rpc3QvJykgPyBlbnYgOiAoJ2Rpc3QvJyArIGVudiksXG4gICAgICAgICAgICAgIHVybCAgPSBocmVmID8gaHJlZiA6IE5lby5jb25maWcuYmFzZVBhdGggKyBwYXRoICsgJy8nICsgbmFtZTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGxpbmssIHtcbiAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgIHJlbCA6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0L2NzcydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBsaW5rLmlkID0gaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YS5ydWxlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkZWxldGVDc3NSdWxlcyhkYXRhKSB7XG4gICAgICAgIGxldCBzdHlsZUVsICAgID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5keW5hbWljU3R5bGVTaGVldElkKSxcbiAgICAgICAgICAgIHN0eWxlU2hlZXQgPSBzdHlsZUVsLnNoZWV0LFxuICAgICAgICAgICAgY3NzUnVsZXMgICA9IHN0eWxlU2hlZXQuY3NzUnVsZXMsXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSBkYXRhLnJ1bGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGosIHJ1bGVzTGVuO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGogICAgICAgID0gMDtcbiAgICAgICAgICAgIHJ1bGVzTGVuID0gY3NzUnVsZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaiA8IHJ1bGVzTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY3NzUnVsZXNbal0uc2VsZWN0b3JUZXh0ID09PSBkYXRhLnJ1bGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXQuZGVsZXRlUnVsZShqKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzU3R5bGVTaGVldCh0b2tlbikge1xuICAgICAgICBsZXQgaSAgID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aCxcbiAgICAgICAgICAgIHNoZWV0O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHNoZWV0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG4gICAgICAgICAgICBpZiAoc2hlZXQuaHJlZj8uaW5jbHVkZXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhLnJ1bGVzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluc2VydENzc1J1bGVzKGRhdGEpIHtcbiAgICAgICAgbGV0IHN0eWxlRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmR5bmFtaWNTdHlsZVNoZWV0SWQpLFxuICAgICAgICAgICAgaSAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgPSBkYXRhLnJ1bGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXQ7XG5cbiAgICAgICAgaWYgKCFzdHlsZUVsKSB7XG4gICAgICAgICAgICBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICAgICAgICAgICAgc3R5bGVFbC5pZCA9IHRoaXMuZHluYW1pY1N0eWxlU2hlZXRJZDtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZVNoZWV0ID0gc3R5bGVFbC5zaGVldDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUoZGF0YS5ydWxlc1tpXSwgc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvcHRzLmluY2x1ZGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb3B0cy5leGNsdWRlZFxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlU2hlZXRzKG9wdHMpIHtcbiAgICAgICAgbGV0IGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5jbHVkZWQgPSBvcHRzLmluY2x1ZGVkIHx8IFtdLFxuICAgICAgICAgICAgZXhjbHVkZWQgPSBvcHRzLmluY2x1ZGVkIHx8IFtdLFxuICAgICAgICAgICAgc2hlZXQsIHJlbW92ZVNoZWV0O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHNoZWV0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG5cbiAgICAgICAgICAgIHJlbW92ZVNoZWV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHNoZWV0LmhyZWYpIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlZC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hlZXQuaHJlZi5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2hlZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVkLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNoZWV0LmhyZWYuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVTaGVldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0Lm93bmVyTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNoZWV0Lm93bmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5wcmlvcml0eV0gb3B0aW9uYWxseSBwYXNzICdpbXBvcnRhbnQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudGhlbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIHNldENzc1ZhcmlhYmxlKGRhdGEpIHtcbiAgICAgICAgbGV0IGtleSA9IGRhdGEua2V5LFxuICAgICAgICAgICAgcnVsZSwgc2hlZXQ7XG5cbiAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnLS0nKSkge1xuICAgICAgICAgICAga2V5ID0gJy0tJyArIGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoc2hlZXQgb2YgZG9jdW1lbnQuc3R5bGVTaGVldHMpIHtcbiAgICAgICAgICAgIGlmIChzaGVldC5ocmVmLmluY2x1ZGVzKGRhdGEudGhlbWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChydWxlIG9mIHNoZWV0LmNzc1J1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKHJ1bGUpID09PSAnQ1NTU3R5bGVSdWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCBkYXRhLnZhbHVlLCBkYXRhLnByaW9yaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmhyZWZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqL1xuICAgIHN3YXBTdHlsZVNoZWV0KGRhdGEpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YS5pZCkuc2V0QXR0cmlidXRlKCdocmVmJywgZGF0YS5ocmVmKTtcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKFN0eWxlc2hlZXQpO1xuXG5leHBvcnQgZGVmYXVsdCBTdHlsZXNoZWV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9