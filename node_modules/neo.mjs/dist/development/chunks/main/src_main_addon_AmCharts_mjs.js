"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_addon_AmCharts_mjs"],{

/***/ "./src/main/addon/AmCharts.mjs":
/*!*************************************!*\
  !*** ./src/main/addon/AmCharts.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/main/addon/Base.mjs");
/* harmony import */ var _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DomAccess.mjs */ "./src/main/DomAccess.mjs");



/**
 * Helper class to include amCharts into your neo.mjs app
 * https://www.amcharts.com/docs/v4/
 * @class Neo.main.addon.AmCharts
 * @extends Neo.main.addon.Base
 */
class AmCharts extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.AmCharts'
         * @protected
         */
        className: 'Neo.main.addon.AmCharts',
        /**
         * Stores all chart ids inside an object
         * @member {Object} charts={}
         * @protected
         */
        charts: {},
        /**
         * Stores all chart config objects which arrived before the chart lib scripts got loaded
         * @member {Object[]} chartsToCreate=[]
         * @protected
         */
        chartsToCreate: [],
        /**
         * Stores all chart data inside an object. key => chart id
         * No array since in case a chart gets loaded multiple times, we only want to apply the last data on mount.
         * @member {Object} dataMap={}
         * @protected
         */
        dataMap: {},
        /**
         * @member {String} downloadPath='https//www.amcharts.com/lib/4/'
         * @protected
         */
        downloadPath: 'https://www.amcharts.com/lib/4/',
        /**
         * @member {String} fallbackPath='https://neomjs.github.io/pages/resources_pub/amCharts/'
         * @protected
         */
        fallbackPath: 'https://neomjs.github.io/pages/resources_pub/amCharts/',
        /**
         * Remote method access for other workers
         * @member {Object} remote={app: [//...]}
         * @protected
         */
        remote: {
            app: [
                'callMethod',
                'create',
                'destroy',
                'setProperties',
                'setProperty',
                'updateData'
            ]
        },
        /**
         * @member {Boolean} scriptsLoaded_=true
         * @protected
         */
        scriptsLoaded_: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        this.insertAmChartsScripts()
    }

    /**
     * Triggered after the scriptsLoaded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetScriptsLoaded(value, oldValue) {
        if (value) {
            let me = this;

            me.chartsToCreate.forEach(config => {
                me.create(config)
            });

            me.chartsToCreate = [];

            me.timeout(1000).then(() => {
                Object.entries(me.dataMap).forEach(([key, dataValue]) => {
                    me.updateData(dataValue)
                });

                me.dataMap = {}
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.path
     * @param {Array} [data.params]
     */
    callMethod(data) {
        if (this.hasChart(data.id)) {
            let chart      = this.charts[data.id],
                pathArray  = data.path.split('.'),
                methodName = pathArray.pop(),
                scope      = pathArray.length < 1 ? chart:  Neo.ns(pathArray.join('.'), false, chart);

            scope[methodName].call(scope, ...data.params || [])
        } else {
            // todo
        }
    }

    /**
     * @param {Object} chart
     */
    combineSeriesTooltip(chart) {
        chart.series.each(series => {
            series.adapter.add('tooltipText', () => {
                let text = "[bold]{dateX}[/]\n";

                chart.series.each(item => {
                    text += "[" + item.stroke + "]●[/] " + item.name + ": {" + item.dataFields.valueY + "}\n"
                });

                return text
            })
        })
    }

    /**
     * @param {Object}  data
     * @param {Boolean} data.combineSeriesTooltip
     * @param {Object}  data.config
     * @param {Array}   [data.data]
     * @param {String}  [data.dataPath]
     * @param {String}  data.id
     * @param {String}  data.package
     * @param {String}  data.type='XYChart'
     */
    create(data) {
        let me = this;

        if (!me.scriptsLoaded) {
            me.chartsToCreate.push(data)
        } else {
            // todo: check if globalThis[data.package] exists, if not load it and call create afterwards

            am4core.useTheme(am4themes_dark);

            me.charts[data.id] = am4core.createFromConfig(data.config, data.id, globalThis[data.package][data.type || 'XYChart']);

            if (data.combineSeriesTooltip) {
                me.combineSeriesTooltip(me.charts[data.id])
            }

            // in case data has arrived before the chart got created, apply it now
            if (data.data) {
                me.updateData({
                    data    : data.data,
                    dataPath: data.dataPath,
                    id      : data.id
                })
            } else if (me.dataMap[data.id]) {
                me.updateData(me.dataMap[data.id]);
                delete me.dataMap[data.id]
            }
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     */
    destroy(data) {
        this.charts[data.id]?.dispose?.();
        delete this.charts[data.id]
    }

    /**
     * @param {String} id
     * @returns {Boolean}
     */
    hasChart(id) {
        return !!this.charts[id]
    }

    /**
     * Async approach
     * core.js has to arrive first or the other scripts will cause JS errors since they rely on it
     * => fetching the other files after core.js is loaded
     */
    insertAmChartsScripts(useFallback=false) {
        let me       = this,
            basePath = useFallback ? me.fallbackPath : me.downloadPath;

        _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'core.js').then(() => {
            Promise.all([
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'charts.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'maps.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'themes/dark.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'geodata/worldLow.js')
            ]).then(() => {
                me.scriptsLoaded = true
            });
        }).catch(e => {
            console.log('Download from amcharts.com failed, switching to fallback', e);
            me.insertAmChartsScripts(true)
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Object} data.properties
     */
    setProperties(data) {
        Object.entries(data.properties).forEach(([key, value]) => {
            this.setProperty({
                id   : data.id,
                path : key,
                value
            })
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Boolean} [data.isColor=false] true will wrap the value into am4core.color()
     * @param {String} data.path
     * @param {*} data.value
     */
    setProperty(data) {
        if (this.hasChart(data.id)) {
            let chart        = this.charts[data.id],
                pathArray    = data.path.split('.'),
                propertyName = pathArray.pop(),
                scope        = Neo.ns(pathArray.join('.'), false, chart);

            scope[propertyName] = data.isColor ? am4core.color(data.value) : data.value
        } else {
            // todo
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.data
     * @param {String} data.dataPath
     * @param {String} data.id
     */
    updateData(data) {
        let me = this;

        if (!me.scriptsLoaded || !me.hasChart(data.id)) {
            me.dataMap[data.id] = data
        } else {
            const chart = me.charts[data.id];

            if (data.dataPath === '') {
                chart.data = data.data
            } else {
                Neo.ns(data.dataPath, false, chart).data = data.data
            }
        }
    }
}

Neo.setupClass(AmCharts);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AmCharts);


/***/ }),

/***/ "./src/main/addon/Base.mjs":
/*!*********************************!*\
  !*** ./src/main/addon/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for main thread addons
 * @class Neo.main.addon.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.Base'
         * @protected
         */
        className: 'Neo.main.addon.Base',
        /**
         * An identifier for core.Base to get handled like singletons for remote method access
         * @member {Boolean} isMainThreadAddon=true
         * @protected
         */
        isMainThreadAddon: true
    }
}

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fYWRkb25fQW1DaGFydHNfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNNOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQUk7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07O0FBRXpDO0FBQ0EsMkVBQTJFLCtCQUErQjtBQUMxRyxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHNEQUFTO0FBQ2pCO0FBQ0EsZ0JBQWdCLHNEQUFTO0FBQ3pCLGdCQUFnQixzREFBUztBQUN6QixnQkFBZ0Isc0RBQVM7QUFDekIsZ0JBQWdCLHNEQUFTO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsUUFBUSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdlJtQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBUTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYWluL2FkZG9uL0FtQ2hhcnRzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vYWRkb24vQmFzZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBEb21BY2Nlc3MgZnJvbSAnLi4vRG9tQWNjZXNzLm1qcyc7XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGluY2x1ZGUgYW1DaGFydHMgaW50byB5b3VyIG5lby5tanMgYXBwXG4gKiBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NC9cbiAqIEBjbGFzcyBOZW8ubWFpbi5hZGRvbi5BbUNoYXJ0c1xuICogQGV4dGVuZHMgTmVvLm1haW4uYWRkb24uQmFzZVxuICovXG5jbGFzcyBBbUNoYXJ0cyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uYWRkb24uQW1DaGFydHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLmFkZG9uLkFtQ2hhcnRzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyBhbGwgY2hhcnQgaWRzIGluc2lkZSBhbiBvYmplY3RcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjaGFydHM9e31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnRzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyBhbGwgY2hhcnQgY29uZmlnIG9iamVjdHMgd2hpY2ggYXJyaXZlZCBiZWZvcmUgdGhlIGNoYXJ0IGxpYiBzY3JpcHRzIGdvdCBsb2FkZWRcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGNoYXJ0c1RvQ3JlYXRlPVtdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNoYXJ0c1RvQ3JlYXRlOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyBhbGwgY2hhcnQgZGF0YSBpbnNpZGUgYW4gb2JqZWN0LiBrZXkgPT4gY2hhcnQgaWRcbiAgICAgICAgICogTm8gYXJyYXkgc2luY2UgaW4gY2FzZSBhIGNoYXJ0IGdldHMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLCB3ZSBvbmx5IHdhbnQgdG8gYXBwbHkgdGhlIGxhc3QgZGF0YSBvbiBtb3VudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhTWFwPXt9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFNYXA6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkb3dubG9hZFBhdGg9J2h0dHBzLy93d3cuYW1jaGFydHMuY29tL2xpYi80LydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZG93bmxvYWRQYXRoOiAnaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2xpYi80LycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGZhbGxiYWNrUGF0aD0naHR0cHM6Ly9uZW9tanMuZ2l0aHViLmlvL3BhZ2VzL3Jlc291cmNlc19wdWIvYW1DaGFydHMvJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmYWxsYmFja1BhdGg6ICdodHRwczovL25lb21qcy5naXRodWIuaW8vcGFnZXMvcmVzb3VyY2VzX3B1Yi9hbUNoYXJ0cy8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGU9e2FwcDogWy8vLi4uXX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnY2FsbE1ldGhvZCcsXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgJ2Rlc3Ryb3knLFxuICAgICAgICAgICAgICAgICdzZXRQcm9wZXJ0aWVzJyxcbiAgICAgICAgICAgICAgICAnc2V0UHJvcGVydHknLFxuICAgICAgICAgICAgICAgICd1cGRhdGVEYXRhJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2NyaXB0c0xvYWRlZF89dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzY3JpcHRzTG9hZGVkXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICB0aGlzLmluc2VydEFtQ2hhcnRzU2NyaXB0cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzY3JpcHRzTG9hZGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2NyaXB0c0xvYWRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5jaGFydHNUb0NyZWF0ZS5mb3JFYWNoKGNvbmZpZyA9PiB7XG4gICAgICAgICAgICAgICAgbWUuY3JlYXRlKGNvbmZpZylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jaGFydHNUb0NyZWF0ZSA9IFtdO1xuXG4gICAgICAgICAgICBtZS50aW1lb3V0KDEwMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG1lLmRhdGFNYXApLmZvckVhY2goKFtrZXksIGRhdGFWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlRGF0YShkYXRhVmFsdWUpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS5kYXRhTWFwID0ge31cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEucGF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtkYXRhLnBhcmFtc11cbiAgICAgKi9cbiAgICBjYWxsTWV0aG9kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2hhcnQoZGF0YS5pZCkpIHtcbiAgICAgICAgICAgIGxldCBjaGFydCAgICAgID0gdGhpcy5jaGFydHNbZGF0YS5pZF0sXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5ICA9IGRhdGEucGF0aC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSBwYXRoQXJyYXkucG9wKCksXG4gICAgICAgICAgICAgICAgc2NvcGUgICAgICA9IHBhdGhBcnJheS5sZW5ndGggPCAxID8gY2hhcnQ6ICBOZW8ubnMocGF0aEFycmF5LmpvaW4oJy4nKSwgZmFsc2UsIGNoYXJ0KTtcblxuICAgICAgICAgICAgc2NvcGVbbWV0aG9kTmFtZV0uY2FsbChzY29wZSwgLi4uZGF0YS5wYXJhbXMgfHwgW10pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2RvXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcbiAgICAgKi9cbiAgICBjb21iaW5lU2VyaWVzVG9vbHRpcChjaGFydCkge1xuICAgICAgICBjaGFydC5zZXJpZXMuZWFjaChzZXJpZXMgPT4ge1xuICAgICAgICAgICAgc2VyaWVzLmFkYXB0ZXIuYWRkKCd0b29sdGlwVGV4dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IFwiW2JvbGRde2RhdGVYfVsvXVxcblwiO1xuXG4gICAgICAgICAgICAgICAgY2hhcnQuc2VyaWVzLmVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gXCJbXCIgKyBpdGVtLnN0cm9rZSArIFwiXeKXj1svXSBcIiArIGl0ZW0ubmFtZSArIFwiOiB7XCIgKyBpdGVtLmRhdGFGaWVsZHMudmFsdWVZICsgXCJ9XFxuXCJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5jb21iaW5lU2VyaWVzVG9vbHRpcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YS5jb25maWdcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIFtkYXRhLmRhdGFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBbZGF0YS5kYXRhUGF0aF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEucGFja2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS50eXBlPSdYWUNoYXJ0J1xuICAgICAqL1xuICAgIGNyZWF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5zY3JpcHRzTG9hZGVkKSB7XG4gICAgICAgICAgICBtZS5jaGFydHNUb0NyZWF0ZS5wdXNoKGRhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2RvOiBjaGVjayBpZiBnbG9iYWxUaGlzW2RhdGEucGFja2FnZV0gZXhpc3RzLCBpZiBub3QgbG9hZCBpdCBhbmQgY2FsbCBjcmVhdGUgYWZ0ZXJ3YXJkc1xuXG4gICAgICAgICAgICBhbTRjb3JlLnVzZVRoZW1lKGFtNHRoZW1lc19kYXJrKTtcblxuICAgICAgICAgICAgbWUuY2hhcnRzW2RhdGEuaWRdID0gYW00Y29yZS5jcmVhdGVGcm9tQ29uZmlnKGRhdGEuY29uZmlnLCBkYXRhLmlkLCBnbG9iYWxUaGlzW2RhdGEucGFja2FnZV1bZGF0YS50eXBlIHx8ICdYWUNoYXJ0J10pO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5jb21iaW5lU2VyaWVzVG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIG1lLmNvbWJpbmVTZXJpZXNUb29sdGlwKG1lLmNoYXJ0c1tkYXRhLmlkXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW4gY2FzZSBkYXRhIGhhcyBhcnJpdmVkIGJlZm9yZSB0aGUgY2hhcnQgZ290IGNyZWF0ZWQsIGFwcGx5IGl0IG5vd1xuICAgICAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZURhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhICAgIDogZGF0YS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUGF0aDogZGF0YS5kYXRhUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IGRhdGEuaWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5kYXRhTWFwW2RhdGEuaWRdKSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlRGF0YShtZS5kYXRhTWFwW2RhdGEuaWRdKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWUuZGF0YU1hcFtkYXRhLmlkXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqL1xuICAgIGRlc3Ryb3koZGF0YSkge1xuICAgICAgICB0aGlzLmNoYXJ0c1tkYXRhLmlkXT8uZGlzcG9zZT8uKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoYXJ0c1tkYXRhLmlkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0NoYXJ0KGlkKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY2hhcnRzW2lkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzeW5jIGFwcHJvYWNoXG4gICAgICogY29yZS5qcyBoYXMgdG8gYXJyaXZlIGZpcnN0IG9yIHRoZSBvdGhlciBzY3JpcHRzIHdpbGwgY2F1c2UgSlMgZXJyb3JzIHNpbmNlIHRoZXkgcmVseSBvbiBpdFxuICAgICAqID0+IGZldGNoaW5nIHRoZSBvdGhlciBmaWxlcyBhZnRlciBjb3JlLmpzIGlzIGxvYWRlZFxuICAgICAqL1xuICAgIGluc2VydEFtQ2hhcnRzU2NyaXB0cyh1c2VGYWxsYmFjaz1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYmFzZVBhdGggPSB1c2VGYWxsYmFjayA/IG1lLmZhbGxiYWNrUGF0aCA6IG1lLmRvd25sb2FkUGF0aDtcblxuICAgICAgICBEb21BY2Nlc3MubG9hZFNjcmlwdChiYXNlUGF0aCArICdjb3JlLmpzJykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgRG9tQWNjZXNzLmxvYWRTY3JpcHQoYmFzZVBhdGggKyAnY2hhcnRzLmpzJyksXG4gICAgICAgICAgICAgICAgRG9tQWNjZXNzLmxvYWRTY3JpcHQoYmFzZVBhdGggKyAnbWFwcy5qcycpLFxuICAgICAgICAgICAgICAgIERvbUFjY2Vzcy5sb2FkU2NyaXB0KGJhc2VQYXRoICsgJ3RoZW1lcy9kYXJrLmpzJyksXG4gICAgICAgICAgICAgICAgRG9tQWNjZXNzLmxvYWRTY3JpcHQoYmFzZVBhdGggKyAnZ2VvZGF0YS93b3JsZExvdy5qcycpXG4gICAgICAgICAgICBdKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5zY3JpcHRzTG9hZGVkID0gdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIGZyb20gYW1jaGFydHMuY29tIGZhaWxlZCwgc3dpdGNoaW5nIHRvIGZhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICBtZS5pbnNlcnRBbUNoYXJ0c1NjcmlwdHModHJ1ZSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucHJvcGVydGllc1xuICAgICAqL1xuICAgIHNldFByb3BlcnRpZXMoZGF0YSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhLnByb3BlcnRpZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgICAgaWQgICA6IGRhdGEuaWQsXG4gICAgICAgICAgICAgICAgcGF0aCA6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5pc0NvbG9yPWZhbHNlXSB0cnVlIHdpbGwgd3JhcCB0aGUgdmFsdWUgaW50byBhbTRjb3JlLmNvbG9yKClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5wYXRoXG4gICAgICogQHBhcmFtIHsqfSBkYXRhLnZhbHVlXG4gICAgICovXG4gICAgc2V0UHJvcGVydHkoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oYXNDaGFydChkYXRhLmlkKSkge1xuICAgICAgICAgICAgbGV0IGNoYXJ0ICAgICAgICA9IHRoaXMuY2hhcnRzW2RhdGEuaWRdLFxuICAgICAgICAgICAgICAgIHBhdGhBcnJheSAgICA9IGRhdGEucGF0aC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHBhdGhBcnJheS5wb3AoKSxcbiAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgPSBOZW8ubnMocGF0aEFycmF5LmpvaW4oJy4nKSwgZmFsc2UsIGNoYXJ0KTtcblxuICAgICAgICAgICAgc2NvcGVbcHJvcGVydHlOYW1lXSA9IGRhdGEuaXNDb2xvciA/IGFtNGNvcmUuY29sb3IoZGF0YS52YWx1ZSkgOiBkYXRhLnZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2RvXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLmRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5kYXRhUGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICovXG4gICAgdXBkYXRlRGF0YShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5zY3JpcHRzTG9hZGVkIHx8ICFtZS5oYXNDaGFydChkYXRhLmlkKSkge1xuICAgICAgICAgICAgbWUuZGF0YU1hcFtkYXRhLmlkXSA9IGRhdGFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnRzW2RhdGEuaWRdO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhUGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBjaGFydC5kYXRhID0gZGF0YS5kYXRhXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE5lby5ucyhkYXRhLmRhdGFQYXRoLCBmYWxzZSwgY2hhcnQpLmRhdGEgPSBkYXRhLmRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoQW1DaGFydHMpO1xuXG5leHBvcnQgZGVmYXVsdCBBbUNoYXJ0cztcbiIsImltcG9ydCBDb3JlQmFzZSBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtYWluIHRocmVhZCBhZGRvbnNcbiAqIEBjbGFzcyBOZW8ubWFpbi5hZGRvbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb3JlQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5hZGRvbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFpbi5hZGRvbi5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGlkZW50aWZpZXIgZm9yIGNvcmUuQmFzZSB0byBnZXQgaGFuZGxlZCBsaWtlIHNpbmdsZXRvbnMgZm9yIHJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTWFpblRocmVhZEFkZG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNNYWluVGhyZWFkQWRkb246IHRydWVcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKEJhc2UpO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9