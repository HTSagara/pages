"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_main_addon_AmCharts_mjs"],{

/***/ "./src/main/addon/AmCharts.mjs":
/*!*************************************!*\
  !*** ./src/main/addon/AmCharts.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/main/addon/Base.mjs");
/* harmony import */ var _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DomAccess.mjs */ "./src/main/DomAccess.mjs");



/**
 * Helper class to include amCharts into your neo.mjs app
 * https://www.amcharts.com/docs/v4/
 * @class Neo.main.addon.AmCharts
 * @extends Neo.main.addon.Base
 */
class AmCharts extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.AmCharts'
         * @protected
         */
        className: 'Neo.main.addon.AmCharts',
        /**
         * Stores all chart ids inside an object
         * @member {Object} charts={}
         * @protected
         */
        charts: {},
        /**
         * Stores all chart data inside an object. key => chart id
         * No array since in case a chart gets loaded multiple times, we only want to apply the last data on mount.
         * @member {Object} dataMap={}
         * @protected
         */
        dataMap: {},
        /**
         * @member {String} downloadPath='https//www.amcharts.com/lib/4/'
         * @protected
         */
        downloadPath: 'https://www.amcharts.com/lib/4/',
        /**
         * @member {String} fallbackPath='https://neomjs.github.io/pages/resources_pub/amCharts/'
         * @protected
         */
        fallbackPath: 'https://neomjs.github.io/pages/resources_pub/amCharts/',
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'callMethod',
                'create',
                'destroy',
                'setProperties',
                'setProperty',
                'updateData'
            ]
        }
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        super.afterSetIsReady(value, oldValue);

        if (value) {
            let me = this;

            me.timeout(1000).then(() => {
                Object.entries(me.dataMap).forEach(([key, dataValue]) => {
                    me.updateData(dataValue)
                });

                me.dataMap = {}
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.path
     * @param {Array} [data.params]
     */
    callMethod(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'callMethod', data})
        } else {
            if (me.hasChart(data.id)) {
                let chart      = me.charts[data.id],
                    pathArray  = data.path.split('.'),
                    methodName = pathArray.pop(),
                    scope      = pathArray.length < 1 ? chart:  Neo.ns(pathArray.join('.'), false, chart);

                scope[methodName].call(scope, ...data.params || [])
            } else {
                // todo
            }
        }
    }

    /**
     * @param {Object} chart
     */
    combineSeriesTooltip(chart) {
        chart.series.each(series => {
            series.adapter.add('tooltipText', () => {
                let text = "[bold]{dateX}[/]\n";

                chart.series.each(item => {
                    text += "[" + item.stroke + "]●[/] " + item.name + ": {" + item.dataFields.valueY + "}\n"
                });

                return text
            })
        })
    }

    /**
     * @param {Object}  data
     * @param {Boolean} data.combineSeriesTooltip
     * @param {Object}  data.config
     * @param {Array}   [data.data]
     * @param {String}  [data.dataPath]
     * @param {String}  data.id
     * @param {String}  data.package
     * @param {String}  data.type='XYChart'
     */
    create(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'create', data})
        } else {
            // todo: check if globalThis[data.package] exists, if not load it and call create afterwards
            am4core.useTheme(am4themes_dark);

            me.charts[data.id] = am4core.createFromConfig(data.config, data.id, globalThis[data.package][data.type || 'XYChart']);

            if (data.combineSeriesTooltip) {
                me.combineSeriesTooltip(me.charts[data.id])
            }

            // in case data has arrived before the chart got created, apply it now
            if (data.data) {
                me.updateData({
                    data    : data.data,
                    dataPath: data.dataPath,
                    id      : data.id
                })
            } else if (me.dataMap[data.id]) {
                me.updateData(me.dataMap[data.id]);
                delete me.dataMap[data.id]
            }
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     */
    destroy(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'destroy', data})
        } else {
            me.charts[data.id]?.dispose?.();
            delete me.charts[data.id]
        }
    }

    /**
     * @param {String} id
     * @returns {Boolean}
     */
    hasChart(id) {
        return !!this.charts[id]
    }

    /**
     * Async approach
     * core.js has to arrive first or the other scripts will cause JS errors since they rely on it
     * => fetching the other files after core.js is loaded
     * @param {Boolean} useFallback=false
     */
    loadFiles(useFallback=false) {
        let me       = this,
            basePath = useFallback ? me.fallbackPath : me.downloadPath;

        me.isLoading = true;

        _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'core.js').then(() => {
            Promise.all([
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'charts.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'maps.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'themes/dark.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'geodata/worldLow.js')
            ]).then(() => {
                me.isLoading = false;
                me.isReady   = true
            })
        }).catch(e => {
            console.log('Download from amcharts.com failed, switching to fallback', e);
            me.loadFiles(true)
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Object} data.properties
     */
    setProperties(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'setProperties', data})
        } else {
            Object.entries(data.properties).forEach(([key, value]) => {
                me.setProperty({
                    id   : data.id,
                    path : key,
                    value
                })
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Boolean} [data.isColor=false] true will wrap the value into am4core.color()
     * @param {String} data.path
     * @param {*} data.value
     */
    setProperty(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'setProperty', data})
        } else {
            if (this.hasChart(data.id)) {
                let chart        = this.charts[data.id],
                    pathArray    = data.path.split('.'),
                    propertyName = pathArray.pop(),
                    scope        = Neo.ns(pathArray.join('.'), false, chart);

                scope[propertyName] = data.isColor ? am4core.color(data.value) : data.value
            } else {
                // todo
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.data
     * @param {String} data.dataPath
     * @param {String} data.id
     */
    updateData(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'updateData', data})
        } else if (!me.hasChart(data.id)) {
            me.dataMap[data.id] = data
        } else {
            let chart = me.charts[data.id];

            if (data.dataPath === '') {
                chart.data = data.data
            } else {
                Neo.ns(data.dataPath, false, chart).data = data.data
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AmCharts));


/***/ }),

/***/ "./src/main/addon/Base.mjs":
/*!*********************************!*\
  !*** ./src/main/addon/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for main thread addons
 * @class Neo.main.addon.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.Base'
         * @protected
         */
        className: 'Neo.main.addon.Base',
        /**
         * An identifier for core.Base to get handled like singletons for remote method access
         * @member {Boolean} isMainThreadAddon=true
         * @protected
         */
        isMainThreadAddon: true,
        /**
         * Will get set to true once all addon related files got loaded (if there is a need to load)
         * @member {Boolean} isReady_=false
         * @protected
         */
        isReady_: false,
        /**
         * Amount in ms to delay the loading of library files, unless remote method access happens
         * Change the value to false in case you don't want an automated preloading
         * @member {Boolean|Number} preloadFilesDelay=5000
         * @protected
         */
        preloadFilesDelay: 5000,
    }

    /**
     * @member {Object[]} cache=[]
     */
    cache = []
    /**
     * Will get set to true once we start loading Monaco related files
     * @member {Boolean} isLoading=false
     */
    isLoading = false
    /**
     * Internal flag to store the setTimeout() id for loading external files
     * @member {Number|null} loadingTimeoutId=null
     */
    loadingTimeoutId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.loadFiles) {
            if (me.preloadFilesDelay === 0) {
                me.loadFiles()
            } else if (Neo.isNumber(me.preloadFilesDelay)) {
                me.loadingTimeoutId = setTimeout(() => {
                    me.loadFiles()
                }, me.preloadFilesDelay)
            }
        }
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        if (value) {
            let me = this,
                returnValue;

            me.cache.forEach(item => {
                returnValue = me[item.fn](item.data);
                item.resolve(returnValue)
            });

            me.cache = []
        }
    }

    /**
     * Internally caches call when isReady===false
     * Loads the library files in case this is not already happening
     * @param item
     * @returns {Promise<unknown>}
     */
    cacheMethodCall(item) {
        let me = this;

        if (!me.isLoading) {
            me.loadingTimeoutId && clearTimeout(me.loadingTimeoutId);
            me.loadingTimeoutId = null;
            me.loadFiles()
        }

        return new Promise((resolve, reject) => {
            me.cache.push({...item, resolve})
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vdmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9BbUNoYXJ0c19tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ007O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTTs7QUFFekM7QUFDQSwyRUFBMkUsK0JBQStCO0FBQzFHLGlCQUFpQjs7QUFFakI7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUMsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vYWRkb24vQW1DaGFydHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9hZGRvbi9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IERvbUFjY2VzcyBmcm9tICcuLi9Eb21BY2Nlc3MubWpzJztcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gaW5jbHVkZSBhbUNoYXJ0cyBpbnRvIHlvdXIgbmVvLm1qcyBhcHBcbiAqIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y0L1xuICogQGNsYXNzIE5lby5tYWluLmFkZG9uLkFtQ2hhcnRzXG4gKiBAZXh0ZW5kcyBOZW8ubWFpbi5hZGRvbi5CYXNlXG4gKi9cbmNsYXNzIEFtQ2hhcnRzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5hZGRvbi5BbUNoYXJ0cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uQW1DaGFydHMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIGFsbCBjaGFydCBpZHMgaW5zaWRlIGFuIG9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNoYXJ0cz17fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydHM6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIGFsbCBjaGFydCBkYXRhIGluc2lkZSBhbiBvYmplY3QuIGtleSA9PiBjaGFydCBpZFxuICAgICAgICAgKiBObyBhcnJheSBzaW5jZSBpbiBjYXNlIGEgY2hhcnQgZ2V0cyBsb2FkZWQgbXVsdGlwbGUgdGltZXMsIHdlIG9ubHkgd2FudCB0byBhcHBseSB0aGUgbGFzdCBkYXRhIG9uIG1vdW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGFNYXA9e31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YU1hcDoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRvd25sb2FkUGF0aD0naHR0cHMvL3d3dy5hbWNoYXJ0cy5jb20vbGliLzQvJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkb3dubG9hZFBhdGg6ICdodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vbGliLzQvJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZmFsbGJhY2tQYXRoPSdodHRwczovL25lb21qcy5naXRodWIuaW8vcGFnZXMvcmVzb3VyY2VzX3B1Yi9hbUNoYXJ0cy8nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGZhbGxiYWNrUGF0aDogJ2h0dHBzOi8vbmVvbWpzLmdpdGh1Yi5pby9wYWdlcy9yZXNvdXJjZXNfcHViL2FtQ2hhcnRzLycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgd29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdjYWxsTWV0aG9kJyxcbiAgICAgICAgICAgICAgICAnY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAnZGVzdHJveScsXG4gICAgICAgICAgICAgICAgJ3NldFByb3BlcnRpZXMnLFxuICAgICAgICAgICAgICAgICdzZXRQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZURhdGEnXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlzUmVhZHkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1JlYWR5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldElzUmVhZHkodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnRpbWVvdXQoMTAwMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobWUuZGF0YU1hcCkuZm9yRWFjaCgoW2tleSwgZGF0YVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVEYXRhKGRhdGFWYWx1ZSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLmRhdGFNYXAgPSB7fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5wYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2RhdGEucGFyYW1zXVxuICAgICAqL1xuICAgIGNhbGxNZXRob2QoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaXNSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmNhY2hlTWV0aG9kQ2FsbCh7Zm46ICdjYWxsTWV0aG9kJywgZGF0YX0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWUuaGFzQ2hhcnQoZGF0YS5pZCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hhcnQgICAgICA9IG1lLmNoYXJ0c1tkYXRhLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aEFycmF5ICA9IGRhdGEucGF0aC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lID0gcGF0aEFycmF5LnBvcCgpLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgID0gcGF0aEFycmF5Lmxlbmd0aCA8IDEgPyBjaGFydDogIE5lby5ucyhwYXRoQXJyYXkuam9pbignLicpLCBmYWxzZSwgY2hhcnQpO1xuXG4gICAgICAgICAgICAgICAgc2NvcGVbbWV0aG9kTmFtZV0uY2FsbChzY29wZSwgLi4uZGF0YS5wYXJhbXMgfHwgW10pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvZG9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydFxuICAgICAqL1xuICAgIGNvbWJpbmVTZXJpZXNUb29sdGlwKGNoYXJ0KSB7XG4gICAgICAgIGNoYXJ0LnNlcmllcy5lYWNoKHNlcmllcyA9PiB7XG4gICAgICAgICAgICBzZXJpZXMuYWRhcHRlci5hZGQoJ3Rvb2x0aXBUZXh0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gXCJbYm9sZF17ZGF0ZVh9Wy9dXFxuXCI7XG5cbiAgICAgICAgICAgICAgICBjaGFydC5zZXJpZXMuZWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcIltcIiArIGl0ZW0uc3Ryb2tlICsgXCJd4pePWy9dIFwiICsgaXRlbS5uYW1lICsgXCI6IHtcIiArIGl0ZW0uZGF0YUZpZWxkcy52YWx1ZVkgKyBcIn1cXG5cIlxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLmNvbWJpbmVTZXJpZXNUb29sdGlwXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhLmNvbmZpZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW2RhdGEuZGF0YV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIFtkYXRhLmRhdGFQYXRoXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS5wYWNrYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBkYXRhLnR5cGU9J1hZQ2hhcnQnXG4gICAgICovXG4gICAgY3JlYXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5jYWNoZU1ldGhvZENhbGwoe2ZuOiAnY3JlYXRlJywgZGF0YX0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2RvOiBjaGVjayBpZiBnbG9iYWxUaGlzW2RhdGEucGFja2FnZV0gZXhpc3RzLCBpZiBub3QgbG9hZCBpdCBhbmQgY2FsbCBjcmVhdGUgYWZ0ZXJ3YXJkc1xuICAgICAgICAgICAgYW00Y29yZS51c2VUaGVtZShhbTR0aGVtZXNfZGFyayk7XG5cbiAgICAgICAgICAgIG1lLmNoYXJ0c1tkYXRhLmlkXSA9IGFtNGNvcmUuY3JlYXRlRnJvbUNvbmZpZyhkYXRhLmNvbmZpZywgZGF0YS5pZCwgZ2xvYmFsVGhpc1tkYXRhLnBhY2thZ2VdW2RhdGEudHlwZSB8fCAnWFlDaGFydCddKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuY29tYmluZVNlcmllc1Rvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBtZS5jb21iaW5lU2VyaWVzVG9vbHRpcChtZS5jaGFydHNbZGF0YS5pZF0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluIGNhc2UgZGF0YSBoYXMgYXJyaXZlZCBiZWZvcmUgdGhlIGNoYXJ0IGdvdCBjcmVhdGVkLCBhcHBseSBpdCBub3dcbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSAgICA6IGRhdGEuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVBhdGg6IGRhdGEuZGF0YVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBkYXRhLmlkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuZGF0YU1hcFtkYXRhLmlkXSkge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZURhdGEobWUuZGF0YU1hcFtkYXRhLmlkXSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lLmRhdGFNYXBbZGF0YS5pZF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKi9cbiAgICBkZXN0cm95KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5jYWNoZU1ldGhvZENhbGwoe2ZuOiAnZGVzdHJveScsIGRhdGF9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuY2hhcnRzW2RhdGEuaWRdPy5kaXNwb3NlPy4oKTtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5jaGFydHNbZGF0YS5pZF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0NoYXJ0KGlkKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY2hhcnRzW2lkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzeW5jIGFwcHJvYWNoXG4gICAgICogY29yZS5qcyBoYXMgdG8gYXJyaXZlIGZpcnN0IG9yIHRoZSBvdGhlciBzY3JpcHRzIHdpbGwgY2F1c2UgSlMgZXJyb3JzIHNpbmNlIHRoZXkgcmVseSBvbiBpdFxuICAgICAqID0+IGZldGNoaW5nIHRoZSBvdGhlciBmaWxlcyBhZnRlciBjb3JlLmpzIGlzIGxvYWRlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlRmFsbGJhY2s9ZmFsc2VcbiAgICAgKi9cbiAgICBsb2FkRmlsZXModXNlRmFsbGJhY2s9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJhc2VQYXRoID0gdXNlRmFsbGJhY2sgPyBtZS5mYWxsYmFja1BhdGggOiBtZS5kb3dubG9hZFBhdGg7XG5cbiAgICAgICAgbWUuaXNMb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICBEb21BY2Nlc3MubG9hZFNjcmlwdChiYXNlUGF0aCArICdjb3JlLmpzJykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgRG9tQWNjZXNzLmxvYWRTY3JpcHQoYmFzZVBhdGggKyAnY2hhcnRzLmpzJyksXG4gICAgICAgICAgICAgICAgRG9tQWNjZXNzLmxvYWRTY3JpcHQoYmFzZVBhdGggKyAnbWFwcy5qcycpLFxuICAgICAgICAgICAgICAgIERvbUFjY2Vzcy5sb2FkU2NyaXB0KGJhc2VQYXRoICsgJ3RoZW1lcy9kYXJrLmpzJyksXG4gICAgICAgICAgICAgICAgRG9tQWNjZXNzLmxvYWRTY3JpcHQoYmFzZVBhdGggKyAnZ2VvZGF0YS93b3JsZExvdy5qcycpXG4gICAgICAgICAgICBdKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtZS5pc1JlYWR5ICAgPSB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb3dubG9hZCBmcm9tIGFtY2hhcnRzLmNvbSBmYWlsZWQsIHN3aXRjaGluZyB0byBmYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgbWUubG9hZEZpbGVzKHRydWUpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5jYWNoZU1ldGhvZENhbGwoe2ZuOiAnc2V0UHJvcGVydGllcycsIGRhdGF9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YS5wcm9wZXJ0aWVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBtZS5zZXRQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiBkYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoIDoga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuaXNDb2xvcj1mYWxzZV0gdHJ1ZSB3aWxsIHdyYXAgdGhlIHZhbHVlIGludG8gYW00Y29yZS5jb2xvcigpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEucGF0aFxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIHNldFByb3BlcnR5KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5jYWNoZU1ldGhvZENhbGwoe2ZuOiAnc2V0UHJvcGVydHknLCBkYXRhfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0NoYXJ0KGRhdGEuaWQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoYXJ0ICAgICAgICA9IHRoaXMuY2hhcnRzW2RhdGEuaWRdLFxuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkgICAgPSBkYXRhLnBhdGguc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gcGF0aEFycmF5LnBvcCgpLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgPSBOZW8ubnMocGF0aEFycmF5LmpvaW4oJy4nKSwgZmFsc2UsIGNoYXJ0KTtcblxuICAgICAgICAgICAgICAgIHNjb3BlW3Byb3BlcnR5TmFtZV0gPSBkYXRhLmlzQ29sb3IgPyBhbTRjb3JlLmNvbG9yKGRhdGEudmFsdWUpIDogZGF0YS52YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLmRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5kYXRhUGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICovXG4gICAgdXBkYXRlRGF0YShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuY2FjaGVNZXRob2RDYWxsKHtmbjogJ3VwZGF0ZURhdGEnLCBkYXRhfSlcbiAgICAgICAgfSBlbHNlIGlmICghbWUuaGFzQ2hhcnQoZGF0YS5pZCkpIHtcbiAgICAgICAgICAgIG1lLmRhdGFNYXBbZGF0YS5pZF0gPSBkYXRhXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhcnQgPSBtZS5jaGFydHNbZGF0YS5pZF07XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGFQYXRoID09PSAnJykge1xuICAgICAgICAgICAgICAgIGNoYXJ0LmRhdGEgPSBkYXRhLmRhdGFcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTmVvLm5zKGRhdGEuZGF0YVBhdGgsIGZhbHNlLCBjaGFydCkuZGF0YSA9IGRhdGEuZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBbUNoYXJ0cyk7XG4iLCJpbXBvcnQgQ29yZUJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbWFpbiB0aHJlYWQgYWRkb25zXG4gKiBAY2xhc3MgTmVvLm1haW4uYWRkb24uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uYWRkb24uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpZGVudGlmaWVyIGZvciBjb3JlLkJhc2UgdG8gZ2V0IGhhbmRsZWQgbGlrZSBzaW5nbGV0b25zIGZvciByZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc01haW5UaHJlYWRBZGRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzTWFpblRocmVhZEFkZG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSBhbGwgYWRkb24gcmVsYXRlZCBmaWxlcyBnb3QgbG9hZGVkIChpZiB0aGVyZSBpcyBhIG5lZWQgdG8gbG9hZClcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNSZWFkeV89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNSZWFkeV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IGluIG1zIHRvIGRlbGF5IHRoZSBsb2FkaW5nIG9mIGxpYnJhcnkgZmlsZXMsIHVubGVzcyByZW1vdGUgbWV0aG9kIGFjY2VzcyBoYXBwZW5zXG4gICAgICAgICAqIENoYW5nZSB0aGUgdmFsdWUgdG8gZmFsc2UgaW4gY2FzZSB5b3UgZG9uJ3Qgd2FudCBhbiBhdXRvbWF0ZWQgcHJlbG9hZGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufE51bWJlcn0gcHJlbG9hZEZpbGVzRGVsYXk9NTAwMFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwcmVsb2FkRmlsZXNEZWxheTogNTAwMCxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gY2FjaGU9W11cbiAgICAgKi9cbiAgICBjYWNoZSA9IFtdXG4gICAgLyoqXG4gICAgICogV2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSB3ZSBzdGFydCBsb2FkaW5nIE1vbmFjbyByZWxhdGVkIGZpbGVzXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNMb2FkaW5nPWZhbHNlXG4gICAgICovXG4gICAgaXNMb2FkaW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHN0b3JlIHRoZSBzZXRUaW1lb3V0KCkgaWQgZm9yIGxvYWRpbmcgZXh0ZXJuYWwgZmlsZXNcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbG9hZGluZ1RpbWVvdXRJZD1udWxsXG4gICAgICovXG4gICAgbG9hZGluZ1RpbWVvdXRJZCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmxvYWRGaWxlcykge1xuICAgICAgICAgICAgaWYgKG1lLnByZWxvYWRGaWxlc0RlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzTnVtYmVyKG1lLnByZWxvYWRGaWxlc0RlbGF5KSkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWRpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgICAgICAgICB9LCBtZS5wcmVsb2FkRmlsZXNEZWxheSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNSZWFkeSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzUmVhZHkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICAgICAgbWUuY2FjaGUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG1lW2l0ZW0uZm5dKGl0ZW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXNvbHZlKHJldHVyblZhbHVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmNhY2hlID0gW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgY2FjaGVzIGNhbGwgd2hlbiBpc1JlYWR5PT09ZmFsc2VcbiAgICAgKiBMb2FkcyB0aGUgbGlicmFyeSBmaWxlcyBpbiBjYXNlIHRoaXMgaXMgbm90IGFscmVhZHkgaGFwcGVuaW5nXG4gICAgICogQHBhcmFtIGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAgICAgKi9cbiAgICBjYWNoZU1ldGhvZENhbGwoaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBtZS5sb2FkaW5nVGltZW91dElkICYmIGNsZWFyVGltZW91dChtZS5sb2FkaW5nVGltZW91dElkKTtcbiAgICAgICAgICAgIG1lLmxvYWRpbmdUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZS5jYWNoZS5wdXNoKHsuLi5pdGVtLCByZXNvbHZlfSlcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9