"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_addon_ResizeObserver_mjs"],{

/***/ "./src/main/addon/ResizeObserver.mjs":
/*!*******************************************!*\
  !*** ./src/main/addon/ResizeObserver.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DomAccess.mjs */ "./src/main/DomAccess.mjs");
/* harmony import */ var _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DomEvents.mjs */ "./src/main/DomEvents.mjs");




/**
 * @class Neo.main.addon.ResizeObserver
 * @extends Neo.core.Base
 * @singleton
 */
class NeoResizeObserver extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.ResizeObserver'
         * @protected
         */
        className: 'Neo.main.addon.ResizeObserver',
        /**
         * @member {ResizeObserver|null} instance=null
         * @protected
         */
        instance: null,
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'register',
                'unregister'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.instance = new ResizeObserver(me.onResize.bind(me))
    }

    /**
     * Internal callback for the ResizeObserver instance.
     * See: https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry
     * @param {HTMLElement[]} entries
     * @param {ResizeObserver} observer
     * @protected
     */
    onResize(entries, observer) {
        entries.forEach(entry => {
            // the content of entry is not spreadable, so we need to manually convert it
            // structuredClone(entry) throws a JS error => ResizeObserverEntry object could not be cloned.

            let borderBoxSize             = entry.borderBoxSize[0],
                contentBoxSize            = entry.contentBoxSize[0],
                devicePixelContentBoxSize = entry.devicePixelContentBoxSize?.[0] || {}, // Not supported in Safari yet
                path                      = _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getPathFromElement(entry.target).map(e => _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getTargetData(e));

            Neo.worker.Manager.sendMessage('app', {
                action   : 'domEvent',
                eventName: 'resize',

                data: {
                    contentRect: _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].parseDomRect(entry.contentRect),
                    id         : entry.target.id,
                    path,
                    rect       : path[0].rect,

                    borderBoxSize: {
                        blockSize : borderBoxSize.blockSize,
                        inlineSize: borderBoxSize.inlineSize
                    },

                    contentBoxSize: {
                        blockSize : contentBoxSize.blockSize,
                        inlineSize: contentBoxSize.inlineSize
                    },

                    devicePixelContentBoxSize: {
                        blockSize : devicePixelContentBoxSize.blockSize,
                        inlineSize: devicePixelContentBoxSize.inlineSize
                    }
                }
            })
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     */
    register(data) {
        this.instance.observe(_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(data.id))
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     */
    unregister(data) {
        this.instance.unobserve(_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(data.id))
    }
}

let instance = Neo.applyClassConfig(NeoResizeObserver);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fYWRkb25fUmVzaXplT2JzZXJ2ZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDSDtBQUNBOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFJO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGLDRDQUE0QyxzREFBUywyQ0FBMkMsc0RBQVM7O0FBRXpHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxzREFBUztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsOEJBQThCLHNEQUFTO0FBQ3ZDOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYWluL2FkZG9uL1Jlc2l6ZU9ic2VydmVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IERvbUFjY2VzcyBmcm9tICcuLi9Eb21BY2Nlc3MubWpzJztcbmltcG9ydCBEb21FdmVudHMgZnJvbSAnLi4vRG9tRXZlbnRzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIE5lb1Jlc2l6ZU9ic2VydmVyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5hZGRvbi5SZXNpemVPYnNlcnZlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7UmVzaXplT2JzZXJ2ZXJ8bnVsbH0gaW5zdGFuY2U9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIGZvciBvdGhlciB3b3JrZXJzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ3JlZ2lzdGVyJyxcbiAgICAgICAgICAgICAgICAndW5yZWdpc3RlcidcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaW5zdGFuY2UgPSBuZXcgUmVzaXplT2JzZXJ2ZXIobWUub25SZXNpemUuYmluZChtZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2FsbGJhY2sgZm9yIHRoZSBSZXNpemVPYnNlcnZlciBpbnN0YW5jZS5cbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNpemVPYnNlcnZlckVudHJ5XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSBlbnRyaWVzXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gb2JzZXJ2ZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25SZXNpemUoZW50cmllcywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIC8vIHRoZSBjb250ZW50IG9mIGVudHJ5IGlzIG5vdCBzcHJlYWRhYmxlLCBzbyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNvbnZlcnQgaXRcbiAgICAgICAgICAgIC8vIHN0cnVjdHVyZWRDbG9uZShlbnRyeSkgdGhyb3dzIGEgSlMgZXJyb3IgPT4gUmVzaXplT2JzZXJ2ZXJFbnRyeSBvYmplY3QgY291bGQgbm90IGJlIGNsb25lZC5cblxuICAgICAgICAgICAgbGV0IGJvcmRlckJveFNpemUgICAgICAgICAgICAgPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRCb3hTaXplICAgICAgICAgICAgPSBlbnRyeS5jb250ZW50Qm94U2l6ZVswXSxcbiAgICAgICAgICAgICAgICBkZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplID0gZW50cnkuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZT8uWzBdIHx8IHt9LCAvLyBOb3Qgc3VwcG9ydGVkIGluIFNhZmFyaSB5ZXRcbiAgICAgICAgICAgICAgICBwYXRoICAgICAgICAgICAgICAgICAgICAgID0gRG9tRXZlbnRzLmdldFBhdGhGcm9tRWxlbWVudChlbnRyeS50YXJnZXQpLm1hcChlID0+IERvbUV2ZW50cy5nZXRUYXJnZXREYXRhKGUpKTtcblxuICAgICAgICAgICAgTmVvLndvcmtlci5NYW5hZ2VyLnNlbmRNZXNzYWdlKCdhcHAnLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uICAgOiAnZG9tRXZlbnQnLFxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG5cbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSZWN0OiBEb21FdmVudHMucGFyc2VEb21SZWN0KGVudHJ5LmNvbnRlbnRSZWN0KSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgICA6IGVudHJ5LnRhcmdldC5pZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmVjdCAgICAgICA6IHBhdGhbMF0ucmVjdCxcblxuICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3hTaXplOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NpemUgOiBib3JkZXJCb3hTaXplLmJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubGluZVNpemU6IGJvcmRlckJveFNpemUuaW5saW5lU2l6ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRCb3hTaXplOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NpemUgOiBjb250ZW50Qm94U2l6ZS5ibG9ja1NpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmVTaXplOiBjb250ZW50Qm94U2l6ZS5pbmxpbmVTaXplXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTaXplIDogZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZS5ibG9ja1NpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmVTaXplOiBkZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplLmlubGluZVNpemVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5vYnNlcnZlKERvbUFjY2Vzcy5nZXRFbGVtZW50KGRhdGEuaWQpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS51bm9ic2VydmUoRG9tQWNjZXNzLmdldEVsZW1lbnQoZGF0YS5pZCkpXG4gICAgfVxufVxuXG5sZXQgaW5zdGFuY2UgPSBOZW8uYXBwbHlDbGFzc0NvbmZpZyhOZW9SZXNpemVPYnNlcnZlcik7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9