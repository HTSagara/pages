"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_addon_GoogleMaps_mjs"],{

/***/ "./src/main/addon/GoogleMaps.mjs":
/*!***************************************!*\
  !*** ./src/main/addon/GoogleMaps.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DomAccess.mjs */ "./src/main/DomAccess.mjs");
/* harmony import */ var _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DomEvents.mjs */ "./src/main/DomEvents.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./src/core/Observable.mjs");





/**
 * @class Neo.main.addon.GoogleMaps
 * @extends Neo.core.Base
 * @singleton
 */
class GoogleMaps extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.GoogleMaps'
         * @protected
         */
        className: 'Neo.main.addon.GoogleMaps',
        /**
         * @member {Neo.core.Base[]} mixins=[Observable]
         */
        mixins: [_core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]],
        /**
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'addMarker',
                'create',
                'destroyMarkers',
                'geocode',
                'hideMarker',
                'panTo',
                'removeMap',
                'removeMarker',
                'setCenter',
                'setZoom',
                'showMarker'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {google.maps.Geocoder|null} maps=null
     */
    geoCoder = null
    /**
     * @member {Object} maps={}
     */
    maps     = {}
    /**
     * @member {Object} markers={}
     */
    markers  = {}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.loadApi();
    }

    /**
     * @param {Object} data
     * @param {Object} [data.anchorPoint] x & y
     * @param {String} [data.icon]
     * @param {String} data.id
     * @param {String} [data.label]
     * @param {String} data.mapId
     * @param {Object} data.position
     * @param {String} [data.title]
     */
    addMarker(data) {
        let me    = this,
            mapId = data.mapId,
            listenerId, marker;

        if (!me.maps[mapId]) {
            listenerId = me.on('mapCreated', id => {
                if (mapId === id) {
                    me.un(listenerId);
                    me.addMarker(data);
                }
            })
        } else {
            Neo.ns(`${mapId}`, true, me.markers);

            me.markers[mapId][data.id] = marker = new google.maps.Marker({
                icon    : data.icon,
                label   : data.label,
                map     : me.maps[mapId],
                neoId   : data.id, // custom property
                neoMapId: mapId,   // custom property
                position: data.position,
                title   : data.title,
            });

            marker.addListener('click', me.onMarkerClick.bind(me, marker));
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.center
     * @param {Boolean} data.fullscreenControl
     * @param {String} data.id
     * @param {Object} data.mapOptions // Pass any options which are not explicitly defined here
     * @param {Number} data.maxZoom
     * @param {Number} data.minZoom
     * @param {Number} data.zoom
     * @param {Boolean} data.zoomControl
     */
    create(data) {
        let me = this,
            id = data.id,
            map;

        me.maps[id] = map = new google.maps.Map(_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(id), {
            center           : data.center,
            fullscreenControl: data.fullscreenControl,
            maxZoom          : data.maxZoom,
            minZoom          : data.minZoom,
            zoom             : data.zoom,
            zoomControl      : data.zoomControl,
            ...data.mapOptions
        });

        map.addListener('zoom_changed', me.onMapZoomChange.bind(me, map, id));

        me.fire('mapCreated', id);
    }

    /**
     * Destroys all markers for the specified map ID.
     * @param {Object} data
     * @param {String} data.mapId
     */
    destroyMarkers(data) {
        let me      = this,
            markers = me.markers[data.mapId] || {};

        Object.values(markers).forEach(marker => marker.setMap(null));
        delete me.markers[data.mapId];
    }

    /**
     * Use either address, location or placeId
     * @param {Object} data
     * @param {String} data.address
     * @param {Object} data.location
     * @param {String} data.placeId
     * @returns {Object}
     */
    async geocode(data) {
        let me = this,
            response;

        if (!me.geoCoder) {
            me.geoCoder = new google.maps.Geocoder();
        }

        response = await me.geoCoder.geocode(data);

        return JSON.parse(JSON.stringify(response));
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.mapId
     */
    hideMarker(data) {
        this.markers[data.mapId][data.id].setMap(null);
    }

    /**
     * @protected
     */
    loadApi() {
        let key = Neo.config.googleMapsApiKey,
            url = ' https://maps.googleapis.com/maps/api/js';

        _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(`${url}?key=${key}&v=weekly&callback=Neo.emptyFn`).then(() => {
            console.log('GoogleMaps API loaded');
        })
    }

    /**
     * @param {google.maps.Map} map
     * @param {String} mapId
     */
    onMapZoomChange(map, mapId) {
        _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].sendMessageToApp({
            id   : mapId,
            path : [{cls: [], id: mapId}],
            type : 'googleMapZoomChange',
            value: map.zoom
        })
    }

    /**
     * @param {google.maps.Marker} marker
     * @param {Object} event
     * @param {Object} event.domEvent
     */
    onMarkerClick(marker, event) {
        let transformedEvent = _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getMouseEventData(event.domEvent);

        _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].sendMessageToApp({
            id      : marker.neoId,
            path    : [{cls: [], id: marker.neoMapId}],
            type    : 'googleMarkerClick',
            domEvent: transformedEvent
        })
    }

    /**
     * @param data
     * @param {String} data.mapId
     * @param {Object} data.position
     */
    panTo(data) {
        this.maps[data.mapId].panTo(data.position);
    }

    /**
     * @param {Object} data
     * @param {String} data.mapId
     */
    removeMap(data) {
        delete this.maps[data.mapId];
        delete this.markers[data.mapId];
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.mapId
     */
    removeMarker(data) {
        let markers = this.markers[data.mapId];

        markers[data.id].setMap(null);
        delete markers[data.id];
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Object} data.value
     */
    setCenter(data) {
        this.maps[data.id].setCenter(data.value);
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Number} data.value
     */
    setZoom(data) {
        this.maps[data.id].setZoom(data.value);
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.mapId
     */
    showMarker(data) {
        this.markers[data.mapId][data.id].setMap(this.maps[data.mapId]);
    }
}

let instance = Neo.applyClassConfig(GoogleMaps);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fYWRkb25fR29vZ2xlTWFwc19tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDSDtBQUNBO0FBQ1M7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUk7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBLGlCQUFpQiw0REFBVTtBQUMzQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWLHNCQUFzQixNQUFNOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxzREFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxzREFBUyxlQUFlLElBQUksT0FBTyxJQUFJO0FBQy9DO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRLHNEQUFTO0FBQ2pCO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsK0JBQStCLHNEQUFTOztBQUV4QyxRQUFRLHNEQUFTO0FBQ2pCO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9hZGRvbi9Hb29nbGVNYXBzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBEb21BY2Nlc3MgIGZyb20gJy4uL0RvbUFjY2Vzcy5tanMnO1xuaW1wb3J0IERvbUV2ZW50cyAgZnJvbSAnLi4vRG9tRXZlbnRzLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi8uLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1haW4uYWRkb24uR29vZ2xlTWFwc1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBHb29nbGVNYXBzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5hZGRvbi5Hb29nbGVNYXBzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFpbi5hZGRvbi5Hb29nbGVNYXBzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb3JlLkJhc2VbXX0gbWl4aW5zPVtPYnNlcnZhYmxlXVxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW5zOiBbT2JzZXJ2YWJsZV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdhZGRNYXJrZXInLFxuICAgICAgICAgICAgICAgICdjcmVhdGUnLFxuICAgICAgICAgICAgICAgICdkZXN0cm95TWFya2VycycsXG4gICAgICAgICAgICAgICAgJ2dlb2NvZGUnLFxuICAgICAgICAgICAgICAgICdoaWRlTWFya2VyJyxcbiAgICAgICAgICAgICAgICAncGFuVG8nLFxuICAgICAgICAgICAgICAgICdyZW1vdmVNYXAnLFxuICAgICAgICAgICAgICAgICdyZW1vdmVNYXJrZXInLFxuICAgICAgICAgICAgICAgICdzZXRDZW50ZXInLFxuICAgICAgICAgICAgICAgICdzZXRab29tJyxcbiAgICAgICAgICAgICAgICAnc2hvd01hcmtlcidcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2dvb2dsZS5tYXBzLkdlb2NvZGVyfG51bGx9IG1hcHM9bnVsbFxuICAgICAqL1xuICAgIGdlb0NvZGVyID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWFwcz17fVxuICAgICAqL1xuICAgIG1hcHMgICAgID0ge31cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1hcmtlcnM9e31cbiAgICAgKi9cbiAgICBtYXJrZXJzICA9IHt9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgdGhpcy5sb2FkQXBpKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGEuYW5jaG9yUG9pbnRdIHggJiB5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmljb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEubGFiZWxdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubWFwSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5wb3NpdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS50aXRsZV1cbiAgICAgKi9cbiAgICBhZGRNYXJrZXIoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgbWFwSWQgPSBkYXRhLm1hcElkLFxuICAgICAgICAgICAgbGlzdGVuZXJJZCwgbWFya2VyO1xuXG4gICAgICAgIGlmICghbWUubWFwc1ttYXBJZF0pIHtcbiAgICAgICAgICAgIGxpc3RlbmVySWQgPSBtZS5vbignbWFwQ3JlYXRlZCcsIGlkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWFwSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVuKGxpc3RlbmVySWQpO1xuICAgICAgICAgICAgICAgICAgICBtZS5hZGRNYXJrZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5lby5ucyhgJHttYXBJZH1gLCB0cnVlLCBtZS5tYXJrZXJzKTtcblxuICAgICAgICAgICAgbWUubWFya2Vyc1ttYXBJZF1bZGF0YS5pZF0gPSBtYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtcbiAgICAgICAgICAgICAgICBpY29uICAgIDogZGF0YS5pY29uLFxuICAgICAgICAgICAgICAgIGxhYmVsICAgOiBkYXRhLmxhYmVsLFxuICAgICAgICAgICAgICAgIG1hcCAgICAgOiBtZS5tYXBzW21hcElkXSxcbiAgICAgICAgICAgICAgICBuZW9JZCAgIDogZGF0YS5pZCwgLy8gY3VzdG9tIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgbmVvTWFwSWQ6IG1hcElkLCAgIC8vIGN1c3RvbSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBkYXRhLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRpdGxlICAgOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hcmtlci5hZGRMaXN0ZW5lcignY2xpY2snLCBtZS5vbk1hcmtlckNsaWNrLmJpbmQobWUsIG1hcmtlcikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5jZW50ZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuZnVsbHNjcmVlbkNvbnRyb2xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLm1hcE9wdGlvbnMgLy8gUGFzcyBhbnkgb3B0aW9ucyB3aGljaCBhcmUgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBoZXJlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubWF4Wm9vbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm1pblpvb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS56b29tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLnpvb21Db250cm9sXG4gICAgICovXG4gICAgY3JlYXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGlkID0gZGF0YS5pZCxcbiAgICAgICAgICAgIG1hcDtcblxuICAgICAgICBtZS5tYXBzW2lkXSA9IG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoRG9tQWNjZXNzLmdldEVsZW1lbnQoaWQpLCB7XG4gICAgICAgICAgICBjZW50ZXIgICAgICAgICAgIDogZGF0YS5jZW50ZXIsXG4gICAgICAgICAgICBmdWxsc2NyZWVuQ29udHJvbDogZGF0YS5mdWxsc2NyZWVuQ29udHJvbCxcbiAgICAgICAgICAgIG1heFpvb20gICAgICAgICAgOiBkYXRhLm1heFpvb20sXG4gICAgICAgICAgICBtaW5ab29tICAgICAgICAgIDogZGF0YS5taW5ab29tLFxuICAgICAgICAgICAgem9vbSAgICAgICAgICAgICA6IGRhdGEuem9vbSxcbiAgICAgICAgICAgIHpvb21Db250cm9sICAgICAgOiBkYXRhLnpvb21Db250cm9sLFxuICAgICAgICAgICAgLi4uZGF0YS5tYXBPcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1hcC5hZGRMaXN0ZW5lcignem9vbV9jaGFuZ2VkJywgbWUub25NYXBab29tQ2hhbmdlLmJpbmQobWUsIG1hcCwgaWQpKTtcblxuICAgICAgICBtZS5maXJlKCdtYXBDcmVhdGVkJywgaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFsbCBtYXJrZXJzIGZvciB0aGUgc3BlY2lmaWVkIG1hcCBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLm1hcElkXG4gICAgICovXG4gICAgZGVzdHJveU1hcmtlcnMoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtYXJrZXJzID0gbWUubWFya2Vyc1tkYXRhLm1hcElkXSB8fCB7fTtcblxuICAgICAgICBPYmplY3QudmFsdWVzKG1hcmtlcnMpLmZvckVhY2gobWFya2VyID0+IG1hcmtlci5zZXRNYXAobnVsbCkpO1xuICAgICAgICBkZWxldGUgbWUubWFya2Vyc1tkYXRhLm1hcElkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgZWl0aGVyIGFkZHJlc3MsIGxvY2F0aW9uIG9yIHBsYWNlSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5sb2NhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnBsYWNlSWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFzeW5jIGdlb2NvZGUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmVzcG9uc2U7XG5cbiAgICAgICAgaWYgKCFtZS5nZW9Db2Rlcikge1xuICAgICAgICAgICAgbWUuZ2VvQ29kZXIgPSBuZXcgZ29vZ2xlLm1hcHMuR2VvY29kZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgbWUuZ2VvQ29kZXIuZ2VvY29kZShkYXRhKTtcblxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNwb25zZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5tYXBJZFxuICAgICAqL1xuICAgIGhpZGVNYXJrZXIoZGF0YSkge1xuICAgICAgICB0aGlzLm1hcmtlcnNbZGF0YS5tYXBJZF1bZGF0YS5pZF0uc2V0TWFwKG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBsb2FkQXBpKCkge1xuICAgICAgICBsZXQga2V5ID0gTmVvLmNvbmZpZy5nb29nbGVNYXBzQXBpS2V5LFxuICAgICAgICAgICAgdXJsID0gJyBodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanMnO1xuXG4gICAgICAgIERvbUFjY2Vzcy5sb2FkU2NyaXB0KGAke3VybH0/a2V5PSR7a2V5fSZ2PXdlZWtseSZjYWxsYmFjaz1OZW8uZW1wdHlGbmApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0dvb2dsZU1hcHMgQVBJIGxvYWRlZCcpO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Z29vZ2xlLm1hcHMuTWFwfSBtYXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWFwSWRcbiAgICAgKi9cbiAgICBvbk1hcFpvb21DaGFuZ2UobWFwLCBtYXBJZCkge1xuICAgICAgICBEb21FdmVudHMuc2VuZE1lc3NhZ2VUb0FwcCh7XG4gICAgICAgICAgICBpZCAgIDogbWFwSWQsXG4gICAgICAgICAgICBwYXRoIDogW3tjbHM6IFtdLCBpZDogbWFwSWR9XSxcbiAgICAgICAgICAgIHR5cGUgOiAnZ29vZ2xlTWFwWm9vbUNoYW5nZScsXG4gICAgICAgICAgICB2YWx1ZTogbWFwLnpvb21cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2dvb2dsZS5tYXBzLk1hcmtlcn0gbWFya2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRvbUV2ZW50XG4gICAgICovXG4gICAgb25NYXJrZXJDbGljayhtYXJrZXIsIGV2ZW50KSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZEV2ZW50ID0gRG9tRXZlbnRzLmdldE1vdXNlRXZlbnREYXRhKGV2ZW50LmRvbUV2ZW50KTtcblxuICAgICAgICBEb21FdmVudHMuc2VuZE1lc3NhZ2VUb0FwcCh7XG4gICAgICAgICAgICBpZCAgICAgIDogbWFya2VyLm5lb0lkLFxuICAgICAgICAgICAgcGF0aCAgICA6IFt7Y2xzOiBbXSwgaWQ6IG1hcmtlci5uZW9NYXBJZH1dLFxuICAgICAgICAgICAgdHlwZSAgICA6ICdnb29nbGVNYXJrZXJDbGljaycsXG4gICAgICAgICAgICBkb21FdmVudDogdHJhbnNmb3JtZWRFdmVudFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubWFwSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5wb3NpdGlvblxuICAgICAqL1xuICAgIHBhblRvKGRhdGEpIHtcbiAgICAgICAgdGhpcy5tYXBzW2RhdGEubWFwSWRdLnBhblRvKGRhdGEucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubWFwSWRcbiAgICAgKi9cbiAgICByZW1vdmVNYXAoZGF0YSkge1xuICAgICAgICBkZWxldGUgdGhpcy5tYXBzW2RhdGEubWFwSWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5tYXJrZXJzW2RhdGEubWFwSWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5tYXBJZFxuICAgICAqL1xuICAgIHJlbW92ZU1hcmtlcihkYXRhKSB7XG4gICAgICAgIGxldCBtYXJrZXJzID0gdGhpcy5tYXJrZXJzW2RhdGEubWFwSWRdO1xuXG4gICAgICAgIG1hcmtlcnNbZGF0YS5pZF0uc2V0TWFwKG51bGwpO1xuICAgICAgICBkZWxldGUgbWFya2Vyc1tkYXRhLmlkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEudmFsdWVcbiAgICAgKi9cbiAgICBzZXRDZW50ZXIoZGF0YSkge1xuICAgICAgICB0aGlzLm1hcHNbZGF0YS5pZF0uc2V0Q2VudGVyKGRhdGEudmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIHNldFpvb20oZGF0YSkge1xuICAgICAgICB0aGlzLm1hcHNbZGF0YS5pZF0uc2V0Wm9vbShkYXRhLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubWFwSWRcbiAgICAgKi9cbiAgICBzaG93TWFya2VyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJzW2RhdGEubWFwSWRdW2RhdGEuaWRdLnNldE1hcCh0aGlzLm1hcHNbZGF0YS5tYXBJZF0pO1xuICAgIH1cbn1cblxubGV0IGluc3RhbmNlID0gTmVvLmFwcGx5Q2xhc3NDb25maWcoR29vZ2xlTWFwcyk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9