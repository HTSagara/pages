"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_component_timer_app_mjs-src_selection_Model_mjs"],{

/***/ "./examples/component/timer/MainContainer.mjs":
/*!****************************************************!*\
  !*** ./examples/component/timer/MainContainer.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/form/field/Color.mjs */ "./src/form/field/Color.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _src_component_Timer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/component/Timer.mjs */ "./src/component/Timer.mjs");






/**
 * @class Neo.examples.component.timer.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className: 'Neo.examples.component.timer.MainContainer',
    }

    createConfigurationComponents() {
        let me = this;

        return [{
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            labelText: 'dimensions',
            listeners: {change: me.onConfigChange.bind(me, 'dimensions')},
            value    : '8rem'
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: false,
            labelText: 'colorStart',
            listeners: {change: me.onConfigChange.bind(me, 'colorStart')},
            value    : '#8a9b0f'
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: false,
            labelText: 'colorEnd',
            listeners: {change: me.onConfigChange.bind(me, 'colorEnd')},
            value    : '#940a3d'
        }]
    }

    createExampleComponent() {
        return Neo.create({
            module: _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            style : {
                overflow : 'auto',
                maxHeight: '100%'
            },
            items : [{
                html: '<h1>Configurable</h1>',
                style: {textAlign: 'center'}
            }, {
                module    : _src_component_Timer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                duration  : '20s',
                flag      : 'timer-component',
                dimensions: '8rem'
            }]
        })
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        const timer = this.down({flag: 'timer-component'});

        timer[config] = opts.value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./examples/component/timer/app.mjs":
/*!******************************************!*\
  !*** ./examples/component/timer/app.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/timer/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.timer'
});



/***/ }),

/***/ "./src/component/Timer.mjs":
/*!*********************************!*\
  !*** ./src/component/Timer.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.component.Timer
 * @extends Neo.component.Base
 */
class Timer extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Timer'
         * @protected
         */
        className: 'Neo.component.Timer',
        /**
         * @member {String} ntype='timer'
         * @protected
         */
        ntype: 'timer',
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=['timer']
         */
        baseCls: ['neo-timer'],
        /**
         * End color of the circle. If not set, it uses the css default
         * @member {Number|String} colorEnd_=null
         */
        colorEnd_: null,
        /**
         * Start color of the circle. If not set, it uses the css default
         * @member {Number|String} colorStart_=null
         */
        colorStart_: null,
        /**
         * Start time. This might be '5m', '30s' or milliseconds as number
         * @member {Number|String} duration_='5m'
         */
        duration_: '10m',
        /**
         * Defines height and min-width. This can be a number in px or a string.
         * @member {Number|String} dimensions_='6rem'
         */
        dimensions_: '8em',
        /**
         * Helper to keep running smooth at minimum cost
         * @member {Object}      timer={}
         * @member {Number|null} timer.currentSecond =null // run only once per second
         * @member {Number|null} timer.intervalId    =null // setInterval id
         * @member {Boolean}     timer.running       =false// keeps track if timer/entry is up
         * @member {Number|null} timer.startTime     =null // calc the current progress
         */
        timer: {
            currentSecond: null,
            intervalId   : null,
            running      : false,
            startTime    : null
        },
        /**
         * The vdom markup for this component.
         * @member {Object} vdom={}
         */
        vdom:
        {cn: [
            {cls: 'countdown', cn: [
                {tag: 'svg', cls: 'clock', viewBox: '-50 -50 100 100', strokeWidth: '10', cn: [
                    {tag: 'circle', r: 45},
                    {tag: 'circle', r: 45, pathLength: 1}
                ]},
                {cls: ['flip-card'], cn : [
                    {cls: 'flip-card-inner enter-mask', cn : [
                        {cls: 'flip-card-front', cn : [
                            {tag: 'input', cls: 'enter-time'},
                            {tag: 'button',cls: 'fa fa-play'}
                        ]},
                        {cls: 'flip-card-back', cn : [
                            {cls: 'runner', html: '00:00'}
                        ]}
                    ]}
                ]}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click   : me.onTimerClick,   delegate: 'flip-card-back'},
            {click   : me.onTimerClick,   delegate: 'fa fa-play'},
            {input   : me.onTimerInput,   delegate: 'enter-time'},
            {focusout: me.onTimerInput,   delegate: 'enter-time'},
            {keydown : me.onFieldKeyDown, delegate: 'enter-time'}
        ])
    }

    /**
     * Triggered after the dimensions config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetDimensions(value, oldValue) {
        if (typeof value === 'number') {
            value = value + 'px'
        }

        this.updateProperties({dimensions: value})
    }

    /**
     * Triggered after the colorStart config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetColorStart(value, oldValue) {
        value && this.updateProperties({colorStart: value})
    }

    /**
     * Triggered after the colorEnd config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetColorEnd(value, oldValue) {
        value && this.updateProperties({colorEnd: value})
    }

    /**
     * Triggered before the duration config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetDuration(value, oldValue) {
        let me = this,
            durationType;

        me.updateInputField(value)

        if (Neo.isString(value)) {
            durationType = value.at(-1);

            if (durationType === 'm') {
                value = value.split('m')[0] * 60 * 1000
            } else if (durationType === 's') {
                value = value.split('s')[0] * 1000
            }
        }

        me.updateProperties({full: value});

        return value
    }

    /**
     * Check if Enter was pressed
     * @param {Object} data
     */
    onFieldKeyDown(data) {
        let me = this;

        if (data.key === 'Enter') {
            me.duration = me.timer.entry;
            me.onTimerClick()
        }
    }

    /**
     * Click on Play or Timer
     */
    onTimerClick() {
        let me = this;

        // If the timer is running, stop and clear it
        if (me.timer.intervalId) {
            me.toggleTimer(false);
            me.resetTimer()
        } else {
            // prepare
            me.timer.startTime = new Date().getTime();

            me.timer.intervalId = setInterval(function () {
                const startTime = me.timer.startTime,
                      curTime   = new Date().getTime(),
                      totalTime = me.duration,
                      endTime   = startTime + totalTime;

                if (curTime > endTime) {
                    me.toggleTimer(false);
                    me.resetTimer()
                } else {
                    const milliseconds = endTime - curTime,
                          secondsLeft  = Math.floor(milliseconds / 1000);
                    let secondsNow = secondsLeft % 60,
                        minutesNow = Math.floor(secondsLeft / 60)

                    // Ensure this does not run 10 times a second
                    if (secondsNow !== me.timer.currentSecond) {
                        me.timer.currentSecond = secondsNow;

                        secondsNow = secondsNow.toString().padStart(2, '0');
                        minutesNow = minutesNow.toString().padStart(2, '0');

                        me.updateTimer(`${minutesNow}:${secondsNow}`);
                        me.updateProperties({current: milliseconds});
                        me.toggleTimer(true)
                    }
                }
            }, 100)
        }
    }

    /**
     * On change event of the textfield
     * @param {Object} data
     */
    onTimerInput(data) {
        let me = this;

        if (data.value) {
            me.timer.entry = data.value
        } else {
            me.duration = me.timer.entry
        }
    }

    /**
     * Reset the properties, timer and remove Interval
     */
    resetTimer() {
        let me = this;

        me.updateProperties({current: ''});
        me.updateTimer('00:00');

        clearInterval(me.timer.intervalId);
        delete me.timer.intervalId
    }

    /**
     * Flip over the timer face
     * @param {Boolean} doShow
     */
    toggleTimer(doShow) {
        if(this.running === doShow) return;

        let me       = this,
            flipCard = me.vdom.cn[0].cn[1];

        me.running = doShow;

        flipCard.cls = flipCard.cls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][doShow ? 'add' : 'remove'](flipCard.cls, 'turn');
        me.update()
    }

    /**
     * Write to the input field
     * @param {String} value
     */
    updateInputField(value) {
        let me         = this,
            inputField = me.vdom.cn[0].cn[1].cn[0].cn[0].cn[0];

        inputField.value = value;
    }

    /**
     * Update the timer, typically once per second
     * @param {String} value
     */
    updateTimer(value) {
        let me    = this,
            timer = me.vdom.cn[0].cn[1].cn[0].cn[1].cn[0];

        timer.innerHTML = value;
        me.update()
    }

    /**
     * Update the css properties
     * - current amount of seconds left
     * - full amount of time
     * - size of the timer
     * @param {Object} properties
     */
    updateProperties(properties) {
        let {style} = this;

        if (properties.current !== undefined) {
            style['--neo-timer-current'] = `${properties.current}!important`
        }
        if (properties.full !== undefined) {
            style['--neo-timer-full'] = `${properties.full}!important`
        }
        if (properties.colorEnd !== undefined) {
            style['--timer-color-end'] = `${properties.colorEnd}!important`
        }
        if (properties.colorStart !== undefined) {
            style['--timer-color-start'] = `${properties.colorStart}!important`
        }
        if (properties.dimensions !== undefined) {
            style['--timer-dimension'] = `${properties.dimensions}!important`
        }

        this.style = style
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Timer));


/***/ }),

/***/ "./src/form/field/Color.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.ComboBox
 */
class Color extends _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-combobox','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-combobox', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getInputWrapperId()});

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getColorIndicatorId()})?.vdom,
            {list, record} = me,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor();
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]))
        } else {
            selectionModel?.deselectAll(true)
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter)
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me                  = this,
            {inputValue, value} = me;

        return value ? me.colorFormatter(me, value) : me.forceSelection ? null : inputValue
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let {list} = this,
            index  = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem()
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let {list} = this;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ }),

/***/ "./src/list/Color.mjs":
/*!****************************!*\
  !*** ./src/list/Color.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.list.Color
 * @extends Neo.list.Base
 */
class Color extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Color'
         * @protected
         */
        className: 'Neo.list.Color',
        /**
         * @member {String} ntype='colorlist'
         * @protected
         */
        ntype: 'colorlist',
        /**
         * @member {String[]} baseCls=['neo-color-list','neo-list']
         */
        baseCls: ['neo-color-list', 'neo-list'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField]
    }

    /**
     * form.field.Color needs to trigger a silent vdom update
     * @member {Boolean} silentSelectUpdate=false
     * @protected
     */
    silentSelectUpdate = false

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me         = this,
            id         = record[me.store.keyProperty],
            isSelected = me.selectionModel.isSelected(me.getItemId(id));

        return [{
            tag  : 'i',
            cls  : ['neo-icon', 'fas', `fa-${isSelected ? 'check-' : ''}square`],
            id   : me.getListItemIconId(id),
            style: {
                color: me.colorFormatter(me, record)
            }
        }, {
            vtype: 'text',
            html : record[me.displayField],
            id   : me.getListItemVtextId(id)
        }]
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemIconId(recordId) {
        return `${this.id}__icon__${recordId}`
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemVtextId(recordId) {
        return `${this.id}__vtext__${recordId}`
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        let me = this;

        me.createItems(me.silentSelectUpdate);

        !me.silentSelect && me.focus(items[0])
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ }),

/***/ "./src/selection/Model.mjs":
/*!*********************************!*\
  !*** ./src/selection/Model.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.selection.Model
 * @extends Neo.core.Base
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.selection.Model'
         * @protected
         */
        className: 'Neo.selection.Model',
        /**
         * @member {String} ntype='selection-model'
         * @protected
         */
        ntype: 'selection-model',
        /**
         * Placeholder for extended classes to add a custom css rule to this owner component
         * @member {String|null} cls=null
         * @protected
         */
        cls: null,
        /**
         * @member {Array} items_=null
         * @protected
         */
        items_: null,
        /**
         * @member {String} selectedCls='selected'
         */
        selectedCls: 'neo-selected',
        /**
         * @member {Boolean} singleSelect=true
         */
        singleSelect: true,
        /**
         * Internally saves the view id, but the getter will return the matching instance
         * @member {Object} view_=null
         * @protected
         */
        view_: null
    }

    /**
     * Gets triggered before getting the value of the items config
     * @param {Array|null} value
     * @returns {Array}
     */
    beforeGetItems(value) {
        if (!value) {
            this._items = value = []
        }

        return value
    }

    /**
     * Gets triggered before getting the value of the view config
     * @param {String} value
     * @returns {Neo.component.Base}
     */
    beforeGetView(value) {
        return Neo.getComponent(this._view)
    }

    /**
     * Gets triggered before setting the value of the view config
     * @returns {String} the view id
     */
    beforeSetView(value) {
        return value && value.id
    }

    /**
     *
     */
    addDomListener() {}

    /**
     * @param {Object} item
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    deselect(item, silent, itemCollection=this.items, selectedCls) {
        // We hold vdom ids for now, so all incoming selections must be converted.
        item = item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item;

        if (itemCollection.includes(item)) {
            let me     = this,
                {view} = me,
                node   = view.getVdomChild(item);

            if (node) {
                node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(node.cls || [], selectedCls || me.selectedCls);
                node['aria-selected'] = false
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(itemCollection, item);

            if (!silent) {
                view.update();

                me.fire('selectionChange', {
                    selection: itemCollection
                })
            }
        }
        else if (!silent) {
            this.fire('noChange')
        }
    }

    /**
     * @param {Boolean} [silent] true to prevent a vdom update
     */
    deselectAll(silent) {
        let me     = this,
            items  = [...me.items],
            {view} = me;

        if (items.length) {
            items.forEach(item => {
                me.deselect(item, true)
            });

            if (!silent && items.length > 0) {
                view.update()
            }

            me.fire('selectionChange', {
                selection: this.items
            })
        }
        else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     *
     */
    destroy(...args) {
        this.unregister();
        super.destroy(...args)
    }

    /**
     * @returns {Array} this.items
     */
    getSelection() {
        return this.items
    }

    /**
     * @returns {Boolean} true in case there is a selection
     */
    hasSelection() {
        return this.items.length > 0
    }

    /**
     * @param {String} id
     * @returns {Boolean} true in case the item is selected
     */
    isSelected(id) {
        return this.items.includes(id)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me  = this,
            cls = component.cls || [];

        if (me.cls && !cls.includes(me.cls)) {
            cls.push(me.cls);
            component.cls = cls
        }

        me.view = component;
        me.addDomListener()
    }

    /**
     *
     */
    removeDomListeners() {
        let me           = this,
            component    = me.view,
            domListeners = [...component.domListeners];

        component.domListeners.forEach(listener => {
            if (listener.scope === me) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(domListeners, listener)
            }
        });

        component.domListeners = domListeners
    }

    /**
     * @param {Object|Object[]|String[]} items
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    select(items, itemCollection=this.items, selectedCls) {
        let me     = this,
            {view} = me;

        // We hold vdom ids for now, so all incoming selections must be converted.
        items = (items = Array.isArray(items) ?
            items: [items]).map(item => item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item);

        if (!Neo.isEqual(itemCollection, items)) {
            if (me.singleSelect) {
                me.deselectAll(true)
            }

            items.forEach((node, i) => {
                node = view.getVdomChild(node);

                if (node) {
                    node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls || [], selectedCls || me.selectedCls);
                    node['aria-selected'] = true
                }
            });

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemCollection, items);

            !view.silentSelect && view.update();

            view.onSelect?.(items);

            me.fire('selectionChange', {
                selection: itemCollection
            })
        }
        else {
            me.fire('noChange')
        }
    }

    /**
     * @param {Object} item
     */
    toggleSelection(item) {
        let me = this;

        if (me.isSelected(item)) {
            me.deselect(item)
        } else {
            me.select(item)
        }
    }

    /**
     *
     */
    unregister() {
        let me  = this,
            cls = me.view.cls || [];

        if (me.cls && cls.includes(me.cls)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, me.cls);
            me.view.cls = cls
        }

        me.deselectAll();

        me.removeDomListeners()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90aW1lcl9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNBO0FBQ0U7QUFDRDtBQUNBOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBcUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZ0VBQVM7QUFDaEM7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFO0FBQ0EsU0FBUztBQUNULHVCQUF1QixpRUFBVTtBQUNqQztBQUNBO0FBQ0Esd0JBQXdCLGlEQUFpRDtBQUN6RTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsaUVBQVU7QUFDakM7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBK0M7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2IsNEJBQTRCLGdFQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRUc7O0FBRXpDO0FBQ1AsY0FBYywwREFBYTtBQUMzQjtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xrQztBQUNPOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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VTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHVEQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NvbXBvbmVudC90aW1lci9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY29tcG9uZW50L3RpbWVyL2FwcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvVGltZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9Db2xvci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9saXN0L0NvbG9yLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9Nb2RlbC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbmZpZ3VyYXRpb25WaWV3cG9ydCBmcm9tICcuLi8uLi9Db25maWd1cmF0aW9uVmlld3BvcnQubWpzJztcbmltcG9ydCBDb250YWluZXIgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ29sb3JGaWVsZCAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NvbG9yLm1qcyc7XG5pbXBvcnQgVGV4dEZpZWxkICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL1RleHQubWpzJztcbmltcG9ydCBUaW1lciAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBvbmVudC9UaW1lci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY29tcG9uZW50LnRpbWVyLk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5leGFtcGxlcy5Db25maWd1cmF0aW9uVmlld3BvcnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIENvbmZpZ3VyYXRpb25WaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmV4YW1wbGVzLmNvbXBvbmVudC50aW1lci5NYWluQ29udGFpbmVyJyxcbiAgICB9XG5cbiAgICBjcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50cygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdkaW1lbnNpb25zJyl9LFxuICAgICAgICAgICAgdmFsdWUgICAgOiAnOHJlbSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDb2xvckZpZWxkLFxuICAgICAgICAgICAgY2xlYXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ2NvbG9yU3RhcnQnLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnY29sb3JTdGFydCcpfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogJyM4YTliMGYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogQ29sb3JGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdjb2xvckVuZCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdjb2xvckVuZCcpfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogJyM5NDBhM2QnXG4gICAgICAgIH1dXG4gICAgfVxuXG4gICAgY3JlYXRlRXhhbXBsZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlOiBDb250YWluZXIsXG4gICAgICAgICAgICBzdHlsZSA6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6ICcxMDAlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW1zIDogW3tcbiAgICAgICAgICAgICAgICBodG1sOiAnPGgxPkNvbmZpZ3VyYWJsZTwvaDE+JyxcbiAgICAgICAgICAgICAgICBzdHlsZToge3RleHRBbGlnbjogJ2NlbnRlcid9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgIDogVGltZXIsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gIDogJzIwcycsXG4gICAgICAgICAgICAgICAgZmxhZyAgICAgIDogJ3RpbWVyLWNvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogJzhyZW0nXG4gICAgICAgICAgICB9XVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIG9uQ29uZmlnQ2hhbmdlKGNvbmZpZywgb3B0cykge1xuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuZG93bih7ZmxhZzogJ3RpbWVyLWNvbXBvbmVudCd9KTtcblxuICAgICAgICB0aW1lcltjb25maWddID0gb3B0cy52YWx1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL01haW5Db250YWluZXIubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogTWFpbkNvbnRhaW5lcixcbiAgICBuYW1lICAgIDogJ05lby5leGFtcGxlcy5jb21wb25lbnQudGltZXInXG59KTtcblxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LlRpbWVyXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgVGltZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5UaW1lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5UaW1lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0aW1lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0aW1lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDU1Mgc2VsZWN0b3JzIHRvIGFwcGx5IHRvIHRoZSByb290IGxldmVsIG5vZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9Wyd0aW1lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10aW1lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5kIGNvbG9yIG9mIHRoZSBjaXJjbGUuIElmIG5vdCBzZXQsIGl0IHVzZXMgdGhlIGNzcyBkZWZhdWx0XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IGNvbG9yRW5kXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckVuZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydCBjb2xvciBvZiB0aGUgY2lyY2xlLiBJZiBub3Qgc2V0LCBpdCB1c2VzIHRoZSBjc3MgZGVmYXVsdFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBjb2xvclN0YXJ0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvclN0YXJ0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IHRpbWUuIFRoaXMgbWlnaHQgYmUgJzVtJywgJzMwcycgb3IgbWlsbGlzZWNvbmRzIGFzIG51bWJlclxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBkdXJhdGlvbl89JzVtJ1xuICAgICAgICAgKi9cbiAgICAgICAgZHVyYXRpb25fOiAnMTBtJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgaGVpZ2h0IGFuZCBtaW4td2lkdGguIFRoaXMgY2FuIGJlIGEgbnVtYmVyIGluIHB4IG9yIGEgc3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBkaW1lbnNpb25zXz0nNnJlbSdcbiAgICAgICAgICovXG4gICAgICAgIGRpbWVuc2lvbnNfOiAnOGVtJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlciB0byBrZWVwIHJ1bm5pbmcgc21vb3RoIGF0IG1pbmltdW0gY29zdFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9ICAgICAgdGltZXI9e31cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRpbWVyLmN1cnJlbnRTZWNvbmQgPW51bGwgLy8gcnVuIG9ubHkgb25jZSBwZXIgc2Vjb25kXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB0aW1lci5pbnRlcnZhbElkICAgID1udWxsIC8vIHNldEludGVydmFsIGlkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59ICAgICB0aW1lci5ydW5uaW5nICAgICAgID1mYWxzZS8vIGtlZXBzIHRyYWNrIGlmIHRpbWVyL2VudHJ5IGlzIHVwXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB0aW1lci5zdGFydFRpbWUgICAgID1udWxsIC8vIGNhbGMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3NcbiAgICAgICAgICovXG4gICAgICAgIHRpbWVyOiB7XG4gICAgICAgICAgICBjdXJyZW50U2Vjb25kOiBudWxsLFxuICAgICAgICAgICAgaW50ZXJ2YWxJZCAgIDogbnVsbCxcbiAgICAgICAgICAgIHJ1bm5pbmcgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRUaW1lICAgIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZkb20gbWFya3VwIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tPXt9XG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHtjbHM6ICdjb3VudGRvd24nLCBjbjogW1xuICAgICAgICAgICAgICAgIHt0YWc6ICdzdmcnLCBjbHM6ICdjbG9jaycsIHZpZXdCb3g6ICctNTAgLTUwIDEwMCAxMDAnLCBzdHJva2VXaWR0aDogJzEwJywgY246IFtcbiAgICAgICAgICAgICAgICAgICAge3RhZzogJ2NpcmNsZScsIHI6IDQ1fSxcbiAgICAgICAgICAgICAgICAgICAge3RhZzogJ2NpcmNsZScsIHI6IDQ1LCBwYXRoTGVuZ3RoOiAxfVxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnZmxpcC1jYXJkJ10sIGNuIDogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiAnZmxpcC1jYXJkLWlubmVyIGVudGVyLW1hc2snLCBjbiA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6ICdmbGlwLWNhcmQtZnJvbnQnLCBjbiA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGFnOiAnaW5wdXQnLCBjbHM6ICdlbnRlci10aW1lJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RhZzogJ2J1dHRvbicsY2xzOiAnZmEgZmEtcGxheSd9XG4gICAgICAgICAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6ICdmbGlwLWNhcmQtYmFjaycsIGNuIDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6ICdydW5uZXInLCBodG1sOiAnMDA6MDAnfVxuICAgICAgICAgICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7Y2xpY2sgICA6IG1lLm9uVGltZXJDbGljaywgICBkZWxlZ2F0ZTogJ2ZsaXAtY2FyZC1iYWNrJ30sXG4gICAgICAgICAgICB7Y2xpY2sgICA6IG1lLm9uVGltZXJDbGljaywgICBkZWxlZ2F0ZTogJ2ZhIGZhLXBsYXknfSxcbiAgICAgICAgICAgIHtpbnB1dCAgIDogbWUub25UaW1lcklucHV0LCAgIGRlbGVnYXRlOiAnZW50ZXItdGltZSd9LFxuICAgICAgICAgICAge2ZvY3Vzb3V0OiBtZS5vblRpbWVySW5wdXQsICAgZGVsZWdhdGU6ICdlbnRlci10aW1lJ30sXG4gICAgICAgICAgICB7a2V5ZG93biA6IG1lLm9uRmllbGRLZXlEb3duLCBkZWxlZ2F0ZTogJ2VudGVyLXRpbWUnfVxuICAgICAgICBdKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZGltZW5zaW9ucyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERpbWVuc2lvbnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJ3B4J1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHtkaW1lbnNpb25zOiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjb2xvclN0YXJ0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDb2xvclN0YXJ0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoe2NvbG9yU3RhcnQ6IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbG9yRW5kIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDb2xvckVuZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHtjb2xvckVuZDogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGR1cmF0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RHVyYXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBkdXJhdGlvblR5cGU7XG5cbiAgICAgICAgbWUudXBkYXRlSW5wdXRGaWVsZCh2YWx1ZSlcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgZHVyYXRpb25UeXBlID0gdmFsdWUuYXQoLTEpO1xuXG4gICAgICAgICAgICBpZiAoZHVyYXRpb25UeXBlID09PSAnbScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCdtJylbMF0gKiA2MCAqIDEwMDBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb25UeXBlID09PSAncycpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCdzJylbMF0gKiAxMDAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGVQcm9wZXJ0aWVzKHtmdWxsOiB2YWx1ZX0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIEVudGVyIHdhcyBwcmVzc2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkZpZWxkS2V5RG93bihkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBtZS5kdXJhdGlvbiA9IG1lLnRpbWVyLmVudHJ5O1xuICAgICAgICAgICAgbWUub25UaW1lckNsaWNrKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaWNrIG9uIFBsYXkgb3IgVGltZXJcbiAgICAgKi9cbiAgICBvblRpbWVyQ2xpY2soKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gSWYgdGhlIHRpbWVyIGlzIHJ1bm5pbmcsIHN0b3AgYW5kIGNsZWFyIGl0XG4gICAgICAgIGlmIChtZS50aW1lci5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBtZS50b2dnbGVUaW1lcihmYWxzZSk7XG4gICAgICAgICAgICBtZS5yZXNldFRpbWVyKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHByZXBhcmVcbiAgICAgICAgICAgIG1lLnRpbWVyLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICBtZS50aW1lci5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG1lLnRpbWVyLnN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBjdXJUaW1lICAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRpbWUgPSBtZS5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lICAgPSBzdGFydFRpbWUgKyB0b3RhbFRpbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VyVGltZSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudG9nZ2xlVGltZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtZS5yZXNldFRpbWVyKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBlbmRUaW1lIC0gY3VyVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kc0xlZnQgID0gTWF0aC5mbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlY29uZHNOb3cgPSBzZWNvbmRzTGVmdCAlIDYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlc05vdyA9IE1hdGguZmxvb3Ioc2Vjb25kc0xlZnQgLyA2MClcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBkb2VzIG5vdCBydW4gMTAgdGltZXMgYSBzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY29uZHNOb3cgIT09IG1lLnRpbWVyLmN1cnJlbnRTZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRpbWVyLmN1cnJlbnRTZWNvbmQgPSBzZWNvbmRzTm93O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzTm93ID0gc2Vjb25kc05vdy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzTm93ID0gbWludXRlc05vdy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZVRpbWVyKGAke21pbnV0ZXNOb3d9OiR7c2Vjb25kc05vd31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZVByb3BlcnRpZXMoe2N1cnJlbnQ6IG1pbGxpc2Vjb25kc30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudG9nZ2xlVGltZXIodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uIGNoYW5nZSBldmVudCBvZiB0aGUgdGV4dGZpZWxkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRpbWVySW5wdXQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICBtZS50aW1lci5lbnRyeSA9IGRhdGEudmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmR1cmF0aW9uID0gbWUudGltZXIuZW50cnlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBwcm9wZXJ0aWVzLCB0aW1lciBhbmQgcmVtb3ZlIEludGVydmFsXG4gICAgICovXG4gICAgcmVzZXRUaW1lcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS51cGRhdGVQcm9wZXJ0aWVzKHtjdXJyZW50OiAnJ30pO1xuICAgICAgICBtZS51cGRhdGVUaW1lcignMDA6MDAnKTtcblxuICAgICAgICBjbGVhckludGVydmFsKG1lLnRpbWVyLmludGVydmFsSWQpO1xuICAgICAgICBkZWxldGUgbWUudGltZXIuaW50ZXJ2YWxJZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXAgb3ZlciB0aGUgdGltZXIgZmFjZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG9TaG93XG4gICAgICovXG4gICAgdG9nZ2xlVGltZXIoZG9TaG93KSB7XG4gICAgICAgIGlmKHRoaXMucnVubmluZyA9PT0gZG9TaG93KSByZXR1cm47XG5cbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZsaXBDYXJkID0gbWUudmRvbS5jblswXS5jblsxXTtcblxuICAgICAgICBtZS5ydW5uaW5nID0gZG9TaG93O1xuXG4gICAgICAgIGZsaXBDYXJkLmNscyA9IGZsaXBDYXJkLmNscyB8fCBbXTtcblxuICAgICAgICBOZW9BcnJheVtkb1Nob3cgPyAnYWRkJyA6ICdyZW1vdmUnXShmbGlwQ2FyZC5jbHMsICd0dXJuJyk7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JpdGUgdG8gdGhlIGlucHV0IGZpZWxkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlSW5wdXRGaWVsZCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnB1dEZpZWxkID0gbWUudmRvbS5jblswXS5jblsxXS5jblswXS5jblswXS5jblswXTtcblxuICAgICAgICBpbnB1dEZpZWxkLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB0aW1lciwgdHlwaWNhbGx5IG9uY2UgcGVyIHNlY29uZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRpbWVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB0aW1lciA9IG1lLnZkb20uY25bMF0uY25bMV0uY25bMF0uY25bMV0uY25bMF07XG5cbiAgICAgICAgdGltZXIuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjc3MgcHJvcGVydGllc1xuICAgICAqIC0gY3VycmVudCBhbW91bnQgb2Ygc2Vjb25kcyBsZWZ0XG4gICAgICogLSBmdWxsIGFtb3VudCBvZiB0aW1lXG4gICAgICogLSBzaXplIG9mIHRoZSB0aW1lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgdXBkYXRlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGxldCB7c3R5bGV9ID0gdGhpcztcblxuICAgICAgICBpZiAocHJvcGVydGllcy5jdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLW5lby10aW1lci1jdXJyZW50J10gPSBgJHtwcm9wZXJ0aWVzLmN1cnJlbnR9IWltcG9ydGFudGBcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5mdWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLW5lby10aW1lci1mdWxsJ10gPSBgJHtwcm9wZXJ0aWVzLmZ1bGx9IWltcG9ydGFudGBcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5jb2xvckVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHlsZVsnLS10aW1lci1jb2xvci1lbmQnXSA9IGAke3Byb3BlcnRpZXMuY29sb3JFbmR9IWltcG9ydGFudGBcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5jb2xvclN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLXRpbWVyLWNvbG9yLXN0YXJ0J10gPSBgJHtwcm9wZXJ0aWVzLmNvbG9yU3RhcnR9IWltcG9ydGFudGBcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5kaW1lbnNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLXRpbWVyLWRpbWVuc2lvbiddID0gYCR7cHJvcGVydGllcy5kaW1lbnNpb25zfSFpbXBvcnRhbnRgXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpbWVyKTtcbiIsImltcG9ydCBDb2xvckxpc3QgZnJvbSAnLi4vLi4vbGlzdC9Db2xvci5tanMnXG5pbXBvcnQgQ29tYm9Cb3ggIGZyb20gJy4vQ29tYm9Cb3gubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLkNvbG9yXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5Db21ib0JveFxuICovXG5jbGFzcyBDb2xvciBleHRlbmRzIENvbWJvQm94IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLmZpZWxkLkNvbG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5Db2xvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb2xvcmZpZWxkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbG9yZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY29sb3JmaWVsZCcsJ25lby1jb21ib2JveCcsJ25lby1waWNrZXJmaWVsZCcsJ25lby10ZXh0ZmllbGQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY29sb3JmaWVsZCcsICduZW8tY29tYm9ib3gnLCAnbmVvLXBpY2tlcmZpZWxkJywgJ25lby10ZXh0ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhLk1vZGVsIGZpZWxkIHdoaWNoIGNvbnRhaW5zIHRoZSBjb2xvciB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbG9yRmllbGQ9J25hbWUnXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZpZWxkOiAnbmFtZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSB0aGUgZm9ybWF0dGVyIHRvIGFwcGx5IGEgY3VzdG9tIGJhY2tncm91bmQtY29sb3Igc3R5bGluZy5cbiAgICAgICAgICogRS5nLiB1c2luZyBDU1MgdmFycyBmb3IgZGlmZmVyZW50IHRoZW1lc1xuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gY29sb3JGaWVsZD0oc2NvcGUsZGF0YSk9PmRhdGFbc2NvcGUuY29sb3JGaWVsZF1cbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRm9ybWF0dGVyOiAoc2NvcGUsZGF0YSkgPT4gZGF0YVtzY29wZS5jb2xvckZpZWxkXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBsaXN0Q29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0Q29uZmlnOiB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICA6IENvbG9yTGlzdCxcbiAgICAgICAgICAgIGNvbG9yRmllbGQgICAgICAgIDogJ0Bjb25maWc6Y29sb3JGaWVsZCcsXG4gICAgICAgICAgICBjb2xvckZvcm1hdHRlciAgICA6ICdAY29uZmlnOmNvbG9yRm9ybWF0dGVyJyxcbiAgICAgICAgICAgIHNpbGVudFNlbGVjdFVwZGF0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnB1dFdyYXBwZXIgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG1lLnZkb20sIHtpZDogbWUuZ2V0SW5wdXRXcmFwcGVySWQoKX0pO1xuXG4gICAgICAgIGlucHV0V3JhcHBlci52ZG9tLmNuLnVuc2hpZnQoe1xuICAgICAgICAgICAgY2xzICA6ICduZW8tY29sb3InLFxuICAgICAgICAgICAgaWQgICA6IG1lLmdldENvbG9ySW5kaWNhdG9ySWQoKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtZS5nZXRDb2xvcigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudEZpbHRlcj1mYWxzZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHByZXZlbnRGaWx0ZXI9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbG9ySW5kaWNhdG9yID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCB7aWQ6IG1lLmdldENvbG9ySW5kaWNhdG9ySWQoKX0pPy52ZG9tLFxuICAgICAgICAgICAge2xpc3QsIHJlY29yZH0gPSBtZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsID0gbWUubGlzdD8uc2VsZWN0aW9uTW9kZWw7XG5cbiAgICAgICAgaWYgKGNvbG9ySW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBjb2xvckluZGljYXRvci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtZS5nZXRDb2xvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LnNlbGVjdChsaXN0LmdldEl0ZW1JZChyZWNvcmRbbWUuc3RvcmUua2V5UHJvcGVydHldKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCh0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHN1cGVyIGNhbGwgd2lsbCB0cmlnZ2VyIHRoZSB2ZG9tIHVwZGF0ZVxuICAgICAgICBzdXBlci5hZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgcHJldmVudEZpbHRlcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbG9yKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aW5wdXRWYWx1ZSwgdmFsdWV9ID0gbWU7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gbWUuY29sb3JGb3JtYXR0ZXIobWUsIHZhbHVlKSA6IG1lLmZvcmNlU2VsZWN0aW9uID8gbnVsbCA6IGlucHV0VmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbG9ySW5kaWNhdG9ySWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fY29sb3ItaW5kaWNhdG9yYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNlbGVjdFBvc3RMYXN0SXRlbSgpIHtcbiAgICAgICAgbGV0IHtsaXN0fSA9IHRoaXMsXG4gICAgICAgICAgICBpbmRleCAgPSBsaXN0LnN0b3JlLmdldENvdW50KCkgLSAxO1xuXG4gICAgICAgIGxpc3QudmRvbS5jbltpbmRleF0gPSBsaXN0LmNyZWF0ZUl0ZW0obGlzdC5zdG9yZS5nZXRBdChpbmRleCksIGluZGV4KTtcblxuICAgICAgICBzdXBlci5vblNlbGVjdFBvc3RMYXN0SXRlbSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UHJlRmlyc3RJdGVtKCkge1xuICAgICAgICBsZXQge2xpc3R9ID0gdGhpcztcblxuICAgICAgICBsaXN0LnZkb20uY25bMF0gPSBsaXN0LmNyZWF0ZUl0ZW0obGlzdC5zdG9yZS5nZXRBdCgwKSwgMCk7XG5cbiAgICAgICAgc3VwZXIub25TZWxlY3RQcmVGaXJzdEl0ZW0oKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29sb3IpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5saXN0LkNvbG9yXG4gKiBAZXh0ZW5kcyBOZW8ubGlzdC5CYXNlXG4gKi9cbmNsYXNzIENvbG9yIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubGlzdC5Db2xvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxpc3QuQ29sb3InLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29sb3JsaXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbG9ybGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jb2xvci1saXN0JywnbmVvLWxpc3QnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY29sb3ItbGlzdCcsICduZW8tbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEuTW9kZWwgZmllbGQgd2hpY2ggY29udGFpbnMgdGhlIGNvbG9yIHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY29sb3JGaWVsZD0nbmFtZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmllbGQ6ICduYW1lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIHRoZSBmb3JtYXR0ZXIgdG8gYXBwbHkgYSBjdXN0b20gYmFja2dyb3VuZC1jb2xvciBzdHlsaW5nLlxuICAgICAgICAgKiBFLmcuIHVzaW5nIENTUyB2YXJzIGZvciBkaWZmZXJlbnQgdGhlbWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBjb2xvckZpZWxkPShzY29wZSxkYXRhKT0+ZGF0YVtzY29wZS5jb2xvckZpZWxkXVxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGb3JtYXR0ZXI6IChzY29wZSxkYXRhKSA9PiBkYXRhW3Njb3BlLmNvbG9yRmllbGRdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZm9ybS5maWVsZC5Db2xvciBuZWVkcyB0byB0cmlnZ2VyIGEgc2lsZW50IHZkb20gdXBkYXRlXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2lsZW50U2VsZWN0VXBkYXRlPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNpbGVudFNlbGVjdFVwZGF0ZSA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIHJlbmRlcmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ30gRWl0aGVyIGEgY29uZmlnIG9iamVjdCB0byBhc3NpZ24gdG8gdGhlIGl0ZW0sIGEgdmRvbSBjbiBhcnJheSBvciBhIGh0bWwgc3RyaW5nXG4gICAgICovXG4gICAgY3JlYXRlSXRlbUNvbnRlbnQocmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICAgID0gcmVjb3JkW21lLnN0b3JlLmtleVByb3BlcnR5XSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBtZS5zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKG1lLmdldEl0ZW1JZChpZCkpO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgdGFnICA6ICdpJyxcbiAgICAgICAgICAgIGNscyAgOiBbJ25lby1pY29uJywgJ2ZhcycsIGBmYS0ke2lzU2VsZWN0ZWQgPyAnY2hlY2stJyA6ICcnfXNxdWFyZWBdLFxuICAgICAgICAgICAgaWQgICA6IG1lLmdldExpc3RJdGVtSWNvbklkKGlkKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG1lLmNvbG9yRm9ybWF0dGVyKG1lLCByZWNvcmQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZ0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBodG1sIDogcmVjb3JkW21lLmRpc3BsYXlGaWVsZF0sXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0TGlzdEl0ZW1WdGV4dElkKGlkKVxuICAgICAgICB9XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcmVjb3JkSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExpc3RJdGVtSWNvbklkKHJlY29yZElkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9faWNvbl9fJHtyZWNvcmRJZH1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TGlzdEl0ZW1WdGV4dElkKHJlY29yZElkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fdnRleHRfXyR7cmVjb3JkSWR9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGl0ZW1zXG4gICAgICovXG4gICAgb25TZWxlY3QoaXRlbXMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jcmVhdGVJdGVtcyhtZS5zaWxlbnRTZWxlY3RVcGRhdGUpO1xuXG4gICAgICAgICFtZS5zaWxlbnRTZWxlY3QgJiYgbWUuZm9jdXMoaXRlbXNbMF0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb2xvcik7XG4iLCJpbXBvcnQgQmFzZSAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIE1vZGVsIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5Nb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5Nb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLW1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYWNlaG9sZGVyIGZvciBleHRlbmRlZCBjbGFzc2VzIHRvIGFkZCBhIGN1c3RvbSBjc3MgcnVsZSB0byB0aGlzIG93bmVyIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2xzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGl0ZW1zXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc2VsZWN0ZWRDbHM9J3NlbGVjdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRDbHM6ICduZW8tc2VsZWN0ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xlU2VsZWN0PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZVNlbGVjdDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsbHkgc2F2ZXMgdGhlIHZpZXcgaWQsIGJ1dCB0aGUgZ2V0dGVyIHdpbGwgcmV0dXJuIHRoZSBtYXRjaGluZyBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZpZXdfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdmlld186IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGl0ZW1zIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgYmVmb3JlR2V0SXRlbXModmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSB2YWx1ZSA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIHZpZXcgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRWaWV3KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuX3ZpZXcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYmVmb3JlIHNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSB2aWV3IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSB2aWV3IGlkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Vmlldyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50XSB0cnVlIHRvIHByZXZlbnQgYSB2ZG9tIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118U3RyaW5nW119IGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdGVkQ2xzXVxuICAgICAqL1xuICAgIGRlc2VsZWN0KGl0ZW0sIHNpbGVudCwgaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtcywgc2VsZWN0ZWRDbHMpIHtcbiAgICAgICAgLy8gV2UgaG9sZCB2ZG9tIGlkcyBmb3Igbm93LCBzbyBhbGwgaW5jb21pbmcgc2VsZWN0aW9ucyBtdXN0IGJlIGNvbnZlcnRlZC5cbiAgICAgICAgaXRlbSA9IGl0ZW0uaXNSZWNvcmQgPyB2aWV3LmdldEl0ZW1JZChpdGVtKSA6IE5lby5pc09iamVjdChpdGVtKSA/IGl0ZW0uaWQgOiBpdGVtO1xuXG4gICAgICAgIGlmIChpdGVtQ29sbGVjdGlvbi5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICAgICAgbm9kZSAgID0gdmlldy5nZXRWZG9tQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5yZW1vdmUobm9kZS5jbHMgfHwgW10sIHNlbGVjdGVkQ2xzIHx8IG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgICAgICBub2RlWydhcmlhLXNlbGVjdGVkJ10gPSBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoaXRlbUNvbGxlY3Rpb24sIGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdzZWxlY3Rpb25DaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogaXRlbUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbm9DaGFuZ2UnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50XSB0cnVlIHRvIHByZXZlbnQgYSB2ZG9tIHVwZGF0ZVxuICAgICAqL1xuICAgIGRlc2VsZWN0QWxsKHNpbGVudCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICA9IFsuLi5tZS5pdGVtc10sXG4gICAgICAgICAgICB7dmlld30gPSBtZTtcblxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIG1lLmRlc2VsZWN0KGl0ZW0sIHRydWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFzaWxlbnQgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5pdGVtc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBtZS5maXJlKCdub0NoYW5nZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gdGhpcy5pdGVtc1xuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZXJlIGlzIGEgc2VsZWN0aW9uXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaW5jbHVkZXMoaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IGNvbXBvbmVudC5jbHMgfHwgW107XG5cbiAgICAgICAgaWYgKG1lLmNscyAmJiAhY2xzLmluY2x1ZGVzKG1lLmNscykpIHtcbiAgICAgICAgICAgIGNscy5wdXNoKG1lLmNscyk7XG4gICAgICAgICAgICBjb21wb25lbnQuY2xzID0gY2xzXG4gICAgICAgIH1cblxuICAgICAgICBtZS52aWV3ID0gY29tcG9uZW50O1xuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVEb21MaXN0ZW5lcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ICAgID0gbWUudmlldyxcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IFsuLi5jb21wb25lbnQuZG9tTGlzdGVuZXJzXTtcblxuICAgICAgICBjb21wb25lbnQuZG9tTGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnNjb3BlID09PSBtZSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShkb21MaXN0ZW5lcnMsIGxpc3RlbmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb21wb25lbnQuZG9tTGlzdGVuZXJzID0gZG9tTGlzdGVuZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W118U3RyaW5nW119IGl0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0ZWRDbHNdXG4gICAgICovXG4gICAgc2VsZWN0KGl0ZW1zLCBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zLCBzZWxlY3RlZENscykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lO1xuXG4gICAgICAgIC8vIFdlIGhvbGQgdmRvbSBpZHMgZm9yIG5vdywgc28gYWxsIGluY29taW5nIHNlbGVjdGlvbnMgbXVzdCBiZSBjb252ZXJ0ZWQuXG4gICAgICAgIGl0ZW1zID0gKGl0ZW1zID0gQXJyYXkuaXNBcnJheShpdGVtcykgP1xuICAgICAgICAgICAgaXRlbXM6IFtpdGVtc10pLm1hcChpdGVtID0+IGl0ZW0uaXNSZWNvcmQgPyB2aWV3LmdldEl0ZW1JZChpdGVtKSA6IE5lby5pc09iamVjdChpdGVtKSA/IGl0ZW0uaWQgOiBpdGVtKTtcblxuICAgICAgICBpZiAoIU5lby5pc0VxdWFsKGl0ZW1Db2xsZWN0aW9uLCBpdGVtcykpIHtcbiAgICAgICAgICAgIGlmIChtZS5zaW5nbGVTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdEFsbCh0cnVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHZpZXcuZ2V0VmRvbUNoaWxkKG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5hZGQobm9kZS5jbHMgfHwgW10sIHNlbGVjdGVkQ2xzIHx8IG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVsnYXJpYS1zZWxlY3RlZCddID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoaXRlbUNvbGxlY3Rpb24sIGl0ZW1zKTtcblxuICAgICAgICAgICAgIXZpZXcuc2lsZW50U2VsZWN0ICYmIHZpZXcudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIHZpZXcub25TZWxlY3Q/LihpdGVtcyk7XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGl0ZW1Db2xsZWN0aW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWUuZmlyZSgnbm9DaGFuZ2UnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKi9cbiAgICB0b2dnbGVTZWxlY3Rpb24oaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc1NlbGVjdGVkKGl0ZW0pKSB7XG4gICAgICAgICAgICBtZS5kZXNlbGVjdChpdGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuc2VsZWN0KGl0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUudmlldy5jbHMgfHwgW107XG5cbiAgICAgICAgaWYgKG1lLmNscyAmJiBjbHMuaW5jbHVkZXMobWUuY2xzKSkge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgbWUuY2xzKTtcbiAgICAgICAgICAgIG1lLnZpZXcuY2xzID0gY2xzXG4gICAgICAgIH1cblxuICAgICAgICBtZS5kZXNlbGVjdEFsbCgpO1xuXG4gICAgICAgIG1lLnJlbW92ZURvbUxpc3RlbmVycygpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNb2RlbCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=