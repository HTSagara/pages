"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_component_process_app_mjs-src_form_field_Base_mjs"],{

/***/ "./examples/component/process/MainContainer.mjs":
/*!******************************************************!*\
  !*** ./examples/component/process/MainContainer.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_component_Process_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/component/Process.mjs */ "./src/component/Process.mjs");
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/form/field/Color.mjs */ "./src/form/field/Color.mjs");






/**
 * @class Neo.examples.component.process.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className           : 'Neo.examples.component.process.MainContainer',
    }

    createConfigurationComponents() {
        let me = this;

        return [{
            module   : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            checked  : false,
            value    : 5,
            labelText: 'horizontal',
            listeners: {change: me.onConfigChange.bind(me, 'horizontal')}
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            clearable : false,
            labelText: 'arrowColor',
            value: '#aaa',
            listeners: {change: me.onConfigChange.bind(me, 'arrowColor')}
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            clearable : false,
            labelText: 'iconColor',
            value: '#953499',
            listeners: {change: me.onConfigChange.bind(me, 'iconColor')}
        }];
    }

    createExampleComponent() {
        return Neo.create({
            module: _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            style: {
                overflow: 'auto',
                maxHeight: '100%'
            },
            items : [{
                html: '<h1>Configurable</h1>',
                style: {textAlign: 'center'}
            }, {
                module    : _src_component_Process_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                flag      : 'color-change',
                arrowColor: '#aaa',
                horizontal: false,
                iconColor : '#953499',
                items     : [{
                    iconCls: 'fa fa-plane-departure',
                    title  : 'Start Eingabe',
                    text   : 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas porttitor congue massa. Fusce posuere, magna sed pulvinar ultricies, purus lectus malesuada libero, sit amet commodo magna eros quis urna.'
                }, {
                    iconCls: 'fa fa-road',
                    title  : 'Zwischenstand',
                    text   : 'Nunc viverra imperdiet enim. Fusce est. Vivamus a tellus.'
                }, {
                    iconCls: 'fa fa-plane-arrival',
                    title  : 'Endstand vor dem Aufladen',
                    text   : 'Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Proin pharetra nonummy pede. Mauris et orci.'
                }, {
                    iconCls: 'fa fa-square-poll-vertical',
                    title  : 'Ausgabe',
                    text   : 'Suspendisse dui purus, scelerisque at, vulputate vitae, pretium mattis, nunc. Mauris eget neque at sem venenatis eleifend. Ut nonummy.'
                }]
            }]
        });
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        const process = this.down({flag: 'color-change'});

        process[config] = opts.value;
    }
}

Neo.setupClass(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./examples/component/process/app.mjs":
/*!********************************************!*\
  !*** ./examples/component/process/app.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/process/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.process'
});

/***/ }),

/***/ "./src/component/Process.mjs":
/*!***********************************!*\
  !*** ./src/component/Process.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.component.Process
 * @extends Neo.component.Base
 *
 * @example
 *     {
 *         module: Process,
 *         arrowColor: 'darkred',
 *         items: [{
 *             iconCls: 'fa fa-car',
 *             header: '1. Wunschkennzeichen',
 *             text: 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit...'
 *         }, {
 *             iconCls: 'fa fa-house',
 *             header: '2. Termine',
 *             text: 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit...'
 *         }]
 *     }
 */
class Process extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Each item gets an arrow and the content, which gets filled with an item.
     * The slit allows to fade out the sidebar.
     *
     * @member {Object} itemLayout={cls: 'process-step', cn: [{cls: ['arrow', 'white']},{cls: ['slit']},{cls: ['arrow', 'yellow']},{cls: 'process-content', cn: [{cls: ['process-step-icon']},{tag: 'h2', cls: ['process-step-header']},{cls: ['process-step-text']}]}]}
     */
    itemLayout = {
        cls: 'process-step', cn: [
            {cls: ['arrow', 'white']},
            {cls: ['slit']},
            {cls: ['arrow', 'yellow']},
            {
                cls: 'process-content', cn: [
                    {cls: ['process-step-icon']},
                    {tag: 'h2', cls: ['process-step-header']},
                    {cls: ['process-step-text']}
                ]
            }
        ]
    }

    static config = {
        /**
         * @member {String} className='Neo.component.Process'
         * @protected
         */
        className: 'Neo.component.Process',
        /**
         * @member {String} ntype='process'
         * @protected
         */
        ntype: 'process',
        /**
         * @member {String[]} baseCls=['neo-process']
         */
        baseCls: ['neo-process'],

        /**
         * Set the color of the process arrow.
         * Out of the box this is #ffdb4a
         *
         * @member {String|null} arrowColor=null
         */
        arrowColor_: null,
        /**
         * 'true' shows the items from left to right
         * 'false' shows the items from top to bottom
         * There is a minimum width of 700px to show items 'true'
         *
         * @member {Boolean} horizontal=true
         */
        horizontal_: true,
        /**
         * Set the color of the icons.
         * Out of the box this is #ffdb4a
         *
         * @member {String|null} iconColor=null
         */
        iconColor_: null,

        /**
         * Each item will be transferred into the itemLayout
         *
         * @member {Object[]|Object} items=null
         *
         * @example
         *     items: [{
         *         iconCls: 'fa fa-car',
         *         header: '1. First Step',
         *         text: 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas porttitor congue massa. Fusce posuere, magna sed pulvinar ultricies, purus lectus malesuada libero, sit amet commodo magna eros quis urna.'
         *     }, {
         *         iconCls: 'fa fa-house',
         *         header: '2. Second Step',
         *         text: 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas porttitor congue massa. Fusce posuere, magna sed pulvinar ultricies, purus lectus malesuada libero, sit amet commodo magna eros quis urna.'
         *     }]
         */
        items_: null,

        /**
         * vdom definition is used during item creation
         * Do not remove
         *
         * @member {Object} vdom={cn:[]}
         */
        vdom: {cn: []}
    }

    /**
     * Triggered after arrowColor config got changed
     * @param {String} newValue
     * @protected
     */
    afterSetArrowColor(newValue) {
        if (newValue === null) return;

        let style = this.style;

        style['--process-arrow-color'] = newValue + '!important';
        this.style = style;
    }

    /**
     * Triggered after horizontal config got changed
     * @param {Boolean} isHorizontal
     * @protected
     */
    afterSetHorizontal(isHorizontal) {
        let cls         = this.cls,
            positionCls = isHorizontal ? 'neo-process-horizontal' : 'neo-process-vertical',
            removeCls   = !isHorizontal ? 'neo-process-horizontal' : 'neo-process-vertical';

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, positionCls);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, removeCls);

        this.cls = cls;
    }

    /**
     * Triggered after iconColor config got changed
     * @param {String} newValue
     * @protected
     */
    afterSetIconColor(newValue) {
        if (newValue === null) return;
        let style = this.style;

        style['--process-icon-color'] = newValue + '!important';

        this.style = style;
    }

    /**
     * Triggered after items config got changed
     * @param {Object[]} items
     * @protected
     */
    afterSetItems(items) {
        if (!(Neo.isArray(items) || Neo.isObject(items))) return;
        if (!Neo.isArray(items)) {
            items = [items];
        }

        let vdomRoot   = this.vdom,
            itemLayout = this.itemLayout;

        items.forEach((newItem) => {
            let curItem = Neo.clone(itemLayout, true),
                content = curItem.cn[3];

            content.cn[0].cls.push(newItem.iconCls);
            content.cn[1].innerHTML = newItem.title;
            content.cn[2].innerHTML = newItem.text;

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(vdomRoot.cn, curItem);
        });
    }
}

Neo.setupClass(Process);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Process);


/***/ }),

/***/ "./src/form/field/Base.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        fireChangeEvent    : {type: 'debounce', timer: 1000},
        fireUserChangeEvent: {type: 'debounce', timer: 1000}
    }
    /**
     * Valid values for isTouchedEvent
     * @member {String[]} isTouchedEvents=['focusEnter','focusLeave']
     * @protected
     * @static
     */
    static isTouchedEvents = ['focusEnter', 'focusLeave']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         */
        formGroup_: null,
        /**
         * True indicates that a user has interacted with the form field
         * @member {Boolean} isTouched_=false
         */
        isTouched_: false,
        /**
         * Event name which sets isTouched to true. Valid options are 'focusEnter' & 'focusLeave'
         * @member {String} isTouched_=false
         */
        isTouchedEvent_: 'focusLeave',
        /**
         * @member {String|null} name_=null
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * Triggered after the name isTouched got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetIsTouched(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'neo-is-touched', value);
        this.cls = cls;
    }

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.getInputEl().role = value;
        this.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {
        oldValue !== undefined && this.fireChangeEvent(value, oldValue)
    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString;
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Triggered before the isTouchedEvent config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetIsTouchedEvent(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'isTouchedEvent')
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value;
        } else {
            delete me.getInputEl()[key];
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*}      value
     * @param {*}      oldValue
     * @param {String} eventName
     */
    doFireChangeEvent(value, oldValue, eventName) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            formEvent     = 'field' + Neo.capitalize(eventName),
            opts          = {component: me, oldValue, value};

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        me.fire(eventName, opts);

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire(formEvent, opts)
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'change')
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireUserChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'userChange')
    }

    /**
     * Forms in neo can be nested. This method will return the closest parent which is a form.Container or null.
     * @returns {Neo.form.Container|null}
     */
    getClosestForm() {
        let me            = this,
            FormContainer = Neo.form?.Container,
            parent;

        for (parent of _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me)) {
            if (FormContainer && parent instanceof FormContainer) {
                return parent
            }
        }

        return null
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        // fields could have formGroups, but no name.
        // returning the namespace can confuse form.Container.adjustTreeLeaves(),
        // since namespaces could be considered as field instances.
        if (!me.name) {
            return null
        }

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getValue() {
        return this.value;
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true;
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        super.onFocusLeave(data);

        if (this.isTouchedEvent === 'focusEnter') {
            this.isTouched = true
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave(data);

        let me            = this,
            FormContainer = Neo.form?.Container,
            opts          = {...data, component: me, value: me.getValue()};

        if (me.isTouchedEvent === 'focusLeave') {
            me.isTouched = true
        }

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', opts)
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.value = value;
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true;
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/form/field/Color.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _Select_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Select.mjs */ "./src/form/field/Select.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.Select
 */
class Color extends _Select_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-selectfield','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-selectfield', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getInputWrapperId()});

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getColorIndicatorId()})?.vdom,
            list           = me.list,
            record         = me.record,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor();
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]));
        } else {
            selectionModel?.deselectAll(true);
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter);
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me     = this,
            record = me.record,
            value  = me.value;

        return record ? me.colorFormatter(me, record) : me.forceSelection ? null : value;
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`;
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let list  = this.list,
            index = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem();
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let list = this.list;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem();
    }
}

Neo.setupClass(Color);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color);


/***/ }),

/***/ "./src/list/Color.mjs":
/*!****************************!*\
  !*** ./src/list/Color.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.list.Color
 * @extends Neo.list.Base
 */
class Color extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Color'
         * @protected
         */
        className: 'Neo.list.Color',
        /**
         * @member {String} ntype='colorlist'
         * @protected
         */
        ntype: 'colorlist',
        /**
         * @member {String[]} baseCls=['neo-color-list','neo-list']
         */
        baseCls: ['neo-color-list', 'neo-list'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField]
    }

    /**
     * form.field.Color needs to trigger a silent vdom update
     * @member {Boolean} silentSelectUpdate=false
     * @protected
     */
    silentSelectUpdate = false

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me         = this,
            id         = record[me.store.keyProperty],
            isSelected = me.selectionModel.isSelected(me.getItemId(id));

        return [{
            tag  : 'i',
            cls  : ['neo-icon', 'fas', `fa-${isSelected ? 'check-' : ''}square`],
            id   : me.getListItemIconId(id),
            style: {
                color: me.colorFormatter(me, record)
            }
        }, {
            vtype: 'text',
            html : record[me.displayField],
            id   : me.getListItemVtextId(id)
        }];
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemIconId(recordId) {
        return `${this.id}__icon__${recordId}`;
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemVtextId(recordId) {
        return `${this.id}__vtext__${recordId}`;
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        let me = this;

        me.createItems(me.silentSelectUpdate);

        !me.silentSelect && me.focus(items[0]);
    }
}

Neo.setupClass(Color);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9wcm9jZXNzX2FwcF9tanMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ0c7QUFDSDtBQUNLO0FBQ0g7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFxQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvRUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNULHVCQUF1QixpRUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNULHVCQUF1QixpRUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiLDRCQUE0QixrRUFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsYUFBYSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDekZtQjs7QUFFekM7QUFDUCxjQUFjLDBEQUFhO0FBQzNCO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ0xpQztBQUNPOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtB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QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxLQUFLLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxSVM7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFJO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFrQixRQUFRLFVBQVUsU0FBUztBQUM3Qzs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFrQixRQUFRLFdBQVcsU0FBUztBQUM5Qzs7QUFFQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvcHJvY2Vzcy9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY29tcG9uZW50L3Byb2Nlc3MvYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9Qcm9jZXNzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL0NvbG9yLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xpc3QvQ29sb3IubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb25maWd1cmF0aW9uVmlld3BvcnQgZnJvbSAnLi4vLi4vQ29uZmlndXJhdGlvblZpZXdwb3J0Lm1qcyc7XG5pbXBvcnQgUHJvY2VzcyAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvUHJvY2Vzcy5tanMnO1xuaW1wb3J0IENvbnRhaW5lciAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBDaGVja0JveCAgICAgICAgICAgICAgZnJvbSBcIi4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NoZWNrQm94Lm1qc1wiO1xuaW1wb3J0IENvbG9yRmllbGQgICAgICAgICAgICAgZnJvbSBcIi4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NvbG9yLm1qc1wiXG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy5jb21wb25lbnQucHJvY2Vzcy5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZXhhbXBsZXMuQ29uZmlndXJhdGlvblZpZXdwb3J0XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBDb25maWd1cmF0aW9uVmlld3BvcnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIGNsYXNzTmFtZSAgICAgICAgICAgOiAnTmVvLmV4YW1wbGVzLmNvbXBvbmVudC5wcm9jZXNzLk1haW5Db250YWluZXInLFxuICAgIH1cblxuICAgIGNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnRzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDaGVja0JveCxcbiAgICAgICAgICAgIGNoZWNrZWQgIDogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAgICA6IDUsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2hvcml6b250YWwnKX1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDb2xvckZpZWxkLFxuICAgICAgICAgICAgY2xlYXJhYmxlIDogZmFsc2UsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdhcnJvd0NvbG9yJyxcbiAgICAgICAgICAgIHZhbHVlOiAnI2FhYScsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdhcnJvd0NvbG9yJyl9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogQ29sb3JGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZSA6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnaWNvbkNvbG9yJyxcbiAgICAgICAgICAgIHZhbHVlOiAnIzk1MzQ5OScsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdpY29uQ29sb3InKX1cbiAgICAgICAgfV07XG4gICAgfVxuXG4gICAgY3JlYXRlRXhhbXBsZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlOiBDb250YWluZXIsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtcyA6IFt7XG4gICAgICAgICAgICAgICAgaHRtbDogJzxoMT5Db25maWd1cmFibGU8L2gxPicsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHt0ZXh0QWxpZ246ICdjZW50ZXInfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICA6IFByb2Nlc3MsXG4gICAgICAgICAgICAgICAgZmxhZyAgICAgIDogJ2NvbG9yLWNoYW5nZScsXG4gICAgICAgICAgICAgICAgYXJyb3dDb2xvcjogJyNhYWEnLFxuICAgICAgICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGljb25Db2xvciA6ICcjOTUzNDk5JyxcbiAgICAgICAgICAgICAgICBpdGVtcyAgICAgOiBbe1xuICAgICAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtcGxhbmUtZGVwYXJ0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgIDogJ1N0YXJ0IEVpbmdhYmUnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVlciBhZGlwaXNjaW5nIGVsaXQuIE1hZWNlbmFzIHBvcnR0aXRvciBjb25ndWUgbWFzc2EuIEZ1c2NlIHBvc3VlcmUsIG1hZ25hIHNlZCBwdWx2aW5hciB1bHRyaWNpZXMsIHB1cnVzIGxlY3R1cyBtYWxlc3VhZGEgbGliZXJvLCBzaXQgYW1ldCBjb21tb2RvIG1hZ25hIGVyb3MgcXVpcyB1cm5hLidcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYSBmYS1yb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgIDogJ1p3aXNjaGVuc3RhbmQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnTnVuYyB2aXZlcnJhIGltcGVyZGlldCBlbmltLiBGdXNjZSBlc3QuIFZpdmFtdXMgYSB0ZWxsdXMuJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLXBsYW5lLWFycml2YWwnLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSAgOiAnRW5kc3RhbmQgdm9yIGRlbSBBdWZsYWRlbicsXG4gICAgICAgICAgICAgICAgICAgIHRleHQgICA6ICdQZWxsZW50ZXNxdWUgaGFiaXRhbnQgbW9yYmkgdHJpc3RpcXVlIHNlbmVjdHVzIGV0IG5ldHVzIGV0IG1hbGVzdWFkYSBmYW1lcyBhYyB0dXJwaXMgZWdlc3Rhcy4gUHJvaW4gcGhhcmV0cmEgbm9udW1teSBwZWRlLiBNYXVyaXMgZXQgb3JjaS4nXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtc3F1YXJlLXBvbGwtdmVydGljYWwnLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSAgOiAnQXVzZ2FiZScsXG4gICAgICAgICAgICAgICAgICAgIHRleHQgICA6ICdTdXNwZW5kaXNzZSBkdWkgcHVydXMsIHNjZWxlcmlzcXVlIGF0LCB2dWxwdXRhdGUgdml0YWUsIHByZXRpdW0gbWF0dGlzLCBudW5jLiBNYXVyaXMgZWdldCBuZXF1ZSBhdCBzZW0gdmVuZW5hdGlzIGVsZWlmZW5kLiBVdCBub251bW15LidcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgb25Db25maWdDaGFuZ2UoY29uZmlnLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3MgPSB0aGlzLmRvd24oe2ZsYWc6ICdjb2xvci1jaGFuZ2UnfSk7XG5cbiAgICAgICAgcHJvY2Vzc1tjb25maWddID0gb3B0cy52YWx1ZTtcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBNYWluQ29udGFpbmVyO1xuIiwiaW1wb3J0IE1haW5Db250YWluZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvblN0YXJ0ID0gKCkgPT4gTmVvLmFwcCh7XG4gICAgbWFpblZpZXc6IE1haW5Db250YWluZXIsXG4gICAgbmFtZSAgICA6ICdOZW8uZXhhbXBsZXMuY29tcG9uZW50LnByb2Nlc3MnXG59KTsiLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LlByb2Nlc3NcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAge1xuICogICAgICAgICBtb2R1bGU6IFByb2Nlc3MsXG4gKiAgICAgICAgIGFycm93Q29sb3I6ICdkYXJrcmVkJyxcbiAqICAgICAgICAgaXRlbXM6IFt7XG4gKiAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY2FyJyxcbiAqICAgICAgICAgICAgIGhlYWRlcjogJzEuIFd1bnNjaGtlbm56ZWljaGVuJyxcbiAqICAgICAgICAgICAgIHRleHQ6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dWVyIGFkaXBpc2NpbmcgZWxpdC4uLidcbiAqICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLWhvdXNlJyxcbiAqICAgICAgICAgICAgIGhlYWRlcjogJzIuIFRlcm1pbmUnLFxuICogICAgICAgICAgICAgdGV4dDogJ0xvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ZXIgYWRpcGlzY2luZyBlbGl0Li4uJ1xuICogICAgICAgICB9XVxuICogICAgIH1cbiAqL1xuY2xhc3MgUHJvY2VzcyBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEVhY2ggaXRlbSBnZXRzIGFuIGFycm93IGFuZCB0aGUgY29udGVudCwgd2hpY2ggZ2V0cyBmaWxsZWQgd2l0aCBhbiBpdGVtLlxuICAgICAqIFRoZSBzbGl0IGFsbG93cyB0byBmYWRlIG91dCB0aGUgc2lkZWJhci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbUxheW91dD17Y2xzOiAncHJvY2Vzcy1zdGVwJywgY246IFt7Y2xzOiBbJ2Fycm93JywgJ3doaXRlJ119LHtjbHM6IFsnc2xpdCddfSx7Y2xzOiBbJ2Fycm93JywgJ3llbGxvdyddfSx7Y2xzOiAncHJvY2Vzcy1jb250ZW50JywgY246IFt7Y2xzOiBbJ3Byb2Nlc3Mtc3RlcC1pY29uJ119LHt0YWc6ICdoMicsIGNsczogWydwcm9jZXNzLXN0ZXAtaGVhZGVyJ119LHtjbHM6IFsncHJvY2Vzcy1zdGVwLXRleHQnXX1dfV19XG4gICAgICovXG4gICAgaXRlbUxheW91dCA9IHtcbiAgICAgICAgY2xzOiAncHJvY2Vzcy1zdGVwJywgY246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnYXJyb3cnLCAnd2hpdGUnXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ3NsaXQnXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ2Fycm93JywgJ3llbGxvdyddfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbHM6ICdwcm9jZXNzLWNvbnRlbnQnLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ3Byb2Nlc3Mtc3RlcC1pY29uJ119LFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiAnaDInLCBjbHM6IFsncHJvY2Vzcy1zdGVwLWhlYWRlciddfSxcbiAgICAgICAgICAgICAgICAgICAge2NsczogWydwcm9jZXNzLXN0ZXAtdGV4dCddfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5Qcm9jZXNzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LlByb2Nlc3MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncHJvY2VzcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwcm9jZXNzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXByb2Nlc3MnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcHJvY2VzcyddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNvbG9yIG9mIHRoZSBwcm9jZXNzIGFycm93LlxuICAgICAgICAgKiBPdXQgb2YgdGhlIGJveCB0aGlzIGlzICNmZmRiNGFcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFycm93Q29sb3I9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYXJyb3dDb2xvcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAndHJ1ZScgc2hvd3MgdGhlIGl0ZW1zIGZyb20gbGVmdCB0byByaWdodFxuICAgICAgICAgKiAnZmFsc2UnIHNob3dzIHRoZSBpdGVtcyBmcm9tIHRvcCB0byBib3R0b21cbiAgICAgICAgICogVGhlcmUgaXMgYSBtaW5pbXVtIHdpZHRoIG9mIDcwMHB4IHRvIHNob3cgaXRlbXMgJ3RydWUnXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhvcml6b250YWw9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaG9yaXpvbnRhbF86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNvbG9yIG9mIHRoZSBpY29ucy5cbiAgICAgICAgICogT3V0IG9mIHRoZSBib3ggdGhpcyBpcyAjZmZkYjRhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpY29uQ29sb3I9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNvbG9yXzogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRWFjaCBpdGVtIHdpbGwgYmUgdHJhbnNmZXJyZWQgaW50byB0aGUgaXRlbUxheW91dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxPYmplY3R9IGl0ZW1zPW51bGxcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogICAgIGl0ZW1zOiBbe1xuICAgICAgICAgKiAgICAgICAgIGljb25DbHM6ICdmYSBmYS1jYXInLFxuICAgICAgICAgKiAgICAgICAgIGhlYWRlcjogJzEuIEZpcnN0IFN0ZXAnLFxuICAgICAgICAgKiAgICAgICAgIHRleHQ6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dWVyIGFkaXBpc2NpbmcgZWxpdC4gTWFlY2VuYXMgcG9ydHRpdG9yIGNvbmd1ZSBtYXNzYS4gRnVzY2UgcG9zdWVyZSwgbWFnbmEgc2VkIHB1bHZpbmFyIHVsdHJpY2llcywgcHVydXMgbGVjdHVzIG1hbGVzdWFkYSBsaWJlcm8sIHNpdCBhbWV0IGNvbW1vZG8gbWFnbmEgZXJvcyBxdWlzIHVybmEuJ1xuICAgICAgICAgKiAgICAgfSwge1xuICAgICAgICAgKiAgICAgICAgIGljb25DbHM6ICdmYSBmYS1ob3VzZScsXG4gICAgICAgICAqICAgICAgICAgaGVhZGVyOiAnMi4gU2Vjb25kIFN0ZXAnLFxuICAgICAgICAgKiAgICAgICAgIHRleHQ6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dWVyIGFkaXBpc2NpbmcgZWxpdC4gTWFlY2VuYXMgcG9ydHRpdG9yIGNvbmd1ZSBtYXNzYS4gRnVzY2UgcG9zdWVyZSwgbWFnbmEgc2VkIHB1bHZpbmFyIHVsdHJpY2llcywgcHVydXMgbGVjdHVzIG1hbGVzdWFkYSBsaWJlcm8sIHNpdCBhbWV0IGNvbW1vZG8gbWFnbmEgZXJvcyBxdWlzIHVybmEuJ1xuICAgICAgICAgKiAgICAgfV1cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdmRvbSBkZWZpbml0aW9uIGlzIHVzZWQgZHVyaW5nIGl0ZW0gY3JlYXRpb25cbiAgICAgICAgICogRG8gbm90IHJlbW92ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209e2NuOltdfVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbToge2NuOiBbXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgYXJyb3dDb2xvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3VmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcnJvd0NvbG9yKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICAgICAgc3R5bGVbJy0tcHJvY2Vzcy1hcnJvdy1jb2xvciddID0gbmV3VmFsdWUgKyAnIWltcG9ydGFudCc7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgaG9yaXpvbnRhbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSG9yaXpvbnRhbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhvcml6b250YWwoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGxldCBjbHMgICAgICAgICA9IHRoaXMuY2xzLFxuICAgICAgICAgICAgcG9zaXRpb25DbHMgPSBpc0hvcml6b250YWwgPyAnbmVvLXByb2Nlc3MtaG9yaXpvbnRhbCcgOiAnbmVvLXByb2Nlc3MtdmVydGljYWwnLFxuICAgICAgICAgICAgcmVtb3ZlQ2xzICAgPSAhaXNIb3Jpem9udGFsID8gJ25lby1wcm9jZXNzLWhvcml6b250YWwnIDogJ25lby1wcm9jZXNzLXZlcnRpY2FsJztcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCBwb3NpdGlvbkNscyk7XG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIHJlbW92ZUNscyk7XG5cbiAgICAgICAgdGhpcy5jbHMgPSBjbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIGljb25Db2xvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3VmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJY29uQ29sb3IobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICAgICAgc3R5bGVbJy0tcHJvY2Vzcy1pY29uLWNvbG9yJ10gPSBuZXdWYWx1ZSArICchaW1wb3J0YW50JztcblxuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIGl0ZW1zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXRlbXMoaXRlbXMpIHtcbiAgICAgICAgaWYgKCEoTmVvLmlzQXJyYXkoaXRlbXMpIHx8IE5lby5pc09iamVjdChpdGVtcykpKSByZXR1cm47XG4gICAgICAgIGlmICghTmVvLmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmRvbVJvb3QgICA9IHRoaXMudmRvbSxcbiAgICAgICAgICAgIGl0ZW1MYXlvdXQgPSB0aGlzLml0ZW1MYXlvdXQ7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgobmV3SXRlbSkgPT4ge1xuICAgICAgICAgICAgbGV0IGN1ckl0ZW0gPSBOZW8uY2xvbmUoaXRlbUxheW91dCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgY29udGVudCA9IGN1ckl0ZW0uY25bM107XG5cbiAgICAgICAgICAgIGNvbnRlbnQuY25bMF0uY2xzLnB1c2gobmV3SXRlbS5pY29uQ2xzKTtcbiAgICAgICAgICAgIGNvbnRlbnQuY25bMV0uaW5uZXJIVE1MID0gbmV3SXRlbS50aXRsZTtcbiAgICAgICAgICAgIGNvbnRlbnQuY25bMl0uaW5uZXJIVE1MID0gbmV3SXRlbS50ZXh0O1xuXG4gICAgICAgICAgICBOZW9BcnJheS5hZGQodmRvbVJvb3QuY24sIGN1ckl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKFByb2Nlc3MpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9jZXNzO1xuIiwiaW1wb3J0IENvbXBvbmVudCAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZm9ybSBmaWVsZHNcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7XG4gICAgICAgIGZpcmVDaGFuZ2VFdmVudCAgICA6IHt0eXBlOiAnZGVib3VuY2UnLCB0aW1lcjogMTAwMH0sXG4gICAgICAgIGZpcmVVc2VyQ2hhbmdlRXZlbnQ6IHt0eXBlOiAnZGVib3VuY2UnLCB0aW1lcjogMTAwMH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBpc1RvdWNoZWRFdmVudFxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBpc1RvdWNoZWRFdmVudHM9Wydmb2N1c0VudGVyJywnZm9jdXNMZWF2ZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUb3VjaGVkRXZlbnRzID0gWydmb2N1c0VudGVyJywgJ2ZvY3VzTGVhdmUnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Jhc2VmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdiYXNlZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybSBncm91cHMgY2FuIGdldCBzZXQgb24gYW55IHBhcmVudCBjb21wb25lbnQgbGV2ZWwuXG4gICAgICAgICAqIEFuIGFsdGVybmF0aXZlIHdheSBmb3IgdXNpbmcgZG90cyBpbiBmaWVsZCBuYW1lcy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybUdyb3VwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaW5kaWNhdGVzIHRoYXQgYSB1c2VyIGhhcyBpbnRlcmFjdGVkIHdpdGggdGhlIGZvcm0gZmllbGRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNUb3VjaGVkXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNUb3VjaGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBuYW1lIHdoaWNoIHNldHMgaXNUb3VjaGVkIHRvIHRydWUuIFZhbGlkIG9wdGlvbnMgYXJlICdmb2N1c0VudGVyJyAmICdmb2N1c0xlYXZlJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlzVG91Y2hlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzVG91Y2hlZEV2ZW50XzogJ2ZvY3VzTGVhdmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IG5hbWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogTmVvIGl0c2VsZiBkb2VzIG5vdCBuZWVkIGZpZWxkIG5hbWVzIHRvIGdldCBtYXBwZWQgdG8gdGhlIERPTSAoaW5wdXQgbm9kZXMpLFxuICAgICAgICAgKiBleGNlcHQgZm9yIENoZWNrQm94ZXMgJiBSYWRpb3MgdG8gd29yay4gSXQgY2FuIGJlIHVzZWZ1bCBmb3IgdGVzdGluZyB0b29sc1xuICAgICAgICAgKiAmIGFjY2Vzc2liaWxpdHkgdGhvdWdoLCBzbyB0aGUgZGVmYXVsdCBnb3Qgc2V0IHRvIHRydWUuXG4gICAgICAgICAqIEZlZWwgZnJlZSB0byBjaGFuZ2UgaXQgdG8gZmFsc2UgdG8ga2VlcCB0aGUgRE9NIG1pbmltYWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlck5hbWVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlck5hbWVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gY2FzZSByZW5kZXJOYW1lIGlzIHNldCB0byB0cnVlLCB5b3UgY2FuIG9wdGlvbmFsbHkgcmVuZGVyIHRoZSBjb21iaW5hdGlvblxuICAgICAgICAgKiBvZiBhbGwgZm9ybUdyb3VwKHMpICYgdGhlIGZpZWxkIG5hbWUgaW50byB0aGUgRE9NID0+IGlucHV0IG5vZGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyUGF0aD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJQYXRoOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Kn0gdmFsdWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGNhY2hlIGZvciBmb3JtR3JvdXBzIG9mIGFsbCBwYXJlbnQgbGV2ZWxzXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cFN0cmluZz1udWxsXG4gICAgICovXG4gICAgZm9ybUdyb3VwU3RyaW5nID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGNhY2hlIGZvciBmb3JtR3JvdXAocykgYW5kIHRoZSBmaWVsZCBuYW1lXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHBhdGg9bnVsbFxuICAgICAqL1xuICAgIHBhdGggPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG5hbWUgaXNUb3VjaGVkIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNUb3VjaGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1pcy10b3VjaGVkJywgdmFsdWUpO1xuICAgICAgICB0aGlzLmNscyA9IGNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0TmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZW5kZXJOYW1lICYmIG1lLmNoYW5nZUlucHV0RWxLZXkoJ25hbWUnLCBtZS5yZW5kZXJQYXRoID8gbWUuZ2V0UGF0aCgpIDogdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb2xlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb2xlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmdldElucHV0RWwoKS5yb2xlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZm9ybUdyb3VwIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBwYXJlbnRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldEZvcm1Hcm91cCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JvdXAgPSBbXSxcbiAgICAgICAgICAgIHJldHVyblZhbHVlO1xuXG4gICAgICAgIGlmIChtZS5mb3JtR3JvdXBTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5mb3JtR3JvdXBTdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAmJiBncm91cC5wdXNoKHZhbHVlKTtcblxuICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgIHBhcmVudC5mb3JtR3JvdXAgJiYgZ3JvdXAudW5zaGlmdChwYXJlbnQuZm9ybUdyb3VwKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm5WYWx1ZSA9IGdyb3VwLmpvaW4oJy4nKTtcblxuICAgICAgICBtZS5mb3JtR3JvdXBTdHJpbmcgPSByZXR1cm5WYWx1ZTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBpc1RvdWNoZWRFdmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldElzVG91Y2hlZEV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnaXNUb3VjaGVkRXZlbnQnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlIG9mIGEgaW5wdXRFbCB2ZG9tIG9iamVjdCBhdHRyaWJ1dGUgb3IgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IGhhcyBubyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcnxPYmplY3R8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjaGFuZ2VJbnB1dEVsS2V5KGtleSwgdmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSB8fCBOZW8uaXNCb29sZWFuKHZhbHVlKSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgbWUuZ2V0SW5wdXRFbCgpW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5nZXRJbnB1dEVsKClba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICovXG4gICAgZG9GaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlLCBldmVudE5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICBmb3JtRXZlbnQgICAgID0gJ2ZpZWxkJyArIE5lby5jYXBpdGFsaXplKGV2ZW50TmFtZSksXG4gICAgICAgICAgICBvcHRzICAgICAgICAgID0ge2NvbXBvbmVudDogbWUsIG9sZFZhbHVlLCB2YWx1ZX07XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKG1lLmdldEdyb3VwVmFsdWUpKSB7XG4gICAgICAgICAgICBvcHRzLmdyb3VwVmFsdWUgPSBtZS5nZXRHcm91cFZhbHVlKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmZpcmUoZXZlbnROYW1lLCBvcHRzKTtcblxuICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZpcmUoZm9ybUV2ZW50LCBvcHRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb0ZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUsICdjaGFuZ2UnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZVVzZXJDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb0ZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUsICd1c2VyQ2hhbmdlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtcyBpbiBuZW8gY2FuIGJlIG5lc3RlZC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgcGFyZW50IHdoaWNoIGlzIGEgZm9ybS5Db250YWluZXIgb3IgbnVsbC5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmZvcm0uQ29udGFpbmVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q2xvc2VzdEZvcm0oKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyLFxuICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgIGZvciAocGFyZW50IG9mIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkpIHtcbiAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRJbnB1dEVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tYmluYXRpb24gb2YgdGhlIGZpZWxkIGZvcm1Hcm91cChzKSAmIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHBhdGg7XG5cbiAgICAgICAgLy8gZmllbGRzIGNvdWxkIGhhdmUgZm9ybUdyb3VwcywgYnV0IG5vIG5hbWUuXG4gICAgICAgIC8vIHJldHVybmluZyB0aGUgbmFtZXNwYWNlIGNhbiBjb25mdXNlIGZvcm0uQ29udGFpbmVyLmFkanVzdFRyZWVMZWF2ZXMoKSxcbiAgICAgICAgLy8gc2luY2UgbmFtZXNwYWNlcyBjb3VsZCBiZSBjb25zaWRlcmVkIGFzIGZpZWxkIGluc3RhbmNlcy5cbiAgICAgICAgaWYgKCFtZS5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5wYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gbWUuZm9ybUdyb3VwID8gbWUuZm9ybUdyb3VwLnNwbGl0KCcuJykgOiBbXTtcblxuICAgICAgICAgICAgbWUubmFtZSAmJiBwYXRoLnB1c2gobWUubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5wYXRoID0gcGF0aC5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnBhdGgpIHtcbiAgICAgICAgICAgIG1lLnBhdGggPSAnbm9uZSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5wYXRoID09PSAnbm9uZScgPyBudWxsOiBtZS5wYXRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Gb2N1c0VudGVyKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hlZEV2ZW50ID09PSAnZm9jdXNFbnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyLFxuICAgICAgICAgICAgb3B0cyAgICAgICAgICA9IHsuLi5kYXRhLCBjb21wb25lbnQ6IG1lLCB2YWx1ZTogbWUuZ2V0VmFsdWUoKX07XG5cbiAgICAgICAgaWYgKG1lLmlzVG91Y2hlZEV2ZW50ID09PSAnZm9jdXNMZWF2ZScpIHtcbiAgICAgICAgICAgIG1lLmlzVG91Y2hlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihtZS5nZXRHcm91cFZhbHVlKSkge1xuICAgICAgICAgICAgb3B0cy5ncm91cFZhbHVlID0gbWUuZ2V0R3JvdXBWYWx1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZpcmUoJ2ZpZWxkRm9jdXNMZWF2ZScsIG9wdHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZmllbGQgdG8gYSBuZXcgdmFsdWUgb3IgbnVsbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWU9bnVsbFxuICAgICAqL1xuICAgIHJlc2V0KHZhbHVlPW51bGwpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY2xpZW50LXNpZGUgZmllbGQgZXJyb3JzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2xpZW50LXNpZGUgZXJyb3JzXG4gICAgICovXG4gICAgdmFsaWRhdGUoc2lsZW50PXRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBjaGFuZ2UgZXZlbnQgZmlyZXMgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAqIEBldmVudCBjaGFuZ2VcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U7XG4iLCJpbXBvcnQgQ29sb3JMaXN0IGZyb20gJy4uLy4uL2xpc3QvQ29sb3IubWpzJ1xuaW1wb3J0IFNlbGVjdCAgICBmcm9tICcuL1NlbGVjdC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLlNlbGVjdFxuICovXG5jbGFzcyBDb2xvciBleHRlbmRzIFNlbGVjdCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5Db2xvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuQ29sb3InLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29sb3JmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb2xvcmZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvbG9yZmllbGQnLCduZW8tc2VsZWN0ZmllbGQnLCduZW8tcGlja2VyZmllbGQnLCduZW8tdGV4dGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNvbG9yZmllbGQnLCAnbmVvLXNlbGVjdGZpZWxkJywgJ25lby1waWNrZXJmaWVsZCcsICduZW8tdGV4dGZpZWxkJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YS5Nb2RlbCBmaWVsZCB3aGljaCBjb250YWlucyB0aGUgY29sb3IgdmFsdWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb2xvckZpZWxkPSduYW1lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgdGhlIGZvcm1hdHRlciB0byBhcHBseSBhIGN1c3RvbSBiYWNrZ3JvdW5kLWNvbG9yIHN0eWxpbmcuXG4gICAgICAgICAqIEUuZy4gdXNpbmcgQ1NTIHZhcnMgZm9yIGRpZmZlcmVudCB0aGVtZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGNvbG9yRmllbGQ9KHNjb3BlLGRhdGEpPT5kYXRhW3Njb3BlLmNvbG9yRmllbGRdXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZvcm1hdHRlcjogKHNjb3BlLGRhdGEpID0+IGRhdGFbc2NvcGUuY29sb3JGaWVsZF0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbGlzdENvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbmZpZzoge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgOiBDb2xvckxpc3QsXG4gICAgICAgICAgICBjb2xvckZpZWxkICAgICAgICA6ICdAY29uZmlnOmNvbG9yRmllbGQnLFxuICAgICAgICAgICAgY29sb3JGb3JtYXR0ZXIgICAgOiAnQGNvbmZpZzpjb2xvckZvcm1hdHRlcicsXG4gICAgICAgICAgICBzaWxlbnRTZWxlY3RVcGRhdGU6IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5wdXRXcmFwcGVyID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCB7aWQ6IG1lLmdldElucHV0V3JhcHBlcklkKCl9KTtcblxuICAgICAgICBpbnB1dFdyYXBwZXIudmRvbS5jbi51bnNoaWZ0KHtcbiAgICAgICAgICAgIGNscyAgOiAnbmVvLWNvbG9yJyxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRDb2xvckluZGljYXRvcklkKCksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbWUuZ2V0Q29sb3IoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRGaWx0ZXI9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBwcmV2ZW50RmlsdGVyPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb2xvckluZGljYXRvciA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQobWUudmRvbSwge2lkOiBtZS5nZXRDb2xvckluZGljYXRvcklkKCl9KT8udmRvbSxcbiAgICAgICAgICAgIGxpc3QgICAgICAgICAgID0gbWUubGlzdCxcbiAgICAgICAgICAgIHJlY29yZCAgICAgICAgID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwgPSBtZS5saXN0Py5zZWxlY3Rpb25Nb2RlbDtcblxuICAgICAgICBpZiAoY29sb3JJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGNvbG9ySW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1lLmdldENvbG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uc2VsZWN0KGxpc3QuZ2V0SXRlbUlkKHJlY29yZFttZS5zdG9yZS5rZXlQcm9wZXJ0eV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBzdXBlciBjYWxsIHdpbGwgdHJpZ2dlciB0aGUgdmRvbSB1cGRhdGVcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHByZXZlbnRGaWx0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29sb3IoKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgdmFsdWUgID0gbWUudmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZCA/IG1lLmNvbG9yRm9ybWF0dGVyKG1lLCByZWNvcmQpIDogbWUuZm9yY2VTZWxlY3Rpb24gPyBudWxsIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2xvckluZGljYXRvcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2NvbG9yLWluZGljYXRvcmA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UG9zdExhc3RJdGVtKCkge1xuICAgICAgICBsZXQgbGlzdCAgPSB0aGlzLmxpc3QsXG4gICAgICAgICAgICBpbmRleCA9IGxpc3Quc3RvcmUuZ2V0Q291bnQoKSAtIDE7XG5cbiAgICAgICAgbGlzdC52ZG9tLmNuW2luZGV4XSA9IGxpc3QuY3JlYXRlSXRlbShsaXN0LnN0b3JlLmdldEF0KGluZGV4KSwgaW5kZXgpO1xuXG4gICAgICAgIHN1cGVyLm9uU2VsZWN0UG9zdExhc3RJdGVtKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UHJlRmlyc3RJdGVtKCkge1xuICAgICAgICBsZXQgbGlzdCA9IHRoaXMubGlzdDtcblxuICAgICAgICBsaXN0LnZkb20uY25bMF0gPSBsaXN0LmNyZWF0ZUl0ZW0obGlzdC5zdG9yZS5nZXRBdCgwKSwgMCk7XG5cbiAgICAgICAgc3VwZXIub25TZWxlY3RQcmVGaXJzdEl0ZW0oKTtcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKENvbG9yKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29sb3I7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxpc3QuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqL1xuY2xhc3MgQ29sb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5saXN0LkNvbG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGlzdC5Db2xvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb2xvcmxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29sb3JsaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvbG9yLWxpc3QnLCduZW8tbGlzdCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb2xvci1saXN0JywgJ25lby1saXN0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YS5Nb2RlbCBmaWVsZCB3aGljaCBjb250YWlucyB0aGUgY29sb3IgdmFsdWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb2xvckZpZWxkPSduYW1lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgdGhlIGZvcm1hdHRlciB0byBhcHBseSBhIGN1c3RvbSBiYWNrZ3JvdW5kLWNvbG9yIHN0eWxpbmcuXG4gICAgICAgICAqIEUuZy4gdXNpbmcgQ1NTIHZhcnMgZm9yIGRpZmZlcmVudCB0aGVtZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGNvbG9yRmllbGQ9KHNjb3BlLGRhdGEpPT5kYXRhW3Njb3BlLmNvbG9yRmllbGRdXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZvcm1hdHRlcjogKHNjb3BlLGRhdGEpID0+IGRhdGFbc2NvcGUuY29sb3JGaWVsZF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmb3JtLmZpZWxkLkNvbG9yIG5lZWRzIHRvIHRyaWdnZXIgYSBzaWxlbnQgdmRvbSB1cGRhdGVcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWxlbnRTZWxlY3RVcGRhdGU9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2lsZW50U2VsZWN0VXBkYXRlID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgICAgICAgPSByZWNvcmRbbWUuc3RvcmUua2V5UHJvcGVydHldLFxuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IG1lLnNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQobWUuZ2V0SXRlbUlkKGlkKSk7XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICB0YWcgIDogJ2knLFxuICAgICAgICAgICAgY2xzICA6IFsnbmVvLWljb24nLCAnZmFzJywgYGZhLSR7aXNTZWxlY3RlZCA/ICdjaGVjay0nIDogJyd9c3F1YXJlYF0sXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0TGlzdEl0ZW1JY29uSWQoaWQpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbWUuY29sb3JGb3JtYXR0ZXIobWUsIHJlY29yZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdnR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGh0bWwgOiByZWNvcmRbbWUuZGlzcGxheUZpZWxkXSxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRMaXN0SXRlbVZ0ZXh0SWQoaWQpXG4gICAgICAgIH1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcmVjb3JkSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExpc3RJdGVtSWNvbklkKHJlY29yZElkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9faWNvbl9fJHtyZWNvcmRJZH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcmVjb3JkSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExpc3RJdGVtVnRleHRJZChyZWNvcmRJZCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX3Z0ZXh0X18ke3JlY29yZElkfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zKG1lLnNpbGVudFNlbGVjdFVwZGF0ZSk7XG5cbiAgICAgICAgIW1lLnNpbGVudFNlbGVjdCAmJiBtZS5mb2N1cyhpdGVtc1swXSk7XG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhDb2xvcik7XG5cbmV4cG9ydCBkZWZhdWx0IENvbG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9