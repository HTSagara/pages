"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_code_LivePreview_mjs"],{

/***/ "./src/code/LivePreview.mjs":
/*!**********************************!*\
  !*** ./src/code/LivePreview.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/wrapper/MonacoEditor.mjs */ "./src/component/wrapper/MonacoEditor.mjs");
/* harmony import */ var _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tab/Container.mjs */ "./src/tab/Container.mjs");




const
    classDeclarationRegex = /class\s+([a-zA-Z$_][a-zA-Z0-9$_]*)\s*(?:extends\s+[a-zA-Z$_][a-zA-Z0-9$_]*)?\s*{[\s\S]*?}/g,
    exportRegex           = /export\s+(?:default\s+)?(?:const|let|var|class|function|async\s+function|generator\s+function|async\s+generator\s+function|(\{[\s\S]*?\}))/g,
    importRegex           = /import\s+([\w-]+)\s+from\s+['"]([^'"]+)['"]/;

/**
 * @class Neo.code.LivePreview
 * @extends Neo.container.Base
 */
class LivePreview extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for iconPosition
     * @member {String[]} activeViews=['preview','source']
     * @protected
     * @static
     */
    static activeViews = ['preview', 'source']

    static config = {
        /**
         * @member {String} className='Neo.code.LivePreview'
         * @protected
         */
        className: 'Neo.code.LivePreview',
        /**
         * @member {String} ntype='live-preview'
         * @protected
         */
        ntype: 'live-preview',
        /**
         * Valid values are 'preview' and 'source'
         * @member {String} activeView_='source'
         */
        activeView_: 'source',
        /**
         * @member {String[]} baseCls=['neo-code-live-preview']
         */
        baseCls: ['neo-code-live-preview'],
        /**
         * @member {Boolean} disableRunSource=false
         */
        disableRunSource: false,
        /**
         * @member {Number} height=400
         */
        height: 400,
        /**
         * @member {Object|String} layout='fit'
         */
        layout: 'fit',
        /**
         * @member {Object[]} items
         */
        items: [{
            module             : _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            cls                : ['live-preview-container'],
            reference          : 'tab-container',
            removeInactiveCards: false,

            items: [{
                module         : _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                hideLabel      : true,
                listeners      : {editorChange: 'up.onEditorChange'},
                style          : {height: '100%'},
                reference      : 'editor',
                tabButtonConfig: {text: 'Source'}
            }, {
                module         : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                reference      : 'preview',
                tabButtonConfig: {text: 'Preview'}
            }]
        }],
        /**
         * The code to display inside the Monaco editor
         * @member {String|null} value_=null
         */
        value_: null,
    }

    /**
     * Link the preview output to different targets
     * @member {Neo.component.Base} previewContainer=null
     */
    previewContainer = null

    /**
     * @returns {Neo.component.Base|null}
     */
    get tabContainer() {
        return this.getItem('tab-container')
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        this.tabContainer.activeIndex = value === 'source' ? 0 : 1
    }

    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        if (value) {
            this.getItem('editor').value = value?.trim()
        }
    }

    /**
     * Triggered before the activeView config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView')
    }

    /**
     *
     */
    async createPopupWindow() {
        let me      = this,
            winData = await Neo.Main.getWindowData(),
            rect    = await me.getDomRect(me.getReference('preview').id);

        let {height, left, top, width} = rect;

        height -= 50; // popup header in Chrome
        left   += winData.screenLeft;
        top    += (winData.outerHeight - winData.innerHeight + winData.screenTop);

        Neo.Main.windowOpen({
            url           : `./childapps/preview/index.html?id=${me.id}`,
            windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
            windowName    : me.id
        })
    }

    /**
     *
     */
    doRunSource() {
        if (this.disableRunSource) {
            return
        }

        let me                = this,
            source            = me.editorValue || me.value,
            cleanLines        = [],
            importModuleNames = [],
            moduleNameAndPath = [],
            className         = me.findLastClassName(source);

        source.split('\n').forEach(line => {
            let importMatch = line.match(importRegex);

            if (importMatch) {
                let moduleName = importMatch[1],
                    path       = importMatch[2];

                moduleNameAndPath.push({moduleName, path});

                importModuleNames.push(moduleName);
            } else if (line.match(exportRegex)) {
                // Skip export statements
            } else {
                cleanLines.push(`    ${line}`);
            }
        });

        var params = [];
        var vars   = [];
        // Figure out the parts of the source we'll be running.
        // o The promises/import() corresponding to the user's import statements
        // o The vars holding the name of the imported module based on the module name for each import
        // o The rest of the user-provided source
        // It'll end up looking like this:
        // Promise.all([
        //     import('../../../node_modules/neo.mjs/src/container/Base.mjs'),
        //     import('../../../node_modules/neo.mjs/src/button/Base.mjs')
        //   ]).then(([BaseModule, ButtonModule]) => {
        //       const Base = BaseModule.default;
        //       const Button = ButtonModule.default;
        //       // Class declaration goes here...
        //   });
        // Making the promise part of the eval seems weird, but it made it easier to
        // set up the import vars.

        let promises = moduleNameAndPath.map(item => {
            params.push(`${item.moduleName}Module`);
            vars.push(`    const ${item.moduleName} = ${item.moduleName}Module.default;`);
            return `import('${item.path}')`
        });

        const codeString = [
            'Promise.all([',
            `    ${promises.join(',\n')}`,
            `]).then(([${params.join(', ')}]) => {`,
            `${vars.join('\n')}`,
            `    ${cleanLines.join('\n')}`,
            '',
            `    if (${className} && Neo.component.Base.isPrototypeOf(${className})) {`,
            `        container.add({module:${className}})`,
            '    }',
            '})',
            '.catch(error => container.add({ntype:\'component\', html:error.message}));'
        ].join('\n')

        const container = me.getPreviewContainer();
        container.removeAll();

        try {
            new Function('container', codeString)(container);
        } catch (error) {
            container.add({
                ntype: 'component',
                html : error.message
            })
        }
    }

    /**
     * @param {String} sourceCode
     * @returns {String|null}
     */
    findLastClassName(sourceCode) {
        let lastClassName = null,
            match;

        // Iterate through all matches of the regular expression
        while ((match = classDeclarationRegex.exec(sourceCode)) !== null) {
            // Update the last class name found
            lastClassName = match[1]
        }

        return lastClassName
    }

    /**
     * @returns {Neo.component.Base|null}
     */
    getPreviewContainer() {
        let me = this;

        if (me.previewContainer) {
            return me.previewContainer
        }

        return me.getReference('preview')
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.item
     * @param {Number} data.oldValue
     * @param {String} data.source
     * @param {Number} data.value
     */
    onActiveIndexChange(data) {
        if (data.item.reference === 'preview') {
            this.doRunSource()
        }

        this.getReference('popout-window-button').hidden = data.value !== 1
        this.disableRunSource = false;
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me             = this,
            {tabContainer} = me;

        // we want to add a normal (non-header) button
        tabContainer.getTabBar().add({
            handler  : me.popoutPreview.bind(me),
            hidden   : tabContainer.activeIndex !== 1,
            iconCls  : 'far fa-window-maximize',
            reference: 'popout-window-button',
            style    : {marginLeft: 'auto'},
            ui       : 'ghost'
        });

        tabContainer.on('activeIndexChange', me.onActiveIndexChange, me);

        // changing the activeView initially will not trigger our onActiveIndexChange() logic
        me.activeView === 'preview' && me.doRunSource()
    }

    /**
     * @param {Object} data
     */
    onEditorChange(data) {
        let me = this;

        me.editorValue = data.value;

        // We are not using getPreviewContainer(), since we only want to update the LivePreview in case it is visible.
        if (me.previewContainer) {
            me.doRunSource()
        }
    }

    /**
     * @param {Object} data
     */
    async popoutPreview(data) {
        let me = this;

        data.component.disabled = true;
        await me.createPopupWindow();

        // this component requires a view controller to manage connected apps
        me.getController('viewport-controller')?.connectedApps.push(me.id)
    }
}

Neo.setupClass(LivePreview);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LivePreview);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb2RlX0xpdmVQcmV2aWV3X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEI7O0FBRWhEO0FBQ0EsNkdBQTZHLFNBQVM7QUFDdEgsMkpBQTJKLFVBQVU7QUFDcks7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVM7QUFDbkM7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFZO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQywyRUFBWTtBQUM3QztBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEUsa0NBQWtDLGVBQWU7QUFDakQ7QUFDQSxrQ0FBa0M7QUFDbEMsYUFBYTtBQUNiLGlDQUFpQywyREFBUztBQUMxQztBQUNBLGtDQUFrQztBQUNsQyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsMEJBQTBCOztBQUV2QyxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFLHNDQUFzQyxPQUFPLFFBQVEsS0FBSyxPQUFPLElBQUksU0FBUyxNQUFNO0FBQ3BGO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsaUJBQWlCOztBQUV6RDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCx1Q0FBdUMsS0FBSztBQUM1QztBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQyxtQ0FBbUMsaUJBQWlCLElBQUksZ0JBQWdCLGVBQWU7QUFDdkYsOEJBQThCLFVBQVU7QUFDeEMsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4Qyx5QkFBeUIsa0JBQWtCLE9BQU87QUFDbEQsZUFBZSxnQkFBZ0I7QUFDL0IsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBLHVCQUF1QixXQUFXLHNDQUFzQyxVQUFVLElBQUk7QUFDdEYsb0NBQW9DLFNBQVMsV0FBVztBQUN4RCxrQkFBa0I7QUFDbEIsY0FBYztBQUNkLDRDQUE0Qyx3Q0FBd0MsR0FBRztBQUN2Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsY0FBYzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFdBQVcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29kZS9MaXZlUHJldmlldy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbnRhaW5lciAgICBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IE1vbmFjb0VkaXRvciBmcm9tICcuLi9jb21wb25lbnQvd3JhcHBlci9Nb25hY29FZGl0b3IubWpzJ1xuaW1wb3J0IFRhYkNvbnRhaW5lciBmcm9tICcuLi90YWIvQ29udGFpbmVyLm1qcyc7XG5cbmNvbnN0XG4gICAgY2xhc3NEZWNsYXJhdGlvblJlZ2V4ID0gL2NsYXNzXFxzKyhbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopXFxzKig/OmV4dGVuZHNcXHMrW2EtekEtWiRfXVthLXpBLVowLTkkX10qKT9cXHMqe1tcXHNcXFNdKj99L2csXG4gICAgZXhwb3J0UmVnZXggICAgICAgICAgID0gL2V4cG9ydFxccysoPzpkZWZhdWx0XFxzKyk/KD86Y29uc3R8bGV0fHZhcnxjbGFzc3xmdW5jdGlvbnxhc3luY1xccytmdW5jdGlvbnxnZW5lcmF0b3JcXHMrZnVuY3Rpb258YXN5bmNcXHMrZ2VuZXJhdG9yXFxzK2Z1bmN0aW9ufChcXHtbXFxzXFxTXSo/XFx9KSkvZyxcbiAgICBpbXBvcnRSZWdleCAgICAgICAgICAgPSAvaW1wb3J0XFxzKyhbXFx3LV0rKVxccytmcm9tXFxzK1snXCJdKFteJ1wiXSspWydcIl0vO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29kZS5MaXZlUHJldmlld1xuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIExpdmVQcmV2aWV3IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGljb25Qb3NpdGlvblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhY3RpdmVWaWV3cz1bJ3ByZXZpZXcnLCdzb3VyY2UnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGFjdGl2ZVZpZXdzID0gWydwcmV2aWV3JywgJ3NvdXJjZSddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb2RlLkxpdmVQcmV2aWV3J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29kZS5MaXZlUHJldmlldycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsaXZlLXByZXZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGl2ZS1wcmV2aWV3JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmUgJ3ByZXZpZXcnIGFuZCAnc291cmNlJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGFjdGl2ZVZpZXdfPSdzb3VyY2UnXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVWaWV3XzogJ3NvdXJjZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jb2RlLWxpdmUtcHJldmlldyddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb2RlLWxpdmUtcHJldmlldyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGlzYWJsZVJ1blNvdXJjZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZVJ1blNvdXJjZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGhlaWdodD00MDBcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodDogNDAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ30gbGF5b3V0PSdmaXQnXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6ICdmaXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IFRhYkNvbnRhaW5lcixcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgICA6IFsnbGl2ZS1wcmV2aWV3LWNvbnRhaW5lciddLFxuICAgICAgICAgICAgcmVmZXJlbmNlICAgICAgICAgIDogJ3RhYi1jb250YWluZXInLFxuICAgICAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogZmFsc2UsXG5cbiAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgIDogTW9uYWNvRWRpdG9yLFxuICAgICAgICAgICAgICAgIGhpZGVMYWJlbCAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICAgICA6IHtlZGl0b3JDaGFuZ2U6ICd1cC5vbkVkaXRvckNoYW5nZSd9LFxuICAgICAgICAgICAgICAgIHN0eWxlICAgICAgICAgIDoge2hlaWdodDogJzEwMCUnfSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2UgICAgICA6ICdlZGl0b3InLFxuICAgICAgICAgICAgICAgIHRhYkJ1dHRvbkNvbmZpZzoge3RleHQ6ICdTb3VyY2UnfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgIDogQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZSAgICAgIDogJ3ByZXZpZXcnLFxuICAgICAgICAgICAgICAgIHRhYkJ1dHRvbkNvbmZpZzoge3RleHQ6ICdQcmV2aWV3J31cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvZGUgdG8gZGlzcGxheSBpbnNpZGUgdGhlIE1vbmFjbyBlZGl0b3JcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHZhbHVlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGwsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGluayB0aGUgcHJldmlldyBvdXRwdXQgdG8gZGlmZmVyZW50IHRhcmdldHNcbiAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V9IHByZXZpZXdDb250YWluZXI9bnVsbFxuICAgICAqL1xuICAgIHByZXZpZXdDb250YWluZXIgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0IHRhYkNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbSgndGFiLWNvbnRhaW5lcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhY3RpdmVWaWV3IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFjdGl2ZVZpZXcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudGFiQ29udGFpbmVyLmFjdGl2ZUluZGV4ID0gdmFsdWUgPT09ICdzb3VyY2UnID8gMCA6IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmdldEl0ZW0oJ2VkaXRvcicpLnZhbHVlID0gdmFsdWU/LnRyaW0oKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgYWN0aXZlVmlldyBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0QWN0aXZlVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2FjdGl2ZVZpZXcnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUG9wdXBXaW5kb3coKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHdpbkRhdGEgPSBhd2FpdCBOZW8uTWFpbi5nZXRXaW5kb3dEYXRhKCksXG4gICAgICAgICAgICByZWN0ICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChtZS5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKS5pZCk7XG5cbiAgICAgICAgbGV0IHtoZWlnaHQsIGxlZnQsIHRvcCwgd2lkdGh9ID0gcmVjdDtcblxuICAgICAgICBoZWlnaHQgLT0gNTA7IC8vIHBvcHVwIGhlYWRlciBpbiBDaHJvbWVcbiAgICAgICAgbGVmdCAgICs9IHdpbkRhdGEuc2NyZWVuTGVmdDtcbiAgICAgICAgdG9wICAgICs9ICh3aW5EYXRhLm91dGVySGVpZ2h0IC0gd2luRGF0YS5pbm5lckhlaWdodCArIHdpbkRhdGEuc2NyZWVuVG9wKTtcblxuICAgICAgICBOZW8uTWFpbi53aW5kb3dPcGVuKHtcbiAgICAgICAgICAgIHVybCAgICAgICAgICAgOiBgLi9jaGlsZGFwcHMvcHJldmlldy9pbmRleC5odG1sP2lkPSR7bWUuaWR9YCxcbiAgICAgICAgICAgIHdpbmRvd0ZlYXR1cmVzOiBgaGVpZ2h0PSR7aGVpZ2h0fSxsZWZ0PSR7bGVmdH0sdG9wPSR7dG9wfSx3aWR0aD0ke3dpZHRofWAsXG4gICAgICAgICAgICB3aW5kb3dOYW1lICAgIDogbWUuaWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRvUnVuU291cmNlKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlUnVuU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzb3VyY2UgICAgICAgICAgICA9IG1lLmVkaXRvclZhbHVlIHx8IG1lLnZhbHVlLFxuICAgICAgICAgICAgY2xlYW5MaW5lcyAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGltcG9ydE1vZHVsZU5hbWVzID0gW10sXG4gICAgICAgICAgICBtb2R1bGVOYW1lQW5kUGF0aCA9IFtdLFxuICAgICAgICAgICAgY2xhc3NOYW1lICAgICAgICAgPSBtZS5maW5kTGFzdENsYXNzTmFtZShzb3VyY2UpO1xuXG4gICAgICAgIHNvdXJjZS5zcGxpdCgnXFxuJykuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgIGxldCBpbXBvcnRNYXRjaCA9IGxpbmUubWF0Y2goaW1wb3J0UmVnZXgpO1xuXG4gICAgICAgICAgICBpZiAoaW1wb3J0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW9kdWxlTmFtZSA9IGltcG9ydE1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICBwYXRoICAgICAgID0gaW1wb3J0TWF0Y2hbMl07XG5cbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lQW5kUGF0aC5wdXNoKHttb2R1bGVOYW1lLCBwYXRofSk7XG5cbiAgICAgICAgICAgICAgICBpbXBvcnRNb2R1bGVOYW1lcy5wdXNoKG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKGV4cG9ydFJlZ2V4KSkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgZXhwb3J0IHN0YXRlbWVudHNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW5MaW5lcy5wdXNoKGAgICAgJHtsaW5lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIHZhciB2YXJzICAgPSBbXTtcbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgcGFydHMgb2YgdGhlIHNvdXJjZSB3ZSdsbCBiZSBydW5uaW5nLlxuICAgICAgICAvLyBvIFRoZSBwcm9taXNlcy9pbXBvcnQoKSBjb3JyZXNwb25kaW5nIHRvIHRoZSB1c2VyJ3MgaW1wb3J0IHN0YXRlbWVudHNcbiAgICAgICAgLy8gbyBUaGUgdmFycyBob2xkaW5nIHRoZSBuYW1lIG9mIHRoZSBpbXBvcnRlZCBtb2R1bGUgYmFzZWQgb24gdGhlIG1vZHVsZSBuYW1lIGZvciBlYWNoIGltcG9ydFxuICAgICAgICAvLyBvIFRoZSByZXN0IG9mIHRoZSB1c2VyLXByb3ZpZGVkIHNvdXJjZVxuICAgICAgICAvLyBJdCdsbCBlbmQgdXAgbG9va2luZyBsaWtlIHRoaXM6XG4gICAgICAgIC8vIFByb21pc2UuYWxsKFtcbiAgICAgICAgLy8gICAgIGltcG9ydCgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL2NvbnRhaW5lci9CYXNlLm1qcycpLFxuICAgICAgICAvLyAgICAgaW1wb3J0KCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmVvLm1qcy9zcmMvYnV0dG9uL0Jhc2UubWpzJylcbiAgICAgICAgLy8gICBdKS50aGVuKChbQmFzZU1vZHVsZSwgQnV0dG9uTW9kdWxlXSkgPT4ge1xuICAgICAgICAvLyAgICAgICBjb25zdCBCYXNlID0gQmFzZU1vZHVsZS5kZWZhdWx0O1xuICAgICAgICAvLyAgICAgICBjb25zdCBCdXR0b24gPSBCdXR0b25Nb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgLy8gICAgICAgLy8gQ2xhc3MgZGVjbGFyYXRpb24gZ29lcyBoZXJlLi4uXG4gICAgICAgIC8vICAgfSk7XG4gICAgICAgIC8vIE1ha2luZyB0aGUgcHJvbWlzZSBwYXJ0IG9mIHRoZSBldmFsIHNlZW1zIHdlaXJkLCBidXQgaXQgbWFkZSBpdCBlYXNpZXIgdG9cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBpbXBvcnQgdmFycy5cblxuICAgICAgICBsZXQgcHJvbWlzZXMgPSBtb2R1bGVOYW1lQW5kUGF0aC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgJHtpdGVtLm1vZHVsZU5hbWV9TW9kdWxlYCk7XG4gICAgICAgICAgICB2YXJzLnB1c2goYCAgICBjb25zdCAke2l0ZW0ubW9kdWxlTmFtZX0gPSAke2l0ZW0ubW9kdWxlTmFtZX1Nb2R1bGUuZGVmYXVsdDtgKTtcbiAgICAgICAgICAgIHJldHVybiBgaW1wb3J0KCcke2l0ZW0ucGF0aH0nKWBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY29kZVN0cmluZyA9IFtcbiAgICAgICAgICAgICdQcm9taXNlLmFsbChbJyxcbiAgICAgICAgICAgIGAgICAgJHtwcm9taXNlcy5qb2luKCcsXFxuJyl9YCxcbiAgICAgICAgICAgIGBdKS50aGVuKChbJHtwYXJhbXMuam9pbignLCAnKX1dKSA9PiB7YCxcbiAgICAgICAgICAgIGAke3ZhcnMuam9pbignXFxuJyl9YCxcbiAgICAgICAgICAgIGAgICAgJHtjbGVhbkxpbmVzLmpvaW4oJ1xcbicpfWAsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIGAgICAgaWYgKCR7Y2xhc3NOYW1lfSAmJiBOZW8uY29tcG9uZW50LkJhc2UuaXNQcm90b3R5cGVPZigke2NsYXNzTmFtZX0pKSB7YCxcbiAgICAgICAgICAgIGAgICAgICAgIGNvbnRhaW5lci5hZGQoe21vZHVsZToke2NsYXNzTmFtZX19KWAsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJ30pJyxcbiAgICAgICAgICAgICcuY2F0Y2goZXJyb3IgPT4gY29udGFpbmVyLmFkZCh7bnR5cGU6XFwnY29tcG9uZW50XFwnLCBodG1sOmVycm9yLm1lc3NhZ2V9KSk7J1xuICAgICAgICBdLmpvaW4oJ1xcbicpXG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbWUuZ2V0UHJldmlld0NvbnRhaW5lcigpO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbignY29udGFpbmVyJywgY29kZVN0cmluZykoY29udGFpbmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGQoe1xuICAgICAgICAgICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICBodG1sIDogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2VDb2RlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGZpbmRMYXN0Q2xhc3NOYW1lKHNvdXJjZUNvZGUpIHtcbiAgICAgICAgbGV0IGxhc3RDbGFzc05hbWUgPSBudWxsLFxuICAgICAgICAgICAgbWF0Y2g7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBtYXRjaGVzIG9mIHRoZSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGNsYXNzRGVjbGFyYXRpb25SZWdleC5leGVjKHNvdXJjZUNvZGUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNsYXNzIG5hbWUgZm91bmRcbiAgICAgICAgICAgIGxhc3RDbGFzc05hbWUgPSBtYXRjaFsxXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhc3RDbGFzc05hbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0UHJldmlld0NvbnRhaW5lcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucHJldmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByZXZpZXdDb250YWluZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuc291cmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudmFsdWVcbiAgICAgKi9cbiAgICBvbkFjdGl2ZUluZGV4Q2hhbmdlKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaXRlbS5yZWZlcmVuY2UgPT09ICdwcmV2aWV3Jykge1xuICAgICAgICAgICAgdGhpcy5kb1J1blNvdXJjZSgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgncG9wb3V0LXdpbmRvdy1idXR0b24nKS5oaWRkZW4gPSBkYXRhLnZhbHVlICE9PSAxXG4gICAgICAgIHRoaXMuZGlzYWJsZVJ1blNvdXJjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dGFiQ29udGFpbmVyfSA9IG1lO1xuXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gYWRkIGEgbm9ybWFsIChub24taGVhZGVyKSBidXR0b25cbiAgICAgICAgdGFiQ29udGFpbmVyLmdldFRhYkJhcigpLmFkZCh7XG4gICAgICAgICAgICBoYW5kbGVyICA6IG1lLnBvcG91dFByZXZpZXcuYmluZChtZSksXG4gICAgICAgICAgICBoaWRkZW4gICA6IHRhYkNvbnRhaW5lci5hY3RpdmVJbmRleCAhPT0gMSxcbiAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhciBmYS13aW5kb3ctbWF4aW1pemUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAncG9wb3V0LXdpbmRvdy1idXR0b24nLFxuICAgICAgICAgICAgc3R5bGUgICAgOiB7bWFyZ2luTGVmdDogJ2F1dG8nfSxcbiAgICAgICAgICAgIHVpICAgICAgIDogJ2dob3N0J1xuICAgICAgICB9KTtcblxuICAgICAgICB0YWJDb250YWluZXIub24oJ2FjdGl2ZUluZGV4Q2hhbmdlJywgbWUub25BY3RpdmVJbmRleENoYW5nZSwgbWUpO1xuXG4gICAgICAgIC8vIGNoYW5naW5nIHRoZSBhY3RpdmVWaWV3IGluaXRpYWxseSB3aWxsIG5vdCB0cmlnZ2VyIG91ciBvbkFjdGl2ZUluZGV4Q2hhbmdlKCkgbG9naWNcbiAgICAgICAgbWUuYWN0aXZlVmlldyA9PT0gJ3ByZXZpZXcnICYmIG1lLmRvUnVuU291cmNlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRWRpdG9yQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5lZGl0b3JWYWx1ZSA9IGRhdGEudmFsdWU7XG5cbiAgICAgICAgLy8gV2UgYXJlIG5vdCB1c2luZyBnZXRQcmV2aWV3Q29udGFpbmVyKCksIHNpbmNlIHdlIG9ubHkgd2FudCB0byB1cGRhdGUgdGhlIExpdmVQcmV2aWV3IGluIGNhc2UgaXQgaXMgdmlzaWJsZS5cbiAgICAgICAgaWYgKG1lLnByZXZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIG1lLmRvUnVuU291cmNlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgcG9wb3V0UHJldmlldyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgZGF0YS5jb21wb25lbnQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBhd2FpdCBtZS5jcmVhdGVQb3B1cFdpbmRvdygpO1xuXG4gICAgICAgIC8vIHRoaXMgY29tcG9uZW50IHJlcXVpcmVzIGEgdmlldyBjb250cm9sbGVyIHRvIG1hbmFnZSBjb25uZWN0ZWQgYXBwc1xuICAgICAgICBtZS5nZXRDb250cm9sbGVyKCd2aWV3cG9ydC1jb250cm9sbGVyJyk/LmNvbm5lY3RlZEFwcHMucHVzaChtZS5pZClcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKExpdmVQcmV2aWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgTGl2ZVByZXZpZXc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=