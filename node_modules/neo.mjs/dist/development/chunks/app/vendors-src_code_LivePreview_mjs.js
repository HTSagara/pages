"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_code_LivePreview_mjs"],{

/***/ "./src/code/LivePreview.mjs":
/*!**********************************!*\
  !*** ./src/code/LivePreview.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/wrapper/MonacoEditor.mjs */ "./src/component/wrapper/MonacoEditor.mjs");
/* harmony import */ var _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tab/Container.mjs */ "./src/tab/Container.mjs");




const
    classDeclarationRegex = /class\s+([a-zA-Z$_][a-zA-Z0-9$_]*)\s*(?:extends\s+[a-zA-Z$_][a-zA-Z0-9$_]*)?\s*{[\s\S]*?}/g,
    exportRegex           = /export\s+(?:default\s+)?(?:const|let|var|class|function|async\s+function|generator\s+function|async\s+generator\s+function|(\{[\s\S]*?\}))/g,
    importRegex           = /import\s+([\w-]+)\s+from\s+['"]([^'"]+)['"]/;

/**
 * @class Neo.code.LivePreview
 * @extends Neo.container.Base
 */
class LivePreview extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for iconPosition
     * @member {String[]} activeViews=['preview','source']
     * @protected
     * @static
     */
    static activeViews = ['preview', 'source']

    static config = {
        /**
         * @member {String} className='Neo.code.LivePreview'
         * @protected
         */
        className: 'Neo.code.LivePreview',
        /**
         * @member {String} ntype='live-preview'
         * @protected
         */
        ntype: 'live-preview',
        /**
         * Valid values are 'preview' and 'source'
         * @member {String} activeView_='source'
         */
        activeView_: 'source',
        /**
         * @member {String[]} baseCls=['neo-code-live-preview']
         */
        baseCls: ['neo-code-live-preview'],
        /**
         * @member {Boolean} disableRunSource=false
         */
        disableRunSource: false,
        /**
         * @member {Boolean} enableFullscreen=true
         */
        enableFullscreen: true,
        /**
         * @member {Number} height=400
         */
        height: 400,
        /**
         * @member {Object|String} layout='fit'
         */
        layout: 'fit',
        /**
         * @member {Object[]} items
         */
        items: [{
            module             : _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            cls                : ['live-preview-container'],
            reference          : 'tab-container',
            removeInactiveCards: false,

            items: [{
                module         : _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                hideLabel      : true,
                listeners      : {editorChange: 'up.onEditorChange'},
                style          : {height: '100%'},
                reference      : 'editor',
                tabButtonConfig: {text: 'Source'}
            }, {
                module         : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                reference      : 'preview',
                tabButtonConfig: {text: 'Preview'}
            }]
        }],
        /**
         * The code to display inside the Monaco editor
         * @member {String|null} value_=null
         */
        value_: null,
    }

    /**
     * Link the preview output to different targets
     * @member {Neo.component.Base} previewContainer=null
     */
    previewContainer = null

    /**
     * @returns {Neo.component.Base|null}
     */
    get tabContainer() {
        return this.getItem('tab-container')
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        this.tabContainer.activeIndex = value === 'source' ? 0 : 1
    }

    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        if (value) {
            this.getItem('editor').value = value?.trim()
        }
    }

    /**
     * Triggered before the activeView config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView')
    }

    /**
     * @param {Object} data
     */
    async collapseExpand(data) {
        let me       = this,
            button   = data.component,
            collapse = button.iconCls === 'fas fa-compress',
            {vdom}   = me,
            rect;

        if (collapse) {
            button.iconCls = 'fas fa-expand';

            rect = me.collapseRect;

            delete me.collapseRect;

            Object.assign(vdom.style, {
                height  : rect.height + 'px',
                left    : rect.x      + 'px',
                top     : rect.y      + 'px',
                width   : rect.width  + 'px'
            });

            me.update();

            await me.timeout(300);

            Object.assign(vdom.style, {
                position: null,
                zIndex  : null
            })
        } else {
            button.iconCls = 'fas fa-compress';

            rect = await me.getDomRect();

            me.collapseRect = rect;

            vdom.style = vdom.style || {};

            Object.assign(vdom.style, {
                height  : rect.height + 'px',
                left    : rect.x      + 'px',
                position: 'fixed',
                top     : rect.y      + 'px',
                width   : rect.width  + 'px',
                zIndex  : 100
            });

            me.update();

            await me.timeout(50);

            Object.assign(vdom.style, {
                height: '100%',
                left  : 0,
                top   : 0,
                width : '100%'
            })
        }

        me.update()
    }

    /**
     *
     */
    async createPopupWindow() {
        let me      = this,
            winData = await Neo.Main.getWindowData(),
            rect    = await me.getDomRect(me.getReference('preview').id);

        let {height, left, top, width} = rect;

        height -= 50; // popup header in Chrome
        left   += winData.screenLeft;
        top    += (winData.outerHeight - winData.innerHeight + winData.screenTop);

        Neo.Main.windowOpen({
            url           : `./childapps/preview/index.html?id=${me.id}`,
            windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
            windowName    : me.id
        })
    }

    /**
     *
     */
    doRunSource() {
        if (this.disableRunSource) {
            return
        }

        let me                = this,
            source            = me.editorValue || me.value,
            cleanLines        = [],
            importModuleNames = [],
            moduleNameAndPath = [],
            className         = me.findLastClassName(source);

        source.split('\n').forEach(line => {
            let importMatch = line.match(importRegex);

            if (importMatch) {
                let moduleName = importMatch[1],
                    path       = importMatch[2];

                moduleNameAndPath.push({moduleName, path});

                importModuleNames.push(moduleName);
            } else if (line.match(exportRegex)) {
                // Skip export statements
            } else {
                cleanLines.push(`    ${line}`);
            }
        });

        var params = [];
        var vars   = [];
        // Figure out the parts of the source we'll be running.
        // o The promises/import() corresponding to the user's import statements
        // o The vars holding the name of the imported module based on the module name for each import
        // o The rest of the user-provided source
        // It'll end up looking like this:
        // Promise.all([
        //     import('../../../node_modules/neo.mjs/src/container/Base.mjs'),
        //     import('../../../node_modules/neo.mjs/src/button/Base.mjs')
        //   ]).then(([BaseModule, ButtonModule]) => {
        //       const Base = BaseModule.default;
        //       const Button = ButtonModule.default;
        //       // Class declaration goes here...
        //   });
        // Making the promise part of the eval seems weird, but it made it easier to
        // set up the import vars.

        let promises = moduleNameAndPath.map(item => {
            params.push(`${item.moduleName}Module`);
            vars.push(`    const ${item.moduleName} = ${item.moduleName}Module.default;`);
            return `import('${item.path}')`
        });

        const codeString = [
            'Promise.all([',
            `    ${promises.join(',\n')}`,
            `]).then(([${params.join(', ')}]) => {`,
            `${vars.join('\n')}`,
            `    ${cleanLines.join('\n')}`,
            '',
            `    if (${className} && Neo.component.Base.isPrototypeOf(${className})) {`,
            `        container.add({module:${className}})`,
            '    }',
            '})',
            '.catch(error => container.add({ntype:\'component\', html:error.message}));'
        ].join('\n')

        const container = me.getPreviewContainer();
        container.removeAll();

        try {
            new Function('container', codeString)(container);
        } catch (error) {
            container.add({
                ntype: 'component',
                html : error.message
            })
        }
    }

    /**
     * @param {String} sourceCode
     * @returns {String|null}
     */
    findLastClassName(sourceCode) {
        let lastClassName = null,
            match;

        // Iterate through all matches of the regular expression
        while ((match = classDeclarationRegex.exec(sourceCode)) !== null) {
            // Update the last class name found
            lastClassName = match[1]
        }

        return lastClassName
    }

    /**
     * @returns {Neo.component.Base|null}
     */
    getPreviewContainer() {
        let me = this;

        if (me.previewContainer) {
            return me.previewContainer
        }

        return me.getReference('preview')
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.item
     * @param {Number} data.oldValue
     * @param {String} data.source
     * @param {Number} data.value
     */
    onActiveIndexChange(data) {
        let me     = this,
            hidden = data.value !== 1;

        if (data.item.reference === 'preview') {
            me.doRunSource()
        }

        me.getReference('popout-window-button').hidden = hidden
        me.disableRunSource = false;
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me             = this,
            items          = [],
            {tabContainer} = me;

        if (me.enableFullscreen) {
            items.push({
                handler: me.collapseExpand.bind(me),
                iconCls: 'fas fa-expand',
                ui     : 'ghost'
            })
        }

        items.push({
            handler  : me.popoutPreview.bind(me),
            hidden   : tabContainer.activeIndex !== 1,
            iconCls  : 'far fa-window-maximize',
            reference: 'popout-window-button',
            ui       : 'ghost'
        });

        items[0].style = {marginLeft: 'auto'};

        // we want to add a normal (non-header) button
        tabContainer.getTabBar().add(items);

        tabContainer.getTabBar().update();

        tabContainer.on('activeIndexChange', me.onActiveIndexChange, me);

        // changing the activeView initially will not trigger our onActiveIndexChange() logic
        me.activeView === 'preview' && me.doRunSource()
    }

    /**
     * @param {Object} data
     */
    onEditorChange(data) {
        let me = this;

        me.editorValue = data.value;

        // We are not using getPreviewContainer(), since we only want to update the LivePreview in case it is visible.
        if (me.previewContainer) {
            me.doRunSource()
        }
    }

    /**
     * @param {Object} data
     */
    async popoutPreview(data) {
        let me = this;

        data.component.disabled = true;
        await me.createPopupWindow();

        // this component requires a view controller to manage connected apps
        me.getController('viewport-controller')?.connectedApps.push(me.id)
    }
}

Neo.setupClass(LivePreview);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LivePreview);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb2RlX0xpdmVQcmV2aWV3X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEI7O0FBRWhEO0FBQ0EsNkdBQTZHLFNBQVM7QUFDdEgsMkpBQTJKLFVBQVU7QUFDcks7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVM7QUFDbkM7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFZO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQywyRUFBWTtBQUM3QztBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEUsa0NBQWtDLGVBQWU7QUFDakQ7QUFDQSxrQ0FBa0M7QUFDbEMsYUFBYTtBQUNiLGlDQUFpQywyREFBUztBQUMxQztBQUNBLGtDQUFrQztBQUNsQyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxR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Q0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsV0FBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb2RlL0xpdmVQcmV2aWV3Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGFpbmVyICAgIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgTW9uYWNvRWRpdG9yIGZyb20gJy4uL2NvbXBvbmVudC93cmFwcGVyL01vbmFjb0VkaXRvci5tanMnXG5pbXBvcnQgVGFiQ29udGFpbmVyIGZyb20gJy4uL3RhYi9Db250YWluZXIubWpzJztcblxuY29uc3RcbiAgICBjbGFzc0RlY2xhcmF0aW9uUmVnZXggPSAvY2xhc3NcXHMrKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcXHMqKD86ZXh0ZW5kc1xccytbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopP1xccyp7W1xcc1xcU10qP30vZyxcbiAgICBleHBvcnRSZWdleCAgICAgICAgICAgPSAvZXhwb3J0XFxzKyg/OmRlZmF1bHRcXHMrKT8oPzpjb25zdHxsZXR8dmFyfGNsYXNzfGZ1bmN0aW9ufGFzeW5jXFxzK2Z1bmN0aW9ufGdlbmVyYXRvclxccytmdW5jdGlvbnxhc3luY1xccytnZW5lcmF0b3JcXHMrZnVuY3Rpb258KFxce1tcXHNcXFNdKj9cXH0pKS9nLFxuICAgIGltcG9ydFJlZ2V4ICAgICAgICAgICA9IC9pbXBvcnRcXHMrKFtcXHctXSspXFxzK2Zyb21cXHMrWydcIl0oW14nXCJdKylbJ1wiXS87XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb2RlLkxpdmVQcmV2aWV3XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgTGl2ZVByZXZpZXcgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaWNvblBvc2l0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGFjdGl2ZVZpZXdzPVsncHJldmlldycsJ3NvdXJjZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgYWN0aXZlVmlld3MgPSBbJ3ByZXZpZXcnLCAnc291cmNlJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvZGUuTGl2ZVByZXZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb2RlLkxpdmVQcmV2aWV3JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xpdmUtcHJldmlldydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsaXZlLXByZXZpZXcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZSAncHJldmlldycgYW5kICdzb3VyY2UnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYWN0aXZlVmlld189J3NvdXJjZSdcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZVZpZXdfOiAnc291cmNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvZGUtbGl2ZS1wcmV2aWV3J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNvZGUtbGl2ZS1wcmV2aWV3J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlUnVuU291cmNlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlUnVuU291cmNlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZUZ1bGxzY3JlZW49dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlRnVsbHNjcmVlbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaGVpZ2h0PTQwMFxuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0OiA0MDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfSBsYXlvdXQ9J2ZpdCdcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogJ2ZpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogVGFiQ29udGFpbmVyLFxuICAgICAgICAgICAgY2xzICAgICAgICAgICAgICAgIDogWydsaXZlLXByZXZpZXctY29udGFpbmVyJ10sXG4gICAgICAgICAgICByZWZlcmVuY2UgICAgICAgICAgOiAndGFiLWNvbnRhaW5lcicsXG4gICAgICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiBmYWxzZSxcblxuICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBNb25hY29FZGl0b3IsXG4gICAgICAgICAgICAgICAgaGlkZUxhYmVsICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgIDoge2VkaXRvckNoYW5nZTogJ3VwLm9uRWRpdG9yQ2hhbmdlJ30sXG4gICAgICAgICAgICAgICAgc3R5bGUgICAgICAgICAgOiB7aGVpZ2h0OiAnMTAwJSd9LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZSAgICAgIDogJ2VkaXRvcicsXG4gICAgICAgICAgICAgICAgdGFiQnV0dG9uQ29uZmlnOiB7dGV4dDogJ1NvdXJjZSd9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBDb250YWluZXIsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlICAgICAgOiAncHJldmlldycsXG4gICAgICAgICAgICAgICAgdGFiQnV0dG9uQ29uZmlnOiB7dGV4dDogJ1ByZXZpZXcnfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29kZSB0byBkaXNwbGF5IGluc2lkZSB0aGUgTW9uYWNvIGVkaXRvclxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdmFsdWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogbnVsbCxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW5rIHRoZSBwcmV2aWV3IG91dHB1dCB0byBkaWZmZXJlbnQgdGFyZ2V0c1xuICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gcHJldmlld0NvbnRhaW5lcj1udWxsXG4gICAgICovXG4gICAgcHJldmlld0NvbnRhaW5lciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgdGFiQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKCd0YWItY29udGFpbmVyJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFjdGl2ZVZpZXcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWN0aXZlVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy50YWJDb250YWluZXIuYWN0aXZlSW5kZXggPSB2YWx1ZSA9PT0gJ3NvdXJjZScgPyAwIDogMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0SXRlbSgnZWRpdG9yJykudmFsdWUgPSB2YWx1ZT8udHJpbSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhY3RpdmVWaWV3IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBY3RpdmVWaWV3KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWN0aXZlVmlldycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBjb2xsYXBzZUV4cGFuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidXR0b24gICA9IGRhdGEuY29tcG9uZW50LFxuICAgICAgICAgICAgY29sbGFwc2UgPSBidXR0b24uaWNvbkNscyA9PT0gJ2ZhcyBmYS1jb21wcmVzcycsXG4gICAgICAgICAgICB7dmRvbX0gICA9IG1lLFxuICAgICAgICAgICAgcmVjdDtcblxuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5pY29uQ2xzID0gJ2ZhcyBmYS1leHBhbmQnO1xuXG4gICAgICAgICAgICByZWN0ID0gbWUuY29sbGFwc2VSZWN0O1xuXG4gICAgICAgICAgICBkZWxldGUgbWUuY29sbGFwc2VSZWN0O1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHZkb20uc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgIDogcmVjdC5oZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgOiByZWN0LnggICAgICArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wICAgICA6IHJlY3QueSAgICAgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB3aWR0aCAgIDogcmVjdC53aWR0aCAgKyAncHgnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzAwKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgekluZGV4ICA6IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidXR0b24uaWNvbkNscyA9ICdmYXMgZmEtY29tcHJlc3MnO1xuXG4gICAgICAgICAgICByZWN0ID0gYXdhaXQgbWUuZ2V0RG9tUmVjdCgpO1xuXG4gICAgICAgICAgICBtZS5jb2xsYXBzZVJlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICB2ZG9tLnN0eWxlID0gdmRvbS5zdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICA6IHJlY3QuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgIDogcmVjdC54ICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgOiByZWN0LnkgICAgICArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IHJlY3Qud2lkdGggICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB6SW5kZXggIDogMTAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoNTApO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHZkb20uc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBsZWZ0ICA6IDAsXG4gICAgICAgICAgICAgICAgdG9wICAgOiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogJzEwMCUnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVBvcHVwV2luZG93KCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB3aW5EYXRhID0gYXdhaXQgTmVvLk1haW4uZ2V0V2luZG93RGF0YSgpLFxuICAgICAgICAgICAgcmVjdCAgICA9IGF3YWl0IG1lLmdldERvbVJlY3QobWUuZ2V0UmVmZXJlbmNlKCdwcmV2aWV3JykuaWQpO1xuXG4gICAgICAgIGxldCB7aGVpZ2h0LCBsZWZ0LCB0b3AsIHdpZHRofSA9IHJlY3Q7XG5cbiAgICAgICAgaGVpZ2h0IC09IDUwOyAvLyBwb3B1cCBoZWFkZXIgaW4gQ2hyb21lXG4gICAgICAgIGxlZnQgICArPSB3aW5EYXRhLnNjcmVlbkxlZnQ7XG4gICAgICAgIHRvcCAgICArPSAod2luRGF0YS5vdXRlckhlaWdodCAtIHdpbkRhdGEuaW5uZXJIZWlnaHQgKyB3aW5EYXRhLnNjcmVlblRvcCk7XG5cbiAgICAgICAgTmVvLk1haW4ud2luZG93T3Blbih7XG4gICAgICAgICAgICB1cmwgICAgICAgICAgIDogYC4vY2hpbGRhcHBzL3ByZXZpZXcvaW5kZXguaHRtbD9pZD0ke21lLmlkfWAsXG4gICAgICAgICAgICB3aW5kb3dGZWF0dXJlczogYGhlaWdodD0ke2hlaWdodH0sbGVmdD0ke2xlZnR9LHRvcD0ke3RvcH0sd2lkdGg9JHt3aWR0aH1gLFxuICAgICAgICAgICAgd2luZG93TmFtZSAgICA6IG1lLmlkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkb1J1blNvdXJjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZVJ1blNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc291cmNlICAgICAgICAgICAgPSBtZS5lZGl0b3JWYWx1ZSB8fCBtZS52YWx1ZSxcbiAgICAgICAgICAgIGNsZWFuTGluZXMgICAgICAgID0gW10sXG4gICAgICAgICAgICBpbXBvcnRNb2R1bGVOYW1lcyA9IFtdLFxuICAgICAgICAgICAgbW9kdWxlTmFtZUFuZFBhdGggPSBbXSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSAgICAgICAgID0gbWUuZmluZExhc3RDbGFzc05hbWUoc291cmNlKTtcblxuICAgICAgICBzb3VyY2Uuc3BsaXQoJ1xcbicpLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICBsZXQgaW1wb3J0TWF0Y2ggPSBsaW5lLm1hdGNoKGltcG9ydFJlZ2V4KTtcblxuICAgICAgICAgICAgaWYgKGltcG9ydE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vZHVsZU5hbWUgPSBpbXBvcnRNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCAgICAgICA9IGltcG9ydE1hdGNoWzJdO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZUFuZFBhdGgucHVzaCh7bW9kdWxlTmFtZSwgcGF0aH0pO1xuXG4gICAgICAgICAgICAgICAgaW1wb3J0TW9kdWxlTmFtZXMucHVzaChtb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5tYXRjaChleHBvcnRSZWdleCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGV4cG9ydCBzdGF0ZW1lbnRzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFuTGluZXMucHVzaChgICAgICR7bGluZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgdmFycyAgID0gW107XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHBhcnRzIG9mIHRoZSBzb3VyY2Ugd2UnbGwgYmUgcnVubmluZy5cbiAgICAgICAgLy8gbyBUaGUgcHJvbWlzZXMvaW1wb3J0KCkgY29ycmVzcG9uZGluZyB0byB0aGUgdXNlcidzIGltcG9ydCBzdGF0ZW1lbnRzXG4gICAgICAgIC8vIG8gVGhlIHZhcnMgaG9sZGluZyB0aGUgbmFtZSBvZiB0aGUgaW1wb3J0ZWQgbW9kdWxlIGJhc2VkIG9uIHRoZSBtb2R1bGUgbmFtZSBmb3IgZWFjaCBpbXBvcnRcbiAgICAgICAgLy8gbyBUaGUgcmVzdCBvZiB0aGUgdXNlci1wcm92aWRlZCBzb3VyY2VcbiAgICAgICAgLy8gSXQnbGwgZW5kIHVwIGxvb2tpbmcgbGlrZSB0aGlzOlxuICAgICAgICAvLyBQcm9taXNlLmFsbChbXG4gICAgICAgIC8vICAgICBpbXBvcnQoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZW8ubWpzL3NyYy9jb250YWluZXIvQmFzZS5tanMnKSxcbiAgICAgICAgLy8gICAgIGltcG9ydCgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL2J1dHRvbi9CYXNlLm1qcycpXG4gICAgICAgIC8vICAgXSkudGhlbigoW0Jhc2VNb2R1bGUsIEJ1dHRvbk1vZHVsZV0pID0+IHtcbiAgICAgICAgLy8gICAgICAgY29uc3QgQmFzZSA9IEJhc2VNb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgLy8gICAgICAgY29uc3QgQnV0dG9uID0gQnV0dG9uTW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgIC8vICAgICAgIC8vIENsYXNzIGRlY2xhcmF0aW9uIGdvZXMgaGVyZS4uLlxuICAgICAgICAvLyAgIH0pO1xuICAgICAgICAvLyBNYWtpbmcgdGhlIHByb21pc2UgcGFydCBvZiB0aGUgZXZhbCBzZWVtcyB3ZWlyZCwgYnV0IGl0IG1hZGUgaXQgZWFzaWVyIHRvXG4gICAgICAgIC8vIHNldCB1cCB0aGUgaW1wb3J0IHZhcnMuXG5cbiAgICAgICAgbGV0IHByb21pc2VzID0gbW9kdWxlTmFtZUFuZFBhdGgubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYCR7aXRlbS5tb2R1bGVOYW1lfU1vZHVsZWApO1xuICAgICAgICAgICAgdmFycy5wdXNoKGAgICAgY29uc3QgJHtpdGVtLm1vZHVsZU5hbWV9ID0gJHtpdGVtLm1vZHVsZU5hbWV9TW9kdWxlLmRlZmF1bHQ7YCk7XG4gICAgICAgICAgICByZXR1cm4gYGltcG9ydCgnJHtpdGVtLnBhdGh9JylgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBbXG4gICAgICAgICAgICAnUHJvbWlzZS5hbGwoWycsXG4gICAgICAgICAgICBgICAgICR7cHJvbWlzZXMuam9pbignLFxcbicpfWAsXG4gICAgICAgICAgICBgXSkudGhlbigoWyR7cGFyYW1zLmpvaW4oJywgJyl9XSkgPT4ge2AsXG4gICAgICAgICAgICBgJHt2YXJzLmpvaW4oJ1xcbicpfWAsXG4gICAgICAgICAgICBgICAgICR7Y2xlYW5MaW5lcy5qb2luKCdcXG4nKX1gLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBgICAgIGlmICgke2NsYXNzTmFtZX0gJiYgTmVvLmNvbXBvbmVudC5CYXNlLmlzUHJvdG90eXBlT2YoJHtjbGFzc05hbWV9KSkge2AsXG4gICAgICAgICAgICBgICAgICAgICBjb250YWluZXIuYWRkKHttb2R1bGU6JHtjbGFzc05hbWV9fSlgLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICd9KScsXG4gICAgICAgICAgICAnLmNhdGNoKGVycm9yID0+IGNvbnRhaW5lci5hZGQoe250eXBlOlxcJ2NvbXBvbmVudFxcJywgaHRtbDplcnJvci5tZXNzYWdlfSkpOydcbiAgICAgICAgXS5qb2luKCdcXG4nKVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1lLmdldFByZXZpZXdDb250YWluZXIoKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgRnVuY3Rpb24oJ2NvbnRhaW5lcicsIGNvZGVTdHJpbmcpKGNvbnRhaW5lcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkKHtcbiAgICAgICAgICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgaHRtbCA6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlQ29kZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kTGFzdENsYXNzTmFtZShzb3VyY2VDb2RlKSB7XG4gICAgICAgIGxldCBsYXN0Q2xhc3NOYW1lID0gbnVsbCxcbiAgICAgICAgICAgIG1hdGNoO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbWF0Y2hlcyBvZiB0aGUgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBjbGFzc0RlY2xhcmF0aW9uUmVnZXguZXhlYyhzb3VyY2VDb2RlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCBjbGFzcyBuYW1lIGZvdW5kXG4gICAgICAgICAgICBsYXN0Q2xhc3NOYW1lID0gbWF0Y2hbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXN0Q2xhc3NOYW1lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldFByZXZpZXdDb250YWluZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnByZXZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcmV2aWV3Q29udGFpbmVyXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuZ2V0UmVmZXJlbmNlKCdwcmV2aWV3JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkYXRhLml0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnNvdXJjZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnZhbHVlXG4gICAgICovXG4gICAgb25BY3RpdmVJbmRleENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGlkZGVuID0gZGF0YS52YWx1ZSAhPT0gMTtcblxuICAgICAgICBpZiAoZGF0YS5pdGVtLnJlZmVyZW5jZSA9PT0gJ3ByZXZpZXcnKSB7XG4gICAgICAgICAgICBtZS5kb1J1blNvdXJjZSgpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRSZWZlcmVuY2UoJ3BvcG91dC13aW5kb3ctYnV0dG9uJykuaGlkZGVuID0gaGlkZGVuXG4gICAgICAgIG1lLmRpc2FibGVSdW5Tb3VyY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHt0YWJDb250YWluZXJ9ID0gbWU7XG5cbiAgICAgICAgaWYgKG1lLmVuYWJsZUZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLmNvbGxhcHNlRXhwYW5kLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYXMgZmEtZXhwYW5kJyxcbiAgICAgICAgICAgICAgICB1aSAgICAgOiAnZ2hvc3QnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICBoYW5kbGVyICA6IG1lLnBvcG91dFByZXZpZXcuYmluZChtZSksXG4gICAgICAgICAgICBoaWRkZW4gICA6IHRhYkNvbnRhaW5lci5hY3RpdmVJbmRleCAhPT0gMSxcbiAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhciBmYS13aW5kb3ctbWF4aW1pemUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAncG9wb3V0LXdpbmRvdy1idXR0b24nLFxuICAgICAgICAgICAgdWkgICAgICAgOiAnZ2hvc3QnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW1zWzBdLnN0eWxlID0ge21hcmdpbkxlZnQ6ICdhdXRvJ307XG5cbiAgICAgICAgLy8gd2Ugd2FudCB0byBhZGQgYSBub3JtYWwgKG5vbi1oZWFkZXIpIGJ1dHRvblxuICAgICAgICB0YWJDb250YWluZXIuZ2V0VGFiQmFyKCkuYWRkKGl0ZW1zKTtcblxuICAgICAgICB0YWJDb250YWluZXIuZ2V0VGFiQmFyKCkudXBkYXRlKCk7XG5cbiAgICAgICAgdGFiQ29udGFpbmVyLm9uKCdhY3RpdmVJbmRleENoYW5nZScsIG1lLm9uQWN0aXZlSW5kZXhDaGFuZ2UsIG1lKTtcblxuICAgICAgICAvLyBjaGFuZ2luZyB0aGUgYWN0aXZlVmlldyBpbml0aWFsbHkgd2lsbCBub3QgdHJpZ2dlciBvdXIgb25BY3RpdmVJbmRleENoYW5nZSgpIGxvZ2ljXG4gICAgICAgIG1lLmFjdGl2ZVZpZXcgPT09ICdwcmV2aWV3JyAmJiBtZS5kb1J1blNvdXJjZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkVkaXRvckNoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZWRpdG9yVmFsdWUgPSBkYXRhLnZhbHVlO1xuXG4gICAgICAgIC8vIFdlIGFyZSBub3QgdXNpbmcgZ2V0UHJldmlld0NvbnRhaW5lcigpLCBzaW5jZSB3ZSBvbmx5IHdhbnQgdG8gdXBkYXRlIHRoZSBMaXZlUHJldmlldyBpbiBjYXNlIGl0IGlzIHZpc2libGUuXG4gICAgICAgIGlmIChtZS5wcmV2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBtZS5kb1J1blNvdXJjZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIHBvcG91dFByZXZpZXcoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGRhdGEuY29tcG9uZW50LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgbWUuY3JlYXRlUG9wdXBXaW5kb3coKTtcblxuICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCByZXF1aXJlcyBhIHZpZXcgY29udHJvbGxlciB0byBtYW5hZ2UgY29ubmVjdGVkIGFwcHNcbiAgICAgICAgbWUuZ2V0Q29udHJvbGxlcigndmlld3BvcnQtY29udHJvbGxlcicpPy5jb25uZWN0ZWRBcHBzLnB1c2gobWUuaWQpXG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhMaXZlUHJldmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IExpdmVQcmV2aWV3O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9