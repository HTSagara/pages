"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_form_field_fileupload_app_mjs"],{

/***/ "./examples/form/field/fileupload/MainContainer.mjs":
/*!**********************************************************!*\
  !*** ./examples/form/field/fileupload/MainContainer.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_form_field_FileUpload_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../src/form/field/FileUpload.mjs */ "./src/form/field/FileUpload.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../src/container/Panel.mjs */ "./src/container/Panel.mjs");





/**
 * @class Neo.examples.form.field.text.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className           : 'Neo.examples.form.field.text.MainContainer',
        autoMount           : true,
        configItemLabelWidth: 160,
        layout              : {ntype: 'hbox', align: 'stretch'}
    }

    createConfigurationComponents() {
        let me = this;

        return [{
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            labelText: 'width',
            listeners: {change: me.onConfigChange.bind(me, 'width')},
            maxValue : 350,
            minValue : 200,
            stepSize : 5,
            style    : {marginTop: '10px'},
            value    : me.exampleComponent.width
        }];
    }

    createExampleComponent() {
        return Neo.create(_src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
            style : 'padding:1em',
            items : [{
                module            : _src_form_field_FileUpload_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                id                : 'my-downloadable-test',
                uploadUrl         : 'http://127.0.0.1:3000/file-upload-test',
                documentStatusUrl : 'http://127.0.0.1:3000/document-status-downloadable?documentId={documentId}',
                documentDeleteUrl : 'http://127.0.0.1:3000/document-delete?documentId={documentId}',
                downloadUrl       : 'http://127.0.0.1:3000/getDocument?documentId={documentId}',
                width             : 350,
                maxSize           : '10mb',
                types             : {
                    png : 1,
                    jpg : 1,
                    xls : 1,
                    pdf : 1
                },
                listeners : {
                    beforeRequest({ headers }) {
                        headers['X-XSRF-TOKEN'] = 'my-xsrf-token'
                    }
                }
            }, {
                module            : _src_form_field_FileUpload_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                id                : 'my-not-downloadable-test',
                uploadUrl         : 'http://127.0.0.1:3000/file-upload-test',
                documentStatusUrl : 'http://127.0.0.1:3000/document-status-not-downloadable?documentId={documentId}',
                documentDeleteUrl : 'http://127.0.0.1:3000/document-delete?documentId={documentId}',
                downloadUrl       : 'http://127.0.0.1:3000/getDocument?documentId={documentId}',
                width             : 350,
                maxSize           : '10mb',
                types             : {
                    png : 1,
                    jpg : 1,
                    xls : 1,
                    pdf : 1
                }
            }, {
                module            : _src_form_field_FileUpload_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                id                : 'my-upload-fail-test',
                uploadUrl         : 'http://127.0.0.1:3000/file-upload-test-fail',
                documentStatusUrl : 'http://127.0.0.1:3000/document-status?documentId={documentId}',
                documentDeleteUrl : 'http://127.0.0.1:3000/document-delete?documentId={documentId}',
                downloadUrl       : 'http://127.0.0.1:3000/getDocument?documentId={documentId}',
                width             : 350,
                maxSize           : '10mb',
                types             : {
                    png : 1,
                    jpg : 1,
                    xls : 1,
                    pdf : 1
                }
            }, {
                module            : _src_form_field_FileUpload_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                id                : 'my-scan-fail-test',
                uploadUrl         : 'http://127.0.0.1:3000/file-upload-test',
                documentStatusUrl : 'http://127.0.0.1:3000/document-status-fail?documentId={documentId}',
                documentDeleteUrl : 'http://127.0.0.1:3000/document-delete?documentId={documentId}',
                downloadUrl       : 'http://127.0.0.1:3000/getDocument?documentId={documentId}',
                width             : 350,
                maxSize           : '10mb',
                types             : {
                    png : 1,
                    jpg : 1,
                    xls : 1,
                    pdf : 1
                }
            }, {
                module            : _src_form_field_FileUpload_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                id                : 'my-existing-document-test',
                document          : {
                    id       : 2,
                    fileName : 'test.pdf',
                    size     : 10664885,
                    status   : 'AVAILABLE'
                },
                uploadUrl         : 'http://127.0.0.1:3000/file-upload-test',
                documentStatusUrl : 'http://127.0.0.1:3000/document-status-not-downloadable?documentId={documentId}',
                documentDeleteUrl : 'http://127.0.0.1:3000/document-delete?documentId={documentId}',
                downloadUrl       : 'http://127.0.0.1:3000/getDocument?documentId={documentId}',
                width             : 350,
                maxSize           : '10mb',
                types             : {
                    png : 1,
                    jpg : 1,
                    xls : 1,
                    pdf : 1
                }
            }, {
                module            : _src_form_field_FileUpload_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                id                : 'my-non-existing-document-test',
                document          : {
                    id       : 2,
                    fileName : 'test.pdf',
                    size     : 10664885,
                    status   : 'DELETED'
                },
                uploadUrl         : 'http://127.0.0.1:3000/file-upload-test',
                documentStatusUrl : 'http://127.0.0.1:3000/document-status-non-existent?documentId={documentId}',
                documentDeleteUrl : 'http://127.0.0.1:3000/document-delete?documentId={documentId}',
                downloadUrl       : 'http://127.0.0.1:3000/getDocument?documentId={documentId}',
                width             : 350,
                maxSize           : '10mb',
                types             : {
                    png : 1,
                    jpg : 1,
                    xls : 1,
                    pdf : 1
                }
            }, {
                module            : _src_form_field_FileUpload_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                id                : 'my-failing-document-status-test',
                uploadUrl         : 'http://127.0.0.1:3000/file-upload-test',
                documentStatusUrl : 'http://127.0.0.1:3000/document-status-fails?documentId={documentId}',
                documentDeleteUrl : 'http://127.0.0.1:3000/document-delete?documentId={documentId}',
                downloadUrl       : 'http://127.0.0.1:3000/getDocument?documentId={documentId}',
                width             : 350,
                maxSize           : '10mb',
                types             : {
                    png : 1,
                    jpg : 1,
                    xls : 1,
                    pdf : 1
                }
            }]
        });
    }
}

Neo.setupClass(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./examples/form/field/fileupload/app.mjs":
/*!************************************************!*\
  !*** ./examples/form/field/fileupload/app.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/form/field/fileupload/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.form.field.fileupload'
});


/***/ }),

/***/ "./src/form/field/Base.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        fireChangeEvent    : {type: 'debounce', timer: 1000},
        fireUserChangeEvent: {type: 'debounce', timer: 1000}
    }
    /**
     * Valid values for isTouchedEvent
     * @member {String[]} isTouchedEvents=['focusEnter','focusLeave']
     * @protected
     * @static
     */
    static isTouchedEvents = ['focusEnter', 'focusLeave']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         */
        formGroup_: null,
        /**
         * True indicates that a user has interacted with the form field
         * @member {Boolean} isTouched_=false
         */
        isTouched_: false,
        /**
         * Event name which sets isTouched to true. Valid options are 'focusEnter' & 'focusLeave'
         * @member {String} isTouched_=false
         */
        isTouchedEvent_: 'focusLeave',
        /**
         * @member {String|null} name_=null
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * Triggered after the name isTouched got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetIsTouched(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'neo-is-touched', value);
        this.cls = cls;
    }

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.getInputEl().role = value;
        this.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {
        oldValue !== undefined && this.fireChangeEvent(value, oldValue)
    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString;
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Triggered before the isTouchedEvent config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetIsTouchedEvent(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'isTouchedEvent')
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value;
        } else {
            delete me.getInputEl()[key];
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*}      value
     * @param {*}      oldValue
     * @param {String} eventName
     */
    doFireChangeEvent(value, oldValue, eventName) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            formEvent     = 'field' + Neo.capitalize(eventName),
            opts          = {component: me, oldValue, value};

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        me.fire(eventName, opts);

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire(formEvent, opts)
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'change')
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireUserChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'userChange')
    }

    /**
     * Forms in neo can be nested. This method will return the closest parent which is a form.Container or null.
     * @returns {Neo.form.Container|null}
     */
    getClosestForm() {
        let me            = this,
            FormContainer = Neo.form?.Container,
            parent;

        for (parent of _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me)) {
            if (FormContainer && parent instanceof FormContainer) {
                return parent
            }
        }

        return null
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        // fields could have formGroups, but no name.
        // returning the namespace can confuse form.Container.adjustTreeLeaves(),
        // since namespaces could be considered as field instances.
        if (!me.name) {
            return null
        }

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getValue() {
        return this.value;
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true;
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        super.onFocusLeave(data);

        if (this.isTouchedEvent === 'focusEnter') {
            this.isTouched = true
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave(data);

        let me            = this,
            FormContainer = Neo.form?.Container,
            opts          = {...data, component: me, value: me.getValue()};

        if (me.isTouchedEvent === 'focusLeave') {
            me.isTouched = true
        }

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', opts)
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.value = value;
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true;
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/form/field/FileUpload.mjs":
/*!***************************************!*\
  !*** ./src/form/field/FileUpload.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../form/field/Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/String.mjs */ "./src/util/String.mjs");




const
    sizeRE           = /^(\d+)(kb|mb|gb)?$/i,
    sizeMultiplier   = {
        unit : 1,
        kb   : 1000,
        mb   : 1000000,
        gb   : 1000000000
    },
    httpSuccessCodes = {
        2 : 1,
        4 : 1
    };

/**
 * An accessible file uploading widget which automatically commences an upload as soon as
 * a file is selected using the UI.
 *
 * The URL to which the file must be uploaded is specified in the {@link config#uploadUrl} property.
 * This service must return a JSON status response in the following form for successful uploads:
 *
 * ```json
 * {
 *     "success" : true,
 *     "documentId" : 1
 * }
 * ```
 *
 * And the following form for unsuccessful uploads:
 *
 * ```json
 * {
 *     "success" : false,
 *     "message" : "Why the upload was rejected"
 * }
 * ```
 *
 * The name of the `documentId` property is configured in {@link #member-documentIdParameter}.
 * It defaults to `'documentId'`.
 *
 * The `documentId` is used when requesting the document malware scan status, and when requesting
 * that the document be deleted, or downloaded.
 *
 * If the upload is successful, then the {@link #member-documentStatusUrl} is polled until the
 * malware scan. The document id returned from the upload is passed in the parameter named
 * by the {@link #member-documentIdParameter}. It defaults to `'documentId'`.
 *
 * This service must return a JSON status response in the following if the scan is still progressing:
 *
 * ```json
 * {
 *     "status" : "scanning"
 * }
 * ```
 *
 * And the following form is malware was detected:
 *
 * ```json
 * {
 *     "status" : "scan-failed"
 * }
 * ```
 *
 * After a successful scan, a document may or may not be downloadable.
 *
 * For a downloadable document, the response must be:
 *
 * ```json
 * {
 *     "status" : "downloadable"
 * }
 * ```
 *
 * For a non-downloadable document, the response must be:
 *
 * ```json
 * {
 *     "status" : "not-downloadable"
 * }
 * ```
 * @class Neo.form.field.FileUpload
 * @extends Neo.form.field.Base
 */
class FileUpload extends _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.FileUpload'
         * @protected
         */
        className: 'Neo.form.field.FileUpload',
        /**
         * @member {String} ntype='file-upload-field'
         * @protected
         */
        ntype: 'file-upload-field',
        /**
         * @member {String[]} baseCls=['neo-file-upload-field']
         * @protected
         */
        baseCls: ['neo-file-upload-field'],
        /**
         * @member {String[]} cls=['neo-field-empty']
         */
        cls: ['neo-field-empty'],
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'i', cls: 'neo-file-upload-state-icon'},
            {cls: 'neo-file-upload-body', cn: [
                {cls: 'neo-file-upload-filename'},
                {cls: 'neo-file-upload-state'}
            ]},
            {tag: 'button', cls: 'neo-file-upload-action-button'},
            {tag: 'input', cls: 'neo-file-upload-input', type: 'file'},
            {tag: 'label', cls: 'neo-file-upload-label'},
            {cls: 'neo-file-upload-error-message'}
        ]},

        /**
         * An Object containing a default set of headers to be passed to the server on every HTTP request.
         * @member {Object} headers
         */
        headers_: {},

        /**
         * An Object which allows the status text returned from the {@link #property-documentStatusUrl} to be
         * mapped to the corresponding next widget state.
         * @member {Object} documentStatusMap
         */
        documentStatusMap: {
            SCANNING         : 'scanning',

            // The server doing its own secondary upload to the final storage location may return this.
            // We enter the same state as scanning. A spinner shows for the duration of this state
            UPLOADING       : 'scanning',

            MALWARE_DETECTED: 'scan-failed',
            UN_DOWNLOADABLE : 'not-downloadable',
            AVAILABLE       : 'not-downloadable',
            DOWNLOADABLE    : 'downloadable',
            DELETED         : 'deleted',
            ERROR           : 'error'
        },

        /**
         * @member {String|null} document_=null
         */
        document_: null,

        /**
         * If this widget should reference an existing document, configure the widget with a documentId
         * so that it can initialize in the correct "uploaded" state.
         *
         * If this is *not* configured, then this property will be set after a successful upload to
         * the id returned from the {@link #property-uploadUrl}.
         * @member {String|Number} documentId
         */
        documentId: null,

        /**
         * The URL of the file upload service to which the selected file is sent.
         *
         * This service must return a JSON response of the form:
         *
         * ```json
         * {
         *     "success"    : true,
         *     "message"    : "Only needed if the success property is false",
         *     "documentId" : 1
         * }
         * ```
         *
         * The document id is needed so that this widget can follow up and request the results of the
         * scan operation to see if the file was accepted, and whether it is to be subsequently downloadable.
         *
         * The document status request URL must be configured in {@link #member-documentStatusUrl}
         * @member {String|null} uploadUrl=null
         */
        uploadUrl: null,

        /**
         * The name of the JSON property in which the document id is returned in the upload response
         * JSON packet and the token string which is substituted for the document id when requesting
         * a malware scan and a document deletion.
         *
         * Defaults fro `documentId`
         *
         * @member {String} documentIdParameter='documentId'
         */
        documentIdParameter: 'documentId',

        /**
         * The URL from which the file may be downloaded after it has finished its scan.
         *
         * This must contain a substitution token named the same as the {@link #property-documentIdParameter}
         * which is used when creating a URL
         *
         * for example:
         *
         * ```json
         * {
         *     downloadUrl : '/getDocument/${documentId}'
         * }
         * ```
         *
         * The document id returned from the {@link #member-uploadUrl upload} is passed in the parameter named
         * by the {@link #member-documentIdParameter}. It defaults to `'documentId'`.
         *
         * @member {String|null} downloadUrl_=null
         */
        downloadUrl_: null,

        /**
         * The URL of the file status reporting service.
         *
         * This must contain a substitution token named the same as the {@link #property-documentIdParameter}
         * which is used when creating a URL
         *
         * for example:
         *
         * ```json
         * {
         *     documentStatusUrl : '/getDocumentStatus/${documentId}'
         * }
         * ```
         *
         * This widget will use this service after a successful upload to determine its next
         * state.
         *
         * This service must return a JSON response of the form:
         *
         * ```json
         * {
         *     "status" : "scanning" or "scan-failed" or "downloadable or "not-downloadable"
         * }
         * ```
         *
         * @member {String|null} documentStatusUrl_=null
         */
        documentStatusUrl_: null,

        /**
         * The polling interval *in milliseconds* to wait between asking the server how the document scan
         * is proceeding.
         *
         * Defaults to 2000ms
         *
         * @member {Number} statusScanInterval=2000
         */
        statusScanInterval: 2000,

        /**
         * The URL of the file deletion service.
         *
         * This must contain a substitution token named the same as the {@link #property-documentIdParameter}
         * which is used when creating a URL
         *
         * for example:
         *
         * ```json
         * {
         *     documentDeleteUrl : '/deleteDocument/${documentId}'
         * }
         * ```
         *
         * This widget will use this service after a successful upload to determine its next
         * state.
         *
         * If this service yields an HTTP 200 status, the deletion is taken to have been successful.
         *
         * @member {String|null} documentDeleteUrl_=null
         */
        documentDeleteUrl_: null,

        /**
         * The HTTP method to use when requesting a document deletion using the {@link #member-documentDeleteUrl}.
         *
         * Defaults to `DELETE`.
         * @member {String} documentDeleteMethod='DELETE'
         */
        documentDeleteMethod: 'DELETE',

        /**
         * @member {String} state_=ready
         */
        state_: 'ready',

        /**
         * @member {Object} types=null
         */
        types_: null,

        /**
         * @member {String|Number|null} maxSize=null
         */
        maxSize_: null,

        /**
         * The error text to show below the widget
         * @member {String|null} error_=null
         */
        error_ : null,

        // UI strings which can be overridden for other languages
        chooseFile           : 'Choose file',
        documentText         : 'Document',
        invalidFileFormat    : 'invalid file format',
        pleaseUseTheseTypes  : 'Please use these file types {allowedFileTypes}',
        fileSizeMoreThan     : 'File size exceeds {allowedFileSize}',
        uploadError          : 'Please try again',
        documentDeleteError  : 'Document delete service error',
        isNoLongerAvailable  : 'is no longer available',
        documentStatusError  : 'Document status service error',
        uploadFailed         : 'Upload failed',
        scanning             : 'Scanning',
        uploading            : 'Uploading...',
        malwareFoundInFile   : 'Malware found in file',
        pleaseCheck          : 'Please check the file and try again',
        successfullyUploaded : 'Successfully uploaded',
        fileWasDeleted       : 'File was deleted',
        fileIsInAnErrorState : 'File is in an error state'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        const me = this;

        me.addDomListeners([
            { input : me.onInputValueChange, scope: me},
            { click : me.onActionButtonClick, delegate : '.neo-file-upload-action-button', scope : me}
        ]);
    }

    afterSetId(value, oldValue) {
        const inputElId = `${this.id}-input`;

        this.getInputEl().id =  this.vdom.cn[4].for = inputElId;

        // silent vdom update, the super call will trigger the engine
        super.afterSetId?.(value, oldValue);
    }

    onConstructed() {
        super.onConstructed(...arguments);

        this.vdom.cn[4].html = this.chooseFile;
    }

    /**
     * @returns {Object}
     */
    getInputEl() {
        return this.vdom.cn[3];
    }

    async clear() {
        const
            me      = this,
            { cls } = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-field-empty');
        me.cls = cls;

        me.vdom.cn[3] = {
            id    : `${me.id}-input`,
            cls   : 'neo-file-upload-input',
            tag   : 'input',
            type  : 'file',
            value : ''
        };
        me.state = 'ready';
        me.error = '';
        me.file = me.document = null;

        // We have to wait for the DOM to have changed, and the input field to be visible
        await new Promise(resolve => setTimeout(resolve, 100));
        me.focus(me.getInputEl().id);
    }

    /**
     * @param {Object} data
     * @protected
     */
    onInputValueChange({ files }) {
        const
            me        = this,
            {
                types,
                cls
            } = me,
            body      = me.vdom.cn[1];

        if (files.length) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-field-empty');
            me.cls = cls;

            const
                file     = files.item(0),
                pointPos = file.name.lastIndexOf('.'),
                type     = pointPos > -1 ? file.name.slice(pointPos + 1) : '',
                escapedFileName = _util_String_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].escapeHtml(file.name);

            if (me.types && !types[type]) {
                body.cn[0].innerHTML = escapedFileName;
                body.cn[1].innerHTML = `${me.invalidFileFormat} (.${type}) ${me.formatSize(file.size)}`;
                me.error = me.pleaseUseTheseTypes?.replace('{allowedFileTypes}', Object.keys(types).join(' .'))
            }
            else if (file.size > me.maxSize) {
                body.cn[0].innerHTML = escapedFileName;
                body.cn[1].innerHTML = me.formatSize(file.size);
                me.error = me.fileSizeMoreThan?.replace('{allowedFileSize}', String(me._maxSize).toUpperCase());
            }
            // If it passes the type and maxSize check, upload it
            else {
                me.fileSize = me.formatSize(file.size);
                me.error = '';
                me.upload(file);
            }
        }
        // If cleared, we go back to ready state
        else {
            me.state = 'ready';
        }
    }

    async upload(file) {
        const
            me         = this,
            xhr        = me.xhr = new XMLHttpRequest(),
            { upload } = xhr,
            fileData   = new FormData(),
            headers    = { ...me.headers };

        // Show the action button
        me.file  = file;
        me.state = 'starting';

        // We have to wait for the DOM to have changed, and the action button to be visible
        await new Promise(resolve => setTimeout(resolve, 100));
        me.focus(me.vdom.cn[2].id);

        me.vdom.cn[1].cn[0].innerHTML = _util_String_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].escapeHtml(file.name);
        me.update();
        me.state = 'uploading';

        // This means no progress as opposed to zero, but still during a currently successful ongoing upload.
        // When it is NaN, the error display does not attempt to show progress.
        me.progress = NaN;

        fileData.append("file", file);

        // React to upload state changes
        upload.addEventListener('progress', me.onUploadProgress.bind(me));
        upload.addEventListener('error',    me.onUploadError.bind(me));
        upload.addEventListener('abort',    me.onUploadAbort.bind(me));
        xhr.addEventListener('loadend',     me.onUploadDone.bind(me));

        xhr.open("POST", me.uploadUrl, true);

        /**
         * This event fires before every HTTP request is sent to the server via any of the configured URLs.
         *
         * @event beforeRequest
         * @param {Object} event The event
         * @param {Object} event.headers An object containing the configured {@link #property-headers}
         * for this widget, into which new headers may be injected.
         * @returns {Object}
         */
        me.fire('beforeRequest', {
            headers
        });
        for (const header in headers) {
            xhr.setRequestHeader(header, headers[header]);
        }

        xhr.send(fileData);
    }

    onUploadProgress({ loaded, total }) {
        const
            progress = this.progress = loaded / total,
            { vdom } = this;

        (vdom.style || (vdom.style = {}))['--upload-progress'] = `${progress}turn`;

        vdom.cn[1].cn[1].innerHTML = `${this.uploading}... (${Math.round(progress * 100)}%)`;

        this.uploadSize = loaded;
        this.update();
    }

    onUploadAbort(e) {
        this.xhr = null;
        this.clear();
    }

    onUploadError(e) {
        this.xhr = null;
        this.state = 'upload-failed';
        this.error = `${this.uploadError}`;
    }

    onUploadDone({ loaded, target : xhr }) {
        const me = this;

        me.xhr = null;

        // Successful network request.
        // Check the resulting JSON packet for details and any error.
        if (httpSuccessCodes[String(xhr.status)[0]]) {
            if (loaded !== 0) {
                const response = JSON.parse(xhr.response);

                if (response.success) {
                    me.documentId = response[me.documentIdParameter];

                    // The status check phase is optional.
                    // If no URL specified, the file is taken to be downloadable.
                    if (me.documentStatusUrl) {
                        me.state = 'processing';

                        // Start polling the server to see when the scan has a result;
                        me.checkDocumentStatus();
                    }
                    else {
                        me.state = 'downloadable';
                    }
                }
                else {
                    me.error = response.message;
                    me.state = 'upload-failed';
                }
            }
        }
        // Failed network requests are handled in onUploadError
        // so no else condition necessary here
    }

    onActionButtonClick() {
        const
            me        = this,
            { state } = me;

        // When they click the action button, depending on which state we are in, we go to
        // different states.
        switch (state) {
            // During upload, its an abort
            case 'uploading':
                me.abortUpload();
                break;

            // While processing we just have to wait until it's succeeded or failed..
            case 'processing':
                break;

            // If the upload or the scan failed, the document will not have been
            // saved, so we just go back to ready state
            case 'upload-failed':
            case 'scan-failed':
            case 'error':
                me.clear();
                me.state = 'ready';
                break;

            // For stored documents, we need to tell the server the document
            // is not required.
            case 'processing':
            case 'downloadable':
            case 'not-downloadable':
                me.deleteDocument();
                break;
            case 'deleted':
                me.clear();
                me.state = 'ready';
                break;
            case 'ready':
                me.clear();
                break;
        }
    }

    abortUpload() {
        this.xhr?.abort();
    }

    async deleteDocument() {
        const
            me          = this,
            { headers } = me;

        me.fire('beforeRequest', {
            headers
        });

        // We ask the server to delete using our this.documentId
        const statusResponse = await fetch(me.documentDeleteUrl, {
            method : me.documentDeleteMethod,
            headers
        });

        // Success
        if (httpSuccessCodes[String(statusResponse.status)[0]]) {
            me.clear();
            me.state = 'ready';
        }
        else {
            me.error = `${me.documentDeleteError}: ${statusResponse.statusText}`;
        }
    }

    async checkDocumentStatus() {
        const
            me          = this,
            { headers } = me;

        if (me.state === 'processing') {
            me.fire('beforeRequest', {
                headers
            });

            const statusResponse = await fetch(me.documentStatusUrl, {
                headers
            });

            // Success
            if (httpSuccessCodes[String(statusResponse.status)[0]]) {
                const
                    serverJson   = await statusResponse.json(),
                    serverStatus = serverJson.status,
                    // Map the server's states codes to our own status codes
                    status       = me.documentStatusMap[serverStatus] || serverStatus;

                switch (status) {
                    case 'scanning':
                        setTimeout(() => me.checkDocumentStatus(), me.statusScanInterval);
                        break;
                    case 'deleted':
                        me.error = `${me.documentText} ${me.documentId} ${isNoLongerAvailable}`;
                        me.state = 'ready';
                        break;
                    case 'error':
                        me.error = `${me.documentStatusError}: ${statusResponse.statusText || `Server error ${statusResponse.status}`}`;
                        me.state = 'deleted';
                        break;
                    default:
                        me.state = status;
                }
            }
            else {
                me.error = `${me.documentStatusError}: ${statusResponse.statusText || `Server error ${statusResponse.status}`}`;
                me.state = 'deleted';
            }
        }
    }

    afterSetDocument(document) {
        if (document) {
            const
                me      = this,
                { cls } = me;

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-field-empty');
            me.cls = cls;

            me.documentId = document.id;
            me.fileSize = me.formatSize(document.size);
            me.vdom.cn[1].cn[0].innerHTML = _util_String_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].escapeHtml(document.fileName);
            me.state = me.documentStatusMap[document.status];
        }
    }

    /**
     * Triggered after the state config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetState(value, oldValue) {
        const
            me      = this,
            {
                vdom
            } = me,
            anchor  = vdom.cn[1].cn[0],
            status  = vdom.cn[1].cn[1];

        delete vdom.inert;

        let isChangeEventNeeded;

        switch (value) {
            case 'ready':
                anchor.tag = 'div';
                anchor.href = '';
                isChangeEventNeeded = true;
                break;
            case 'upload-failed':
                status.innerHTML = `${me.uploadFailed}${isNaN(me.progress) ? '' : `... (${Math.round(me.progress * 100)}%)`}`;
                isChangeEventNeeded = true;
                break;
            case 'processing':
                status.innerHTML = `${me.scanning}... (${me.formatSize(me.uploadSize)})`;
                vdom.inert = true;
                break;
            case 'scan-failed':
                status.innerHTML = `${me.malwareFoundInFile}. \u2022 ${me.fileSize}`;
                me.error = me.pleaseCheck;
                isChangeEventNeeded = true;
                break;
            case 'downloadable':
                anchor.tag = 'a';
                anchor.href = me.createUrl(me.downloadUrl, {
                    [me.documentIdParameter] : me.documentId
                });
                status.innerHTML = me.fileSize;
                isChangeEventNeeded = true;
                break;
            case 'not-downloadable':
                status.innerHTML = me.document ? me.fileSize : `${me.successfullyUploaded} \u2022 ${me.fileSize}`;
                isChangeEventNeeded = true;
                break;
            case 'deleted':
                status.innerHTML = me.fileWasDeleted;
                isChangeEventNeeded = true;
                break;
            case 'error':
                status.innerHTML = me.fileIsInAnErrorState;
                me.error = me.pleaseCheck;
                isChangeEventNeeded = true;
            }

        if (isChangeEventNeeded && oldValue !== undefined) {
            me.fireChangeEvent(me.file)
        }
        me.validate();
        me.update();

        // Processing above may mutate cls
        const { cls } = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-file-upload-state-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-file-upload-state-' + value);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][me.file || me.document ? 'remove' : 'add', 'neo-field-empty'];
        me.cls = cls;
    }

    /**
     * Creates a URL substituting the passed parameter names in at the places where the name
     * occurs within `{}` in the pattern.
     * @param {String} urlPattern
     * @param {Object} params
     */
    createUrl(urlPattern, params) {
        for (const paramName in params) {
            urlPattern = urlPattern.replace(`{${paramName}}`, params[paramName]);
        }
        return urlPattern;
    }

    beforeGetHeaders(headers) {
        return { ...(headers || {}) }
    }

    beforeGetDocumentStatusUrl(documentStatusUrl) {
        const me = this;

        return typeof documentStatusUrl === 'function'? documentStatusUrl.call(me, me) : me.createUrl(documentStatusUrl, {
            [me.documentIdParameter] : me.documentId
        });
    }

    beforeGetDocumentDeleteUrl(documentDeleteUrl) {
        const me = this;

        return typeof documentDeleteUrl === 'function'? documentDeleteUrl.call(me, me) : me.createUrl(documentDeleteUrl, {
            [me.documentIdParameter] : me.documentId
        });
    }

    beforeGetDownloadUrl(downloadUrl) {
        const me = this;

        return typeof downloadUrl === 'function'? downloadUrl.call(me, me) : me.createUrl(downloadUrl, {
            [me.documentIdParameter] : me.documentId
        });
    }

    beforeGetMaxSize(maxSize) {
        // Not configured means no limit
        if (maxSize == null) {
            return Number.MAX_SAFE_INTEGER;
        }

        // Split eg "100mb" into the numeric and units parts
        const sizeParts = sizeRE.exec(maxSize);

        if (sizeParts) {
            // Convert mb to 1000000 etc
            const multiplier = sizeMultiplier[(sizeParts[2]||'unit').toLowerCase()];

            return parseInt(sizeParts[1]) * multiplier;
        }
    }

    afterSetError(text) {
        if (text) {
            this.vdom.cn[5].cn = [{
                vtype : 'text',
                html  : text
            }];
        }
        else {
            this.vdom.cn[5].cn = [];
        }

        this.validate();
        this.update();
    }

    formatSize(bytes, separator = '', postFix = '') {
        if (bytes) {
            const
                sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'],
                i     = Math.min(parseInt(Math.floor(Math.log(bytes) / Math.log(1000)).toString(), 10), sizes.length - 1);

            return `${(bytes / (1000 ** i)).toFixed(i ? 1 : 0)}${separator}${sizes[i]}${postFix}`;
        }
        return 'n/a';
    }

    /**
     * @returns {Boolean}
     */
    validate() {
        const
            { cls } = this,
            isValid = this.isValid();

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(cls, 'neo-invalid', !isValid);
        this.cls = cls;

        return isValid;
    }

    isValid() {
        const me = this;

        return !me.error &&  !(me.state === 'ready' && me.required) ||
               (    (me.state === 'downloadable') ||
                    (me.state === 'not-downloadable')
               );
    }
}

Neo.setupClass(FileUpload);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileUpload);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfZmlsZXVwbG9hZF9hcHBfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ087QUFDSjtBQUNEOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixrRUFBVztBQUNsQztBQUNBLHdCQUF3Qiw0Q0FBNEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDBCQUEwQixnRUFBSztBQUMvQjtBQUNBO0FBQ0Esb0NBQW9DLHNFQUFlO0FBQ25EO0FBQ0E7QUFDQSxvR0FBb0csV0FBVztBQUMvRyx1RkFBdUYsV0FBVztBQUNsRyxtRkFBbUYsV0FBVztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQ0FBb0Msc0VBQWU7QUFDbkQ7QUFDQTtBQUNBLHdHQUF3RyxXQUFXO0FBQ25ILHVGQUF1RixXQUFXO0FBQ2xHLG1GQUFtRixXQUFXO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0NBQW9DLHNFQUFlO0FBQ25EO0FBQ0E7QUFDQSx1RkFBdUYsV0FBVztBQUNsRyx1RkFBdUYsV0FBVztBQUNsRyxtRkFBbUYsV0FBVztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9DQUFvQyxzRUFBZTtBQUNuRDtBQUNBO0FBQ0EsNEZBQTRGLFdBQVc7QUFDdkcsdUZBQXVGLFdBQVc7QUFDbEcsbUZBQW1GLFdBQVc7QUFDOUY7QUFD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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix5Q0FBeUMsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVE7QUFDaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2Zvcm0vZmllbGQvZmlsZXVwbG9hZC9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvZm9ybS9maWVsZC9maWxldXBsb2FkL2FwcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9GaWxlVXBsb2FkLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29uZmlndXJhdGlvblZpZXdwb3J0IGZyb20gJy4uLy4uLy4uL0NvbmZpZ3VyYXRpb25WaWV3cG9ydC5tanMnO1xuaW1wb3J0IEZpbGVVcGxvYWRGaWVsZCAgICAgICBmcm9tICcuLi8uLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9GaWxlVXBsb2FkLm1qcyc7XG5pbXBvcnQgTnVtYmVyRmllbGQgICAgICAgICAgIGZyb20gJy4uLy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL051bWJlci5tanMnO1xuaW1wb3J0IFBhbmVsICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9QYW5lbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuZm9ybS5maWVsZC50ZXh0Lk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5leGFtcGxlcy5Db25maWd1cmF0aW9uVmlld3BvcnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIENvbmZpZ3VyYXRpb25WaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgY2xhc3NOYW1lICAgICAgICAgICA6ICdOZW8uZXhhbXBsZXMuZm9ybS5maWVsZC50ZXh0Lk1haW5Db250YWluZXInLFxuICAgICAgICBhdXRvTW91bnQgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgY29uZmlnSXRlbUxhYmVsV2lkdGg6IDE2MCxcbiAgICAgICAgbGF5b3V0ICAgICAgICAgICAgICA6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgIH1cblxuICAgIGNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnRzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBOdW1iZXJGaWVsZCxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ3dpZHRoJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ3dpZHRoJyl9LFxuICAgICAgICAgICAgbWF4VmFsdWUgOiAzNTAsXG4gICAgICAgICAgICBtaW5WYWx1ZSA6IDIwMCxcbiAgICAgICAgICAgIHN0ZXBTaXplIDogNSxcbiAgICAgICAgICAgIHN0eWxlICAgIDoge21hcmdpblRvcDogJzEwcHgnfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogbWUuZXhhbXBsZUNvbXBvbmVudC53aWR0aFxuICAgICAgICB9XTtcbiAgICB9XG5cbiAgICBjcmVhdGVFeGFtcGxlQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZShQYW5lbCwge1xuICAgICAgICAgICAgc3R5bGUgOiAncGFkZGluZzoxZW0nLFxuICAgICAgICAgICAgaXRlbXMgOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgIDogRmlsZVVwbG9hZEZpZWxkLFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgIDogJ215LWRvd25sb2FkYWJsZS10ZXN0JyxcbiAgICAgICAgICAgICAgICB1cGxvYWRVcmwgICAgICAgICA6ICdodHRwOi8vMTI3LjAuMC4xOjMwMDAvZmlsZS11cGxvYWQtdGVzdCcsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRTdGF0dXNVcmwgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2RvY3VtZW50LXN0YXR1cy1kb3dubG9hZGFibGU/ZG9jdW1lbnRJZD17ZG9jdW1lbnRJZH0nLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGVsZXRlVXJsIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9kb2N1bWVudC1kZWxldGU/ZG9jdW1lbnRJZD17ZG9jdW1lbnRJZH0nLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsICAgICAgIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9nZXREb2N1bWVudD9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgOiAzNTAsXG4gICAgICAgICAgICAgICAgbWF4U2l6ZSAgICAgICAgICAgOiAnMTBtYicsXG4gICAgICAgICAgICAgICAgdHlwZXMgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIHBuZyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGpwZyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHhscyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHBkZiA6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA6IHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlUmVxdWVzdCh7IGhlYWRlcnMgfSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snWC1YU1JGLVRPS0VOJ10gPSAnbXkteHNyZi10b2tlbidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICA6IEZpbGVVcGxvYWRGaWVsZCxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgICA6ICdteS1ub3QtZG93bmxvYWRhYmxlLXRlc3QnLFxuICAgICAgICAgICAgICAgIHVwbG9hZFVybCAgICAgICAgIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9maWxlLXVwbG9hZC10ZXN0JyxcbiAgICAgICAgICAgICAgICBkb2N1bWVudFN0YXR1c1VybCA6ICdodHRwOi8vMTI3LjAuMC4xOjMwMDAvZG9jdW1lbnQtc3RhdHVzLW5vdC1kb3dubG9hZGFibGU/ZG9jdW1lbnRJZD17ZG9jdW1lbnRJZH0nLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGVsZXRlVXJsIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9kb2N1bWVudC1kZWxldGU/ZG9jdW1lbnRJZD17ZG9jdW1lbnRJZH0nLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsICAgICAgIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9nZXREb2N1bWVudD9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgOiAzNTAsXG4gICAgICAgICAgICAgICAgbWF4U2l6ZSAgICAgICAgICAgOiAnMTBtYicsXG4gICAgICAgICAgICAgICAgdHlwZXMgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIHBuZyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGpwZyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHhscyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHBkZiA6IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgOiBGaWxlVXBsb2FkRmllbGQsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgICAgICAgICAgOiAnbXktdXBsb2FkLWZhaWwtdGVzdCcsXG4gICAgICAgICAgICAgICAgdXBsb2FkVXJsICAgICAgICAgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2ZpbGUtdXBsb2FkLXRlc3QtZmFpbCcsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRTdGF0dXNVcmwgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2RvY3VtZW50LXN0YXR1cz9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREZWxldGVVcmwgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2RvY3VtZW50LWRlbGV0ZT9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgZG93bmxvYWRVcmwgICAgICAgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2dldERvY3VtZW50P2RvY3VtZW50SWQ9e2RvY3VtZW50SWR9JyxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgICA6IDM1MCxcbiAgICAgICAgICAgICAgICBtYXhTaXplICAgICAgICAgICA6ICcxMG1iJyxcbiAgICAgICAgICAgICAgICB0eXBlcyAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgcG5nIDogMSxcbiAgICAgICAgICAgICAgICAgICAganBnIDogMSxcbiAgICAgICAgICAgICAgICAgICAgeGxzIDogMSxcbiAgICAgICAgICAgICAgICAgICAgcGRmIDogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICA6IEZpbGVVcGxvYWRGaWVsZCxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgICA6ICdteS1zY2FuLWZhaWwtdGVzdCcsXG4gICAgICAgICAgICAgICAgdXBsb2FkVXJsICAgICAgICAgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2ZpbGUtdXBsb2FkLXRlc3QnLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50U3RhdHVzVXJsIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9kb2N1bWVudC1zdGF0dXMtZmFpbD9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREZWxldGVVcmwgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2RvY3VtZW50LWRlbGV0ZT9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgZG93bmxvYWRVcmwgICAgICAgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2dldERvY3VtZW50P2RvY3VtZW50SWQ9e2RvY3VtZW50SWR9JyxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgICA6IDM1MCxcbiAgICAgICAgICAgICAgICBtYXhTaXplICAgICAgICAgICA6ICcxMG1iJyxcbiAgICAgICAgICAgICAgICB0eXBlcyAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgcG5nIDogMSxcbiAgICAgICAgICAgICAgICAgICAganBnIDogMSxcbiAgICAgICAgICAgICAgICAgICAgeGxzIDogMSxcbiAgICAgICAgICAgICAgICAgICAgcGRmIDogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICA6IEZpbGVVcGxvYWRGaWVsZCxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgICA6ICdteS1leGlzdGluZy1kb2N1bWVudC10ZXN0JyxcbiAgICAgICAgICAgICAgICBkb2N1bWVudCAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiAyLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA6ICd0ZXN0LnBkZicsXG4gICAgICAgICAgICAgICAgICAgIHNpemUgICAgIDogMTA2NjQ4ODUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyAgIDogJ0FWQUlMQUJMRSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwbG9hZFVybCAgICAgICAgIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9maWxlLXVwbG9hZC10ZXN0JyxcbiAgICAgICAgICAgICAgICBkb2N1bWVudFN0YXR1c1VybCA6ICdodHRwOi8vMTI3LjAuMC4xOjMwMDAvZG9jdW1lbnQtc3RhdHVzLW5vdC1kb3dubG9hZGFibGU/ZG9jdW1lbnRJZD17ZG9jdW1lbnRJZH0nLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGVsZXRlVXJsIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9kb2N1bWVudC1kZWxldGU/ZG9jdW1lbnRJZD17ZG9jdW1lbnRJZH0nLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsICAgICAgIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9nZXREb2N1bWVudD9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgOiAzNTAsXG4gICAgICAgICAgICAgICAgbWF4U2l6ZSAgICAgICAgICAgOiAnMTBtYicsXG4gICAgICAgICAgICAgICAgdHlwZXMgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIHBuZyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGpwZyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHhscyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHBkZiA6IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgOiBGaWxlVXBsb2FkRmllbGQsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgICAgICAgICAgOiAnbXktbm9uLWV4aXN0aW5nLWRvY3VtZW50LXRlc3QnLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50ICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IDIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lIDogJ3Rlc3QucGRmJyxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSAgICAgOiAxMDY2NDg4NSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzICAgOiAnREVMRVRFRCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwbG9hZFVybCAgICAgICAgIDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzAwMC9maWxlLXVwbG9hZC10ZXN0JyxcbiAgICAgICAgICAgICAgICBkb2N1bWVudFN0YXR1c1VybCA6ICdodHRwOi8vMTI3LjAuMC4xOjMwMDAvZG9jdW1lbnQtc3RhdHVzLW5vbi1leGlzdGVudD9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREZWxldGVVcmwgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2RvY3VtZW50LWRlbGV0ZT9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgZG93bmxvYWRVcmwgICAgICAgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2dldERvY3VtZW50P2RvY3VtZW50SWQ9e2RvY3VtZW50SWR9JyxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgICA6IDM1MCxcbiAgICAgICAgICAgICAgICBtYXhTaXplICAgICAgICAgICA6ICcxMG1iJyxcbiAgICAgICAgICAgICAgICB0eXBlcyAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgcG5nIDogMSxcbiAgICAgICAgICAgICAgICAgICAganBnIDogMSxcbiAgICAgICAgICAgICAgICAgICAgeGxzIDogMSxcbiAgICAgICAgICAgICAgICAgICAgcGRmIDogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICA6IEZpbGVVcGxvYWRGaWVsZCxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgICA6ICdteS1mYWlsaW5nLWRvY3VtZW50LXN0YXR1cy10ZXN0JyxcbiAgICAgICAgICAgICAgICB1cGxvYWRVcmwgICAgICAgICA6ICdodHRwOi8vMTI3LjAuMC4xOjMwMDAvZmlsZS11cGxvYWQtdGVzdCcsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRTdGF0dXNVcmwgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2RvY3VtZW50LXN0YXR1cy1mYWlscz9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREZWxldGVVcmwgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2RvY3VtZW50LWRlbGV0ZT9kb2N1bWVudElkPXtkb2N1bWVudElkfScsXG4gICAgICAgICAgICAgICAgZG93bmxvYWRVcmwgICAgICAgOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2dldERvY3VtZW50P2RvY3VtZW50SWQ9e2RvY3VtZW50SWR9JyxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgICA6IDM1MCxcbiAgICAgICAgICAgICAgICBtYXhTaXplICAgICAgICAgICA6ICcxMG1iJyxcbiAgICAgICAgICAgICAgICB0eXBlcyAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgcG5nIDogMSxcbiAgICAgICAgICAgICAgICAgICAganBnIDogMSxcbiAgICAgICAgICAgICAgICAgICAgeGxzIDogMSxcbiAgICAgICAgICAgICAgICAgICAgcGRmIDogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5Db250YWluZXI7XG4iLCJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL01haW5Db250YWluZXIubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogTWFpbkNvbnRhaW5lcixcbiAgICBuYW1lICAgIDogJ05lby5leGFtcGxlcy5mb3JtLmZpZWxkLmZpbGV1cGxvYWQnXG59KTtcbiIsImltcG9ydCBDb21wb25lbnQgICAgICAgIGZyb20gJy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGZvcm0gZmllbGRzXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVsYXlhYmxlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsYXlhYmxlID0ge1xuICAgICAgICBmaXJlQ2hhbmdlRXZlbnQgICAgOiB7dHlwZTogJ2RlYm91bmNlJywgdGltZXI6IDEwMDB9LFxuICAgICAgICBmaXJlVXNlckNoYW5nZUV2ZW50OiB7dHlwZTogJ2RlYm91bmNlJywgdGltZXI6IDEwMDB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaXNUb3VjaGVkRXZlbnRcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaXNUb3VjaGVkRXZlbnRzPVsnZm9jdXNFbnRlcicsJ2ZvY3VzTGVhdmUnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGlzVG91Y2hlZEV2ZW50cyA9IFsnZm9jdXNFbnRlcicsICdmb2N1c0xlYXZlJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdiYXNlZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnYmFzZWZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcm0gZ3JvdXBzIGNhbiBnZXQgc2V0IG9uIGFueSBwYXJlbnQgY29tcG9uZW50IGxldmVsLlxuICAgICAgICAgKiBBbiBhbHRlcm5hdGl2ZSB3YXkgZm9yIHVzaW5nIGRvdHMgaW4gZmllbGQgbmFtZXMuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBmb3JtR3JvdXBfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGZvcm1Hcm91cF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluZGljYXRlcyB0aGF0IGEgdXNlciBoYXMgaW50ZXJhY3RlZCB3aXRoIHRoZSBmb3JtIGZpZWxkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVG91Y2hlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzVG91Y2hlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgbmFtZSB3aGljaCBzZXRzIGlzVG91Y2hlZCB0byB0cnVlLiBWYWxpZCBvcHRpb25zIGFyZSAnZm9jdXNFbnRlcicgJiAnZm9jdXNMZWF2ZSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpc1RvdWNoZWRfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc1RvdWNoZWRFdmVudF86ICdmb2N1c0xlYXZlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBuYW1lXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5lbyBpdHNlbGYgZG9lcyBub3QgbmVlZCBmaWVsZCBuYW1lcyB0byBnZXQgbWFwcGVkIHRvIHRoZSBET00gKGlucHV0IG5vZGVzKSxcbiAgICAgICAgICogZXhjZXB0IGZvciBDaGVja0JveGVzICYgUmFkaW9zIHRvIHdvcmsuIEl0IGNhbiBiZSB1c2VmdWwgZm9yIHRlc3RpbmcgdG9vbHNcbiAgICAgICAgICogJiBhY2Nlc3NpYmlsaXR5IHRob3VnaCwgc28gdGhlIGRlZmF1bHQgZ290IHNldCB0byB0cnVlLlxuICAgICAgICAgKiBGZWVsIGZyZWUgdG8gY2hhbmdlIGl0IHRvIGZhbHNlIHRvIGtlZXAgdGhlIERPTSBtaW5pbWFsLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJOYW1lXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJOYW1lXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2UgcmVuZGVyTmFtZSBpcyBzZXQgdG8gdHJ1ZSwgeW91IGNhbiBvcHRpb25hbGx5IHJlbmRlciB0aGUgY29tYmluYXRpb25cbiAgICAgICAgICogb2YgYWxsIGZvcm1Hcm91cChzKSAmIHRoZSBmaWVsZCBuYW1lIGludG8gdGhlIERPTSA9PiBpbnB1dCBub2RlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlclBhdGg9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyUGF0aDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIgeyp9IHZhbHVlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwcyBvZiBhbGwgcGFyZW50IGxldmVsc1xuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBmb3JtR3JvdXBTdHJpbmc9bnVsbFxuICAgICAqL1xuICAgIGZvcm1Hcm91cFN0cmluZyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwKHMpIGFuZCB0aGUgZmllbGQgbmFtZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBwYXRoPW51bGxcbiAgICAgKi9cbiAgICBwYXRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuYW1lIGlzVG91Y2hlZCBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldElzVG91Y2hlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8taXMtdG91Y2hlZCcsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUucmVuZGVyTmFtZSAmJiBtZS5jaGFuZ2VJbnB1dEVsS2V5KCduYW1lJywgbWUucmVuZGVyUGF0aCA/IG1lLmdldFBhdGgoKSA6IHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm9sZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um9sZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRJbnB1dEVsKCkucm9sZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGZvcm1Hcm91cCBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gcGFyZW50c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRGb3JtR3JvdXAodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGdyb3VwID0gW10sXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICBpZiAobWUuZm9ybUdyb3VwU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuZm9ybUdyb3VwU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgJiYgZ3JvdXAucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICBwYXJlbnQuZm9ybUdyb3VwICYmIGdyb3VwLnVuc2hpZnQocGFyZW50LmZvcm1Hcm91cClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuVmFsdWUgPSBncm91cC5qb2luKCcuJyk7XG5cbiAgICAgICAgbWUuZm9ybUdyb3VwU3RyaW5nID0gcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaXNUb3VjaGVkRXZlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRJc1RvdWNoZWRFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2lzVG91Y2hlZEV2ZW50JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIGlucHV0RWwgdmRvbSBvYmplY3QgYXR0cmlidXRlIG9yIHJlbW92ZXMgaXQgaW4gY2FzZSBpdCBoYXMgbm8gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ8T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgY2hhbmdlSW5wdXRFbEtleShrZXksIHZhbHVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgfHwgTmVvLmlzQm9vbGVhbih2YWx1ZSkgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIG1lLmdldElucHV0RWwoKVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbWUuZ2V0SW5wdXRFbCgpW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSAgICAgIHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSAgICAgIG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqL1xuICAgIGRvRmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSwgZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyLFxuICAgICAgICAgICAgZm9ybUV2ZW50ICAgICA9ICdmaWVsZCcgKyBOZW8uY2FwaXRhbGl6ZShldmVudE5hbWUpLFxuICAgICAgICAgICAgb3B0cyAgICAgICAgICA9IHtjb21wb25lbnQ6IG1lLCBvbGRWYWx1ZSwgdmFsdWV9O1xuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihtZS5nZXRHcm91cFZhbHVlKSkge1xuICAgICAgICAgICAgb3B0cy5ncm91cFZhbHVlID0gbWUuZ2V0R3JvdXBWYWx1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5maXJlKGV2ZW50TmFtZSwgb3B0cyk7XG5cbiAgICAgICAgaWYgKCFtZS5zdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5maXJlKGZvcm1FdmVudCwgb3B0cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBmaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZG9GaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlLCAnY2hhbmdlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGZpcmVVc2VyQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZG9GaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlLCAndXNlckNoYW5nZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybXMgaW4gbmVvIGNhbiBiZSBuZXN0ZWQuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IHBhcmVudCB3aGljaCBpcyBhIGZvcm0uQ29udGFpbmVyIG9yIG51bGwuXG4gICAgICogQHJldHVybnMge05lby5mb3JtLkNvbnRhaW5lcnxudWxsfVxuICAgICAqL1xuICAgIGdldENsb3Nlc3RGb3JtKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBGb3JtQ29udGFpbmVyID0gTmVvLmZvcm0/LkNvbnRhaW5lcixcbiAgICAgICAgICAgIHBhcmVudDtcblxuICAgICAgICBmb3IgKHBhcmVudCBvZiBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpKSB7XG4gICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0SW5wdXRFbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBmaWVsZCBmb3JtR3JvdXAocykgJiBuYW1lXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwYXRoO1xuXG4gICAgICAgIC8vIGZpZWxkcyBjb3VsZCBoYXZlIGZvcm1Hcm91cHMsIGJ1dCBubyBuYW1lLlxuICAgICAgICAvLyByZXR1cm5pbmcgdGhlIG5hbWVzcGFjZSBjYW4gY29uZnVzZSBmb3JtLkNvbnRhaW5lci5hZGp1c3RUcmVlTGVhdmVzKCksXG4gICAgICAgIC8vIHNpbmNlIG5hbWVzcGFjZXMgY291bGQgYmUgY29uc2lkZXJlZCBhcyBmaWVsZCBpbnN0YW5jZXMuXG4gICAgICAgIGlmICghbWUubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUucGF0aCkge1xuICAgICAgICAgICAgcGF0aCA9IG1lLmZvcm1Hcm91cCA/IG1lLmZvcm1Hcm91cC5zcGxpdCgnLicpIDogW107XG5cbiAgICAgICAgICAgIG1lLm5hbWUgJiYgcGF0aC5wdXNoKG1lLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUucGF0aCA9IHBhdGguam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5wYXRoKSB7XG4gICAgICAgICAgICBtZS5wYXRoID0gJ25vbmUnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUucGF0aCA9PT0gJ25vbmUnID8gbnVsbDogbWUucGF0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXNFbnRlcihkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKTtcblxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoZWRFdmVudCA9PT0gJ2ZvY3VzRW50ZXInKSB7XG4gICAgICAgICAgICB0aGlzLmlzVG91Y2hlZCA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBGb3JtQ29udGFpbmVyID0gTmVvLmZvcm0/LkNvbnRhaW5lcixcbiAgICAgICAgICAgIG9wdHMgICAgICAgICAgPSB7Li4uZGF0YSwgY29tcG9uZW50OiBtZSwgdmFsdWU6IG1lLmdldFZhbHVlKCl9O1xuXG4gICAgICAgIGlmIChtZS5pc1RvdWNoZWRFdmVudCA9PT0gJ2ZvY3VzTGVhdmUnKSB7XG4gICAgICAgICAgICBtZS5pc1RvdWNoZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24obWUuZ2V0R3JvdXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9wdHMuZ3JvdXBWYWx1ZSA9IG1lLmdldEdyb3VwVmFsdWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5zdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5maXJlKCdmaWVsZEZvY3VzTGVhdmUnLCBvcHRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGZpZWxkIHRvIGEgbmV3IHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlPW51bGxcbiAgICAgKi9cbiAgICByZXNldCh2YWx1ZT1udWxsKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGNsaWVudC1zaWRlIGZpZWxkIGVycm9yc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PXRydWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNsaWVudC1zaWRlIGVycm9yc1xuICAgICAqL1xuICAgIHZhbGlkYXRlKHNpbGVudD10cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgY2hhbmdlIGV2ZW50IGZpcmVzIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gKiBAZXZlbnQgY2hhbmdlXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbk5lby5zZXR1cENsYXNzKEJhc2UpO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICBmcm9tICcuLi8uLi9mb3JtL2ZpZWxkL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFN0cmluZ1V0aWwgICBmcm9tICcuLi8uLi91dGlsL1N0cmluZy5tanMnO1xuXG5jb25zdFxuICAgIHNpemVSRSAgICAgICAgICAgPSAvXihcXGQrKShrYnxtYnxnYik/JC9pLFxuICAgIHNpemVNdWx0aXBsaWVyICAgPSB7XG4gICAgICAgIHVuaXQgOiAxLFxuICAgICAgICBrYiAgIDogMTAwMCxcbiAgICAgICAgbWIgICA6IDEwMDAwMDAsXG4gICAgICAgIGdiICAgOiAxMDAwMDAwMDAwXG4gICAgfSxcbiAgICBodHRwU3VjY2Vzc0NvZGVzID0ge1xuICAgICAgICAyIDogMSxcbiAgICAgICAgNCA6IDFcbiAgICB9O1xuXG4vKipcbiAqIEFuIGFjY2Vzc2libGUgZmlsZSB1cGxvYWRpbmcgd2lkZ2V0IHdoaWNoIGF1dG9tYXRpY2FsbHkgY29tbWVuY2VzIGFuIHVwbG9hZCBhcyBzb29uIGFzXG4gKiBhIGZpbGUgaXMgc2VsZWN0ZWQgdXNpbmcgdGhlIFVJLlxuICpcbiAqIFRoZSBVUkwgdG8gd2hpY2ggdGhlIGZpbGUgbXVzdCBiZSB1cGxvYWRlZCBpcyBzcGVjaWZpZWQgaW4gdGhlIHtAbGluayBjb25maWcjdXBsb2FkVXJsfSBwcm9wZXJ0eS5cbiAqIFRoaXMgc2VydmljZSBtdXN0IHJldHVybiBhIEpTT04gc3RhdHVzIHJlc3BvbnNlIGluIHRoZSBmb2xsb3dpbmcgZm9ybSBmb3Igc3VjY2Vzc2Z1bCB1cGxvYWRzOlxuICpcbiAqIGBgYGpzb25cbiAqIHtcbiAqICAgICBcInN1Y2Nlc3NcIiA6IHRydWUsXG4gKiAgICAgXCJkb2N1bWVudElkXCIgOiAxXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBBbmQgdGhlIGZvbGxvd2luZyBmb3JtIGZvciB1bnN1Y2Nlc3NmdWwgdXBsb2FkczpcbiAqXG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgICAgXCJzdWNjZXNzXCIgOiBmYWxzZSxcbiAqICAgICBcIm1lc3NhZ2VcIiA6IFwiV2h5IHRoZSB1cGxvYWQgd2FzIHJlamVjdGVkXCJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZSBuYW1lIG9mIHRoZSBgZG9jdW1lbnRJZGAgcHJvcGVydHkgaXMgY29uZmlndXJlZCBpbiB7QGxpbmsgI21lbWJlci1kb2N1bWVudElkUGFyYW1ldGVyfS5cbiAqIEl0IGRlZmF1bHRzIHRvIGAnZG9jdW1lbnRJZCdgLlxuICpcbiAqIFRoZSBgZG9jdW1lbnRJZGAgaXMgdXNlZCB3aGVuIHJlcXVlc3RpbmcgdGhlIGRvY3VtZW50IG1hbHdhcmUgc2NhbiBzdGF0dXMsIGFuZCB3aGVuIHJlcXVlc3RpbmdcbiAqIHRoYXQgdGhlIGRvY3VtZW50IGJlIGRlbGV0ZWQsIG9yIGRvd25sb2FkZWQuXG4gKlxuICogSWYgdGhlIHVwbG9hZCBpcyBzdWNjZXNzZnVsLCB0aGVuIHRoZSB7QGxpbmsgI21lbWJlci1kb2N1bWVudFN0YXR1c1VybH0gaXMgcG9sbGVkIHVudGlsIHRoZVxuICogbWFsd2FyZSBzY2FuLiBUaGUgZG9jdW1lbnQgaWQgcmV0dXJuZWQgZnJvbSB0aGUgdXBsb2FkIGlzIHBhc3NlZCBpbiB0aGUgcGFyYW1ldGVyIG5hbWVkXG4gKiBieSB0aGUge0BsaW5rICNtZW1iZXItZG9jdW1lbnRJZFBhcmFtZXRlcn0uIEl0IGRlZmF1bHRzIHRvIGAnZG9jdW1lbnRJZCdgLlxuICpcbiAqIFRoaXMgc2VydmljZSBtdXN0IHJldHVybiBhIEpTT04gc3RhdHVzIHJlc3BvbnNlIGluIHRoZSBmb2xsb3dpbmcgaWYgdGhlIHNjYW4gaXMgc3RpbGwgcHJvZ3Jlc3Npbmc6XG4gKlxuICogYGBganNvblxuICoge1xuICogICAgIFwic3RhdHVzXCIgOiBcInNjYW5uaW5nXCJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCB0aGUgZm9sbG93aW5nIGZvcm0gaXMgbWFsd2FyZSB3YXMgZGV0ZWN0ZWQ6XG4gKlxuICogYGBganNvblxuICoge1xuICogICAgIFwic3RhdHVzXCIgOiBcInNjYW4tZmFpbGVkXCJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzY2FuLCBhIGRvY3VtZW50IG1heSBvciBtYXkgbm90IGJlIGRvd25sb2FkYWJsZS5cbiAqXG4gKiBGb3IgYSBkb3dubG9hZGFibGUgZG9jdW1lbnQsIHRoZSByZXNwb25zZSBtdXN0IGJlOlxuICpcbiAqIGBgYGpzb25cbiAqIHtcbiAqICAgICBcInN0YXR1c1wiIDogXCJkb3dubG9hZGFibGVcIlxuICogfVxuICogYGBgXG4gKlxuICogRm9yIGEgbm9uLWRvd25sb2FkYWJsZSBkb2N1bWVudCwgdGhlIHJlc3BvbnNlIG11c3QgYmU6XG4gKlxuICogYGBganNvblxuICoge1xuICogICAgIFwic3RhdHVzXCIgOiBcIm5vdC1kb3dubG9hZGFibGVcIlxuICogfVxuICogYGBgXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuRmlsZVVwbG9hZFxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuQmFzZVxuICovXG5jbGFzcyBGaWxlVXBsb2FkIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5GaWxlVXBsb2FkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5GaWxlVXBsb2FkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2ZpbGUtdXBsb2FkLWZpZWxkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2ZpbGUtdXBsb2FkLWZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWZpbGUtdXBsb2FkLWZpZWxkJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZmlsZS11cGxvYWQtZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WyduZW8tZmllbGQtZW1wdHknXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ25lby1maWVsZC1lbXB0eSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge3RhZzogJ2knLCBjbHM6ICduZW8tZmlsZS11cGxvYWQtc3RhdGUtaWNvbid9LFxuICAgICAgICAgICAge2NsczogJ25lby1maWxlLXVwbG9hZC1ib2R5JywgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiAnbmVvLWZpbGUtdXBsb2FkLWZpbGVuYW1lJ30sXG4gICAgICAgICAgICAgICAge2NsczogJ25lby1maWxlLXVwbG9hZC1zdGF0ZSd9XG4gICAgICAgICAgICBdfSxcbiAgICAgICAgICAgIHt0YWc6ICdidXR0b24nLCBjbHM6ICduZW8tZmlsZS11cGxvYWQtYWN0aW9uLWJ1dHRvbid9LFxuICAgICAgICAgICAge3RhZzogJ2lucHV0JywgY2xzOiAnbmVvLWZpbGUtdXBsb2FkLWlucHV0JywgdHlwZTogJ2ZpbGUnfSxcbiAgICAgICAgICAgIHt0YWc6ICdsYWJlbCcsIGNsczogJ25lby1maWxlLXVwbG9hZC1sYWJlbCd9LFxuICAgICAgICAgICAge2NsczogJ25lby1maWxlLXVwbG9hZC1lcnJvci1tZXNzYWdlJ31cbiAgICAgICAgXX0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9iamVjdCBjb250YWluaW5nIGEgZGVmYXVsdCBzZXQgb2YgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIHNlcnZlciBvbiBldmVyeSBIVFRQIHJlcXVlc3QuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaGVhZGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyc186IHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBPYmplY3Qgd2hpY2ggYWxsb3dzIHRoZSBzdGF0dXMgdGV4dCByZXR1cm5lZCBmcm9tIHRoZSB7QGxpbmsgI3Byb3BlcnR5LWRvY3VtZW50U3RhdHVzVXJsfSB0byBiZVxuICAgICAgICAgKiBtYXBwZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCB3aWRnZXQgc3RhdGUuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZG9jdW1lbnRTdGF0dXNNYXBcbiAgICAgICAgICovXG4gICAgICAgIGRvY3VtZW50U3RhdHVzTWFwOiB7XG4gICAgICAgICAgICBTQ0FOTklORyAgICAgICAgIDogJ3NjYW5uaW5nJyxcblxuICAgICAgICAgICAgLy8gVGhlIHNlcnZlciBkb2luZyBpdHMgb3duIHNlY29uZGFyeSB1cGxvYWQgdG8gdGhlIGZpbmFsIHN0b3JhZ2UgbG9jYXRpb24gbWF5IHJldHVybiB0aGlzLlxuICAgICAgICAgICAgLy8gV2UgZW50ZXIgdGhlIHNhbWUgc3RhdGUgYXMgc2Nhbm5pbmcuIEEgc3Bpbm5lciBzaG93cyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgc3RhdGVcbiAgICAgICAgICAgIFVQTE9BRElORyAgICAgICA6ICdzY2FubmluZycsXG5cbiAgICAgICAgICAgIE1BTFdBUkVfREVURUNURUQ6ICdzY2FuLWZhaWxlZCcsXG4gICAgICAgICAgICBVTl9ET1dOTE9BREFCTEUgOiAnbm90LWRvd25sb2FkYWJsZScsXG4gICAgICAgICAgICBBVkFJTEFCTEUgICAgICAgOiAnbm90LWRvd25sb2FkYWJsZScsXG4gICAgICAgICAgICBET1dOTE9BREFCTEUgICAgOiAnZG93bmxvYWRhYmxlJyxcbiAgICAgICAgICAgIERFTEVURUQgICAgICAgICA6ICdkZWxldGVkJyxcbiAgICAgICAgICAgIEVSUk9SICAgICAgICAgICA6ICdlcnJvcidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRvY3VtZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkb2N1bWVudF86IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoaXMgd2lkZ2V0IHNob3VsZCByZWZlcmVuY2UgYW4gZXhpc3RpbmcgZG9jdW1lbnQsIGNvbmZpZ3VyZSB0aGUgd2lkZ2V0IHdpdGggYSBkb2N1bWVudElkXG4gICAgICAgICAqIHNvIHRoYXQgaXQgY2FuIGluaXRpYWxpemUgaW4gdGhlIGNvcnJlY3QgXCJ1cGxvYWRlZFwiIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGlzIGlzICpub3QqIGNvbmZpZ3VyZWQsIHRoZW4gdGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHNldCBhZnRlciBhIHN1Y2Nlc3NmdWwgdXBsb2FkIHRvXG4gICAgICAgICAqIHRoZSBpZCByZXR1cm5lZCBmcm9tIHRoZSB7QGxpbmsgI3Byb3BlcnR5LXVwbG9hZFVybH0uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xOdW1iZXJ9IGRvY3VtZW50SWRcbiAgICAgICAgICovXG4gICAgICAgIGRvY3VtZW50SWQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgb2YgdGhlIGZpbGUgdXBsb2FkIHNlcnZpY2UgdG8gd2hpY2ggdGhlIHNlbGVjdGVkIGZpbGUgaXMgc2VudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBzZXJ2aWNlIG11c3QgcmV0dXJuIGEgSlNPTiByZXNwb25zZSBvZiB0aGUgZm9ybTpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBganNvblxuICAgICAgICAgKiB7XG4gICAgICAgICAqICAgICBcInN1Y2Nlc3NcIiAgICA6IHRydWUsXG4gICAgICAgICAqICAgICBcIm1lc3NhZ2VcIiAgICA6IFwiT25seSBuZWVkZWQgaWYgdGhlIHN1Y2Nlc3MgcHJvcGVydHkgaXMgZmFsc2VcIixcbiAgICAgICAgICogICAgIFwiZG9jdW1lbnRJZFwiIDogMVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZG9jdW1lbnQgaWQgaXMgbmVlZGVkIHNvIHRoYXQgdGhpcyB3aWRnZXQgY2FuIGZvbGxvdyB1cCBhbmQgcmVxdWVzdCB0aGUgcmVzdWx0cyBvZiB0aGVcbiAgICAgICAgICogc2NhbiBvcGVyYXRpb24gdG8gc2VlIGlmIHRoZSBmaWxlIHdhcyBhY2NlcHRlZCwgYW5kIHdoZXRoZXIgaXQgaXMgdG8gYmUgc3Vic2VxdWVudGx5IGRvd25sb2FkYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRvY3VtZW50IHN0YXR1cyByZXF1ZXN0IFVSTCBtdXN0IGJlIGNvbmZpZ3VyZWQgaW4ge0BsaW5rICNtZW1iZXItZG9jdW1lbnRTdGF0dXNVcmx9XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB1cGxvYWRVcmw9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdXBsb2FkVXJsOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgSlNPTiBwcm9wZXJ0eSBpbiB3aGljaCB0aGUgZG9jdW1lbnQgaWQgaXMgcmV0dXJuZWQgaW4gdGhlIHVwbG9hZCByZXNwb25zZVxuICAgICAgICAgKiBKU09OIHBhY2tldCBhbmQgdGhlIHRva2VuIHN0cmluZyB3aGljaCBpcyBzdWJzdGl0dXRlZCBmb3IgdGhlIGRvY3VtZW50IGlkIHdoZW4gcmVxdWVzdGluZ1xuICAgICAgICAgKiBhIG1hbHdhcmUgc2NhbiBhbmQgYSBkb2N1bWVudCBkZWxldGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogRGVmYXVsdHMgZnJvIGBkb2N1bWVudElkYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRvY3VtZW50SWRQYXJhbWV0ZXI9J2RvY3VtZW50SWQnXG4gICAgICAgICAqL1xuICAgICAgICBkb2N1bWVudElkUGFyYW1ldGVyOiAnZG9jdW1lbnRJZCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgZnJvbSB3aGljaCB0aGUgZmlsZSBtYXkgYmUgZG93bmxvYWRlZCBhZnRlciBpdCBoYXMgZmluaXNoZWQgaXRzIHNjYW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbXVzdCBjb250YWluIGEgc3Vic3RpdHV0aW9uIHRva2VuIG5hbWVkIHRoZSBzYW1lIGFzIHRoZSB7QGxpbmsgI3Byb3BlcnR5LWRvY3VtZW50SWRQYXJhbWV0ZXJ9XG4gICAgICAgICAqIHdoaWNoIGlzIHVzZWQgd2hlbiBjcmVhdGluZyBhIFVSTFxuICAgICAgICAgKlxuICAgICAgICAgKiBmb3IgZXhhbXBsZTpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBganNvblxuICAgICAgICAgKiB7XG4gICAgICAgICAqICAgICBkb3dubG9hZFVybCA6ICcvZ2V0RG9jdW1lbnQvJHtkb2N1bWVudElkfSdcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRvY3VtZW50IGlkIHJldHVybmVkIGZyb20gdGhlIHtAbGluayAjbWVtYmVyLXVwbG9hZFVybCB1cGxvYWR9IGlzIHBhc3NlZCBpbiB0aGUgcGFyYW1ldGVyIG5hbWVkXG4gICAgICAgICAqIGJ5IHRoZSB7QGxpbmsgI21lbWJlci1kb2N1bWVudElkUGFyYW1ldGVyfS4gSXQgZGVmYXVsdHMgdG8gYCdkb2N1bWVudElkJ2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBkb3dubG9hZFVybF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZG93bmxvYWRVcmxfOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSBmaWxlIHN0YXR1cyByZXBvcnRpbmcgc2VydmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtdXN0IGNvbnRhaW4gYSBzdWJzdGl0dXRpb24gdG9rZW4gbmFtZWQgdGhlIHNhbWUgYXMgdGhlIHtAbGluayAjcHJvcGVydHktZG9jdW1lbnRJZFBhcmFtZXRlcn1cbiAgICAgICAgICogd2hpY2ggaXMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgVVJMXG4gICAgICAgICAqXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBqc29uXG4gICAgICAgICAqIHtcbiAgICAgICAgICogICAgIGRvY3VtZW50U3RhdHVzVXJsIDogJy9nZXREb2N1bWVudFN0YXR1cy8ke2RvY3VtZW50SWR9J1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpZGdldCB3aWxsIHVzZSB0aGlzIHNlcnZpY2UgYWZ0ZXIgYSBzdWNjZXNzZnVsIHVwbG9hZCB0byBkZXRlcm1pbmUgaXRzIG5leHRcbiAgICAgICAgICogc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgc2VydmljZSBtdXN0IHJldHVybiBhIEpTT04gcmVzcG9uc2Ugb2YgdGhlIGZvcm06XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYGpzb25cbiAgICAgICAgICoge1xuICAgICAgICAgKiAgICAgXCJzdGF0dXNcIiA6IFwic2Nhbm5pbmdcIiBvciBcInNjYW4tZmFpbGVkXCIgb3IgXCJkb3dubG9hZGFibGUgb3IgXCJub3QtZG93bmxvYWRhYmxlXCJcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRvY3VtZW50U3RhdHVzVXJsXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkb2N1bWVudFN0YXR1c1VybF86IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb2xsaW5nIGludGVydmFsICppbiBtaWxsaXNlY29uZHMqIHRvIHdhaXQgYmV0d2VlbiBhc2tpbmcgdGhlIHNlcnZlciBob3cgdGhlIGRvY3VtZW50IHNjYW5cbiAgICAgICAgICogaXMgcHJvY2VlZGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogRGVmYXVsdHMgdG8gMjAwMG1zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc3RhdHVzU2NhbkludGVydmFsPTIwMDBcbiAgICAgICAgICovXG4gICAgICAgIHN0YXR1c1NjYW5JbnRlcnZhbDogMjAwMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgZmlsZSBkZWxldGlvbiBzZXJ2aWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG11c3QgY29udGFpbiBhIHN1YnN0aXR1dGlvbiB0b2tlbiBuYW1lZCB0aGUgc2FtZSBhcyB0aGUge0BsaW5rICNwcm9wZXJ0eS1kb2N1bWVudElkUGFyYW1ldGVyfVxuICAgICAgICAgKiB3aGljaCBpcyB1c2VkIHdoZW4gY3JlYXRpbmcgYSBVUkxcbiAgICAgICAgICpcbiAgICAgICAgICogZm9yIGV4YW1wbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYGpzb25cbiAgICAgICAgICoge1xuICAgICAgICAgKiAgICAgZG9jdW1lbnREZWxldGVVcmwgOiAnL2RlbGV0ZURvY3VtZW50LyR7ZG9jdW1lbnRJZH0nXG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lkZ2V0IHdpbGwgdXNlIHRoaXMgc2VydmljZSBhZnRlciBhIHN1Y2Nlc3NmdWwgdXBsb2FkIHRvIGRldGVybWluZSBpdHMgbmV4dFxuICAgICAgICAgKiBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhpcyBzZXJ2aWNlIHlpZWxkcyBhbiBIVFRQIDIwMCBzdGF0dXMsIHRoZSBkZWxldGlvbiBpcyB0YWtlbiB0byBoYXZlIGJlZW4gc3VjY2Vzc2Z1bC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRvY3VtZW50RGVsZXRlVXJsXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkb2N1bWVudERlbGV0ZVVybF86IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVFRQIG1ldGhvZCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIGEgZG9jdW1lbnQgZGVsZXRpb24gdXNpbmcgdGhlIHtAbGluayAjbWVtYmVyLWRvY3VtZW50RGVsZXRlVXJsfS5cbiAgICAgICAgICpcbiAgICAgICAgICogRGVmYXVsdHMgdG8gYERFTEVURWAuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZG9jdW1lbnREZWxldGVNZXRob2Q9J0RFTEVURSdcbiAgICAgICAgICovXG4gICAgICAgIGRvY3VtZW50RGVsZXRlTWV0aG9kOiAnREVMRVRFJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzdGF0ZV89cmVhZHlcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlXzogJ3JlYWR5JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB0eXBlcz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlc186IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xOdW1iZXJ8bnVsbH0gbWF4U2l6ZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtYXhTaXplXzogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVycm9yIHRleHQgdG8gc2hvdyBiZWxvdyB0aGUgd2lkZ2V0XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBlcnJvcl89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JfIDogbnVsbCxcblxuICAgICAgICAvLyBVSSBzdHJpbmdzIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGZvciBvdGhlciBsYW5ndWFnZXNcbiAgICAgICAgY2hvb3NlRmlsZSAgICAgICAgICAgOiAnQ2hvb3NlIGZpbGUnLFxuICAgICAgICBkb2N1bWVudFRleHQgICAgICAgICA6ICdEb2N1bWVudCcsXG4gICAgICAgIGludmFsaWRGaWxlRm9ybWF0ICAgIDogJ2ludmFsaWQgZmlsZSBmb3JtYXQnLFxuICAgICAgICBwbGVhc2VVc2VUaGVzZVR5cGVzICA6ICdQbGVhc2UgdXNlIHRoZXNlIGZpbGUgdHlwZXMge2FsbG93ZWRGaWxlVHlwZXN9JyxcbiAgICAgICAgZmlsZVNpemVNb3JlVGhhbiAgICAgOiAnRmlsZSBzaXplIGV4Y2VlZHMge2FsbG93ZWRGaWxlU2l6ZX0nLFxuICAgICAgICB1cGxvYWRFcnJvciAgICAgICAgICA6ICdQbGVhc2UgdHJ5IGFnYWluJyxcbiAgICAgICAgZG9jdW1lbnREZWxldGVFcnJvciAgOiAnRG9jdW1lbnQgZGVsZXRlIHNlcnZpY2UgZXJyb3InLFxuICAgICAgICBpc05vTG9uZ2VyQXZhaWxhYmxlICA6ICdpcyBubyBsb25nZXIgYXZhaWxhYmxlJyxcbiAgICAgICAgZG9jdW1lbnRTdGF0dXNFcnJvciAgOiAnRG9jdW1lbnQgc3RhdHVzIHNlcnZpY2UgZXJyb3InLFxuICAgICAgICB1cGxvYWRGYWlsZWQgICAgICAgICA6ICdVcGxvYWQgZmFpbGVkJyxcbiAgICAgICAgc2Nhbm5pbmcgICAgICAgICAgICAgOiAnU2Nhbm5pbmcnLFxuICAgICAgICB1cGxvYWRpbmcgICAgICAgICAgICA6ICdVcGxvYWRpbmcuLi4nLFxuICAgICAgICBtYWx3YXJlRm91bmRJbkZpbGUgICA6ICdNYWx3YXJlIGZvdW5kIGluIGZpbGUnLFxuICAgICAgICBwbGVhc2VDaGVjayAgICAgICAgICA6ICdQbGVhc2UgY2hlY2sgdGhlIGZpbGUgYW5kIHRyeSBhZ2FpbicsXG4gICAgICAgIHN1Y2Nlc3NmdWxseVVwbG9hZGVkIDogJ1N1Y2Nlc3NmdWxseSB1cGxvYWRlZCcsXG4gICAgICAgIGZpbGVXYXNEZWxldGVkICAgICAgIDogJ0ZpbGUgd2FzIGRlbGV0ZWQnLFxuICAgICAgICBmaWxlSXNJbkFuRXJyb3JTdGF0ZSA6ICdGaWxlIGlzIGluIGFuIGVycm9yIHN0YXRlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgeyBpbnB1dCA6IG1lLm9uSW5wdXRWYWx1ZUNoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHsgY2xpY2sgOiBtZS5vbkFjdGlvbkJ1dHRvbkNsaWNrLCBkZWxlZ2F0ZSA6ICcubmVvLWZpbGUtdXBsb2FkLWFjdGlvbi1idXR0b24nLCBzY29wZSA6IG1lfVxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBhZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBpbnB1dEVsSWQgPSBgJHt0aGlzLmlkfS1pbnB1dGA7XG5cbiAgICAgICAgdGhpcy5nZXRJbnB1dEVsKCkuaWQgPSAgdGhpcy52ZG9tLmNuWzRdLmZvciA9IGlucHV0RWxJZDtcblxuICAgICAgICAvLyBzaWxlbnQgdmRvbSB1cGRhdGUsIHRoZSBzdXBlciBjYWxsIHdpbGwgdHJpZ2dlciB0aGUgZW5naW5lXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0SWQ/Lih2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cblxuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoLi4uYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLnZkb20uY25bNF0uaHRtbCA9IHRoaXMuY2hvb3NlRmlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldElucHV0RWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bM107XG4gICAgfVxuXG4gICAgYXN5bmMgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHsgY2xzIH0gPSBtZTtcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLWZpZWxkLWVtcHR5Jyk7XG4gICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICBtZS52ZG9tLmNuWzNdID0ge1xuICAgICAgICAgICAgaWQgICAgOiBgJHttZS5pZH0taW5wdXRgLFxuICAgICAgICAgICAgY2xzICAgOiAnbmVvLWZpbGUtdXBsb2FkLWlucHV0JyxcbiAgICAgICAgICAgIHRhZyAgIDogJ2lucHV0JyxcbiAgICAgICAgICAgIHR5cGUgIDogJ2ZpbGUnLFxuICAgICAgICAgICAgdmFsdWUgOiAnJ1xuICAgICAgICB9O1xuICAgICAgICBtZS5zdGF0ZSA9ICdyZWFkeSc7XG4gICAgICAgIG1lLmVycm9yID0gJyc7XG4gICAgICAgIG1lLmZpbGUgPSBtZS5kb2N1bWVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3YWl0IGZvciB0aGUgRE9NIHRvIGhhdmUgY2hhbmdlZCwgYW5kIHRoZSBpbnB1dCBmaWVsZCB0byBiZSB2aXNpYmxlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgICAgbWUuZm9jdXMobWUuZ2V0SW5wdXRFbCgpLmlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbklucHV0VmFsdWVDaGFuZ2UoeyBmaWxlcyB9KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGVzLFxuICAgICAgICAgICAgICAgIGNsc1xuICAgICAgICAgICAgfSA9IG1lLFxuICAgICAgICAgICAgYm9keSAgICAgID0gbWUudmRvbS5jblsxXTtcblxuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLWZpZWxkLWVtcHR5Jyk7XG4gICAgICAgICAgICBtZS5jbHMgPSBjbHM7XG5cbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgZmlsZSAgICAgPSBmaWxlcy5pdGVtKDApLFxuICAgICAgICAgICAgICAgIHBvaW50UG9zID0gZmlsZS5uYW1lLmxhc3RJbmRleE9mKCcuJyksXG4gICAgICAgICAgICAgICAgdHlwZSAgICAgPSBwb2ludFBvcyA+IC0xID8gZmlsZS5uYW1lLnNsaWNlKHBvaW50UG9zICsgMSkgOiAnJyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkRmlsZU5hbWUgPSBTdHJpbmdVdGlsLmVzY2FwZUh0bWwoZmlsZS5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKG1lLnR5cGVzICYmICF0eXBlc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIGJvZHkuY25bMF0uaW5uZXJIVE1MID0gZXNjYXBlZEZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGJvZHkuY25bMV0uaW5uZXJIVE1MID0gYCR7bWUuaW52YWxpZEZpbGVGb3JtYXR9ICguJHt0eXBlfSkgJHttZS5mb3JtYXRTaXplKGZpbGUuc2l6ZSl9YDtcbiAgICAgICAgICAgICAgICBtZS5lcnJvciA9IG1lLnBsZWFzZVVzZVRoZXNlVHlwZXM/LnJlcGxhY2UoJ3thbGxvd2VkRmlsZVR5cGVzfScsIE9iamVjdC5rZXlzKHR5cGVzKS5qb2luKCcgLicpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsZS5zaXplID4gbWUubWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIGJvZHkuY25bMF0uaW5uZXJIVE1MID0gZXNjYXBlZEZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGJvZHkuY25bMV0uaW5uZXJIVE1MID0gbWUuZm9ybWF0U2l6ZShmaWxlLnNpemUpO1xuICAgICAgICAgICAgICAgIG1lLmVycm9yID0gbWUuZmlsZVNpemVNb3JlVGhhbj8ucmVwbGFjZSgne2FsbG93ZWRGaWxlU2l6ZX0nLCBTdHJpbmcobWUuX21heFNpemUpLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQgcGFzc2VzIHRoZSB0eXBlIGFuZCBtYXhTaXplIGNoZWNrLCB1cGxvYWQgaXRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmZpbGVTaXplID0gbWUuZm9ybWF0U2l6ZShmaWxlLnNpemUpO1xuICAgICAgICAgICAgICAgIG1lLmVycm9yID0gJyc7XG4gICAgICAgICAgICAgICAgbWUudXBsb2FkKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGNsZWFyZWQsIHdlIGdvIGJhY2sgdG8gcmVhZHkgc3RhdGVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZS5zdGF0ZSA9ICdyZWFkeSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB1cGxvYWQoZmlsZSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB4aHIgICAgICAgID0gbWUueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgICAgICB7IHVwbG9hZCB9ID0geGhyLFxuICAgICAgICAgICAgZmlsZURhdGEgICA9IG5ldyBGb3JtRGF0YSgpLFxuICAgICAgICAgICAgaGVhZGVycyAgICA9IHsgLi4ubWUuaGVhZGVycyB9O1xuXG4gICAgICAgIC8vIFNob3cgdGhlIGFjdGlvbiBidXR0b25cbiAgICAgICAgbWUuZmlsZSAgPSBmaWxlO1xuICAgICAgICBtZS5zdGF0ZSA9ICdzdGFydGluZyc7XG5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3YWl0IGZvciB0aGUgRE9NIHRvIGhhdmUgY2hhbmdlZCwgYW5kIHRoZSBhY3Rpb24gYnV0dG9uIHRvIGJlIHZpc2libGVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICBtZS5mb2N1cyhtZS52ZG9tLmNuWzJdLmlkKTtcblxuICAgICAgICBtZS52ZG9tLmNuWzFdLmNuWzBdLmlubmVySFRNTCA9IFN0cmluZ1V0aWwuZXNjYXBlSHRtbChmaWxlLm5hbWUpO1xuICAgICAgICBtZS51cGRhdGUoKTtcbiAgICAgICAgbWUuc3RhdGUgPSAndXBsb2FkaW5nJztcblxuICAgICAgICAvLyBUaGlzIG1lYW5zIG5vIHByb2dyZXNzIGFzIG9wcG9zZWQgdG8gemVybywgYnV0IHN0aWxsIGR1cmluZyBhIGN1cnJlbnRseSBzdWNjZXNzZnVsIG9uZ29pbmcgdXBsb2FkLlxuICAgICAgICAvLyBXaGVuIGl0IGlzIE5hTiwgdGhlIGVycm9yIGRpc3BsYXkgZG9lcyBub3QgYXR0ZW1wdCB0byBzaG93IHByb2dyZXNzLlxuICAgICAgICBtZS5wcm9ncmVzcyA9IE5hTjtcblxuICAgICAgICBmaWxlRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGZpbGUpO1xuXG4gICAgICAgIC8vIFJlYWN0IHRvIHVwbG9hZCBzdGF0ZSBjaGFuZ2VzXG4gICAgICAgIHVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIG1lLm9uVXBsb2FkUHJvZ3Jlc3MuYmluZChtZSkpO1xuICAgICAgICB1cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAgICBtZS5vblVwbG9hZEVycm9yLmJpbmQobWUpKTtcbiAgICAgICAgdXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgICAgbWUub25VcGxvYWRBYm9ydC5iaW5kKG1lKSk7XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgICAgIG1lLm9uVXBsb2FkRG9uZS5iaW5kKG1lKSk7XG5cbiAgICAgICAgeGhyLm9wZW4oXCJQT1NUXCIsIG1lLnVwbG9hZFVybCwgdHJ1ZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZmlyZXMgYmVmb3JlIGV2ZXJ5IEhUVFAgcmVxdWVzdCBpcyBzZW50IHRvIHRoZSBzZXJ2ZXIgdmlhIGFueSBvZiB0aGUgY29uZmlndXJlZCBVUkxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgYmVmb3JlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5oZWFkZXJzIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjb25maWd1cmVkIHtAbGluayAjcHJvcGVydHktaGVhZGVyc31cbiAgICAgICAgICogZm9yIHRoaXMgd2lkZ2V0LCBpbnRvIHdoaWNoIG5ldyBoZWFkZXJzIG1heSBiZSBpbmplY3RlZC5cbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIG1lLmZpcmUoJ2JlZm9yZVJlcXVlc3QnLCB7XG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICB4aHIuc2VuZChmaWxlRGF0YSk7XG4gICAgfVxuXG4gICAgb25VcGxvYWRQcm9ncmVzcyh7IGxvYWRlZCwgdG90YWwgfSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgcHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzID0gbG9hZGVkIC8gdG90YWwsXG4gICAgICAgICAgICB7IHZkb20gfSA9IHRoaXM7XG5cbiAgICAgICAgKHZkb20uc3R5bGUgfHwgKHZkb20uc3R5bGUgPSB7fSkpWyctLXVwbG9hZC1wcm9ncmVzcyddID0gYCR7cHJvZ3Jlc3N9dHVybmA7XG5cbiAgICAgICAgdmRvbS5jblsxXS5jblsxXS5pbm5lckhUTUwgPSBgJHt0aGlzLnVwbG9hZGluZ30uLi4gKCR7TWF0aC5yb3VuZChwcm9ncmVzcyAqIDEwMCl9JSlgO1xuXG4gICAgICAgIHRoaXMudXBsb2FkU2l6ZSA9IGxvYWRlZDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBvblVwbG9hZEFib3J0KGUpIHtcbiAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgb25VcGxvYWRFcnJvcihlKSB7XG4gICAgICAgIHRoaXMueGhyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICd1cGxvYWQtZmFpbGVkJztcbiAgICAgICAgdGhpcy5lcnJvciA9IGAke3RoaXMudXBsb2FkRXJyb3J9YDtcbiAgICB9XG5cbiAgICBvblVwbG9hZERvbmUoeyBsb2FkZWQsIHRhcmdldCA6IHhociB9KSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBtZS54aHIgPSBudWxsO1xuXG4gICAgICAgIC8vIFN1Y2Nlc3NmdWwgbmV0d29yayByZXF1ZXN0LlxuICAgICAgICAvLyBDaGVjayB0aGUgcmVzdWx0aW5nIEpTT04gcGFja2V0IGZvciBkZXRhaWxzIGFuZCBhbnkgZXJyb3IuXG4gICAgICAgIGlmIChodHRwU3VjY2Vzc0NvZGVzW1N0cmluZyh4aHIuc3RhdHVzKVswXV0pIHtcbiAgICAgICAgICAgIGlmIChsb2FkZWQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRvY3VtZW50SWQgPSByZXNwb25zZVttZS5kb2N1bWVudElkUGFyYW1ldGVyXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3RhdHVzIGNoZWNrIHBoYXNlIGlzIG9wdGlvbmFsLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBVUkwgc3BlY2lmaWVkLCB0aGUgZmlsZSBpcyB0YWtlbiB0byBiZSBkb3dubG9hZGFibGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5kb2N1bWVudFN0YXR1c1VybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc3RhdGUgPSAncHJvY2Vzc2luZyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHBvbGxpbmcgdGhlIHNlcnZlciB0byBzZWUgd2hlbiB0aGUgc2NhbiBoYXMgYSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5jaGVja0RvY3VtZW50U3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zdGF0ZSA9ICdkb3dubG9hZGFibGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5lcnJvciA9IHJlc3BvbnNlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIG1lLnN0YXRlID0gJ3VwbG9hZC1mYWlsZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGYWlsZWQgbmV0d29yayByZXF1ZXN0cyBhcmUgaGFuZGxlZCBpbiBvblVwbG9hZEVycm9yXG4gICAgICAgIC8vIHNvIG5vIGVsc2UgY29uZGl0aW9uIG5lY2Vzc2FyeSBoZXJlXG4gICAgfVxuXG4gICAgb25BY3Rpb25CdXR0b25DbGljaygpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7IHN0YXRlIH0gPSBtZTtcblxuICAgICAgICAvLyBXaGVuIHRoZXkgY2xpY2sgdGhlIGFjdGlvbiBidXR0b24sIGRlcGVuZGluZyBvbiB3aGljaCBzdGF0ZSB3ZSBhcmUgaW4sIHdlIGdvIHRvXG4gICAgICAgIC8vIGRpZmZlcmVudCBzdGF0ZXMuXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyB1cGxvYWQsIGl0cyBhbiBhYm9ydFxuICAgICAgICAgICAgY2FzZSAndXBsb2FkaW5nJzpcbiAgICAgICAgICAgICAgICBtZS5hYm9ydFVwbG9hZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBXaGlsZSBwcm9jZXNzaW5nIHdlIGp1c3QgaGF2ZSB0byB3YWl0IHVudGlsIGl0J3Mgc3VjY2VlZGVkIG9yIGZhaWxlZC4uXG4gICAgICAgICAgICBjYXNlICdwcm9jZXNzaW5nJzpcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHVwbG9hZCBvciB0aGUgc2NhbiBmYWlsZWQsIHRoZSBkb2N1bWVudCB3aWxsIG5vdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHNhdmVkLCBzbyB3ZSBqdXN0IGdvIGJhY2sgdG8gcmVhZHkgc3RhdGVcbiAgICAgICAgICAgIGNhc2UgJ3VwbG9hZC1mYWlsZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2Nhbi1mYWlsZWQnOlxuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIG1lLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgbWUuc3RhdGUgPSAncmVhZHknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBGb3Igc3RvcmVkIGRvY3VtZW50cywgd2UgbmVlZCB0byB0ZWxsIHRoZSBzZXJ2ZXIgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAvLyBpcyBub3QgcmVxdWlyZWQuXG4gICAgICAgICAgICBjYXNlICdwcm9jZXNzaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rvd25sb2FkYWJsZSc6XG4gICAgICAgICAgICBjYXNlICdub3QtZG93bmxvYWRhYmxlJzpcbiAgICAgICAgICAgICAgICBtZS5kZWxldGVEb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlZCc6XG4gICAgICAgICAgICAgICAgbWUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBtZS5zdGF0ZSA9ICdyZWFkeSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6XG4gICAgICAgICAgICAgICAgbWUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFib3J0VXBsb2FkKCkge1xuICAgICAgICB0aGlzLnhocj8uYWJvcnQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVEb2N1bWVudCgpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHsgaGVhZGVycyB9ID0gbWU7XG5cbiAgICAgICAgbWUuZmlyZSgnYmVmb3JlUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2UgYXNrIHRoZSBzZXJ2ZXIgdG8gZGVsZXRlIHVzaW5nIG91ciB0aGlzLmRvY3VtZW50SWRcbiAgICAgICAgY29uc3Qgc3RhdHVzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChtZS5kb2N1bWVudERlbGV0ZVVybCwge1xuICAgICAgICAgICAgbWV0aG9kIDogbWUuZG9jdW1lbnREZWxldGVNZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1Y2Nlc3NcbiAgICAgICAgaWYgKGh0dHBTdWNjZXNzQ29kZXNbU3RyaW5nKHN0YXR1c1Jlc3BvbnNlLnN0YXR1cylbMF1dKSB7XG4gICAgICAgICAgICBtZS5jbGVhcigpO1xuICAgICAgICAgICAgbWUuc3RhdGUgPSAncmVhZHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWUuZXJyb3IgPSBgJHttZS5kb2N1bWVudERlbGV0ZUVycm9yfTogJHtzdGF0dXNSZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBjaGVja0RvY3VtZW50U3RhdHVzKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgeyBoZWFkZXJzIH0gPSBtZTtcblxuICAgICAgICBpZiAobWUuc3RhdGUgPT09ICdwcm9jZXNzaW5nJykge1xuICAgICAgICAgICAgbWUuZmlyZSgnYmVmb3JlUmVxdWVzdCcsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChtZS5kb2N1bWVudFN0YXR1c1VybCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTdWNjZXNzXG4gICAgICAgICAgICBpZiAoaHR0cFN1Y2Nlc3NDb2Rlc1tTdHJpbmcoc3RhdHVzUmVzcG9uc2Uuc3RhdHVzKVswXV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJKc29uICAgPSBhd2FpdCBzdGF0dXNSZXNwb25zZS5qc29uKCksXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclN0YXR1cyA9IHNlcnZlckpzb24uc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAvLyBNYXAgdGhlIHNlcnZlcidzIHN0YXRlcyBjb2RlcyB0byBvdXIgb3duIHN0YXR1cyBjb2Rlc1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgICAgICAgPSBtZS5kb2N1bWVudFN0YXR1c01hcFtzZXJ2ZXJTdGF0dXNdIHx8IHNlcnZlclN0YXR1cztcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NjYW5uaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbWUuY2hlY2tEb2N1bWVudFN0YXR1cygpLCBtZS5zdGF0dXNTY2FuSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuZXJyb3IgPSBgJHttZS5kb2N1bWVudFRleHR9ICR7bWUuZG9jdW1lbnRJZH0gJHtpc05vTG9uZ2VyQXZhaWxhYmxlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zdGF0ZSA9ICdyZWFkeSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuZXJyb3IgPSBgJHttZS5kb2N1bWVudFN0YXR1c0Vycm9yfTogJHtzdGF0dXNSZXNwb25zZS5zdGF0dXNUZXh0IHx8IGBTZXJ2ZXIgZXJyb3IgJHtzdGF0dXNSZXNwb25zZS5zdGF0dXN9YH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc3RhdGUgPSAnZGVsZXRlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnN0YXRlID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmVycm9yID0gYCR7bWUuZG9jdW1lbnRTdGF0dXNFcnJvcn06ICR7c3RhdHVzUmVzcG9uc2Uuc3RhdHVzVGV4dCB8fCBgU2VydmVyIGVycm9yICR7c3RhdHVzUmVzcG9uc2Uuc3RhdHVzfWB9YDtcbiAgICAgICAgICAgICAgICBtZS5zdGF0ZSA9ICdkZWxldGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyU2V0RG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHsgY2xzIH0gPSBtZTtcblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1maWVsZC1lbXB0eScpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICBtZS5kb2N1bWVudElkID0gZG9jdW1lbnQuaWQ7XG4gICAgICAgICAgICBtZS5maWxlU2l6ZSA9IG1lLmZvcm1hdFNpemUoZG9jdW1lbnQuc2l6ZSk7XG4gICAgICAgICAgICBtZS52ZG9tLmNuWzFdLmNuWzBdLmlubmVySFRNTCA9IFN0cmluZ1V0aWwuZXNjYXBlSHRtbChkb2N1bWVudC5maWxlTmFtZSk7XG4gICAgICAgICAgICBtZS5zdGF0ZSA9IG1lLmRvY3VtZW50U3RhdHVzTWFwW2RvY3VtZW50LnN0YXR1c107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0YXRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFN0YXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmRvbVxuICAgICAgICAgICAgfSA9IG1lLFxuICAgICAgICAgICAgYW5jaG9yICA9IHZkb20uY25bMV0uY25bMF0sXG4gICAgICAgICAgICBzdGF0dXMgID0gdmRvbS5jblsxXS5jblsxXTtcblxuICAgICAgICBkZWxldGUgdmRvbS5pbmVydDtcblxuICAgICAgICBsZXQgaXNDaGFuZ2VFdmVudE5lZWRlZDtcblxuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6XG4gICAgICAgICAgICAgICAgYW5jaG9yLnRhZyA9ICdkaXYnO1xuICAgICAgICAgICAgICAgIGFuY2hvci5ocmVmID0gJyc7XG4gICAgICAgICAgICAgICAgaXNDaGFuZ2VFdmVudE5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1cGxvYWQtZmFpbGVkJzpcbiAgICAgICAgICAgICAgICBzdGF0dXMuaW5uZXJIVE1MID0gYCR7bWUudXBsb2FkRmFpbGVkfSR7aXNOYU4obWUucHJvZ3Jlc3MpID8gJycgOiBgLi4uICgke01hdGgucm91bmQobWUucHJvZ3Jlc3MgKiAxMDApfSUpYH1gO1xuICAgICAgICAgICAgICAgIGlzQ2hhbmdlRXZlbnROZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2luZyc6XG4gICAgICAgICAgICAgICAgc3RhdHVzLmlubmVySFRNTCA9IGAke21lLnNjYW5uaW5nfS4uLiAoJHttZS5mb3JtYXRTaXplKG1lLnVwbG9hZFNpemUpfSlgO1xuICAgICAgICAgICAgICAgIHZkb20uaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Nhbi1mYWlsZWQnOlxuICAgICAgICAgICAgICAgIHN0YXR1cy5pbm5lckhUTUwgPSBgJHttZS5tYWx3YXJlRm91bmRJbkZpbGV9LiBcXHUyMDIyICR7bWUuZmlsZVNpemV9YDtcbiAgICAgICAgICAgICAgICBtZS5lcnJvciA9IG1lLnBsZWFzZUNoZWNrO1xuICAgICAgICAgICAgICAgIGlzQ2hhbmdlRXZlbnROZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG93bmxvYWRhYmxlJzpcbiAgICAgICAgICAgICAgICBhbmNob3IudGFnID0gJ2EnO1xuICAgICAgICAgICAgICAgIGFuY2hvci5ocmVmID0gbWUuY3JlYXRlVXJsKG1lLmRvd25sb2FkVXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIFttZS5kb2N1bWVudElkUGFyYW1ldGVyXSA6IG1lLmRvY3VtZW50SWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuaW5uZXJIVE1MID0gbWUuZmlsZVNpemU7XG4gICAgICAgICAgICAgICAgaXNDaGFuZ2VFdmVudE5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdub3QtZG93bmxvYWRhYmxlJzpcbiAgICAgICAgICAgICAgICBzdGF0dXMuaW5uZXJIVE1MID0gbWUuZG9jdW1lbnQgPyBtZS5maWxlU2l6ZSA6IGAke21lLnN1Y2Nlc3NmdWxseVVwbG9hZGVkfSBcXHUyMDIyICR7bWUuZmlsZVNpemV9YDtcbiAgICAgICAgICAgICAgICBpc0NoYW5nZUV2ZW50TmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZWQnOlxuICAgICAgICAgICAgICAgIHN0YXR1cy5pbm5lckhUTUwgPSBtZS5maWxlV2FzRGVsZXRlZDtcbiAgICAgICAgICAgICAgICBpc0NoYW5nZUV2ZW50TmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBzdGF0dXMuaW5uZXJIVE1MID0gbWUuZmlsZUlzSW5BbkVycm9yU3RhdGU7XG4gICAgICAgICAgICAgICAgbWUuZXJyb3IgPSBtZS5wbGVhc2VDaGVjaztcbiAgICAgICAgICAgICAgICBpc0NoYW5nZUV2ZW50TmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDaGFuZ2VFdmVudE5lZWRlZCAmJiBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS5maXJlQ2hhbmdlRXZlbnQobWUuZmlsZSlcbiAgICAgICAgfVxuICAgICAgICBtZS52YWxpZGF0ZSgpO1xuICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICAvLyBQcm9jZXNzaW5nIGFib3ZlIG1heSBtdXRhdGUgY2xzXG4gICAgICAgIGNvbnN0IHsgY2xzIH0gPSBtZTtcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLWZpbGUtdXBsb2FkLXN0YXRlLScgKyBvbGRWYWx1ZSk7XG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tZmlsZS11cGxvYWQtc3RhdGUtJyArIHZhbHVlKTtcbiAgICAgICAgTmVvQXJyYXlbbWUuZmlsZSB8fCBtZS5kb2N1bWVudCA/ICdyZW1vdmUnIDogJ2FkZCcsICduZW8tZmllbGQtZW1wdHknXTtcbiAgICAgICAgbWUuY2xzID0gY2xzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVUkwgc3Vic3RpdHV0aW5nIHRoZSBwYXNzZWQgcGFyYW1ldGVyIG5hbWVzIGluIGF0IHRoZSBwbGFjZXMgd2hlcmUgdGhlIG5hbWVcbiAgICAgKiBvY2N1cnMgd2l0aGluIGB7fWAgaW4gdGhlIHBhdHRlcm4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICovXG4gICAgY3JlYXRlVXJsKHVybFBhdHRlcm4sIHBhcmFtcykge1xuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHVybFBhdHRlcm4gPSB1cmxQYXR0ZXJuLnJlcGxhY2UoYHske3BhcmFtTmFtZX19YCwgcGFyYW1zW3BhcmFtTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxQYXR0ZXJuO1xuICAgIH1cblxuICAgIGJlZm9yZUdldEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICByZXR1cm4geyAuLi4oaGVhZGVycyB8fCB7fSkgfVxuICAgIH1cblxuICAgIGJlZm9yZUdldERvY3VtZW50U3RhdHVzVXJsKGRvY3VtZW50U3RhdHVzVXJsKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50U3RhdHVzVXJsID09PSAnZnVuY3Rpb24nPyBkb2N1bWVudFN0YXR1c1VybC5jYWxsKG1lLCBtZSkgOiBtZS5jcmVhdGVVcmwoZG9jdW1lbnRTdGF0dXNVcmwsIHtcbiAgICAgICAgICAgIFttZS5kb2N1bWVudElkUGFyYW1ldGVyXSA6IG1lLmRvY3VtZW50SWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYmVmb3JlR2V0RG9jdW1lbnREZWxldGVVcmwoZG9jdW1lbnREZWxldGVVcmwpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnREZWxldGVVcmwgPT09ICdmdW5jdGlvbic/IGRvY3VtZW50RGVsZXRlVXJsLmNhbGwobWUsIG1lKSA6IG1lLmNyZWF0ZVVybChkb2N1bWVudERlbGV0ZVVybCwge1xuICAgICAgICAgICAgW21lLmRvY3VtZW50SWRQYXJhbWV0ZXJdIDogbWUuZG9jdW1lbnRJZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBiZWZvcmVHZXREb3dubG9hZFVybChkb3dubG9hZFVybCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkb3dubG9hZFVybCA9PT0gJ2Z1bmN0aW9uJz8gZG93bmxvYWRVcmwuY2FsbChtZSwgbWUpIDogbWUuY3JlYXRlVXJsKGRvd25sb2FkVXJsLCB7XG4gICAgICAgICAgICBbbWUuZG9jdW1lbnRJZFBhcmFtZXRlcl0gOiBtZS5kb2N1bWVudElkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGJlZm9yZUdldE1heFNpemUobWF4U2l6ZSkge1xuICAgICAgICAvLyBOb3QgY29uZmlndXJlZCBtZWFucyBubyBsaW1pdFxuICAgICAgICBpZiAobWF4U2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGxpdCBlZyBcIjEwMG1iXCIgaW50byB0aGUgbnVtZXJpYyBhbmQgdW5pdHMgcGFydHNcbiAgICAgICAgY29uc3Qgc2l6ZVBhcnRzID0gc2l6ZVJFLmV4ZWMobWF4U2l6ZSk7XG5cbiAgICAgICAgaWYgKHNpemVQYXJ0cykge1xuICAgICAgICAgICAgLy8gQ29udmVydCBtYiB0byAxMDAwMDAwIGV0Y1xuICAgICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IHNpemVNdWx0aXBsaWVyWyhzaXplUGFydHNbMl18fCd1bml0JykudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzaXplUGFydHNbMV0pICogbXVsdGlwbGllcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyU2V0RXJyb3IodGV4dCkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgdGhpcy52ZG9tLmNuWzVdLmNuID0gW3tcbiAgICAgICAgICAgICAgICB2dHlwZSA6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBodG1sICA6IHRleHRcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52ZG9tLmNuWzVdLmNuID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZm9ybWF0U2l6ZShieXRlcywgc2VwYXJhdG9yID0gJycsIHBvc3RGaXggPSAnJykge1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJ10sXG4gICAgICAgICAgICAgICAgaSAgICAgPSBNYXRoLm1pbihwYXJzZUludChNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKDEwMDApKS50b1N0cmluZygpLCAxMCksIHNpemVzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gYCR7KGJ5dGVzIC8gKDEwMDAgKiogaSkpLnRvRml4ZWQoaSA/IDEgOiAwKX0ke3NlcGFyYXRvcn0ke3NpemVzW2ldfSR7cG9zdEZpeH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbi9hJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHsgY2xzIH0gPSB0aGlzLFxuICAgICAgICAgICAgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8taW52YWxpZCcsICFpc1ZhbGlkKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHM7XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfVxuXG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAhbWUuZXJyb3IgJiYgICEobWUuc3RhdGUgPT09ICdyZWFkeScgJiYgbWUucmVxdWlyZWQpIHx8XG4gICAgICAgICAgICAgICAoICAgIChtZS5zdGF0ZSA9PT0gJ2Rvd25sb2FkYWJsZScpIHx8XG4gICAgICAgICAgICAgICAgICAgIChtZS5zdGF0ZSA9PT0gJ25vdC1kb3dubG9hZGFibGUnKVxuICAgICAgICAgICAgICAgKTtcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKEZpbGVVcGxvYWQpO1xuXG5leHBvcnQgZGVmYXVsdCBGaWxlVXBsb2FkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9