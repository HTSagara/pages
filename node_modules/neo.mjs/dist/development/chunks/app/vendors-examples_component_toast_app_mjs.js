"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_component_toast_app_mjs"],{

/***/ "./examples/component/toast/MainContainer.mjs":
/*!****************************************************!*\
  !*** ./examples/component/toast/MainContainer.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _src_component_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _src_form_Container_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./examples/component/toast/MainContainerController.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_form_field_Select_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../src/form/field/Select.mjs */ "./src/form/field/Select.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");










/**
 * @class Neo.examples.component.toast.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_8__["default"] {
    static config = {
        className : 'Neo.examples.component.toast.MainContainer',
        autoMount : true,
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
        layout: {ntype: 'hbox', align: 'stretch'},

        items: [{
            module   : _src_form_Container_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex     : 'none',
            layout   : {ntype: 'vbox'},
            style    : {margin: '20px'},
            reference: 'form',

            itemDefaults: {
                height        : 27,
                labelPosition : 'inline',
                listeners     : {change: 'onChange'},
                maxValue      : 4000,
                style         : {marginLeft: '10px'},
                useSpinButtons: false,
                width         : 200
            },

            items: [{
                module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
                labelText: 'msg',
                name     : 'msg',
                required : true,
                style    : {paddingBottom: '40px', marginLeft: '10px'}
            }, {
                module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
                labelText: 'title',
                name     : 'title'
            }, {
                module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
                labelText: 'iconCls',
                name     : 'iconCls'
            }, {
                module   : _src_form_field_Select_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                labelText: 'position = tr',
                name     : 'position',
                store    : {data: [{name: 'tl'}, {name: 'tc'}, {name: 'tr'}, {name: 'bl'}, {name: 'bc'}, {name: 'br'}]}
            }, {
                module   : _src_form_field_Select_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                labelText: 'slideDirection = right',
                name     : 'slideDirection',
                store    : {data: [{name: 'down'}, {name: 'up'}, {name: 'left'}, {name: 'right'}]}
            }, {
                module   : _src_form_field_Select_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                labelText: 'ui = info',
                name     : 'ui',
                store    : {data: [{name: 'info'}, {name: 'danger'}, {name: 'success'}]}
            }, {
                module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                labelText: 'minHeight = 50',
                name     : 'minHeight'
            }, {
                module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                labelText: 'maxWidth = 250',
                name     : 'maxWidth'
            }, {
                module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                labelText: 'timeout = 3000',
                name     : 'timeout',
                maxValue : 99999
            }, {
                module       : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                labelPosition: 'left',
                labelText    : 'Closable',
                labelWidth   : 70,
                name         : 'closable',
                reference    : 'closable',
                style        : {padding: '8px 0 10px 9px'}
            }, {
                module   : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                reference: 'creation-button',
                disabled : true,
                handler  : 'createToast',
                height   : 27,
                iconCls  : 'fa-solid fa-window-maximize',
                style    : {marginLeft: '10px'},
                text     : 'create toast'
            }]
        }, {
            module: _src_component_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            reference: 'output',
            cls: ['output'],
            vdom:
            {cn: [
                {tag: 'pre', cn: [
                    {tag: 'code', class: 'javascript'}
                ]}
            ]},

            itemTpl: data => {
                return [
                    {cls: 'import', innerHTML: 'import Toast from \'../../../../node_modules/neo.mjs/src/component/Toast.mjs\';'},
                    {innerHTML: 'Neo.toast({'},
                    {cls: 'tab', cn: [
                        {cls: 'grey', innerHTML: '/* mandatory */'},
                        {innerHTML: `appName: '${data.appName}',`},
                        {innerHTML: `msg: '${data.msg}',`},
                        {innerHTML: '/* optional */'},
                        {innerHTML: `title: '${data.title}',`, removeDom: !data.title},
                        {innerHTML: `iconCls: '${data.iconCls}',`, removeDom: !data.iconCls},
                        {innerHTML: `closable: ${data.closable},`, removeDom: !data.closable},
                        {innerHTML: `position: '${data.position}',`, removeDom: !data.position},
                        {innerHTML: `slideDirection: '${data.slideDirection}',`, removeDom: !data.slideDirection},
                        {innerHTML: `maxWidth: ${data.maxWidth},`, removeDom: !data.maxWidth},
                        {innerHTML: `minHeight: ${data.minHeight},`, removeDom: !data.minHeight},
                        {innerHTML: `ui: '${data.ui}'`, removeDom: !data.ui},
                    ]},
                    {innerHTML: '})'}
                ]
            }
        }]
    }
}

Neo.applyClassConfig(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./examples/component/toast/MainContainerController.mjs":
/*!**************************************************************!*\
  !*** ./examples/component/toast/MainContainerController.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _src_component_Toast_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/component/Toast.mjs */ "./src/component/Toast.mjs");



/**
 * @class Neo.examples.component.toast.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.examples.component.toast.MainContainerController'
         * @protected
         */
        className: 'Neo.examples.component.toast.MainContainerController'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        Neo.main.addon.HighlightJS.switchTheme('dark');
    }

    /**
     * Whenever any field changes we update the output
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onChange(data) {
        let me      = this,
            form    = me.getReference('form'),
            output  = me.getReference('output'),
            button  = me.getReference('creation-button'),
            oVdom   = output.vdom.cn[0].cn[0],
            isValid = form.isValid(),
            values;

        if (Neo.isBoolean(data.value)) {
            me.getReference('closable').value = data.value;
        }

        values = form.getValues();

        values.appName = me.component.appName;
        button.disabled = !isValid;

        if (form.validate()) {
            oVdom.cn = output.itemTpl(values);

            output.update();

            await Neo.timeout(20)
            me.syntaxHighlight();
        }
    }

    /**
     * Cleanup the values and show the toast
     */
    createToast() {
        let me     = this,
            form   = me.getReference('form'),
            values = form.getValues(),
            clear  = ['position', 'slideDirection', 'ui', 'minHeight', 'maxWidth', 'closable', 'timeout'];

        // use the defaults from toast if not set
        clear.forEach(item => {
            if (values[item] === null) {
                delete values[item];
            }
        })

        values.appName = me.component.appName;
        Neo.toast(values);
    }

    /**
     * 3rd party tool to highlight the code
     */
    syntaxHighlight() {
        let me     = this,
            output = me.getReference('output'),
            oVdom  = output.vdom;

        Neo.main.addon.HighlightJS.syntaxHighlight({
            appName: me.component.appName,
            vnodeId: oVdom.cn[0].id
        });
    }
}

Neo.applyClassConfig(MainContainerController);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainerController);


/***/ }),

/***/ "./examples/component/toast/app.mjs":
/*!******************************************!*\
  !*** ./examples/component/toast/app.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onStart": () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/toast/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.toast'
});



/***/ }),

/***/ "./src/component/Toast.mjs":
/*!*********************************!*\
  !*** ./src/component/Toast.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _manager_Toast_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Toast.mjs */ "./src/manager/Toast.mjs");




/**
 * @class Neo.component.Toast
 * @extends Neo.component.Base
 *
 * @example
        Neo.toast({
            // mandatory
            appName         : this.component.appName,
            msg             : 'Alarm was set to 11:30 for journey into Neo development',
            // optional                        defaults
            closable        : true,         // false
            iconCls         : 'fa fa-bell', // null
            maxWidth        : 300,          // 250
            position        : 'br',         // 'tr'
            slideDirection  : 'right',      // 'right'
            title           : 'Alarm Clock' // null
        })
 */
class Toast extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for positions
     * @member {String[]} positions = ['tl','tc','tr','bl','bc','br']
     * @protected
     * @static
     */
    static positions = ['tl', 'tc', 'tr', 'bl', 'bc', 'br']
    /**
     * True automatically applies the core/Observable.mjs mixin
     * @member {String[]} slideDirections = ['down','up','left','right']
     * @static
     */
    static slideDirections = ['down', 'up', 'left', 'right']

    static config = {
        /**
         * @member {String} className='Neo.component.Toast'
         * @protected
         */
        className: 'Neo.component.Toast',
        /**
         * @member {String} ntype='toast'
         * @protected
         */
        ntype: 'toast',
        /**
         * @member {String[]} baseCls=['neo-toast']
         * @protected
         */
        baseCls: ['neo-toast'],
        /**
         * If true makes the toast sticky and show a close icon
         * @member {Boolean} closable=false
         */
        closable_: false,
        /**
         * If set, it shows this icon in front of the text
         * e.g. 'fa fa-cog'
         * @member {String|null} iconCls=null
         */
        iconCls_: null,
        /**
         * Limits the width of the Toast
         * @member {Number} maxWidth=250
         */
        maxWidth: 250,
        /**
         * Sets the minimum height of the Toast
         * @member {Number} minHeight=50
         */
        minHeight: 50,
        /**
         * Your message. You can also pass in an iconCls
         * @member {String|null} msg_=null
         */
        msg_: null,
        /**
         * Describes the position of the toast, e.g. bl=bottom-left
         * This creates a cls `noe-toast-position`
         * @member {'tl'|'tc'|'tr'|'bl'|'bc'|'br'} position='tr'
         */
        position_: 'tr',
        /**
         * Describes which direction from which side the toasts slides-in
         * This creates a cls `neo-toast-slide-${direction}-in`
         * @member {'down'|'up'|'left'|'right'} slideDirection_='right'
         */
        slideDirection_: 'right',
        /**
         * Adds a title to the toast
         * @member {Number} title_=null
         */
        title_: null,
        /**
         * @member {String|null} title=null
         */
        vdom:
        {cn: [{
            cls: 'neo-toast-inner', cn: [
                {cls: ['neo-toast-icon'], removeDom: true},
                {cls: 'neo-toast-text', cn: [
                    {cls: ['neo-toast-title'], removeDom: true},
                    {cls: 'neo-toast-msg'}
                ]},
                {cls: ['neo-toast-close', 'fa', 'fa-close'], removeDom: true}
            ]
        }]}
    }

    /**
     * Used by the ToastManager
     * @member {Boolean} running=false
     * @private
     */
    running = false
    /**
     * Timeout in ms after which the toast is removed
     * @member {Number} timeout=3000
     */
    timeout = 3000

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // click listener for close
        me.addDomListeners([
            {click: {fn: me.destroy, delegate: '.neo-toast-close', scope: me}}
        ]);

        _manager_Toast_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].register(me);
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetClosable(value, oldValue) {
        let vdom = this.getVdomInner().cn[2];

        vdom.removeDom = !value;
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetIconCls(value, oldValue) {
        let vdom  = this.getVdomInner().cn[0],
            cls   = vdom.cls;

        vdom.removeDom = Neo.isEmpty(value);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value ? 'add' : 'remove'](cls, value);
    }

    /**
     * Using the afterSetMsg to trigger the setup of the dom
     * A new container is added as an item.
     * We cannot use the vdom here.
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetMsg(value, oldValue) {
        let vdom = this.getTextRootVdom().cn[1];

        vdom.innerHTML = value;
    }

    /**
     * Apply a cls, based on the position
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetPosition(value, oldValue) {
        value && this.addCls(`neo-toast-${value}`)
    }

    /**
     * Apply a cls, based on the slideDirection
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetSlideDirection(value, oldValue) {
        value && this.addCls(`neo-toast-slide-${value}-in`)
    }

    /**
     * Close the toast after the mounted if not closable
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (!me.closable && value) {
            setTimeout(() => {
                this.destroy(true);
            }, me.timeout)
        }
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetTitle(value, oldValue) {
        let vdom = this.getTextRootVdom().cn[0];

        vdom.removeDom = Neo.isEmpty(value);
        vdom.innerHTML = value;
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value ? 'add' : 'remove'](vdom.cls, 'neo-toast-has-title');
    }

    /**
     * Triggered before the position config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'position');
    }

    /**
     * Triggered before the slideDirection config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetSlideDirection(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'slideDirection');
    }

    /**
     *
     */
    async destroy(...args) {
        let me = this;

        me.addDomListeners({
            animationend: function () {
                _manager_Toast_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].removeToast(me.id);
                _manager_Toast_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(me);
                me.destroy(true);
            }
        });

        me.addCls('neo-toast-fade-out')
    }

    /**
     * This is a dialog, so we have to add an item to be able to
     * @returns {Object} vdom
     */
    getTextRootVdom() {
        return this.getVdomInner().cn[1];
    }

    /**
     * This is a dialog, so we have to add an item to be able to
     * @returns {Object} vdom
     */
    getVdomInner() {
        return this.vdom.cn[0];
    }
}

Neo.applyClassConfig(Toast);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Toast);


/***/ }),

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport']
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName: this.appName,
            cls    : ['neo-body-viewport']
        })
    }
}

Neo.applyClassConfig(Viewport);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Viewport);


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");





/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me        = this,
            component = me.component,
            listenerId;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed();
        } else {
            listenerId = component.on('constructed', () => {
                component.un('constructed', listenerId);
                me.onComponentConstructed();
            });
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value ? value : this.getParent();
    }

    /**
     * @param {String} handlerName
     * @returns {Neo.controller.Component|null}
     */
    getHandlerScope(handlerName) {
        let me     = this,
            parent = me.parent;

        return Neo.isFunction(me[handlerName]) ?
            me : parent ?
            parent.getHandlerScope(handlerName) : null;
    }

    /**
     * sameLevelOnly=false will return the closest VM inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getModel(sameLevelOnly=false) {
        let component = this.component;
        return sameLevelOnly ? component.model : component.getModel();
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me = this,
            parentComponent, parentId;

        if (me.parent) {
            return me.parent;
        }

        parentId        = me.component.parentId;
        parentComponent = parentId && Neo.getComponent(parentId);

        return parentComponent?.getController() || null;
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component;
            }
        }

        return component || null;
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me        = this,
            listeners = component.listeners,
            reference = component.reference,
            validator = component.validator,
            eventHandler, handlerScope;

        if (listeners) {
            Object.entries(listeners).forEach(([key, value]) => {
                if (key !== 'scope' && key !== 'delegate') {
                    if (Neo.isString(value)) {
                        eventHandler = value;
                        handlerScope = me.getHandlerScope(eventHandler);

                        if (!handlerScope) {
                            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown event handler for', eventHandler, component);
                        } else {
                            listeners[key] = {};
                            listeners[key].fn = handlerScope[eventHandler].bind(handlerScope);
                        }
                    } else {
                        value.forEach(listener => {
                            if (Neo.isObject(listener) && listener.hasOwnProperty('fn') && Neo.isString(listener.fn)) {
                                eventHandler = listener.fn;
                                handlerScope = me.getHandlerScope(eventHandler);

                                if (!handlerScope) {
                                    _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown event handler for', eventHandler, component);
                                } else {
                                    listener.fn = handlerScope[eventHandler].bind(handlerScope);
                                }
                            }
                        });
                    }
                }
            });
        }

        if (Neo.isString(validator)) {
            handlerScope = me.getHandlerScope(validator);

            if (!handlerScope) {
                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown validator for', component.id, component);
            } else {
                component.validator = handlerScope[validator].bind(handlerScope);
            }
        }

        if (reference) {
            me.references[reference] = component;
        }
    }

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseDomListeners(component=this.component) {
        let me           = this,
            domListeners = component.domListeners,
            eventHandler, scope;

        if (domListeners) {
            domListeners.forEach(domListener => {
                Object.entries(domListener).forEach(([key, value]) => {
                    eventHandler = null;

                    if (key !== 'scope' && key !== 'delegate') {
                        if (Neo.isString(value)) {
                            eventHandler = value;
                        } else if (Neo.isObject(value) && value.hasOwnProperty('fn') && Neo.isString(value.fn)) {
                            eventHandler = value.fn;
                        }

                        if (eventHandler) {
                            scope = me.getHandlerScope(eventHandler);

                            if (!scope) {
                                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown domEvent handler for', eventHandler, component);
                            } else {
                                domListener[key] = scope[eventHandler].bind(scope);
                            }
                        }
                    }
                });
            });
        }
    }

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me = this,
            references = me.references,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break;
            }
        }

        me.getParent()?.removeReference(component);
    }
}

Neo.applyClassConfig(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ }),

/***/ "./src/form/Container.mjs":
/*!********************************!*\
  !*** ./src/form/Container.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../form/field/Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");




/**
 * @class Neo.form.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.Container'
         * @protected
         */
        className: 'Neo.form.Container',
        /**
         * @member {String} ntype='form-container'
         * @protected
         */
        ntype: 'form-container',
        /**
         * @member {String[]} baseCls=['neo-form-container'],
         * @protected
         */
        baseCls: ['neo-form-container'],
        /**
         * @member {Object} vdom={tag: 'form',cn:[],onsubmit:'return false;'}
         */
        vdom:
        {tag: 'form', cn: [], onsubmit: 'return false;'}
    }

    /**
     * @param {Neo.container.Base} parent
     * @param {Object[]} modules
     * @returns {Object[]}
     */
    findNotLoadedModules(parent=this, modules=[]) {
        parent.items.forEach(item => {
            if (Neo.typeOf(item.module) === 'Function' && !item.isLoading) {
                modules.push({item, parent});
            } else {
                item.items && this.findNotLoadedModules(item, modules);
            }
        });

        return modules;
    }

    /**
     * Either pass a field name or id
     * @param {String} name
     * @returns {Promise<Neo.form.field.Base|null>} fields
     */
    async getField(name) {
        await this.loadModules();

        let fields = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(this),
            field;

        for (field of fields) {
            if (field instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
                if (field.name === name || field.id === name) {
                    return field;
                }
            }
        }

        return null;
    }

    /**
     * @param {Neo.form.field.Base} field
     * @returns {String}
     */
    getFieldPath(field) {
        let path = field.formGroup ? field.formGroup.split('.') : [];

        path.push(field.name || field.id);

        return path.join('.');
    }

    /**
     * @returns {Promise<Neo.form.field.Base[]>} fields
     */
    async getFields() {
        let fields = [];

        await this.loadModules();

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(this).forEach(item => {
            item instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] && fields.push(item);
        });

        return fields;
    }

    /**
     * @returns {Promise<Object>}
     */
    async getValues() {
        let fields = await this.getFields(),
            values = {},
            itemName, key, ns, nsArray, value;

        fields.forEach(item => {
            value = item.getValue();

            if (item.name) {
                itemName = item.name;

                if (item.formGroup) {
                    itemName = item.formGroup + '.' + itemName;
                }

                nsArray = itemName.split('.');
                key     = nsArray.pop();
                ns      = Neo.nsWithArrays(nsArray, true, values);
            } else {
                key = item.id;
                ns  = values;
            }

            /*
             * CheckBoxes need custom logic
             * => we only want to pass the uncheckedValue in case the field does not belong to a group
             * (multiple fields using the same name)
             */
            if (Object.hasOwn(ns, key) && value !== undefined) {
                if (ns[key] === item.uncheckedValue) {
                    ns[key] = []
                } else if (!Array.isArray(ns[key])) {
                    ns[key] = [ns[key]]
                }

                value !== item.uncheckedValue && ns[key].unshift(value)
            } else if (value !== undefined) {
                ns[key] = value
            }
        });

        return values;
    }

    /**
     * Returns true in case no form field isValid() call returns false
     * @returns {Promise<Boolean>}
     */
    async isValid() {
        let fields = await this.getFields(),
            i      = 0,
            len    = fields.length;

        for (; i < len; i++) {
            if (!fields[i].isValid()) {
                return false;
            }
        }

        return true;
    }

    /**
     * Loads all not loaded items inside card layouts
     * @returns {Promise<Neo.component.Base[]>}
     */
    async loadModules() {
        let me       = this,
            modules  = me.findNotLoadedModules(),
            promises = [];

        modules.forEach(module => {
            promises.push(module.parent.layout.loadModule(module.item));
        });

        modules = await Promise.all(promises);

        return modules;
    }

    /**
     * Resets field values by field name or field id.
     * Fields not included with a value will get reset to null.
     * @param {Object} [values]
     */
    async reset(values={}) {
        let me     = this,
            fields = await me.getFields(),
            path, value;

        fields.forEach(item => {
            path  = me.getFieldPath(item);
            value = Neo.nsWithArrays(path, false, values);

            item.reset(path ? value : null);
        })
    }

    /**
     * Set field values by field name or field id
     * @param {Object} values={}
     * @param {Boolean} suspendEvents=false
     */
    async setValues(values={}, suspendEvents=false) {
        let me     = this,
            fields = await me.getFields(),
            isCheckBox, isRadio, path, value;

        fields.forEach(item => {
            if (suspendEvents) {
                item.suspendEvents = true;
            }

            isCheckBox = Neo.form.field?.CheckBox && item instanceof Neo.form.field.CheckBox;
            path       = me.getFieldPath(item);
            value      = Neo.nsWithArrays(path, false, values);

            if (isCheckBox) {
                if (Neo.typeOf(value) === 'Array') {
                    if (value.includes(item.value)) {
                        item.checked = true
                    }
                } else {
                    item.checked = item.value === value
                }
            } else if (value !== undefined) {
                isRadio = Neo.form.field?.Radio && item instanceof Neo.form.field.Radio;

                if (isRadio) {
                    item.checked = item.value === value
                } else {
                    item.value = value
                }
            }

            if (suspendEvents) {
                delete item.suspendEvents;
            }
        })
    }

    /**
     * Updates the invalid state for all fields which have validate() implemented.
     * This can be useful for create-entity forms which show up "clean" until pressing a submit button.
     * @returns {Promise<Boolean>}
     */
    async validate() {
        let isValid = true,
            fields  = await this.getFields(),
            validField;

        fields.forEach(item => {
            validField = item.validate?.(false);

            if (!validField) {
                isValid = false;
            }
        });

        return isValid;
    }
}

Neo.applyClassConfig(Container);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Container);


/***/ }),

/***/ "./src/form/field/Base.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         */
        formGroup_: null,
        /**
         * @member {String|null} name_=null
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {
        if (oldValue !== undefined) {
            this.fireChangeEvent(value, oldValue)
        }
    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString;
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value;
        } else {
            delete me.getInputEl()[key];
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        let me            = this,
            FormContainer = Neo.form?.Container;

        me.fire('change', {
            component: me,
            oldValue,
            value
        });

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldChange', {
                        component: me,
                        oldValue,
                        value
                    })
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getValue() {
        return this.value;
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true;
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave?.(data);

        let me            = this,
            FormContainer = Neo.form?.Container;

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', {
                        ...data,
                        component: me
                    })
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.value = value;
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true;
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

Neo.applyClassConfig(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/manager/Toast.mjs":
/*!*******************************!*\
  !*** ./src/manager/Toast.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * See Neo.dialog.Toast for examples
 * @class Neo.manager.Toast
 * @extends Neo.manager.Base
 * @singleton
 */
class Toast extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Toast'
         * @protected
         */
        className: 'Neo.manager.Toast',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Using a default margin between the item
     * If you switch the distance to the top or bottom you have to change this value accordingly
     * @member {Number} defaultMargin=16
     */
    defaultMargin = 16
    /**
     * Currently only 1 is supported, because they would overlap
     * @member {Number} maxToasts=3
     */
    maxToasts = 3
    /**
     * Counts the currently running Toasts per area
     * @member {Object} running
     */
    running = {
        bc: [], bl: [], br: [],
        tc: [], tl: [], tr: []
    }
    /**
     * If you prefer your own class to open, override here
     * @member {String} toastClass='Neo.component.Toast'
     */
    toastClass = 'Neo.component.Toast'

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        Neo.toast = this.createToast.bind(this);
    }

    /**
     * Create the Toast definition and pass it to the Collection
     * @param {Object} toast
     * @returns {String|null}
     */
    createToast(toast) {
        let me = this;

        if (toast.position && !me.running[toast.position]) {
            Neo.logError('[Neo.manager.Toast] Supported values for slideDirection are: tl, tc, tr, bl, bc, br');
            return null;
        }

        if (!toast.msg || !toast.appName) {
            !toast.msg     && Neo.logError('[Neo.manager.Toast] Toast has to define a msg');
            !toast.appName && Neo.logError('[Neo.manager.Toast] Toast has to define an appName. Typically me.appName.');
            return null;
        }

        toast = Neo.create({
            className: this.toastClass,
            ...toast
        });

        toast.on({
            mounted: me.updateItemsInPosition,
            scope  : me
        })

        return toast.id;
    }

    /**
     * Find the first toast based on the maximum allowed toasts
     * @returns {*}
     * @private
     */
    findFirstToast() {
        let me = this,
            firstToast, item;

        me.filters = [{property: 'running', value: false}];

        for (item of me.map.values()) {
            if (me.running[item.position].length < me.maxToasts) {
                firstToast = item;
                firstToast.running = true;
                break;
            }
        }

        me.clearFilters();

        return firstToast;
    }

    /**
     * @param {Object} item
     */
    register(item) {
        super.register(item);
        this.runQueue();
    }

    /**
     * Removes a task from collection.
     * @param {String} toastId
     */
    removeToast(toastId) {
        let me    = this,
            toast = me.get(toastId),
            position;

        if (!toast) {
            return;
        }

        position = toast.position;

        // decrease total of displayed toasts for a position
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(me.running[position], toastId);

        me.updateItemsInPosition(toastId);
    }

    /**
     * Runs a ToastManager to show an item from collection.
     */
    runQueue() {
        let me = this,
            toast;

        if (me.getCount() > 0) {
            toast = me.findFirstToast();

            toast && me.showToast(toast)
        }
    }

    /**
     * @param {Neo.component.Toast} toast
     */
    showToast(toast) {
        toast.render(true);

        // increase total of displayed toasts for a position
        this.running[toast.position].unshift(toast.id);

        // todo: we could use a mounted listener
        setTimeout(() => {
            this.updateItemsInPosition(toast.id);
        }, 50);
    }

    /**
     * Removes a collection item passed by reference or key
     * @param {Object|String} item
     */
    unregister(item) {
        super.unregister(item);
        this.runQueue();
    }

    /**
     * To handle multiple toasts we handle the exact position
     * from the top or bottom
     * @param {String} id
     * @returns {Promise<void>}
     */
    async updateItemsInPosition(id) {
        let me            = this,
            toast         = me.get(id),
            position      = toast.position,
            positionArray = me.running[position],
            acc           = 0,
            margin        = me.defaultMargin,
            moveTo        = position.substring(0, 1) === 't' ? 'top' : 'bottom',
            component, componentId, index, moveObj, rects;

        rects = await toast.getDomRect(positionArray);

        for ([index, componentId] of positionArray.entries()) {
            component = Neo.getComponent(componentId);
            moveObj   = {};

            acc = acc + margin;
            moveObj[moveTo] = acc + 'px';
            component.style = moveObj;
            component.update();

            acc = acc + rects[index].height;
        }
    }
}

let instance = Neo.applyClassConfig(Toast);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90b2FzdF9hcHBfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUU7QUFDUTtBQUNMO0FBQ0E7QUFDRjtBQUNLO0FBQ0E7QUFDRjtBQUNHOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQXVCO0FBQzNDLGlCQUFpQixnQ0FBZ0M7O0FBRWpEO0FBQ0EsdUJBQXVCLCtEQUFhO0FBQ3BDO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEMsd0JBQXdCLGVBQWU7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSwyQkFBMkIsZ0VBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGFBQWE7QUFDYiwyQkFBMkIsZ0VBQVM7QUFDcEM7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQkFBMkIsZ0VBQVM7QUFDcEM7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQkFBMkIsa0VBQVc7QUFDdEM7QUFDQTtBQUNBLDRCQUE0QixRQUFRLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUNySCxhQUFhO0FBQ2IsMkJBQTJCLGtFQUFXO0FBQ3RDO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxhQUFhLEdBQUcsV0FBVyxHQUFHLGFBQWEsR0FBRyxjQUFjO0FBQ2hHLGFBQWE7QUFDYiwyQkFBMkIsa0VBQVc7QUFDdEM7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGFBQWEsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCO0FBQ3RGLGFBQWE7QUFDYiwyQkFBMkIsa0VBQVc7QUFDdEM7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQkFBMkIsa0VBQVc7QUFDdEM7QUFD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QTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0NBQWtDOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsOERBQWU7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxRQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY29tcG9uZW50L3RvYXN0L01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvdG9hc3QvTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvdG9hc3QvYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9Ub2FzdC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvVG9hc3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCdXR0b24gICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBDaGVja0JveCAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9DaGVja0JveC5tanMnO1xuaW1wb3J0IENvbXBvbmVudCAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IEZvcm1Db250YWluZXIgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJDb250cm9sbGVyIGZyb20gJy4vTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzJztcbmltcG9ydCBOdW1iZXJGaWVsZCAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9OdW1iZXIubWpzJztcbmltcG9ydCBTZWxlY3RGaWVsZCAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9TZWxlY3QubWpzJztcbmltcG9ydCBUZXh0RmllbGQgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5pbXBvcnQgVmlld3BvcnQgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY29tcG9uZW50LnRvYXN0Lk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIFZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWUgOiAnTmVvLmV4YW1wbGVzLmNvbXBvbmVudC50b2FzdC5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgYXV0b01vdW50IDogdHJ1ZSxcbiAgICAgICAgY29udHJvbGxlcjogTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIsXG4gICAgICAgIGxheW91dDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBGb3JtQ29udGFpbmVyLFxuICAgICAgICAgICAgZmxleCAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBsYXlvdXQgICA6IHtudHlwZTogJ3Zib3gnfSxcbiAgICAgICAgICAgIHN0eWxlICAgIDoge21hcmdpbjogJzIwcHgnfSxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ2Zvcm0nLFxuXG4gICAgICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgICAgICAgIDogMjcsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgOiB7Y2hhbmdlOiAnb25DaGFuZ2UnfSxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSAgICAgIDogNDAwMCxcbiAgICAgICAgICAgICAgICBzdHlsZSAgICAgICAgIDoge21hcmdpbkxlZnQ6ICcxMHB4J30sXG4gICAgICAgICAgICAgICAgdXNlU3BpbkJ1dHRvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICAgOiAyMDBcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJ21zZycsXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgOiAnbXNnJyxcbiAgICAgICAgICAgICAgICByZXF1aXJlZCA6IHRydWUsXG4gICAgICAgICAgICAgICAgc3R5bGUgICAgOiB7cGFkZGluZ0JvdHRvbTogJzQwcHgnLCBtYXJnaW5MZWZ0OiAnMTBweCd9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgOiBUZXh0RmllbGQsXG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0OiAndGl0bGUnLFxuICAgICAgICAgICAgICAgIG5hbWUgICAgIDogJ3RpdGxlJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJ2ljb25DbHMnLFxuICAgICAgICAgICAgICAgIG5hbWUgICAgIDogJ2ljb25DbHMnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgOiBTZWxlY3RGaWVsZCxcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQ6ICdwb3NpdGlvbiA9IHRyJyxcbiAgICAgICAgICAgICAgICBuYW1lICAgICA6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgc3RvcmUgICAgOiB7ZGF0YTogW3tuYW1lOiAndGwnfSwge25hbWU6ICd0Yyd9LCB7bmFtZTogJ3RyJ30sIHtuYW1lOiAnYmwnfSwge25hbWU6ICdiYyd9LCB7bmFtZTogJ2JyJ31dfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogU2VsZWN0RmllbGQsXG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0OiAnc2xpZGVEaXJlY3Rpb24gPSByaWdodCcsXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgOiAnc2xpZGVEaXJlY3Rpb24nLFxuICAgICAgICAgICAgICAgIHN0b3JlICAgIDoge2RhdGE6IFt7bmFtZTogJ2Rvd24nfSwge25hbWU6ICd1cCd9LCB7bmFtZTogJ2xlZnQnfSwge25hbWU6ICdyaWdodCd9XX1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICA6IFNlbGVjdEZpZWxkLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJ3VpID0gaW5mbycsXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgOiAndWknLFxuICAgICAgICAgICAgICAgIHN0b3JlICAgIDoge2RhdGE6IFt7bmFtZTogJ2luZm8nfSwge25hbWU6ICdkYW5nZXInfSwge25hbWU6ICdzdWNjZXNzJ31dfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogTnVtYmVyRmllbGQsXG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0OiAnbWluSGVpZ2h0ID0gNTAnLFxuICAgICAgICAgICAgICAgIG5hbWUgICAgIDogJ21pbkhlaWdodCdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICA6IE51bWJlckZpZWxkLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJ21heFdpZHRoID0gMjUwJyxcbiAgICAgICAgICAgICAgICBuYW1lICAgICA6ICdtYXhXaWR0aCdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICA6IE51bWJlckZpZWxkLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJ3RpbWVvdXQgPSAzMDAwJyxcbiAgICAgICAgICAgICAgICBuYW1lICAgICA6ICd0aW1lb3V0JyxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA6IDk5OTk5XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgIDogQ2hlY2tCb3gsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICA6ICdDbG9zYWJsZScsXG4gICAgICAgICAgICAgICAgbGFiZWxXaWR0aCAgIDogNzAsXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgICAgIDogJ2Nsb3NhYmxlJyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2UgICAgOiAnY2xvc2FibGUnLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgICAgICA6IHtwYWRkaW5nOiAnOHB4IDAgMTBweCA5cHgnfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogJ2NyZWF0aW9uLWJ1dHRvbicsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhhbmRsZXIgIDogJ2NyZWF0ZVRvYXN0JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgICA6IDI3LFxuICAgICAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhLXNvbGlkIGZhLXdpbmRvdy1tYXhpbWl6ZScsXG4gICAgICAgICAgICAgICAgc3R5bGUgICAgOiB7bWFyZ2luTGVmdDogJzEwcHgnfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgICA6ICdjcmVhdGUgdG9hc3QnXG4gICAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ291dHB1dCcsXG4gICAgICAgICAgICBjbHM6IFsnb3V0cHV0J10sXG4gICAgICAgICAgICB2ZG9tOlxuICAgICAgICAgICAge2NuOiBbXG4gICAgICAgICAgICAgICAge3RhZzogJ3ByZScsIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHt0YWc6ICdjb2RlJywgY2xhc3M6ICdqYXZhc2NyaXB0J31cbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgXX0sXG5cbiAgICAgICAgICAgIGl0ZW1UcGw6IGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6ICdpbXBvcnQnLCBpbm5lckhUTUw6ICdpbXBvcnQgVG9hc3QgZnJvbSBcXCcuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmVvLm1qcy9zcmMvY29tcG9uZW50L1RvYXN0Lm1qc1xcJzsnfSxcbiAgICAgICAgICAgICAgICAgICAge2lubmVySFRNTDogJ05lby50b2FzdCh7J30sXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6ICd0YWInLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogJ2dyZXknLCBpbm5lckhUTUw6ICcvKiBtYW5kYXRvcnkgKi8nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpbm5lckhUTUw6IGBhcHBOYW1lOiAnJHtkYXRhLmFwcE5hbWV9JyxgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpbm5lckhUTUw6IGBtc2c6ICcke2RhdGEubXNnfScsYH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7aW5uZXJIVE1MOiAnLyogb3B0aW9uYWwgKi8nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpbm5lckhUTUw6IGB0aXRsZTogJyR7ZGF0YS50aXRsZX0nLGAsIHJlbW92ZURvbTogIWRhdGEudGl0bGV9LFxuICAgICAgICAgICAgICAgICAgICAgICAge2lubmVySFRNTDogYGljb25DbHM6ICcke2RhdGEuaWNvbkNsc30nLGAsIHJlbW92ZURvbTogIWRhdGEuaWNvbkNsc30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7aW5uZXJIVE1MOiBgY2xvc2FibGU6ICR7ZGF0YS5jbG9zYWJsZX0sYCwgcmVtb3ZlRG9tOiAhZGF0YS5jbG9zYWJsZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7aW5uZXJIVE1MOiBgcG9zaXRpb246ICcke2RhdGEucG9zaXRpb259JyxgLCByZW1vdmVEb206ICFkYXRhLnBvc2l0aW9ufSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpbm5lckhUTUw6IGBzbGlkZURpcmVjdGlvbjogJyR7ZGF0YS5zbGlkZURpcmVjdGlvbn0nLGAsIHJlbW92ZURvbTogIWRhdGEuc2xpZGVEaXJlY3Rpb259LFxuICAgICAgICAgICAgICAgICAgICAgICAge2lubmVySFRNTDogYG1heFdpZHRoOiAke2RhdGEubWF4V2lkdGh9LGAsIHJlbW92ZURvbTogIWRhdGEubWF4V2lkdGh9LFxuICAgICAgICAgICAgICAgICAgICAgICAge2lubmVySFRNTDogYG1pbkhlaWdodDogJHtkYXRhLm1pbkhlaWdodH0sYCwgcmVtb3ZlRG9tOiAhZGF0YS5taW5IZWlnaHR9LFxuICAgICAgICAgICAgICAgICAgICAgICAge2lubmVySFRNTDogYHVpOiAnJHtkYXRhLnVpfSdgLCByZW1vdmVEb206ICFkYXRhLnVpfSxcbiAgICAgICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAgICAgIHtpbm5lckhUTUw6ICd9KSd9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoTWFpbkNvbnRhaW5lcik7XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5Db250YWluZXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29udHJvbGxlciBmcm9tICcuLi8uLi8uLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBUb2FzdCAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvVG9hc3QubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmV4YW1wbGVzLmNvbXBvbmVudC50b2FzdC5NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXJDb250cm9sbGVyIGV4dGVuZHMgQ29tcG9uZW50Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZXhhbXBsZXMuY29tcG9uZW50LnRvYXN0Lk1haW5Db250YWluZXJDb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZXhhbXBsZXMuY29tcG9uZW50LnRvYXN0Lk1haW5Db250YWluZXJDb250cm9sbGVyJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICBOZW8ubWFpbi5hZGRvbi5IaWdobGlnaHRKUy5zd2l0Y2hUaGVtZSgnZGFyaycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW5ldmVyIGFueSBmaWVsZCBjaGFuZ2VzIHdlIHVwZGF0ZSB0aGUgb3V0cHV0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZvcm0gICAgPSBtZS5nZXRSZWZlcmVuY2UoJ2Zvcm0nKSxcbiAgICAgICAgICAgIG91dHB1dCAgPSBtZS5nZXRSZWZlcmVuY2UoJ291dHB1dCcpLFxuICAgICAgICAgICAgYnV0dG9uICA9IG1lLmdldFJlZmVyZW5jZSgnY3JlYXRpb24tYnV0dG9uJyksXG4gICAgICAgICAgICBvVmRvbSAgID0gb3V0cHV0LnZkb20uY25bMF0uY25bMF0sXG4gICAgICAgICAgICBpc1ZhbGlkID0gZm9ybS5pc1ZhbGlkKCksXG4gICAgICAgICAgICB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKE5lby5pc0Jvb2xlYW4oZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgIG1lLmdldFJlZmVyZW5jZSgnY2xvc2FibGUnKS52YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMgPSBmb3JtLmdldFZhbHVlcygpO1xuXG4gICAgICAgIHZhbHVlcy5hcHBOYW1lID0gbWUuY29tcG9uZW50LmFwcE5hbWU7XG4gICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9ICFpc1ZhbGlkO1xuXG4gICAgICAgIGlmIChmb3JtLnZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgIG9WZG9tLmNuID0gb3V0cHV0Lml0ZW1UcGwodmFsdWVzKTtcblxuICAgICAgICAgICAgb3V0cHV0LnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBhd2FpdCBOZW8udGltZW91dCgyMClcbiAgICAgICAgICAgIG1lLnN5bnRheEhpZ2hsaWdodCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW51cCB0aGUgdmFsdWVzIGFuZCBzaG93IHRoZSB0b2FzdFxuICAgICAqL1xuICAgIGNyZWF0ZVRvYXN0KCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZvcm0gICA9IG1lLmdldFJlZmVyZW5jZSgnZm9ybScpLFxuICAgICAgICAgICAgdmFsdWVzID0gZm9ybS5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIGNsZWFyICA9IFsncG9zaXRpb24nLCAnc2xpZGVEaXJlY3Rpb24nLCAndWknLCAnbWluSGVpZ2h0JywgJ21heFdpZHRoJywgJ2Nsb3NhYmxlJywgJ3RpbWVvdXQnXTtcblxuICAgICAgICAvLyB1c2UgdGhlIGRlZmF1bHRzIGZyb20gdG9hc3QgaWYgbm90IHNldFxuICAgICAgICBjbGVhci5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpdGVtXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNbaXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdmFsdWVzLmFwcE5hbWUgPSBtZS5jb21wb25lbnQuYXBwTmFtZTtcbiAgICAgICAgTmVvLnRvYXN0KHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogM3JkIHBhcnR5IHRvb2wgdG8gaGlnaGxpZ2h0IHRoZSBjb2RlXG4gICAgICovXG4gICAgc3ludGF4SGlnaGxpZ2h0KCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG91dHB1dCA9IG1lLmdldFJlZmVyZW5jZSgnb3V0cHV0JyksXG4gICAgICAgICAgICBvVmRvbSAgPSBvdXRwdXQudmRvbTtcblxuICAgICAgICBOZW8ubWFpbi5hZGRvbi5IaWdobGlnaHRKUy5zeW50YXhIaWdobGlnaHQoe1xuICAgICAgICAgICAgYXBwTmFtZTogbWUuY29tcG9uZW50LmFwcE5hbWUsXG4gICAgICAgICAgICB2bm9kZUlkOiBvVmRvbS5jblswXS5pZFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKE1haW5Db250YWluZXJDb250cm9sbGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXI7XG4iLCJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL01haW5Db250YWluZXIubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogTWFpbkNvbnRhaW5lcixcbiAgICBuYW1lICAgIDogJ05lby5leGFtcGxlcy5jb21wb25lbnQudG9hc3QnXG59KTtcblxuIiwiaW1wb3J0IEJhc2UgICAgICAgICBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICBmcm9tIFwiLi4vdXRpbC9BcnJheS5tanNcIjtcbmltcG9ydCBUb2FzdE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Ub2FzdC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LlRvYXN0XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqXG4gKiBAZXhhbXBsZVxuICAgICAgICBOZW8udG9hc3Qoe1xuICAgICAgICAgICAgLy8gbWFuZGF0b3J5XG4gICAgICAgICAgICBhcHBOYW1lICAgICAgICAgOiB0aGlzLmNvbXBvbmVudC5hcHBOYW1lLFxuICAgICAgICAgICAgbXNnICAgICAgICAgICAgIDogJ0FsYXJtIHdhcyBzZXQgdG8gMTE6MzAgZm9yIGpvdXJuZXkgaW50byBOZW8gZGV2ZWxvcG1lbnQnLFxuICAgICAgICAgICAgLy8gb3B0aW9uYWwgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0c1xuICAgICAgICAgICAgY2xvc2FibGUgICAgICAgIDogdHJ1ZSwgICAgICAgICAvLyBmYWxzZVxuICAgICAgICAgICAgaWNvbkNscyAgICAgICAgIDogJ2ZhIGZhLWJlbGwnLCAvLyBudWxsXG4gICAgICAgICAgICBtYXhXaWR0aCAgICAgICAgOiAzMDAsICAgICAgICAgIC8vIDI1MFxuICAgICAgICAgICAgcG9zaXRpb24gICAgICAgIDogJ2JyJywgICAgICAgICAvLyAndHInXG4gICAgICAgICAgICBzbGlkZURpcmVjdGlvbiAgOiAncmlnaHQnLCAgICAgIC8vICdyaWdodCdcbiAgICAgICAgICAgIHRpdGxlICAgICAgICAgICA6ICdBbGFybSBDbG9jaycgLy8gbnVsbFxuICAgICAgICB9KVxuICovXG5jbGFzcyBUb2FzdCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgcG9zaXRpb25zXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHBvc2l0aW9ucyA9IFsndGwnLCd0YycsJ3RyJywnYmwnLCdiYycsJ2JyJ11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBwb3NpdGlvbnMgPSBbJ3RsJywgJ3RjJywgJ3RyJywgJ2JsJywgJ2JjJywgJ2JyJ11cbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS9PYnNlcnZhYmxlLm1qcyBtaXhpblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBzbGlkZURpcmVjdGlvbnMgPSBbJ2Rvd24nLCd1cCcsJ2xlZnQnLCdyaWdodCddXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBzbGlkZURpcmVjdGlvbnMgPSBbJ2Rvd24nLCAndXAnLCAnbGVmdCcsICdyaWdodCddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuVG9hc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuVG9hc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9hc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndG9hc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9hc3QnXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b2FzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSBtYWtlcyB0aGUgdG9hc3Qgc3RpY2t5IGFuZCBzaG93IGEgY2xvc2UgaWNvblxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjbG9zYWJsZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2FibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCwgaXQgc2hvd3MgdGhpcyBpY29uIGluIGZyb250IG9mIHRoZSB0ZXh0XG4gICAgICAgICAqIGUuZy4gJ2ZhIGZhLWNvZydcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGljb25DbHM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaW1pdHMgdGhlIHdpZHRoIG9mIHRoZSBUb2FzdFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heFdpZHRoPTI1MFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4V2lkdGg6IDI1MCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSBUb2FzdFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbkhlaWdodD01MFxuICAgICAgICAgKi9cbiAgICAgICAgbWluSGVpZ2h0OiA1MCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdXIgbWVzc2FnZS4gWW91IGNhbiBhbHNvIHBhc3MgaW4gYW4gaWNvbkNsc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gbXNnXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtc2dfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzY3JpYmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9hc3QsIGUuZy4gYmw9Ym90dG9tLWxlZnRcbiAgICAgICAgICogVGhpcyBjcmVhdGVzIGEgY2xzIGBub2UtdG9hc3QtcG9zaXRpb25gXG4gICAgICAgICAqIEBtZW1iZXIgeyd0bCd8J3RjJ3wndHInfCdibCd8J2JjJ3wnYnInfSBwb3NpdGlvbj0ndHInXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbl86ICd0cicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXNjcmliZXMgd2hpY2ggZGlyZWN0aW9uIGZyb20gd2hpY2ggc2lkZSB0aGUgdG9hc3RzIHNsaWRlcy1pblxuICAgICAgICAgKiBUaGlzIGNyZWF0ZXMgYSBjbHMgYG5lby10b2FzdC1zbGlkZS0ke2RpcmVjdGlvbn0taW5gXG4gICAgICAgICAqIEBtZW1iZXIgeydkb3duJ3wndXAnfCdsZWZ0J3wncmlnaHQnfSBzbGlkZURpcmVjdGlvbl89J3JpZ2h0J1xuICAgICAgICAgKi9cbiAgICAgICAgc2xpZGVEaXJlY3Rpb25fOiAncmlnaHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIHRpdGxlIHRvIHRoZSB0b2FzdFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRpdGxlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdGl0bGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbTpcbiAgICAgICAge2NuOiBbe1xuICAgICAgICAgICAgY2xzOiAnbmVvLXRvYXN0LWlubmVyJywgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby10b2FzdC1pY29uJ10sIHJlbW92ZURvbTogdHJ1ZX0sXG4gICAgICAgICAgICAgICAge2NsczogJ25lby10b2FzdC10ZXh0JywgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tdG9hc3QtdGl0bGUnXSwgcmVtb3ZlRG9tOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAge2NsczogJ25lby10b2FzdC1tc2cnfVxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLXRvYXN0LWNsb3NlJywgJ2ZhJywgJ2ZhLWNsb3NlJ10sIHJlbW92ZURvbTogdHJ1ZX1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfV19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0aGUgVG9hc3RNYW5hZ2VyXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcnVubmluZz1mYWxzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVubmluZyA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogVGltZW91dCBpbiBtcyBhZnRlciB3aGljaCB0aGUgdG9hc3QgaXMgcmVtb3ZlZFxuICAgICAqIEBtZW1iZXIge051bWJlcn0gdGltZW91dD0zMDAwXG4gICAgICovXG4gICAgdGltZW91dCA9IDMwMDBcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gY2xpY2sgbGlzdGVuZXIgZm9yIGNsb3NlXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7Y2xpY2s6IHtmbjogbWUuZGVzdHJveSwgZGVsZWdhdGU6ICcubmVvLXRvYXN0LWNsb3NlJywgc2NvcGU6IG1lfX1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgVG9hc3RNYW5hZ2VyLnJlZ2lzdGVyKG1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDbG9zYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHZkb20gPSB0aGlzLmdldFZkb21Jbm5lcigpLmNuWzJdO1xuXG4gICAgICAgIHZkb20ucmVtb3ZlRG9tID0gIXZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldEljb25DbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCB2ZG9tICA9IHRoaXMuZ2V0VmRvbUlubmVyKCkuY25bMF0sXG4gICAgICAgICAgICBjbHMgICA9IHZkb20uY2xzO1xuXG4gICAgICAgIHZkb20ucmVtb3ZlRG9tID0gTmVvLmlzRW1wdHkodmFsdWUpO1xuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzaW5nIHRoZSBhZnRlclNldE1zZyB0byB0cmlnZ2VyIHRoZSBzZXR1cCBvZiB0aGUgZG9tXG4gICAgICogQSBuZXcgY29udGFpbmVyIGlzIGFkZGVkIGFzIGFuIGl0ZW0uXG4gICAgICogV2UgY2Fubm90IHVzZSB0aGUgdmRvbSBoZXJlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE1zZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHZkb20gPSB0aGlzLmdldFRleHRSb290VmRvbSgpLmNuWzFdO1xuXG4gICAgICAgIHZkb20uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBjbHMsIGJhc2VkIG9uIHRoZSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0UG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuYWRkQ2xzKGBuZW8tdG9hc3QtJHt2YWx1ZX1gKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgY2xzLCBiYXNlZCBvbiB0aGUgc2xpZGVEaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFNsaWRlRGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLmFkZENscyhgbmVvLXRvYXN0LXNsaWRlLSR7dmFsdWV9LWluYClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgdG9hc3QgYWZ0ZXIgdGhlIG1vdW50ZWQgaWYgbm90IGNsb3NhYmxlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jbG9zYWJsZSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KHRydWUpO1xuICAgICAgICAgICAgfSwgbWUudGltZW91dClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFRpdGxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgdmRvbSA9IHRoaXMuZ2V0VGV4dFJvb3RWZG9tKCkuY25bMF07XG5cbiAgICAgICAgdmRvbS5yZW1vdmVEb20gPSBOZW8uaXNFbXB0eSh2YWx1ZSk7XG4gICAgICAgIHZkb20uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10odmRvbS5jbHMsICduZW8tdG9hc3QtaGFzLXRpdGxlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcG9zaXRpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3Bvc2l0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2xpZGVEaXJlY3Rpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTbGlkZURpcmVjdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3NsaWRlRGlyZWN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgYW5pbWF0aW9uZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgVG9hc3RNYW5hZ2VyLnJlbW92ZVRvYXN0KG1lLmlkKTtcbiAgICAgICAgICAgICAgICBUb2FzdE1hbmFnZXIudW5yZWdpc3RlcihtZSk7XG4gICAgICAgICAgICAgICAgbWUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuYWRkQ2xzKCduZW8tdG9hc3QtZmFkZS1vdXQnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBkaWFsb2csIHNvIHdlIGhhdmUgdG8gYWRkIGFuIGl0ZW0gdG8gYmUgYWJsZSB0b1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBnZXRUZXh0Um9vdFZkb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZkb21Jbm5lcigpLmNuWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBkaWFsb2csIHNvIHdlIGhhdmUgdG8gYWRkIGFuIGl0ZW0gdG8gYmUgYWJsZSB0b1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBnZXRWZG9tSW5uZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF07XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhUb2FzdCk7XG5cbmV4cG9ydCBkZWZhdWx0IFRvYXN0O1xuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzICduZW8tYm9keS12aWV3cG9ydCcgdG8gdGhlIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXBwbHlCb2R5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc3VtaW5nIHRoYXQgYSBWaWV3cG9ydCBpcyB0aGUgdG9wIGxldmVsIHZpZXcgb2YgeW91ciBhcHAsIGFuZCB5b3Ugd2FudCB0byBtb3VudCBpdCByaWdodCBhd2F5LlxuICAgICAgICAgKiBDb3VsZCBiZSB3aXRob3V0IGFueSBpdGVtcy4gVXNlIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXZpZXdwb3J0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXZpZXdwb3J0J11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICB0aGlzLmFwcGx5Qm9keUNscyAmJiBOZW8ubWFpbi5Eb21BY2Nlc3MuYXBwbHlCb2R5Q2xzKHtcbiAgICAgICAgICAgIGFwcE5hbWU6IHRoaXMuYXBwTmFtZSxcbiAgICAgICAgICAgIGNscyAgICA6IFsnbmVvLWJvZHktdmlld3BvcnQnXVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoVmlld3BvcnQpO1xuXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydDtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBEb21FdmVudE1hbmFnZXIgIGZyb20gJy4uL21hbmFnZXIvRG9tRXZlbnQubWpzJztcbmltcG9ydCBMb2dnZXIgICAgICAgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1jb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1jb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZWZlcmVuY2VzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlczogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LFxuICAgICAgICAgICAgbGlzdGVuZXJJZDtcblxuICAgICAgICBtZS5yZWZlcmVuY2VzID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lcklkID0gY29tcG9uZW50Lm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudW4oJ2NvbnN0cnVjdGVkJywgbGlzdGVuZXJJZCk7XG4gICAgICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwYXJlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGFyZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSA6IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudCA9IG1lLnBhcmVudDtcblxuICAgICAgICByZXR1cm4gTmVvLmlzRnVuY3Rpb24obWVbaGFuZGxlck5hbWVdKSA/XG4gICAgICAgICAgICBtZSA6IHBhcmVudCA/XG4gICAgICAgICAgICBwYXJlbnQuZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2FtZUxldmVsT25seT1mYWxzZSB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBWTSBpbnNpZGUgdGhlIGNvbXBvbmVudCBwYXJlbnQgdHJlZSxcbiAgICAgKiBpbiBjYXNlIHRoZXJlIGlzIG5vbmUgb24gdGhlIHNhbWUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2FtZUxldmVsT25seT1mYWxzZV1cbiAgICAgKi9cbiAgICBnZXRNb2RlbChzYW1lTGV2ZWxPbmx5PWZhbHNlKSB7XG4gICAgICAgIGxldCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIHNhbWVMZXZlbE9ubHkgPyBjb21wb25lbnQubW9kZWwgOiBjb21wb25lbnQuZ2V0TW9kZWwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsb3Nlc3QgY29udHJvbGxlciBpbnNpZGUgdGhlIGNvbXBvbmVudHMgcGFyZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRJZDtcblxuICAgICAgICBpZiAobWUucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50SWQgICAgICAgID0gbWUuY29tcG9uZW50LnBhcmVudElkO1xuICAgICAgICBwYXJlbnRDb21wb25lbnQgPSBwYXJlbnRJZCAmJiBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkKTtcblxuICAgICAgICByZXR1cm4gcGFyZW50Q29tcG9uZW50Py5nZXRDb250cm9sbGVyKCkgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiB1cGRhdGUgY2hhbmdlZCByZWZlcmVuY2VzIChlLmcuIGNvbnRhaW5lci5yZW1vdmUoKSB0aGVuIGNvbnRhaW5lci5hZGQoKSB1c2luZyB0aGUgc2FtZSBrZXkpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSZWZlcmVuY2UobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLnJlZmVyZW5jZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLmNvbXBvbmVudC5kb3duKHtyZWZlcmVuY2U6IG5hbWV9KTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIG1lLnJlZmVyZW5jZXNbbmFtZV0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50IHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW5zaWRlIHlvdXIgdmlldyBjb250cm9sbGVycyBhcyBhIHN0YXJ0aW5nIHBvaW50IGluIGNhc2UgeW91IG5lZWQgcmVmZXJlbmNlc1xuICAgICAqIChpbnN0ZWFkIG9mIHVzaW5nIG9uQ29uc3RydWN0ZWQoKSBpbnNpZGUgeW91ciBjb250cm9sbGVyKVxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudD10aGlzLmNvbXBvbmVudFxuICAgICAqL1xuICAgIHBhcnNlQ29uZmlnKGNvbXBvbmVudD10aGlzLmNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IGNvbXBvbmVudC5saXN0ZW5lcnMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBjb21wb25lbnQucmVmZXJlbmNlLFxuICAgICAgICAgICAgdmFsaWRhdG9yID0gY29tcG9uZW50LnZhbGlkYXRvcixcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgaGFuZGxlclNjb3BlO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxpc3RlbmVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3Njb3BlJyAmJiBrZXkgIT09ICdkZWxlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgZm9yJywgZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1trZXldLmZuID0gaGFuZGxlclNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChoYW5kbGVyU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdChsaXN0ZW5lcikgJiYgbGlzdGVuZXIuaGFzT3duUHJvcGVydHkoJ2ZuJykgJiYgTmVvLmlzU3RyaW5nKGxpc3RlbmVyLmZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSBsaXN0ZW5lci5mbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIGZvcicsIGV2ZW50SGFuZGxlciwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmZuID0gaGFuZGxlclNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChoYW5kbGVyU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsaWRhdG9yKSkge1xuICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKHZhbGlkYXRvcik7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9yKCdVbmtub3duIHZhbGlkYXRvciBmb3InLCBjb21wb25lbnQuaWQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC52YWxpZGF0b3IgPSBoYW5kbGVyU2NvcGVbdmFsaWRhdG9yXS5iaW5kKGhhbmRsZXJTY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBtZS5yZWZlcmVuY2VzW3JlZmVyZW5jZV0gPSBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50PXRoaXMuY29tcG9uZW50XG4gICAgICovXG4gICAgcGFyc2VEb21MaXN0ZW5lcnMoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gY29tcG9uZW50LmRvbUxpc3RlbmVycyxcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgc2NvcGU7XG5cbiAgICAgICAgaWYgKGRvbUxpc3RlbmVycykge1xuICAgICAgICAgICAgZG9tTGlzdGVuZXJzLmZvckVhY2goZG9tTGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRvbUxpc3RlbmVyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnc2NvcGUnICYmIGtleSAhPT0gJ2RlbGVnYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZm4nKSAmJiBOZW8uaXNTdHJpbmcodmFsdWUuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gdmFsdWUuZm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShldmVudEhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ1Vua25vd24gZG9tRXZlbnQgaGFuZGxlciBmb3InLCBldmVudEhhbmRsZXIsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTGlzdGVuZXJba2V5XSA9IHNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgZ2V0IGNhbGxlZCBieSBjb21wb25lbnQuQmFzZTogZGVzdHJveSgpIGluIGNhc2UgdGhlIGNvbXBvbmVudCBoYXMgYSByZWZlcmVuY2UgY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZXMgPSBtZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT09IHJlZmVyZW5jZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZWZlcmVuY2VzW2tleV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRQYXJlbnQoKT8ucmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudCk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4iLCJpbXBvcnQgQmFzZUNvbnRhaW5lciAgICBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IEJhc2VGaWVsZCAgICAgICAgZnJvbSAnLi4vZm9ybS9maWVsZC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Zvcm0tY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Zvcm0tY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWZvcm0tY29udGFpbmVyJ10sXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWZvcm0tY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209e3RhZzogJ2Zvcm0nLGNuOltdLG9uc3VibWl0OidyZXR1cm4gZmFsc2U7J31cbiAgICAgICAgICovXG4gICAgICAgIHZkb206XG4gICAgICAgIHt0YWc6ICdmb3JtJywgY246IFtdLCBvbnN1Ym1pdDogJ3JldHVybiBmYWxzZTsnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRhaW5lci5CYXNlfSBwYXJlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBtb2R1bGVzXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGZpbmROb3RMb2FkZWRNb2R1bGVzKHBhcmVudD10aGlzLCBtb2R1bGVzPVtdKSB7XG4gICAgICAgIHBhcmVudC5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoaXRlbS5tb2R1bGUpID09PSAnRnVuY3Rpb24nICYmICFpdGVtLmlzTG9hZGluZykge1xuICAgICAgICAgICAgICAgIG1vZHVsZXMucHVzaCh7aXRlbSwgcGFyZW50fSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uaXRlbXMgJiYgdGhpcy5maW5kTm90TG9hZGVkTW9kdWxlcyhpdGVtLCBtb2R1bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1vZHVsZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWl0aGVyIHBhc3MgYSBmaWVsZCBuYW1lIG9yIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8uZm9ybS5maWVsZC5CYXNlfG51bGw+fSBmaWVsZHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGaWVsZChuYW1lKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1vZHVsZXMoKTtcblxuICAgICAgICBsZXQgZmllbGRzID0gQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZENvbXBvbmVudHModGhpcyksXG4gICAgICAgICAgICBmaWVsZDtcblxuICAgICAgICBmb3IgKGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQmFzZUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IG5hbWUgfHwgZmllbGQuaWQgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmZvcm0uZmllbGQuQmFzZX0gZmllbGRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEZpZWxkUGF0aChmaWVsZCkge1xuICAgICAgICBsZXQgcGF0aCA9IGZpZWxkLmZvcm1Hcm91cCA/IGZpZWxkLmZvcm1Hcm91cC5zcGxpdCgnLicpIDogW107XG5cbiAgICAgICAgcGF0aC5wdXNoKGZpZWxkLm5hbWUgfHwgZmllbGQuaWQpO1xuXG4gICAgICAgIHJldHVybiBwYXRoLmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8uZm9ybS5maWVsZC5CYXNlW10+fSBmaWVsZHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGaWVsZHMoKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcblxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb2R1bGVzKCk7XG5cbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZENvbXBvbmVudHModGhpcykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0gaW5zdGFuY2VvZiBCYXNlRmllbGQgJiYgZmllbGRzLnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRWYWx1ZXMoKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBhd2FpdCB0aGlzLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgdmFsdWVzID0ge30sXG4gICAgICAgICAgICBpdGVtTmFtZSwga2V5LCBucywgbnNBcnJheSwgdmFsdWU7XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZW0uZ2V0VmFsdWUoKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSkge1xuICAgICAgICAgICAgICAgIGl0ZW1OYW1lID0gaXRlbS5uYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZm9ybUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1OYW1lID0gaXRlbS5mb3JtR3JvdXAgKyAnLicgKyBpdGVtTmFtZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuc0FycmF5ID0gaXRlbU5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBrZXkgICAgID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgICAgICBucyAgICAgID0gTmVvLm5zV2l0aEFycmF5cyhuc0FycmF5LCB0cnVlLCB2YWx1ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBpdGVtLmlkO1xuICAgICAgICAgICAgICAgIG5zICA9IHZhbHVlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIENoZWNrQm94ZXMgbmVlZCBjdXN0b20gbG9naWNcbiAgICAgICAgICAgICAqID0+IHdlIG9ubHkgd2FudCB0byBwYXNzIHRoZSB1bmNoZWNrZWRWYWx1ZSBpbiBjYXNlIHRoZSBmaWVsZCBkb2VzIG5vdCBiZWxvbmcgdG8gYSBncm91cFxuICAgICAgICAgICAgICogKG11bHRpcGxlIGZpZWxkcyB1c2luZyB0aGUgc2FtZSBuYW1lKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihucywga2V5KSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5zW2tleV0gPT09IGl0ZW0udW5jaGVja2VkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbnNba2V5XSA9IFtdXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShuc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBuc1trZXldID0gW25zW2tleV1dXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgIT09IGl0ZW0udW5jaGVja2VkVmFsdWUgJiYgbnNba2V5XS51bnNoaWZ0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbnNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGluIGNhc2Ugbm8gZm9ybSBmaWVsZCBpc1ZhbGlkKCkgY2FsbCByZXR1cm5zIGZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgaXNWYWxpZCgpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgID0gZmllbGRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkc1tpXS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgbm90IGxvYWRlZCBpdGVtcyBpbnNpZGUgY2FyZCBsYXlvdXRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLmNvbXBvbmVudC5CYXNlW10+fVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWRNb2R1bGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbW9kdWxlcyAgPSBtZS5maW5kTm90TG9hZGVkTW9kdWxlcygpLFxuICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBtb2R1bGVzLmZvckVhY2gobW9kdWxlID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gobW9kdWxlLnBhcmVudC5sYXlvdXQubG9hZE1vZHVsZShtb2R1bGUuaXRlbSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtb2R1bGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAgIHJldHVybiBtb2R1bGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBmaWVsZCB2YWx1ZXMgYnkgZmllbGQgbmFtZSBvciBmaWVsZCBpZC5cbiAgICAgKiBGaWVsZHMgbm90IGluY2x1ZGVkIHdpdGggYSB2YWx1ZSB3aWxsIGdldCByZXNldCB0byBudWxsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVzXVxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0KHZhbHVlcz17fSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpZWxkcyA9IGF3YWl0IG1lLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgcGF0aCwgdmFsdWU7XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBwYXRoICA9IG1lLmdldEZpZWxkUGF0aChpdGVtKTtcbiAgICAgICAgICAgIHZhbHVlID0gTmVvLm5zV2l0aEFycmF5cyhwYXRoLCBmYWxzZSwgdmFsdWVzKTtcblxuICAgICAgICAgICAgaXRlbS5yZXNldChwYXRoID8gdmFsdWUgOiBudWxsKTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZmllbGQgdmFsdWVzIGJ5IGZpZWxkIG5hbWUgb3IgZmllbGQgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXNwZW5kRXZlbnRzPWZhbHNlXG4gICAgICovXG4gICAgYXN5bmMgc2V0VmFsdWVzKHZhbHVlcz17fSwgc3VzcGVuZEV2ZW50cz1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpZWxkcyA9IGF3YWl0IG1lLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgaXNDaGVja0JveCwgaXNSYWRpbywgcGF0aCwgdmFsdWU7XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgIGl0ZW0uc3VzcGVuZEV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzQ2hlY2tCb3ggPSBOZW8uZm9ybS5maWVsZD8uQ2hlY2tCb3ggJiYgaXRlbSBpbnN0YW5jZW9mIE5lby5mb3JtLmZpZWxkLkNoZWNrQm94O1xuICAgICAgICAgICAgcGF0aCAgICAgICA9IG1lLmdldEZpZWxkUGF0aChpdGVtKTtcbiAgICAgICAgICAgIHZhbHVlICAgICAgPSBOZW8ubnNXaXRoQXJyYXlzKHBhdGgsIGZhbHNlLCB2YWx1ZXMpO1xuXG4gICAgICAgICAgICBpZiAoaXNDaGVja0JveCkge1xuICAgICAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKHZhbHVlKSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoaXRlbS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hlY2tlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hlY2tlZCA9IGl0ZW0udmFsdWUgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXNSYWRpbyA9IE5lby5mb3JtLmZpZWxkPy5SYWRpbyAmJiBpdGVtIGluc3RhbmNlb2YgTmVvLmZvcm0uZmllbGQuUmFkaW87XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNSYWRpbykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNoZWNrZWQgPSBpdGVtLnZhbHVlID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5zdXNwZW5kRXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludmFsaWQgc3RhdGUgZm9yIGFsbCBmaWVsZHMgd2hpY2ggaGF2ZSB2YWxpZGF0ZSgpIGltcGxlbWVudGVkLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgY3JlYXRlLWVudGl0eSBmb3JtcyB3aGljaCBzaG93IHVwIFwiY2xlYW5cIiB1bnRpbCBwcmVzc2luZyBhIHN1Ym1pdCBidXR0b24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZSxcbiAgICAgICAgICAgIGZpZWxkcyAgPSBhd2FpdCB0aGlzLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgdmFsaWRGaWVsZDtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHZhbGlkRmllbGQgPSBpdGVtLnZhbGlkYXRlPy4oZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkRmllbGQpIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ29udGFpbmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyO1xuIiwiaW1wb3J0IENvbXBvbmVudCAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZm9ybSBmaWVsZHNcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Jhc2VmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdiYXNlZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybSBncm91cHMgY2FuIGdldCBzZXQgb24gYW55IHBhcmVudCBjb21wb25lbnQgbGV2ZWwuXG4gICAgICAgICAqIEFuIGFsdGVybmF0aXZlIHdheSBmb3IgdXNpbmcgZG90cyBpbiBmaWVsZCBuYW1lcy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybUdyb3VwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBuYW1lXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5lbyBpdHNlbGYgZG9lcyBub3QgbmVlZCBmaWVsZCBuYW1lcyB0byBnZXQgbWFwcGVkIHRvIHRoZSBET00gKGlucHV0IG5vZGVzKSxcbiAgICAgICAgICogZXhjZXB0IGZvciBDaGVja0JveGVzICYgUmFkaW9zIHRvIHdvcmsuIEl0IGNhbiBiZSB1c2VmdWwgZm9yIHRlc3RpbmcgdG9vbHNcbiAgICAgICAgICogJiBhY2Nlc3NpYmlsaXR5IHRob3VnaCwgc28gdGhlIGRlZmF1bHQgZ290IHNldCB0byB0cnVlLlxuICAgICAgICAgKiBGZWVsIGZyZWUgdG8gY2hhbmdlIGl0IHRvIGZhbHNlIHRvIGtlZXAgdGhlIERPTSBtaW5pbWFsLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJOYW1lXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJOYW1lXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2UgcmVuZGVyTmFtZSBpcyBzZXQgdG8gdHJ1ZSwgeW91IGNhbiBvcHRpb25hbGx5IHJlbmRlciB0aGUgY29tYmluYXRpb25cbiAgICAgICAgICogb2YgYWxsIGZvcm1Hcm91cChzKSAmIHRoZSBmaWVsZCBuYW1lIGludG8gdGhlIERPTSA9PiBpbnB1dCBub2RlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlclBhdGg9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyUGF0aDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIgeyp9IHZhbHVlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwcyBvZiBhbGwgcGFyZW50IGxldmVsc1xuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBmb3JtR3JvdXBTdHJpbmc9bnVsbFxuICAgICAqL1xuICAgIGZvcm1Hcm91cFN0cmluZyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwKHMpIGFuZCB0aGUgZmllbGQgbmFtZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBwYXRoPW51bGxcbiAgICAgKi9cbiAgICBwYXRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUucmVuZGVyTmFtZSAmJiBtZS5jaGFuZ2VJbnB1dEVsS2V5KCduYW1lJywgbWUucmVuZGVyUGF0aCA/IG1lLmdldFBhdGgoKSA6IHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBmb3JtR3JvdXAgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IHBhcmVudHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0Rm9ybUdyb3VwKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBncm91cCA9IFtdLFxuICAgICAgICAgICAgcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgaWYgKG1lLmZvcm1Hcm91cFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmZvcm1Hcm91cFN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICYmIGdyb3VwLnB1c2godmFsdWUpO1xuXG4gICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgcGFyZW50LmZvcm1Hcm91cCAmJiBncm91cC51bnNoaWZ0KHBhcmVudC5mb3JtR3JvdXApXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVyblZhbHVlID0gZ3JvdXAuam9pbignLicpO1xuXG4gICAgICAgIG1lLmZvcm1Hcm91cFN0cmluZyA9IHJldHVyblZhbHVlO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlIG9mIGEgaW5wdXRFbCB2ZG9tIG9iamVjdCBhdHRyaWJ1dGUgb3IgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IGhhcyBubyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcnxPYmplY3R8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjaGFuZ2VJbnB1dEVsS2V5KGtleSwgdmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSB8fCBOZW8uaXNCb29sZWFuKHZhbHVlKSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgbWUuZ2V0SW5wdXRFbCgpW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5nZXRJbnB1dEVsKClba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXI7XG5cbiAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywge1xuICAgICAgICAgICAgY29tcG9uZW50OiBtZSxcbiAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFtZS5zdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5maXJlKCdmaWVsZENoYW5nZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRJbnB1dEVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tYmluYXRpb24gb2YgdGhlIGZpZWxkIGZvcm1Hcm91cChzKSAmIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHBhdGg7XG5cbiAgICAgICAgaWYgKCFtZS5wYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gbWUuZm9ybUdyb3VwID8gbWUuZm9ybUdyb3VwLnNwbGl0KCcuJykgOiBbXTtcblxuICAgICAgICAgICAgbWUubmFtZSAmJiBwYXRoLnB1c2gobWUubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5wYXRoID0gcGF0aC5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnBhdGgpIHtcbiAgICAgICAgICAgIG1lLnBhdGggPSAnbm9uZSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5wYXRoID09PSAnbm9uZScgPyBudWxsOiBtZS5wYXRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZT8uKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyO1xuXG4gICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEZvcm1Db250YWluZXIgJiYgcGFyZW50IGluc3RhbmNlb2YgRm9ybUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZmlyZSgnZmllbGRGb2N1c0xlYXZlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBmaWVsZCB0byBhIG5ldyB2YWx1ZSBvciBudWxsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZT1udWxsXG4gICAgICovXG4gICAgcmVzZXQodmFsdWU9bnVsbCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBjbGllbnQtc2lkZSBmaWVsZCBlcnJvcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD10cnVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpbiBjYXNlIHRoZXJlIGFyZSBubyBjbGllbnQtc2lkZSBlcnJvcnNcbiAgICAgKi9cbiAgICB2YWxpZGF0ZShzaWxlbnQ9dHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIGNoYW5nZSBldmVudCBmaXJlcyBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdldHMgY2hhbmdlZFxuICogQGV2ZW50IGNoYW5nZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhCYXNlKTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZTtcbiIsImltcG9ydCBCYXNlICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tIFwiLi4vdXRpbC9BcnJheS5tanNcIjtcblxuLyoqXG4gKiBTZWUgTmVvLmRpYWxvZy5Ub2FzdCBmb3IgZXhhbXBsZXNcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5Ub2FzdFxuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBUb2FzdCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuVG9hc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLlRvYXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzaW5nIGEgZGVmYXVsdCBtYXJnaW4gYmV0d2VlbiB0aGUgaXRlbVxuICAgICAqIElmIHlvdSBzd2l0Y2ggdGhlIGRpc3RhbmNlIHRvIHRoZSB0b3Agb3IgYm90dG9tIHlvdSBoYXZlIHRvIGNoYW5nZSB0aGlzIHZhbHVlIGFjY29yZGluZ2x5XG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBkZWZhdWx0TWFyZ2luPTE2XG4gICAgICovXG4gICAgZGVmYXVsdE1hcmdpbiA9IDE2XG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IG9ubHkgMSBpcyBzdXBwb3J0ZWQsIGJlY2F1c2UgdGhleSB3b3VsZCBvdmVybGFwXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhUb2FzdHM9M1xuICAgICAqL1xuICAgIG1heFRvYXN0cyA9IDNcbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIFRvYXN0cyBwZXIgYXJlYVxuICAgICAqIEBtZW1iZXIge09iamVjdH0gcnVubmluZ1xuICAgICAqL1xuICAgIHJ1bm5pbmcgPSB7XG4gICAgICAgIGJjOiBbXSwgYmw6IFtdLCBicjogW10sXG4gICAgICAgIHRjOiBbXSwgdGw6IFtdLCB0cjogW11cbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgeW91IHByZWZlciB5b3VyIG93biBjbGFzcyB0byBvcGVuLCBvdmVycmlkZSBoZXJlXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSB0b2FzdENsYXNzPSdOZW8uY29tcG9uZW50LlRvYXN0J1xuICAgICAqL1xuICAgIHRvYXN0Q2xhc3MgPSAnTmVvLmNvbXBvbmVudC5Ub2FzdCdcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICBOZW8udG9hc3QgPSB0aGlzLmNyZWF0ZVRvYXN0LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBUb2FzdCBkZWZpbml0aW9uIGFuZCBwYXNzIGl0IHRvIHRoZSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRvYXN0XG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGNyZWF0ZVRvYXN0KHRvYXN0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRvYXN0LnBvc2l0aW9uICYmICFtZS5ydW5uaW5nW3RvYXN0LnBvc2l0aW9uXSkge1xuICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKCdbTmVvLm1hbmFnZXIuVG9hc3RdIFN1cHBvcnRlZCB2YWx1ZXMgZm9yIHNsaWRlRGlyZWN0aW9uIGFyZTogdGwsIHRjLCB0ciwgYmwsIGJjLCBicicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRvYXN0Lm1zZyB8fCAhdG9hc3QuYXBwTmFtZSkge1xuICAgICAgICAgICAgIXRvYXN0Lm1zZyAgICAgJiYgTmVvLmxvZ0Vycm9yKCdbTmVvLm1hbmFnZXIuVG9hc3RdIFRvYXN0IGhhcyB0byBkZWZpbmUgYSBtc2cnKTtcbiAgICAgICAgICAgICF0b2FzdC5hcHBOYW1lICYmIE5lby5sb2dFcnJvcignW05lby5tYW5hZ2VyLlRvYXN0XSBUb2FzdCBoYXMgdG8gZGVmaW5lIGFuIGFwcE5hbWUuIFR5cGljYWxseSBtZS5hcHBOYW1lLicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0b2FzdCA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLnRvYXN0Q2xhc3MsXG4gICAgICAgICAgICAuLi50b2FzdFxuICAgICAgICB9KTtcblxuICAgICAgICB0b2FzdC5vbih7XG4gICAgICAgICAgICBtb3VudGVkOiBtZS51cGRhdGVJdGVtc0luUG9zaXRpb24sXG4gICAgICAgICAgICBzY29wZSAgOiBtZVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB0b2FzdC5pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCB0b2FzdCBiYXNlZCBvbiB0aGUgbWF4aW11bSBhbGxvd2VkIHRvYXN0c1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmluZEZpcnN0VG9hc3QoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBmaXJzdFRvYXN0LCBpdGVtO1xuXG4gICAgICAgIG1lLmZpbHRlcnMgPSBbe3Byb3BlcnR5OiAncnVubmluZycsIHZhbHVlOiBmYWxzZX1dO1xuXG4gICAgICAgIGZvciAoaXRlbSBvZiBtZS5tYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtZS5ydW5uaW5nW2l0ZW0ucG9zaXRpb25dLmxlbmd0aCA8IG1lLm1heFRvYXN0cykge1xuICAgICAgICAgICAgICAgIGZpcnN0VG9hc3QgPSBpdGVtO1xuICAgICAgICAgICAgICAgIGZpcnN0VG9hc3QucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5jbGVhckZpbHRlcnMoKTtcblxuICAgICAgICByZXR1cm4gZmlyc3RUb2FzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoaXRlbSk7XG4gICAgICAgIHRoaXMucnVuUXVldWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdGFzayBmcm9tIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvYXN0SWRcbiAgICAgKi9cbiAgICByZW1vdmVUb2FzdCh0b2FzdElkKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB0b2FzdCA9IG1lLmdldCh0b2FzdElkKSxcbiAgICAgICAgICAgIHBvc2l0aW9uO1xuXG4gICAgICAgIGlmICghdG9hc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uID0gdG9hc3QucG9zaXRpb247XG5cbiAgICAgICAgLy8gZGVjcmVhc2UgdG90YWwgb2YgZGlzcGxheWVkIHRvYXN0cyBmb3IgYSBwb3NpdGlvblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUobWUucnVubmluZ1twb3NpdGlvbl0sIHRvYXN0SWQpO1xuXG4gICAgICAgIG1lLnVwZGF0ZUl0ZW1zSW5Qb3NpdGlvbih0b2FzdElkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgVG9hc3RNYW5hZ2VyIHRvIHNob3cgYW4gaXRlbSBmcm9tIGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgcnVuUXVldWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB0b2FzdDtcblxuICAgICAgICBpZiAobWUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIHRvYXN0ID0gbWUuZmluZEZpcnN0VG9hc3QoKTtcblxuICAgICAgICAgICAgdG9hc3QgJiYgbWUuc2hvd1RvYXN0KHRvYXN0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LlRvYXN0fSB0b2FzdFxuICAgICAqL1xuICAgIHNob3dUb2FzdCh0b2FzdCkge1xuICAgICAgICB0b2FzdC5yZW5kZXIodHJ1ZSk7XG5cbiAgICAgICAgLy8gaW5jcmVhc2UgdG90YWwgb2YgZGlzcGxheWVkIHRvYXN0cyBmb3IgYSBwb3NpdGlvblxuICAgICAgICB0aGlzLnJ1bm5pbmdbdG9hc3QucG9zaXRpb25dLnVuc2hpZnQodG9hc3QuaWQpO1xuXG4gICAgICAgIC8vIHRvZG86IHdlIGNvdWxkIHVzZSBhIG1vdW50ZWQgbGlzdGVuZXJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1zSW5Qb3NpdGlvbih0b2FzdC5pZCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29sbGVjdGlvbiBpdGVtIHBhc3NlZCBieSByZWZlcmVuY2Ugb3Iga2V5XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpdGVtXG4gICAgICovXG4gICAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoaXRlbSk7XG4gICAgICAgIHRoaXMucnVuUXVldWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBoYW5kbGUgbXVsdGlwbGUgdG9hc3RzIHdlIGhhbmRsZSB0aGUgZXhhY3QgcG9zaXRpb25cbiAgICAgKiBmcm9tIHRoZSB0b3Agb3IgYm90dG9tXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlSXRlbXNJblBvc2l0aW9uKGlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRvYXN0ICAgICAgICAgPSBtZS5nZXQoaWQpLFxuICAgICAgICAgICAgcG9zaXRpb24gICAgICA9IHRvYXN0LnBvc2l0aW9uLFxuICAgICAgICAgICAgcG9zaXRpb25BcnJheSA9IG1lLnJ1bm5pbmdbcG9zaXRpb25dLFxuICAgICAgICAgICAgYWNjICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBtYXJnaW4gICAgICAgID0gbWUuZGVmYXVsdE1hcmdpbixcbiAgICAgICAgICAgIG1vdmVUbyAgICAgICAgPSBwb3NpdGlvbi5zdWJzdHJpbmcoMCwgMSkgPT09ICd0JyA/ICd0b3AnIDogJ2JvdHRvbScsXG4gICAgICAgICAgICBjb21wb25lbnQsIGNvbXBvbmVudElkLCBpbmRleCwgbW92ZU9iaiwgcmVjdHM7XG5cbiAgICAgICAgcmVjdHMgPSBhd2FpdCB0b2FzdC5nZXREb21SZWN0KHBvc2l0aW9uQXJyYXkpO1xuXG4gICAgICAgIGZvciAoW2luZGV4LCBjb21wb25lbnRJZF0gb2YgcG9zaXRpb25BcnJheS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoY29tcG9uZW50SWQpO1xuICAgICAgICAgICAgbW92ZU9iaiAgID0ge307XG5cbiAgICAgICAgICAgIGFjYyA9IGFjYyArIG1hcmdpbjtcbiAgICAgICAgICAgIG1vdmVPYmpbbW92ZVRvXSA9IGFjYyArICdweCc7XG4gICAgICAgICAgICBjb21wb25lbnQuc3R5bGUgPSBtb3ZlT2JqO1xuICAgICAgICAgICAgY29tcG9uZW50LnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBhY2MgPSBhY2MgKyByZWN0c1tpbmRleF0uaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5sZXQgaW5zdGFuY2UgPSBOZW8uYXBwbHlDbGFzc0NvbmZpZyhUb2FzdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9