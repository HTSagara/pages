"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_plugin_Responsive_mjs"],{

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.owner.mounted) {
            me.onOwnerMounted();
        } else {
            me.owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/plugin/Responsive.mjs":
/*!***********************************!*\
  !*** ./src/plugin/Responsive.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/plugin/Base.mjs");


/**
 * @class Neo.plugin.Responsive
 * @extends Neo.plugin.Base
 */
class Responsive extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Responsive'
         * @protected
         */
        className: 'Neo.plugin.Responsive',
        /**
         * @member {String} ntype='plugin-responsive'
         * @protected
         */
        ntype: 'plugin-responsive',
        /**
         * @member {Map} responsiveConfig: new Map()
         */
        responsiveConfig: new Map(),
        /**
         * @member {Object} defaultResponsiveConfig
         */
        defaultResponsiveConfig: {
            landscape(data) {
                return data.width > data.height
            },
            portrait(data) {
                return data.width < data.height
            }
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        owner.addCls('neo-responsive');

        Neo.first('viewport').addDomListeners([
            {resize: me.onResize, scope: me}
        ])

        Neo.Responsive = Neo.Responsive || {
            responsiveConfig: new Map(),
            apps            : {}
        };

        me.addToResponsiveMap(me.defaultResponsiveConfig, me);
        me.addToResponsiveMap(owner.responsiveConfig || {}, owner);
        me.handleBodyCls()
    }

    /**
     * @param responsiveObj
     * @param scope
     */
    addToResponsiveMap(responsiveObj, scope) {
        for (const [key, value] of Object.entries(responsiveObj)) {
            let fn;

            if (Neo.isObject(value)) {
                fn = function (rect) {
                    let returnBool = true;

                    for (const [subKey, subValue] of Object.entries(value)) {
                        const isMin      = subKey.startsWith('min'),
                              testConfig = subKey.substring(3).toLowerCase();

                        if (isMin) {
                            returnBool = rect[testConfig] >= subValue
                        } else {
                            returnBool = rect[testConfig] <= subValue
                        }

                        if (!returnBool) {
                            break
                        }
                    }

                    return returnBool
                }
            } else {
                fn = value
            }

            fn = fn.bind(scope);

            Neo.Responsive.responsiveConfig.set(key, fn)
        }
    }

    /**
     *
     */
    handleBodyCls() {
        const
            me        = this,
            {appName} = me.owner,
            apps      = Neo.Responsive;

        if (!apps[appName]?.activeBodyUpdate) {
            const viewport = Neo.first('viewport'); // todo

            apps[appName] = {
                appId           : viewport.id,
                activeBodyUpdate: true
            };

            viewport.addDomListeners([
                {resize: me.onResizeBody, scope: me}
            ])
        }
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        const
            me           = this,
            config       = {},
            configTester = Neo.Responsive.responsiveConfig,
            {owner}      = me,
            {responsive} = owner;

        for (const [key, value] of Object.entries(responsive)) {
            const hasKey = configTester.get(key)?.(data.rect);

            if (hasKey) {
                for (const [configKey, configValue] of Object.entries(value)) {
                    if (false) {} else {
                        config[configKey] = configValue
                    }
                }
            }
        }

        Object.keys(config).length > 0 && owner.set(config)
    }

    /**
     * Add either neo-landscape or neo-portrait to the parent viewport component
     */
    onResizeBody(data) {
        const
            me          = this,
            newRect     = data.contentRect,
            isLandscape = newRect.width >= newRect.height,
            addCls      = isLandscape ? 'neo-landscape' : 'neo-portrait',
            removeCls   = isLandscape ? 'neo-portrait' : 'neo-landscape';

        Neo.applyDeltas(me.appName, {
            id : 'document.body',
            cls: {
                add   : [addCls],
                remove: [removeCls]
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Responsive));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfcGx1Z2luX1Jlc3BvbnNpdmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBUTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BEQTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQVU7QUFDbkM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsWUFBWTs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXVELEVBQUUsRUFHNUQsQ0FBQztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsMEJBQTBCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9SZXNwb25zaXZlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29yZUJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgcGx1Z2luIGltcGxlbWVudGF0aW9ucy5cbiAqIFBsdWdpbnMgYXJlIGludGVuZGVkIHRvIGdldCBwdXQgaW50byB0aGUgcGx1Z2lucyBjb25maWcgb2YgY29tcG9uZW50LkJhc2VcbiAqIHRvIGVuaGFuY2UgdGhlbSBvciBhZGQgYWRkaXRpb25hbCBmZWF0dXJlc1xuICogQGNsYXNzIE5lby5wbHVnaW4uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHBsdWdpbiBudHlwZXMgbmVlZCB0byBzdGFydCB3aXRoICdwbHVnaW4tJyB0byBlbnN1cmUgdGhhdCBjb21wb25lbnQuQmFzZTogZ2V0UGx1Z2luKCkgY2FuIGZpbmQgdGhlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm93bmVyLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJNb3VudGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5vd25lci5vbignbW91bnRlZCcsIG1lLm9uT3duZXJNb3VudGVkLCBtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBkb2VzIGdldCBtb3VudGVkXG4gICAgICovXG4gICAgb25Pd25lck1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIiwiaW1wb3J0IEJhc2VQbHVnaW4gZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5wbHVnaW4uUmVzcG9uc2l2ZVxuICogQGV4dGVuZHMgTmVvLnBsdWdpbi5CYXNlXG4gKi9cbmNsYXNzIFJlc3BvbnNpdmUgZXh0ZW5kcyBCYXNlUGx1Z2luIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5wbHVnaW4uUmVzcG9uc2l2ZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnBsdWdpbi5SZXNwb25zaXZlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbi1yZXNwb25zaXZlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbi1yZXNwb25zaXZlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge01hcH0gcmVzcG9uc2l2ZUNvbmZpZzogbmV3IE1hcCgpXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zaXZlQ29uZmlnOiBuZXcgTWFwKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlZmF1bHRSZXNwb25zaXZlQ29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0UmVzcG9uc2l2ZUNvbmZpZzoge1xuICAgICAgICAgICAgbGFuZHNjYXBlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS53aWR0aCA+IGRhdGEuaGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9ydHJhaXQoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLndpZHRoIDwgZGF0YS5oZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZTtcblxuICAgICAgICBvd25lci5hZGRDbHMoJ25lby1yZXNwb25zaXZlJyk7XG5cbiAgICAgICAgTmVvLmZpcnN0KCd2aWV3cG9ydCcpLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7cmVzaXplOiBtZS5vblJlc2l6ZSwgc2NvcGU6IG1lfVxuICAgICAgICBdKVxuXG4gICAgICAgIE5lby5SZXNwb25zaXZlID0gTmVvLlJlc3BvbnNpdmUgfHwge1xuICAgICAgICAgICAgcmVzcG9uc2l2ZUNvbmZpZzogbmV3IE1hcCgpLFxuICAgICAgICAgICAgYXBwcyAgICAgICAgICAgIDoge31cbiAgICAgICAgfTtcblxuICAgICAgICBtZS5hZGRUb1Jlc3BvbnNpdmVNYXAobWUuZGVmYXVsdFJlc3BvbnNpdmVDb25maWcsIG1lKTtcbiAgICAgICAgbWUuYWRkVG9SZXNwb25zaXZlTWFwKG93bmVyLnJlc3BvbnNpdmVDb25maWcgfHwge30sIG93bmVyKTtcbiAgICAgICAgbWUuaGFuZGxlQm9keUNscygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlc3BvbnNpdmVPYmpcbiAgICAgKiBAcGFyYW0gc2NvcGVcbiAgICAgKi9cbiAgICBhZGRUb1Jlc3BvbnNpdmVNYXAocmVzcG9uc2l2ZU9iaiwgc2NvcGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzcG9uc2l2ZU9iaikpIHtcbiAgICAgICAgICAgIGxldCBmbjtcblxuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXR1cm5Cb29sID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzdWJLZXksIHN1YlZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTWluICAgICAgPSBzdWJLZXkuc3RhcnRzV2l0aCgnbWluJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0Q29uZmlnID0gc3ViS2V5LnN1YnN0cmluZygzKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5Cb29sID0gcmVjdFt0ZXN0Q29uZmlnXSA+PSBzdWJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5Cb29sID0gcmVjdFt0ZXN0Q29uZmlnXSA8PSBzdWJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJldHVybkJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkJvb2xcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZuID0gdmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4gPSBmbi5iaW5kKHNjb3BlKTtcblxuICAgICAgICAgICAgTmVvLlJlc3BvbnNpdmUucmVzcG9uc2l2ZUNvbmZpZy5zZXQoa2V5LCBmbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlQm9keUNscygpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZX0gPSBtZS5vd25lcixcbiAgICAgICAgICAgIGFwcHMgICAgICA9IE5lby5SZXNwb25zaXZlO1xuXG4gICAgICAgIGlmICghYXBwc1thcHBOYW1lXT8uYWN0aXZlQm9keVVwZGF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBOZW8uZmlyc3QoJ3ZpZXdwb3J0Jyk7IC8vIHRvZG9cblxuICAgICAgICAgICAgYXBwc1thcHBOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBhcHBJZCAgICAgICAgICAgOiB2aWV3cG9ydC5pZCxcbiAgICAgICAgICAgICAgICBhY3RpdmVCb2R5VXBkYXRlOiB0cnVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2aWV3cG9ydC5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgICAgIHtyZXNpemU6IG1lLm9uUmVzaXplQm9keSwgc2NvcGU6IG1lfVxuICAgICAgICAgICAgXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25SZXNpemUoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgICAgICA9IHt9LFxuICAgICAgICAgICAgY29uZmlnVGVzdGVyID0gTmVvLlJlc3BvbnNpdmUucmVzcG9uc2l2ZUNvbmZpZyxcbiAgICAgICAgICAgIHtvd25lcn0gICAgICA9IG1lLFxuICAgICAgICAgICAge3Jlc3BvbnNpdmV9ID0gb3duZXI7XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzcG9uc2l2ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc0tleSA9IGNvbmZpZ1Rlc3Rlci5nZXQoa2V5KT8uKGRhdGEucmVjdCk7XG5cbiAgICAgICAgICAgIGlmIChoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjb25maWdLZXksIGNvbmZpZ1ZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhbHNlICYmIE5lby50eXBlT2Yob3duZXJbY29uZmlnS2V5XSkgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IG50eXBlLCBtb2R1bGUgb3IgY2xhc3NOYW1lIG11c3QgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyW2NvbmZpZ0tleV0uc2V0KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnW2NvbmZpZ0tleV0gPSBjb25maWdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlnKS5sZW5ndGggPiAwICYmIG93bmVyLnNldChjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGVpdGhlciBuZW8tbGFuZHNjYXBlIG9yIG5lby1wb3J0cmFpdCB0byB0aGUgcGFyZW50IHZpZXdwb3J0IGNvbXBvbmVudFxuICAgICAqL1xuICAgIG9uUmVzaXplQm9keShkYXRhKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuZXdSZWN0ICAgICA9IGRhdGEuY29udGVudFJlY3QsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZSA9IG5ld1JlY3Qud2lkdGggPj0gbmV3UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICBhZGRDbHMgICAgICA9IGlzTGFuZHNjYXBlID8gJ25lby1sYW5kc2NhcGUnIDogJ25lby1wb3J0cmFpdCcsXG4gICAgICAgICAgICByZW1vdmVDbHMgICA9IGlzTGFuZHNjYXBlID8gJ25lby1wb3J0cmFpdCcgOiAnbmVvLWxhbmRzY2FwZSc7XG5cbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgIGlkIDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgYWRkICAgOiBbYWRkQ2xzXSxcbiAgICAgICAgICAgICAgICByZW1vdmU6IFtyZW1vdmVDbHNdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhSZXNwb25zaXZlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==