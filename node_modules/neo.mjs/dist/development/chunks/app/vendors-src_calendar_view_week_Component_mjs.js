"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_week_Component_mjs"],{

/***/ "./src/calendar/view/week/Component.mjs":
/*!**********************************************!*\
  !*** ./src/calendar/view/week/Component.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TimeAxisComponent.mjs */ "./src/calendar/view/week/TimeAxisComponent.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.week.Component
 * @extends Neo.component.Base
 */
class Component extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for timeAxisPosition
     * @member {String[]} timeAxisPositions=['end','start']
     * @protected
     * @static
     */
    static timeAxisPositions = ['end', 'start']

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.Component'
         * @protected
         */
        className: 'Neo.calendar.view.week.Component',
        /**
         * @member {String[]} baseCls=['neo-calendar-weekcomponent']
         */
        baseCls: ['neo-calendar-weekcomponent'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            enableDrag          : data => data.events.enableDrag,
            endTime             : data => data.endTime,
            eventBorder         : data => data.events.border,
            eventStore          : 'stores.events',
            intlFormat_time     : data => data.intlFormat_time,
            locale              : data => data.locale,
            minimumEventDuration: data => data.minimumEventDuration,
            showWeekends        : data => data.showWeekends,
            startTime           : data => data.startTime,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Bound to the view model
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore_: null,
        /**
         * Amount of hidden columns on both sides each inside this view.
         * @member {Number} columnsBuffer_=7
         */
        columnsBuffer_: 7,
        /**
         * Amount of visible columns inside this view.
         * @member {Number} columnsVisible_=7
         */
        columnsVisible_: 7,
        /**
         * Bound to the view model.
         * @member {Date|null} currentDate_=null
         * @protected
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='short'
         */
        dayNameFormat_: 'short',
        /**
         * Bound to the view model.
         * @member {Boolean} enableDrag_=true
         * @protected
         */
        enableDrag_: true,
        /**
         * Bound to the view model
         * @member {String|null} eventBorder_=null
         */
        eventBorder_: null,
        /**
         * @member {Neo.calendar.view.week.EventDragZone|null} eventDragZone=null
         */
        eventDragZone: null,
        /**
         * Bound to the view model
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         */
        eventStore_: null,
        /**
         * Will get passed from updateHeader()
         * @member {Date|null} firstColumnDate=null
         * @protected
         */
        firstColumnDate: null,
        /**
         * Internal flag to check if updateHeader(true) has already run
         * @member {Boolean} headerCreated=false
         * @protected
         */
        headerCreated: false,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * Bound to the view model.
         * @member {Intl.DateTimeFormat|null} intlFormat_time_=null
         * @protected
         */
        intlFormat_time_: null,
        /**
         * @member {Boolean} isUpdating=false
         * @protected
         */
        isUpdating: false,
        /**
         * Bound to the view model.
         * @member {String} locale_=Neo.config.locale
         */
        locale_: Neo.config.locale,
        /**
         * Time in minutes. Bound to the view model.
         * @member {Number} minimumEventDuration=30
         * @protected
         */
        minimumEventDuration: 30,
        /**
         * Internal flag to store if updateEvents() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * config values for Neo.calendar.view.week.plugin.DragDrop
         * @member {Object} pluginDragDropConfig=null
         */
        pluginDragDropConfig: null,
        /**
         * config values for Neo.calendar.view.week.plugin.EventResizable
         * @member {Object} pluginResizableConfig=null
         */
        pluginEventResizableConfig: null,
        /**
         * @member {Boolean} showEventEndTime_=false
         */
        showEventEndTime_: false,
        /**
         * Bound to the view model.
         * @member {Boolean} showWeekends_=true
         */
        showWeekends_: true,
        /**
         * @member {Object} timeAxis=null
         */
        timeAxis: null,
        /**
         * @member {Object} timeAxisConfig=null
         */
        timeAxisConfig: null,
        /**
         * Position the timeAxis at the left or right side.
         * Valid values are start & end.
         * start => left, end => right in LTR mode.
         * @member {String} timeAxisPosition_='start'
         */
        timeAxisPosition_: 'start',
        /**
         * Internal flag to store the total amount of rendered columns.
         * Changing columnsBuffer or columnsVisible will update this value.
         * @member {Number|null} totalColumns=null
         * @protected
         */
        totalColumns: null,
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-scroll-overlay']},
            {cls: ['neo-c-w-scrollcontainer'], flag: 'neo-c-w-scrollcontainer', cn: [
                {cls: ['neo-header-row'], flag: 'neo-header-row', cn: []},
                {cls: ['neo-c-w-column-timeaxis-container'], flag: 'neo-c-w-column-timeaxis-container', cn: [
                    {cls: ['neo-c-w-column-container'], flag: 'neo-c-w-column-container', style: {}, cn: []}
                ]}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the view model.
         * @member {Number} weekStartDay_=0
         */
        weekStartDay_: 0
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {dblclick: me.onEventDoubleClick, scope: me, delegate: '.neo-event'},
            {wheel   : me.onWheel,            scope: me}
        ]);

        me.timeAxis = Neo.create(_TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
            appName  : me.appName,
            parentId : me.id,
            listeners: {
                change: me.onTimeAxisChange,
                scope : me
            },
            ...me.timeAxisConfig
        });

        me.getColumnTimeAxisContainer().cn[me.timeAxisPosition === 'start' ? 'unshift' : 'push'](me.timeAxis.vdom);

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {
            me.needsEventUpdate = true;
        }

        me.updateHeader(true, me.needsEventUpdate);

        me.needsEventUpdate && me.updateEvents(false);

        me.headerCreated = true;
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     * @param {Boolean} [silent=false]
     */
    adjustTotalHeight(data, silent=false) {
        let me          = this,
            rowHeight   = data.rowHeight,
            rowsPerItem = data.rowsPerItem,
            height      = data.totalHeight - rowHeight,
            i           = 0,
            gradient    = [];

        for (; i < rowsPerItem; i++) {
            gradient.push(
                `var(--c-w-background-color) ${i * rowHeight + i}px`,
                `var(--c-w-background-color) ${(i + 1) * rowHeight + i}px`,
                'var(--c-w-border-color) 0'
            );
        }

        Object.assign(me.getColumnContainer().style, {
            backgroundImage: `linear-gradient(${gradient.join(',')})`,
            backgroundSize : `1px ${rowsPerItem * rowHeight + rowsPerItem}px`,
            height         : `${height}px`,
            maxHeight      : `${height}px`
        });

        !silent && me.update();
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners);
    }

    /**
     * Triggered after the columnsBuffer config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetColumnsBuffer(value, oldValue) {
        this.totalColumns = this.visibleColumns + 2 * value;
    }

    /**
     * Triggered after the columnsVisible config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetColumnsVisible(value, oldValue) {
        this.totalColumns = 2 * this.columnsBuffer + value;
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        let me = this;

        if (me.isConstructed) {
            me.updateHeader(false, true);
            me.updateEvents();
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});
        oldValue && me.updateHeader();
    }

    /**
     * Triggered after the enableDrag config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetEnableDrag(value, oldValue) {
        let me = this;

        if (value && !me.getPlugin({flag: 'dragdrop'})) {
            Promise.all([
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_calendar_view_week_plugin_DragDrop_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/DragDrop.mjs */ "./src/calendar/view/week/plugin/DragDrop.mjs")),
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_plugin_Resizable_mjs"), __webpack_require__.e("src_calendar_view_week_plugin_EventResizable_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/EventResizable.mjs */ "./src/calendar/view/week/plugin/EventResizable.mjs"))
            ]).then(modules => {
                let me      = this,
                    plugins = me.plugins || [];

                plugins.push({
                    module : modules[0].default,
                    appName: me.appName,
                    flag   : 'dragdrop',
                    ...me.pluginDragDropConfig
                }, {
                    module       : modules[1].default,
                    appName      : me.appName,
                    delegationCls: 'neo-event',
                    directions   : ['b', 't'],
                    flag         : 'resizable',
                    ...me.pluginEventResizableConfig
                });

                me.plugins = plugins;
            });
        }
    }

    /**
     * Triggered after the eventBorder config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetEventBorder(value, oldValue) {
        let me  = this,
            cls = me.cls;

        oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, `neo-event-border-${oldValue}`);
        value    && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(   cls, `neo-event-border-${value}`);

        me.cls = cls;
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onEventStoreLoad,
            recordChange: me.onEventStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners);
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue) {
            let me = this;

            me.intlFormat_day  = new Intl.DateTimeFormat(value, {weekday: me.dayNameFormat});
            me.updateHeader();
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this,
            rect;

        if (value) {
            if (me.needsEventUpdate) {
                me.updateEvents();
                me.needsEventUpdate = false;
            }

            await Neo.timeout(70);

            rect = await me.getDomRect(me.getColumnContainer().id);

            Neo.main.DomAccess.scrollBy({
                appName  : me.appName,
                direction: 'left',
                id       : me.getScrollContainer().id,
                value    : rect.width * me.columnsBuffer / me.columnsVisible / 3
            });
        }
    }

    /**
     * Triggered after the showEventEndTime config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowEventEndTime(value, oldValue) {
        oldValue !== undefined && this.updateEvents();
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-show-weekends');

        me._cls = cls; // silent update

        if (oldValue !== undefined) {
            me.updateHeader(false, true);
            me.updateEvents();
        }
    }

    /**
     * Triggered after the timeAxisPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTimeAxisPosition(value, oldValue) {
        let me                = this,
            cls               = me.cls,
            timeAxisContainer = me.getColumnTimeAxisContainer();

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value === 'end' ? 'add' : 'remove'](cls, 'neo-timeaxis-end');

        if (oldValue !== undefined) {
            timeAxisContainer.cn.unshift(timeAxisContainer.cn.pop()); // switch the order of the 2 items
        }

        me.cls = cls; // silent update
        me.update();
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        if (oldValue !== undefined) {
            this.updateHeader(false, true);
            this.updateEvents();
        }
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.dayNameFormats);
    }

    /**
     * Triggered before the timeAxisPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTimeAxisPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'timeAxisPosition');
    }

    /**
     * Triggered before the weekStartDay config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetWeekStartDay(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'weekStartDay', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.weekStartDays);
    }

    /**
     * @param {Date} date
     * @returns {Object}
     */
    createColumnAndHeader(date) {
        let me          = this,
            columnCls   = ['neo-c-w-column', 'neo-draggable'],
            currentDate = date.getDate(),
            currentDay  = date.getDay(),
            dateCls     = ['neo-date'],
            removeDom   = false,
            column, header;

        if (currentDay === 0 || currentDay === 6) {
            columnCls.push('neo-weekend');
            !me.showWeekends && (removeDom = true);
        }

        if (currentDate === today.day && date.getMonth() === today.month && date.getFullYear() === today.year) {
            dateCls.push('neo-today');
        }

        column = {cls: columnCls, flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date), removeDom};

        header =
        {cls: ['neo-header-row-item'], removeDom: removeDom, cn: [
            {cls: ['neo-day'], html: me.intlFormat_day.format(date)},
            {cls: dateCls,     html: currentDate}
        ]};

        return {column, header};
    }

    /**
     *
     */
    destroy(...args) {
        this.timeAxis = null;

        super.destroy(...args);
    }

    /**
     *
     */
    getColumnContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-column-container');
    }

    /**
     * @param {Date} date
     * @returns {String}
     */
    getColumnId(date) {
        return `${this.id}_col_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date)}`;
    }

    /**
     * @param {Date} date
     * @returns {String}
     */
    getColumnHeaderId(date) {
        return `${this.id}_ch_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date)}`;
    }

    /**
     *
     */
    getColumnTimeAxisContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-column-timeaxis-container');
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getEventId(recordId) {
        return `${this.id}__${recordId}`;
    }

    /**
     *
     */
    getHeaderContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-header-row');
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * @returns {String}
     */
    getIdKey() {
        return 'c-w';
    }

    /**
     *
     */
    getScrollContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-scrollcontainer');
    }

    /**
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.updateEvents();
    }

    /**
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.updateEvents();
    }

    /**
     * @param {Object} data
     */
    onEventDoubleClick(data) {
        if (this.data.events.enableEdit) {
            !data.path[0].cls.includes('neo-event') && data.path.shift();

            let me                 = this,
                editEventContainer = me.owner.editEventContainer,
                eventNode          = data.path[0],
                eventVdom          = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].findVdomChild(me.vdom, eventNode.id).vdom,
                record             = me.eventStore.get(eventVdom.flag),
                style              = editEventContainer.style;

            Object.assign(style, {left: `${eventNode.rect.width + 15}px`, top: eventVdom.style.top});
            editEventContainer.setSilent({parentId: data.path[1].id, record, style});
            editEventContainer.render(true);
        }
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.updateEvents();
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreRecordChange(data) {
        this.updateEvents();
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @param {Object[]} data.path
     */
    onFocusChange(data) {
        let oldPath = data.oldPath,
            path    = data.path;

        oldPath?.[0]?.cls.includes('neo-event') && Neo.applyDeltas(this.appName, {id: oldPath[0].id, cls: {remove: ['neo-focus']}});
        path   ?.[0]?.cls.includes('neo-event') && Neo.applyDeltas(this.appName, {id: path[0]   .id, cls: {add:    ['neo-focus']}});
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     */
    onTimeAxisChange(data) {
        let me = this;

        me.adjustTotalHeight(data, me.headerCreated);
        me.headerCreated && me.updateEvents();
    }

    /**
     * @param {Object} data
     */
    onWheel(data) {
        if (!this.isUpdating && Math.abs(data.deltaX) > Math.abs(data.deltaY)) {
            let me              = this,
                columns         = me.getColumnContainer(),
                columnsBuffer   = me.columnsBuffer,
                columnsVisible  = me.columnsVisible,
                firstColumnDate = me.firstColumnDate,
                header          = me.getHeaderContainer(),
                i               = 0,
                timeAxisWidth   = 50,
                width           = data.clientWidth - timeAxisWidth,
                config, date, scrollValue;

            // console.log(data.scrollLeft, Math.round(data.scrollLeft / (data.clientWidth - timeAxisWidth) * 7));

            if (data.deltaX > 0 && Math.round(data.scrollLeft / width * columnsBuffer) > columnsBuffer + columnsVisible - 1) {
                date = new Date(columns.cn[columns.cn.length - 1].flag);

                columns.cn.splice(0, columnsBuffer);
                header .cn.splice(0, columnsBuffer);

                for (; i < columnsBuffer; i++) {
                    date.setDate(date.getDate() + 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.push(config.column);
                    header .cn.push(config.header);
                }

                firstColumnDate.setDate(firstColumnDate.getDate() + columnsBuffer);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                setTimeout(() => {me.updateEvents(false, columnsBuffer + columnsVisible, me.totalColumns)}, 50);

                scrollValue = -width;
            }

            else if (data.deltaX < 0 && Math.round(data.scrollLeft / width * columnsBuffer) < 1) {
                date = new Date(columns.cn[0].flag);

                columns.cn.length = columnsBuffer + columnsVisible;
                header .cn.length = columnsBuffer + columnsVisible;

                for (; i < columnsBuffer; i++) {
                    date.setDate(date.getDate() - 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.unshift(config.column);
                    header .cn.unshift(config.header);
                }

                firstColumnDate.setDate(firstColumnDate.getDate() - columnsBuffer);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                setTimeout(() => {me.updateEvents(false, 0, columnsBuffer)}, 50);

                scrollValue = width;
            }

            if (scrollValue) {
                me.isUpdating = true;

                me.promiseVdomUpdate().then(() => {
                    Neo.main.DomAccess.scrollBy({
                        direction: 'left',
                        id       : me.getScrollContainer().id,
                        value    : scrollValue
                    }).then(() => {
                        me.isUpdating = false;
                    });
                });
            }
        }
    }

    /**
     * @param {Date} date
     */
    setFirstColumnDate(date) {
        date.setDate(date.getDate() - date.getDay() + this.weekStartDay - this.columnsBuffer);
    }

    /**
     * The algorithm relies on the eventStore being sorted by startDate ASC
     * @param {Boolean} [silent=false]
     * @param {Number} [startIndex=0]
     * @param {Number} [endIndex=this.totalColumns]
     */
    updateEvents(silent=false, startIndex=0, endIndex=this.totalColumns) {
        let me = this;

        if (!me.mounted) {
            me.needsEventUpdate = true;
        } else {
            let calendarStore     = me.calendarStore,
                eventStore        = me.eventStore,
                timeAxis          = me.timeAxis,
                endTime           = timeAxis.getTime(me.endTime),
                startTime         = timeAxis.getTime(me.startTime),
                totalTime         = endTime - startTime,
                date              = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(me.firstColumnDate),
                vdom              = me.vdom,
                content           = me.getColumnContainer(),
                j                 = startIndex,
                showEventEndTime  = me.showEventEndTime,
                calendarRecord, column, dayRecords, duration, endDate, eventCls, eventIntervals, hasOverflow, height, i,
                len, record, recordKey, startDate, startHours, top;

            date.setDate(date.getDate() + startIndex);

            for (; j < endIndex; j++) {
                column = content.cn[j];

                column.cn = []; // remove previous events from the vdom

                dayRecords = eventStore.getDayRecords(date);
                len        = dayRecords.length;

                for (i = 0; i < len; i++) {
                    record         = dayRecords[i];
                    calendarRecord = calendarStore.get(record.calendarId);

                    if (calendarRecord?.active) {
                        endDate   = record.endDate;
                        startDate = record.startDate;

                        if (endTime <= startDate.getHours() || startTime >= endDate.getHours()) {
                            continue;
                        }

                        if (endTime < endDate.getHours()) {
                            endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(endDate);
                            endDate.setHours(endTime);
                            endDate.setMinutes(0);
                        }

                        if (startTime > startDate.getHours()) {
                            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(startDate);
                            startDate.setHours(startTime);
                            startDate.setMinutes(0);
                        }

                        duration       = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                        eventCls       = ['neo-event', 'neo-draggable', `neo-${calendarRecord.color}`];
                        eventIntervals = duration * 60 / timeAxis.interval;
                        hasOverflow    = false;
                        height         = Math.round(duration / totalTime * 100 * 1000) / 1000;
                        recordKey      = record[eventStore.keyProperty];
                        startHours     = (startDate.getHours() * 60 + startDate.getMinutes()) / 60;
                        top            = Math.round((startHours - startTime) / totalTime * 100 * 1000) / 1000;

                        if (eventIntervals <= 2) {
                            hasOverflow = timeAxis.rowHeight * eventIntervals < (showEventEndTime ? 50 : 34);

                            if (hasOverflow && !(showEventEndTime && (timeAxis.rowHeight / eventIntervals >= 34))) {
                                eventCls.push('neo-overflow');
                            }
                        }

                        showEventEndTime = !(hasOverflow && eventIntervals === 1 || !showEventEndTime);

                        showEventEndTime && eventCls.push('neo-show-end-time');

                        column.cn.push({
                            cls     : eventCls,
                            flag    : recordKey,
                            id      : me.getEventId(recordKey),
                            tabIndex: -1,

                            cn: [{
                                cls : ['neo-event-time'],
                                html: me.intlFormat_time.format(record.startDate),
                                id  : `${me.id}__time__${recordKey}`
                            }, {
                                cls : ['neo-event-title'],
                                html: record.title,
                                id  : `${me.id}__title__${recordKey}`
                            }, {
                                cls      : ['neo-event-time', 'neo-event-end-time'],
                                html     : me.intlFormat_time.format(record.endDate),
                                id       : `${me.id}__enddate__${recordKey}`,
                                removeDom: !showEventEndTime
                            }],

                            style: {
                                height: `calc(${height}% - 2px)`,
                                top   : `calc(${top}% + 1px)`,
                                width : 'calc(100% - 1px)'
                            }
                        });
                    }
                }

                date.setDate(date.getDate() + 1);
            }

            me[silent ? '_vdom' : 'vdom'] = vdom;
        }
    }

    /**
     * @param {Boolean} [create=false]
     * @param {Boolean} [silent=false]
     */
    updateHeader(create=false, silent=false) {
        let me           = this,
            date         = me.currentDate, // cloned
            vdom         = me.vdom,
            content      = me.getColumnContainer(),
            header       = me.getHeaderContainer(),
            i            = 0,
            showWeekends = me.showWeekends,
            columnCls, currentDate, currentDay, dateCls, headerId, removeDom;

        me.setFirstColumnDate(date);

        me.firstColumnDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(date);

        for (; i < me.totalColumns; i++) {
            columnCls   = ['neo-c-w-column', 'neo-draggable'];
            currentDate = date.getDate();
            currentDay  = date.getDay();
            dateCls     = ['neo-date'];
            removeDom   = false;

            if (currentDay === 0 || currentDay === 6) {
                columnCls.push('neo-weekend');
                !showWeekends && (removeDom = true);
            }

            if (currentDate === today.day && date.getMonth() === today.month && date.getFullYear() === today.year) {
                dateCls.push('neo-today');
            }

            headerId = me.getColumnHeaderId(date);

            if (create) {
                content.cn.push({cls: columnCls, flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date), id: me.getColumnId(date), removeDom});

                header.cn.push(
                {cls: ['neo-header-row-item'], id: headerId, removeDom, cn: [
                    {cls: ['neo-day'], html: me.intlFormat_day.format(date), id: `${headerId}_day`},
                    {cls : dateCls,    html: currentDate,                    id: `${headerId}_date`}
                ]});
            } else {
                Object.assign(content.cn[i], {
                    cls : columnCls,
                    flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date),
                    id  : me.getColumnId(date),
                    removeDom
                });

                Object.assign(header.cn[i],       {id: headerId, removeDom});
                Object.assign(header.cn[i].cn[0], {html: me.intlFormat_day.format(date), id: `${headerId}_day`});
                Object.assign(header.cn[i].cn[1], {cls: dateCls, html: currentDate, id: `${headerId}_date`});
            }

            date.setDate(date.getDate() + 1);
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }
}

Neo.applyClassConfig(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ }),

/***/ "./src/calendar/view/week/TimeAxisComponent.mjs":
/*!******************************************************!*\
  !*** ./src/calendar/view/week/TimeAxisComponent.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.calendar.view.week.TimeAxisComponent
 * @extends Neo.container.Base
 */
class TimeAxisComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for interval
     * @member {Number[]} intervals=[15,30,60]
     * @protected
     * @static
     */
    static intervals = [15, 30, 60]

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.TimeAxisComponent'
         * @protected
         */
        className: 'Neo.calendar.view.week.TimeAxisComponent',
        /**
         * @member {String[]} baseCls=['neo-calendar-timeaxis']
         */
        baseCls: ['neo-calendar-timeaxis'],
        /**
         * @member {Object} bind
         */
        bind: {
            endTime  : data => data.endTime,
            startTime: data => data.startTime
        },
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         */
        endTime_: '24:00',
        /**
         * The time interval in minutes to display as rows.
         * Valid values: 15, 30, 60
         * @member {Number} interval_=30
         */
        interval_: 30,
        /**
         * @member {Number} rowHeight_=20
         */
        rowHeight_: 20,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         */
        startTime_: '00:00',
        /**
         * @member {Object} vdom
         */
        vdom:
        {style: {}}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.createItems();
        me.afterSetRowHeight(me.rowHeight, 0);
    }

    /**
     * Triggered after the endTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetEndTime(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            // todo: handle 24:00 as 23:59
            if (!value) {
                me._endTime = '24:00';
            }

            me.afterSetRowHeight(me.rowHeight, 0);
        }
    }

    /**
     * Triggered after the interval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInterval(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0);
        }
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        if (oldValue !== undefined && this.vdom.cn) {
            let me          = this,
                endTime     = me.getTime(me.endTime),
                startTime   = me.getTime(me.startTime),
                vdom        = me.vdom,
                rowHeight   = me.rowHeight,
                rowsPerItem = me.getRowsPerItem(),
                itemHeight  = rowsPerItem * rowHeight + rowsPerItem, // rowsPerItem * 1px borders
                totalHeight = rowHeight + ((endTime - startTime) * itemHeight),
                i, itemStyle;

            Object.assign(vdom.style, {
                backgroundImage    : `linear-gradient(var(--c-w-background-color) ${itemHeight - 1}px, var(--c-w-border-color) 1px)`,
                backgroundPositionY: `${-itemHeight + 1}px`,
                backgroundSize     : `0.4em ${itemHeight}px`,
                height             : `${totalHeight - rowHeight + 1}px`,
                maxHeight          : `${totalHeight - rowHeight + 1}px`
            });

            for (i=0; i < 25; i++) {
                itemStyle = {
                    height: `${itemHeight}px`
                };

                if (i === startTime) {
                    itemStyle.marginTop = `${-2 - rowHeight * (rowsPerItem === 1 ? 0.5 : rowsPerItem === 2 ? 1 : 2)}px`;
                } else {
                    delete itemStyle.marginTop;
                }

                vdom.cn[i].style = itemStyle;

                vdom.cn[i].removeDom = (i < startTime || i - 1 >= endTime);
            }

            me.fire('change', {
                component: me,
                rowHeight,
                rowsPerItem,
                totalHeight
            });
        }
    }

    /**
     * Triggered after the startTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetStartTime(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0);
        }
    }

    /**
     * Triggered before the interval config gets changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    beforeSetInterval(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'interval');
    }

    /**
     *
     */
    createItems() {
        let vdom = this.vdom,
            html, i;

        vdom.cn = [];

        for (i=0; i < 25; i++) {
            html = i === 24 ? '00:00' : (i < 10 ? '0' : '') + i + ':00';

            vdom.cn.push({
                cls  : ['neo-c-w-timeaxis-item'],
                cn   : [{html: html}]
            });
        }
    }

    /**
     * Calculates the amount of rows related to the interval config
     * @returns {Number}
     */
    getRowsPerItem() {
        return this.interval === 60 ? 1 : this.interval === 30 ? 2 : 4;
    }

    /**
     * Calculates the time for the end- or startTime
     * @param {String} value
     * @returns {Number}
     */
    getTime(value) {
        return value.split(':').map(Number)[0];
    }
}

Neo.applyClassConfig(TimeAxisComponent);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TimeAxisComponent);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X3dlZWtfQ29tcG9uZW50X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDTDtBQUNDO0FBQ0E7QUFDRDs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBYTtBQUNyQztBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiww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OztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQyxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsaUJBQWlCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy93ZWVrL1RpbWVBeGlzQ29tcG9uZW50Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZUNvbXBvbmVudCAgICAgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBEYXRlVXRpbCAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVGltZUF4aXNDb21wb25lbnQgZnJvbSAnLi9UaW1lQXhpc0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG5jb25zdCB0b2RheURhdGUgPSBuZXcgRGF0ZSgpO1xuXG5jb25zdCB0b2RheSA9IHtcbiAgICBkYXkgIDogdG9kYXlEYXRlLmdldERhdGUoKSxcbiAgICBtb250aDogdG9kYXlEYXRlLmdldE1vbnRoKCksXG4gICAgeWVhciA6IHRvZGF5RGF0ZS5nZXRGdWxsWWVhcigpXG59O1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy53ZWVrLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgdGltZUF4aXNQb3NpdGlvblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB0aW1lQXhpc1Bvc2l0aW9ucz1bJ2VuZCcsJ3N0YXJ0J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyB0aW1lQXhpc1Bvc2l0aW9ucyA9IFsnZW5kJywgJ3N0YXJ0J11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LndlZWsuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLXdlZWtjb21wb25lbnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItd2Vla2NvbXBvbmVudCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBjYWxlbmRhclN0b3JlICAgICAgIDogJ3N0b3Jlcy5jYWxlbmRhcnMnLFxuICAgICAgICAgICAgY3VycmVudERhdGUgICAgICAgICA6IGRhdGEgPT4gZGF0YS5jdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGVuYWJsZURyYWcgICAgICAgICAgOiBkYXRhID0+IGRhdGEuZXZlbnRzLmVuYWJsZURyYWcsXG4gICAgICAgICAgICBlbmRUaW1lICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmVuZFRpbWUsXG4gICAgICAgICAgICBldmVudEJvcmRlciAgICAgICAgIDogZGF0YSA9PiBkYXRhLmV2ZW50cy5ib3JkZXIsXG4gICAgICAgICAgICBldmVudFN0b3JlICAgICAgICAgIDogJ3N0b3Jlcy5ldmVudHMnLFxuICAgICAgICAgICAgaW50bEZvcm1hdF90aW1lICAgICA6IGRhdGEgPT4gZGF0YS5pbnRsRm9ybWF0X3RpbWUsXG4gICAgICAgICAgICBsb2NhbGUgICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmxvY2FsZSxcbiAgICAgICAgICAgIG1pbmltdW1FdmVudER1cmF0aW9uOiBkYXRhID0+IGRhdGEubWluaW11bUV2ZW50RHVyYXRpb24sXG4gICAgICAgICAgICBzaG93V2Vla2VuZHMgICAgICAgIDogZGF0YSA9PiBkYXRhLnNob3dXZWVrZW5kcyxcbiAgICAgICAgICAgIHN0YXJ0VGltZSAgICAgICAgICAgOiBkYXRhID0+IGRhdGEuc3RhcnRUaW1lLFxuICAgICAgICAgICAgd2Vla1N0YXJ0RGF5ICAgICAgICA6IGRhdGEgPT4gZGF0YS53ZWVrU3RhcnREYXlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gY2FsZW5kYXJTdG9yZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY2FsZW5kYXJTdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbW91bnQgb2YgaGlkZGVuIGNvbHVtbnMgb24gYm90aCBzaWRlcyBlYWNoIGluc2lkZSB0aGlzIHZpZXcuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29sdW1uc0J1ZmZlcl89N1xuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uc0J1ZmZlcl86IDcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbW91bnQgb2YgdmlzaWJsZSBjb2x1bW5zIGluc2lkZSB0aGlzIHZpZXcuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29sdW1uc1Zpc2libGVfPTdcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbnNWaXNpYmxlXzogNyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsLlxuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfG51bGx9IGN1cnJlbnREYXRlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnREYXRlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmb3JtYXQgb2YgdGhlIGNvbHVtbiBoZWFkZXJzLlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXMgYXJlOiBuYXJyb3csIHNob3J0ICYgbG9uZ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRheU5hbWVGb3JtYXRfPSdzaG9ydCdcbiAgICAgICAgICovXG4gICAgICAgIGRheU5hbWVGb3JtYXRfOiAnc2hvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZURyYWdfPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlRHJhZ186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZXZlbnRCb3JkZXJfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50Qm9yZGVyXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LndlZWsuRXZlbnREcmFnWm9uZXxudWxsfSBldmVudERyYWdab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50RHJhZ1pvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IGV2ZW50U3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50U3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgcGFzc2VkIGZyb20gdXBkYXRlSGVhZGVyKClcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBmaXJzdENvbHVtbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmaXJzdENvbHVtbkRhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIGNoZWNrIGlmIHVwZGF0ZUhlYWRlcih0cnVlKSBoYXMgYWxyZWFkeSBydW5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGVhZGVyQ3JlYXRlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJDcmVhdGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gaW50bEZvcm1hdF9kYXk9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRsRm9ybWF0X2RheTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsLlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfdGltZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRsRm9ybWF0X3RpbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNVcGRhdGluZz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1VwZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxvY2FsZV89TmVvLmNvbmZpZy5sb2NhbGVcbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZV86IE5lby5jb25maWcubG9jYWxlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGltZSBpbiBtaW51dGVzLiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtaW5pbXVtRXZlbnREdXJhdGlvbj0zMFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtaW5pbXVtRXZlbnREdXJhdGlvbjogMzAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHN0b3JlIGlmIHVwZGF0ZUV2ZW50cygpIGdvdCBjYWxsZWQgd2hpbGUgbm90IGJlaW5nIG1vdW50ZWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbmVlZHNFdmVudFVwZGF0ZT1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBuZWVkc0V2ZW50VXBkYXRlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXJ8bnVsbH0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbmZpZyB2YWx1ZXMgZm9yIE5lby5jYWxlbmRhci52aWV3LndlZWsucGx1Z2luLkRyYWdEcm9wXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcGx1Z2luRHJhZ0Ryb3BDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGx1Z2luRHJhZ0Ryb3BDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb25maWcgdmFsdWVzIGZvciBOZW8uY2FsZW5kYXIudmlldy53ZWVrLnBsdWdpbi5FdmVudFJlc2l6YWJsZVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHBsdWdpblJlc2l6YWJsZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwbHVnaW5FdmVudFJlc2l6YWJsZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dFdmVudEVuZFRpbWVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93RXZlbnRFbmRUaW1lXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd1dlZWtlbmRzXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93V2Vla2VuZHNfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB0aW1lQXhpcz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lQXhpczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdGltZUF4aXNDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGltZUF4aXNDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NpdGlvbiB0aGUgdGltZUF4aXMgYXQgdGhlIGxlZnQgb3IgcmlnaHQgc2lkZS5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZSBzdGFydCAmIGVuZC5cbiAgICAgICAgICogc3RhcnQgPT4gbGVmdCwgZW5kID0+IHJpZ2h0IGluIExUUiBtb2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRpbWVBeGlzUG9zaXRpb25fPSdzdGFydCdcbiAgICAgICAgICovXG4gICAgICAgIHRpbWVBeGlzUG9zaXRpb25fOiAnc3RhcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBzdG9yZSB0aGUgdG90YWwgYW1vdW50IG9mIHJlbmRlcmVkIGNvbHVtbnMuXG4gICAgICAgICAqIENoYW5naW5nIGNvbHVtbnNCdWZmZXIgb3IgY29sdW1uc1Zpc2libGUgd2lsbCB1cGRhdGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRvdGFsQ29sdW1ucz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRvdGFsQ29sdW1uczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1zY3JvbGwtb3ZlcmxheSddfSxcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWMtdy1zY3JvbGxjb250YWluZXInXSwgZmxhZzogJ25lby1jLXctc2Nyb2xsY29udGFpbmVyJywgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1oZWFkZXItcm93J10sIGZsYWc6ICduZW8taGVhZGVyLXJvdycsIGNuOiBbXX0sXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tYy13LWNvbHVtbi10aW1lYXhpcy1jb250YWluZXInXSwgZmxhZzogJ25lby1jLXctY29sdW1uLXRpbWVheGlzLWNvbnRhaW5lcicsIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWMtdy1jb2x1bW4tY29udGFpbmVyJ10sIGZsYWc6ICduZW8tYy13LWNvbHVtbi1jb250YWluZXInLCBzdHlsZToge30sIGNuOiBbXX1cbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwLTYgPT4gU3VuLVNhdFxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWVrU3RhcnREYXlfPTBcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtTdGFydERheV86IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7ZGJsY2xpY2s6IG1lLm9uRXZlbnREb3VibGVDbGljaywgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tZXZlbnQnfSxcbiAgICAgICAgICAgIHt3aGVlbCAgIDogbWUub25XaGVlbCwgICAgICAgICAgICBzY29wZTogbWV9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIG1lLnRpbWVBeGlzID0gTmVvLmNyZWF0ZShUaW1lQXhpc0NvbXBvbmVudCwge1xuICAgICAgICAgICAgYXBwTmFtZSAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5pZCxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgIGNoYW5nZTogbWUub25UaW1lQXhpc0NoYW5nZSxcbiAgICAgICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ubWUudGltZUF4aXNDb25maWdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZ2V0Q29sdW1uVGltZUF4aXNDb250YWluZXIoKS5jblttZS50aW1lQXhpc1Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShtZS50aW1lQXhpcy52ZG9tKTtcblxuICAgICAgICBpZiAobWUuY2FsZW5kYXJTdG9yZS5nZXRDb3VudCgpID4gMCAmJiBtZS5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBtZS5uZWVkc0V2ZW50VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZUhlYWRlcih0cnVlLCBtZS5uZWVkc0V2ZW50VXBkYXRlKTtcblxuICAgICAgICBtZS5uZWVkc0V2ZW50VXBkYXRlICYmIG1lLnVwZGF0ZUV2ZW50cyhmYWxzZSk7XG5cbiAgICAgICAgbWUuaGVhZGVyQ3JlYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dzUGVySXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnRvdGFsSGVpZ2h0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIGFkanVzdFRvdGFsSGVpZ2h0KGRhdGEsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcm93SGVpZ2h0ICAgPSBkYXRhLnJvd0hlaWdodCxcbiAgICAgICAgICAgIHJvd3NQZXJJdGVtID0gZGF0YS5yb3dzUGVySXRlbSxcbiAgICAgICAgICAgIGhlaWdodCAgICAgID0gZGF0YS50b3RhbEhlaWdodCAtIHJvd0hlaWdodCxcbiAgICAgICAgICAgIGkgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGdyYWRpZW50ICAgID0gW107XG5cbiAgICAgICAgZm9yICg7IGkgPCByb3dzUGVySXRlbTsgaSsrKSB7XG4gICAgICAgICAgICBncmFkaWVudC5wdXNoKFxuICAgICAgICAgICAgICAgIGB2YXIoLS1jLXctYmFja2dyb3VuZC1jb2xvcikgJHtpICogcm93SGVpZ2h0ICsgaX1weGAsXG4gICAgICAgICAgICAgICAgYHZhcigtLWMtdy1iYWNrZ3JvdW5kLWNvbG9yKSAkeyhpICsgMSkgKiByb3dIZWlnaHQgKyBpfXB4YCxcbiAgICAgICAgICAgICAgICAndmFyKC0tYy13LWJvcmRlci1jb2xvcikgMCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLmdldENvbHVtbkNvbnRhaW5lcigpLnN0eWxlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGBsaW5lYXItZ3JhZGllbnQoJHtncmFkaWVudC5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSA6IGAxcHggJHtyb3dzUGVySXRlbSAqIHJvd0hlaWdodCArIHJvd3NQZXJJdGVtfXB4YCxcbiAgICAgICAgICAgIGhlaWdodCAgICAgICAgIDogYCR7aGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIG1heEhlaWdodCAgICAgIDogYCR7aGVpZ2h0fXB4YFxuICAgICAgICB9KTtcblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2FsZW5kYXJTdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDYWxlbmRhclN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25DYWxlbmRhclN0b3JlTG9hZCxcbiAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25DYWxlbmRhclN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9O1xuXG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbHVtbnNCdWZmZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29sdW1uc0J1ZmZlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy50b3RhbENvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zICsgMiAqIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29sdW1uc1Zpc2libGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29sdW1uc1Zpc2libGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudG90YWxDb2x1bW5zID0gMiAqIHRoaXMuY29sdW1uc0J1ZmZlciArIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY3VycmVudERhdGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtEYXRlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDdXJyZW50RGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXlOYW1lRm9ybWF0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaW50bEZvcm1hdF9kYXkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChtZS5sb2NhbGUsIHt3ZWVrZGF5OiB2YWx1ZX0pO1xuICAgICAgICBvbGRWYWx1ZSAmJiBtZS51cGRhdGVIZWFkZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVuYWJsZURyYWcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFbmFibGVEcmFnKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuZ2V0UGx1Z2luKHtmbGFnOiAnZHJhZ2Ryb3AnfSkpIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4vcGx1Z2luL0RyYWdEcm9wLm1qcycpLFxuICAgICAgICAgICAgICAgIGltcG9ydCgnLi9wbHVnaW4vRXZlbnRSZXNpemFibGUubWpzJylcbiAgICAgICAgICAgIF0pLnRoZW4obW9kdWxlcyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSA6IG1vZHVsZXNbMF0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmxhZyAgIDogJ2RyYWdkcm9wJyxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUucGx1Z2luRHJhZ0Ryb3BDb25maWdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IG1vZHVsZXNbMV0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGlvbkNsczogJ25lby1ldmVudCcsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMgICA6IFsnYicsICd0J10sXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgICAgICAgICA6ICdyZXNpemFibGUnLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5wbHVnaW5FdmVudFJlc2l6YWJsZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRCb3JkZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEV2ZW50Qm9yZGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBvbGRWYWx1ZSAmJiBOZW9BcnJheS5yZW1vdmUoY2xzLCBgbmVvLWV2ZW50LWJvcmRlci0ke29sZFZhbHVlfWApO1xuICAgICAgICB2YWx1ZSAgICAmJiBOZW9BcnJheS5hZGQoICAgY2xzLCBgbmVvLWV2ZW50LWJvcmRlci0ke3ZhbHVlfWApO1xuXG4gICAgICAgIG1lLmNscyA9IGNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50U3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uRXZlbnRTdG9yZUxvYWQsXG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6IG1lLm9uRXZlbnRTdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfTtcblxuICAgICAgICBvbGRWYWx1ZT8udW4obGlzdGVuZXJzKTtcbiAgICAgICAgdmFsdWUgICA/Lm9uKGxpc3RlbmVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsb2NhbGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TG9jYWxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLmludGxGb3JtYXRfZGF5ICA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHZhbHVlLCB7d2Vla2RheTogbWUuZGF5TmFtZUZvcm1hdH0pO1xuICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmVjdDtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChtZS5uZWVkc0V2ZW50VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCBOZW8udGltZW91dCg3MCk7XG5cbiAgICAgICAgICAgIHJlY3QgPSBhd2FpdCBtZS5nZXREb21SZWN0KG1lLmdldENvbHVtbkNvbnRhaW5lcigpLmlkKTtcblxuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5nZXRTY3JvbGxDb250YWluZXIoKS5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHJlY3Qud2lkdGggKiBtZS5jb2x1bW5zQnVmZmVyIC8gbWUuY29sdW1uc1Zpc2libGUgLyAzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0V2ZW50RW5kVGltZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dFdmVudEVuZFRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dXZWVrZW5kcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dXZWVrZW5kcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBtZS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tc2hvdy13ZWVrZW5kcycpO1xuXG4gICAgICAgIG1lLl9jbHMgPSBjbHM7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aW1lQXhpc1Bvc2l0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRpbWVBeGlzUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgICA9IG1lLmNscyxcbiAgICAgICAgICAgIHRpbWVBeGlzQ29udGFpbmVyID0gbWUuZ2V0Q29sdW1uVGltZUF4aXNDb250YWluZXIoKTtcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA9PT0gJ2VuZCcgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tdGltZWF4aXMtZW5kJyk7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVBeGlzQ29udGFpbmVyLmNuLnVuc2hpZnQodGltZUF4aXNDb250YWluZXIuY24ucG9wKCkpOyAvLyBzd2l0Y2ggdGhlIG9yZGVyIG9mIHRoZSAyIGl0ZW1zXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jbHMgPSBjbHM7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3ZWVrU3RhcnREYXkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2Vla1N0YXJ0RGF5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFkZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRheU5hbWVGb3JtYXQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREYXlOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZGF5TmFtZUZvcm1hdCcsIERhdGVVdGlsLnByb3RvdHlwZS5kYXlOYW1lRm9ybWF0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgdGltZUF4aXNQb3NpdGlvbiBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFRpbWVBeGlzUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICd0aW1lQXhpc1Bvc2l0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgd2Vla1N0YXJ0RGF5IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0V2Vla1N0YXJ0RGF5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnd2Vla1N0YXJ0RGF5JywgRGF0ZVV0aWwucHJvdG90eXBlLndlZWtTdGFydERheXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlQ29sdW1uQW5kSGVhZGVyKGRhdGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbkNscyAgID0gWyduZW8tYy13LWNvbHVtbicsICduZW8tZHJhZ2dhYmxlJ10sXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgY3VycmVudERheSAgPSBkYXRlLmdldERheSgpLFxuICAgICAgICAgICAgZGF0ZUNscyAgICAgPSBbJ25lby1kYXRlJ10sXG4gICAgICAgICAgICByZW1vdmVEb20gICA9IGZhbHNlLFxuICAgICAgICAgICAgY29sdW1uLCBoZWFkZXI7XG5cbiAgICAgICAgaWYgKGN1cnJlbnREYXkgPT09IDAgfHwgY3VycmVudERheSA9PT0gNikge1xuICAgICAgICAgICAgY29sdW1uQ2xzLnB1c2goJ25lby13ZWVrZW5kJyk7XG4gICAgICAgICAgICAhbWUuc2hvd1dlZWtlbmRzICYmIChyZW1vdmVEb20gPSB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGF0ZSA9PT0gdG9kYXkuZGF5ICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gdG9kYXkubW9udGggJiYgZGF0ZS5nZXRGdWxsWWVhcigpID09PSB0b2RheS55ZWFyKSB7XG4gICAgICAgICAgICBkYXRlQ2xzLnB1c2goJ25lby10b2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1uID0ge2NsczogY29sdW1uQ2xzLCBmbGFnOiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKSwgcmVtb3ZlRG9tfTtcblxuICAgICAgICBoZWFkZXIgPVxuICAgICAgICB7Y2xzOiBbJ25lby1oZWFkZXItcm93LWl0ZW0nXSwgcmVtb3ZlRG9tOiByZW1vdmVEb20sIGNuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1kYXknXSwgaHRtbDogbWUuaW50bEZvcm1hdF9kYXkuZm9ybWF0KGRhdGUpfSxcbiAgICAgICAgICAgIHtjbHM6IGRhdGVDbHMsICAgICBodG1sOiBjdXJyZW50RGF0ZX1cbiAgICAgICAgXX07XG5cbiAgICAgICAgcmV0dXJuIHtjb2x1bW4sIGhlYWRlcn07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy50aW1lQXhpcyA9IG51bGw7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldENvbHVtbkNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmdldEJ5RmxhZyh0aGlzLnZkb20sICduZW8tYy13LWNvbHVtbi1jb250YWluZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbHVtbklkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X2NvbF8ke0RhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5IZWFkZXJJZChkYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9jaF8ke0RhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5UaW1lQXhpc0NvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmdldEJ5RmxhZyh0aGlzLnZkb20sICduZW8tYy13LWNvbHVtbi10aW1lYXhpcy1jb250YWluZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRFdmVudElkKHJlY29yZElkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHtyZWNvcmRJZH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZ2V0QnlGbGFnKHRoaXMudmRvbSwgJ25lby1oZWFkZXItcm93Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBpbnNpZGUgY3JlYXRlSWQoKSBhcyB0aGUgZGVmYXVsdCB2YWx1ZSBwYXNzZWQgdG8gdGhlIElkR2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWRLZXkoKSB7XG4gICAgICAgIHJldHVybiAnYy13JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFNjcm9sbENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmdldEJ5RmxhZyh0aGlzLnZkb20sICduZW8tYy13LXNjcm9sbGNvbnRhaW5lcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVMb2FkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwICYmIHRoaXMudXBkYXRlRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudERvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ldmVudHMuZW5hYmxlRWRpdCkge1xuICAgICAgICAgICAgIWRhdGEucGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1ldmVudCcpICYmIGRhdGEucGF0aC5zaGlmdCgpO1xuXG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBlZGl0RXZlbnRDb250YWluZXIgPSBtZS5vd25lci5lZGl0RXZlbnRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgZXZlbnROb2RlICAgICAgICAgID0gZGF0YS5wYXRoWzBdLFxuICAgICAgICAgICAgICAgIGV2ZW50VmRvbSAgICAgICAgICA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQobWUudmRvbSwgZXZlbnROb2RlLmlkKS52ZG9tLFxuICAgICAgICAgICAgICAgIHJlY29yZCAgICAgICAgICAgICA9IG1lLmV2ZW50U3RvcmUuZ2V0KGV2ZW50VmRvbS5mbGFnKSxcbiAgICAgICAgICAgICAgICBzdHlsZSAgICAgICAgICAgICAgPSBlZGl0RXZlbnRDb250YWluZXIuc3R5bGU7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHtsZWZ0OiBgJHtldmVudE5vZGUucmVjdC53aWR0aCArIDE1fXB4YCwgdG9wOiBldmVudFZkb20uc3R5bGUudG9wfSk7XG4gICAgICAgICAgICBlZGl0RXZlbnRDb250YWluZXIuc2V0U2lsZW50KHtwYXJlbnRJZDogZGF0YS5wYXRoWzFdLmlkLCByZWNvcmQsIHN0eWxlfSk7XG4gICAgICAgICAgICBlZGl0RXZlbnRDb250YWluZXIucmVuZGVyKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnRTdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudFN0b3JlUmVjb3JkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucGF0aFxuICAgICAqL1xuICAgIG9uRm9jdXNDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgb2xkUGF0aCA9IGRhdGEub2xkUGF0aCxcbiAgICAgICAgICAgIHBhdGggICAgPSBkYXRhLnBhdGg7XG5cbiAgICAgICAgb2xkUGF0aD8uWzBdPy5jbHMuaW5jbHVkZXMoJ25lby1ldmVudCcpICYmIE5lby5hcHBseURlbHRhcyh0aGlzLmFwcE5hbWUsIHtpZDogb2xkUGF0aFswXS5pZCwgY2xzOiB7cmVtb3ZlOiBbJ25lby1mb2N1cyddfX0pO1xuICAgICAgICBwYXRoICAgPy5bMF0/LmNscy5pbmNsdWRlcygnbmVvLWV2ZW50JykgJiYgTmVvLmFwcGx5RGVsdGFzKHRoaXMuYXBwTmFtZSwge2lkOiBwYXRoWzBdICAgLmlkLCBjbHM6IHthZGQ6ICAgIFsnbmVvLWZvY3VzJ119fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dzUGVySXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnRvdGFsSGVpZ2h0XG4gICAgICovXG4gICAgb25UaW1lQXhpc0NoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRqdXN0VG90YWxIZWlnaHQoZGF0YSwgbWUuaGVhZGVyQ3JlYXRlZCk7XG4gICAgICAgIG1lLmhlYWRlckNyZWF0ZWQgJiYgbWUudXBkYXRlRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbldoZWVsKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRpbmcgJiYgTWF0aC5hYnMoZGF0YS5kZWx0YVgpID4gTWF0aC5hYnMoZGF0YS5kZWx0YVkpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBjb2x1bW5zICAgICAgICAgPSBtZS5nZXRDb2x1bW5Db250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zQnVmZmVyICAgPSBtZS5jb2x1bW5zQnVmZmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbnNWaXNpYmxlICA9IG1lLmNvbHVtbnNWaXNpYmxlLFxuICAgICAgICAgICAgICAgIGZpcnN0Q29sdW1uRGF0ZSA9IG1lLmZpcnN0Q29sdW1uRGF0ZSxcbiAgICAgICAgICAgICAgICBoZWFkZXIgICAgICAgICAgPSBtZS5nZXRIZWFkZXJDb250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIHRpbWVBeGlzV2lkdGggICA9IDUwLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICAgICA9IGRhdGEuY2xpZW50V2lkdGggLSB0aW1lQXhpc1dpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZywgZGF0ZSwgc2Nyb2xsVmFsdWU7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEuc2Nyb2xsTGVmdCwgTWF0aC5yb3VuZChkYXRhLnNjcm9sbExlZnQgLyAoZGF0YS5jbGllbnRXaWR0aCAtIHRpbWVBeGlzV2lkdGgpICogNykpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5kZWx0YVggPiAwICYmIE1hdGgucm91bmQoZGF0YS5zY3JvbGxMZWZ0IC8gd2lkdGggKiBjb2x1bW5zQnVmZmVyKSA+IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZSAtIDEpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoY29sdW1ucy5jbltjb2x1bW5zLmNuLmxlbmd0aCAtIDFdLmZsYWcpO1xuXG4gICAgICAgICAgICAgICAgY29sdW1ucy5jbi5zcGxpY2UoMCwgY29sdW1uc0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgaGVhZGVyIC5jbi5zcGxpY2UoMCwgY29sdW1uc0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvbHVtbnNCdWZmZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBtZS5jcmVhdGVDb2x1bW5BbmRIZWFkZXIoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5jbi5wdXNoKGNvbmZpZy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLnB1c2goY29uZmlnLmhlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlyc3RDb2x1bW5EYXRlLnNldERhdGUoZmlyc3RDb2x1bW5EYXRlLmdldERhdGUoKSArIGNvbHVtbnNCdWZmZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIG1vdmUgdGhlIGV2ZW50IHJlbmRlcmluZyBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgICAgICAgICAgICAvLyBEZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjIxNlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge21lLnVwZGF0ZUV2ZW50cyhmYWxzZSwgY29sdW1uc0J1ZmZlciArIGNvbHVtbnNWaXNpYmxlLCBtZS50b3RhbENvbHVtbnMpfSwgNTApO1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuZGVsdGFYIDwgMCAmJiBNYXRoLnJvdW5kKGRhdGEuc2Nyb2xsTGVmdCAvIHdpZHRoICogY29sdW1uc0J1ZmZlcikgPCAxKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGNvbHVtbnMuY25bMF0uZmxhZyk7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLmxlbmd0aCA9IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZTtcbiAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLmxlbmd0aCA9IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZTtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY29sdW1uc0J1ZmZlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lLmNyZWF0ZUNvbHVtbkFuZEhlYWRlcihkYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLnVuc2hpZnQoY29uZmlnLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciAuY24udW5zaGlmdChjb25maWcuaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJzdENvbHVtbkRhdGUuc2V0RGF0ZShmaXJzdENvbHVtbkRhdGUuZ2V0RGF0ZSgpIC0gY29sdW1uc0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGEgc2hvcnQgZGVsYXkgdG8gbW92ZSB0aGUgZXZlbnQgcmVuZGVyaW5nIGludG8gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAgICAgICAgICAgIC8vIERldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMjE2XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7bWUudXBkYXRlRXZlbnRzKGZhbHNlLCAwLCBjb2x1bW5zQnVmZmVyKX0sIDUwKTtcblxuICAgICAgICAgICAgICAgIHNjcm9sbFZhbHVlID0gd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVZkb21VcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5nZXRTY3JvbGxDb250YWluZXIoKS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogc2Nyb2xsVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICovXG4gICAgc2V0Rmlyc3RDb2x1bW5EYXRlKGRhdGUpIHtcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gZGF0ZS5nZXREYXkoKSArIHRoaXMud2Vla1N0YXJ0RGF5IC0gdGhpcy5jb2x1bW5zQnVmZmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWxnb3JpdGhtIHJlbGllcyBvbiB0aGUgZXZlbnRTdG9yZSBiZWluZyBzb3J0ZWQgYnkgc3RhcnREYXRlIEFTQ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXg9MF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4PXRoaXMudG90YWxDb2x1bW5zXVxuICAgICAqL1xuICAgIHVwZGF0ZUV2ZW50cyhzaWxlbnQ9ZmFsc2UsIHN0YXJ0SW5kZXg9MCwgZW5kSW5kZXg9dGhpcy50b3RhbENvbHVtbnMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm5lZWRzRXZlbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNhbGVuZGFyU3RvcmUgICAgID0gbWUuY2FsZW5kYXJTdG9yZSxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlICAgICAgICA9IG1lLmV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgdGltZUF4aXMgICAgICAgICAgPSBtZS50aW1lQXhpcyxcbiAgICAgICAgICAgICAgICBlbmRUaW1lICAgICAgICAgICA9IHRpbWVBeGlzLmdldFRpbWUobWUuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lICAgICAgICAgPSB0aW1lQXhpcy5nZXRUaW1lKG1lLnN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgdG90YWxUaW1lICAgICAgICAgPSBlbmRUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGRhdGUgICAgICAgICAgICAgID0gRGF0ZVV0aWwuY2xvbmUobWUuZmlyc3RDb2x1bW5EYXRlKSxcbiAgICAgICAgICAgICAgICB2ZG9tICAgICAgICAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICAgICAgY29udGVudCAgICAgICAgICAgPSBtZS5nZXRDb2x1bW5Db250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBqICAgICAgICAgICAgICAgICA9IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgc2hvd0V2ZW50RW5kVGltZSAgPSBtZS5zaG93RXZlbnRFbmRUaW1lLFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyUmVjb3JkLCBjb2x1bW4sIGRheVJlY29yZHMsIGR1cmF0aW9uLCBlbmREYXRlLCBldmVudENscywgZXZlbnRJbnRlcnZhbHMsIGhhc092ZXJmbG93LCBoZWlnaHQsIGksXG4gICAgICAgICAgICAgICAgbGVuLCByZWNvcmQsIHJlY29yZEtleSwgc3RhcnREYXRlLCBzdGFydEhvdXJzLCB0b3A7XG5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0YXJ0SW5kZXgpO1xuXG4gICAgICAgICAgICBmb3IgKDsgaiA8IGVuZEluZGV4OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb250ZW50LmNuW2pdO1xuXG4gICAgICAgICAgICAgICAgY29sdW1uLmNuID0gW107IC8vIHJlbW92ZSBwcmV2aW91cyBldmVudHMgZnJvbSB0aGUgdmRvbVxuXG4gICAgICAgICAgICAgICAgZGF5UmVjb3JkcyA9IGV2ZW50U3RvcmUuZ2V0RGF5UmVjb3JkcyhkYXRlKTtcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgID0gZGF5UmVjb3Jkcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkICAgICAgICAgPSBkYXlSZWNvcmRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhclJlY29yZCA9IGNhbGVuZGFyU3RvcmUuZ2V0KHJlY29yZC5jYWxlbmRhcklkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJSZWNvcmQ/LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZSAgID0gcmVjb3JkLmVuZERhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUgPSByZWNvcmQuc3RhcnREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kVGltZSA8PSBzdGFydERhdGUuZ2V0SG91cnMoKSB8fCBzdGFydFRpbWUgPj0gZW5kRGF0ZS5nZXRIb3VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRUaW1lIDwgZW5kRGF0ZS5nZXRIb3VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZSA9IERhdGVVdGlsLmNsb25lKGVuZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoZW5kVGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lID4gc3RhcnREYXRlLmdldEhvdXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUgPSBEYXRlVXRpbC5jbG9uZShzdGFydERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiAgICAgICA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwOyAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRDbHMgICAgICAgPSBbJ25lby1ldmVudCcsICduZW8tZHJhZ2dhYmxlJywgYG5lby0ke2NhbGVuZGFyUmVjb3JkLmNvbG9yfWBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnRlcnZhbHMgPSBkdXJhdGlvbiAqIDYwIC8gdGltZUF4aXMuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPdmVyZmxvdyAgICA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgICAgPSBNYXRoLnJvdW5kKGR1cmF0aW9uIC8gdG90YWxUaW1lICogMTAwICogMTAwMCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkS2V5ICAgICAgPSByZWNvcmRbZXZlbnRTdG9yZS5rZXlQcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEhvdXJzICAgICA9IChzdGFydERhdGUuZ2V0SG91cnMoKSAqIDYwICsgc3RhcnREYXRlLmdldE1pbnV0ZXMoKSkgLyA2MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgICAgICAgICAgID0gTWF0aC5yb3VuZCgoc3RhcnRIb3VycyAtIHN0YXJ0VGltZSkgLyB0b3RhbFRpbWUgKiAxMDAgKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEludGVydmFscyA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3cgPSB0aW1lQXhpcy5yb3dIZWlnaHQgKiBldmVudEludGVydmFscyA8IChzaG93RXZlbnRFbmRUaW1lID8gNTAgOiAzNCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcmZsb3cgJiYgIShzaG93RXZlbnRFbmRUaW1lICYmICh0aW1lQXhpcy5yb3dIZWlnaHQgLyBldmVudEludGVydmFscyA+PSAzNCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xzLnB1c2goJ25lby1vdmVyZmxvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50RW5kVGltZSA9ICEoaGFzT3ZlcmZsb3cgJiYgZXZlbnRJbnRlcnZhbHMgPT09IDEgfHwgIXNob3dFdmVudEVuZFRpbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRFbmRUaW1lICYmIGV2ZW50Q2xzLnB1c2goJ25lby1zaG93LWVuZC10aW1lJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgIDogZXZlbnRDbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyAgICA6IHJlY29yZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuZ2V0RXZlbnRJZChyZWNvcmRLZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiAtMSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNuOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1ldmVudC10aW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IG1lLmludGxGb3JtYXRfdGltZS5mb3JtYXQocmVjb3JkLnN0YXJ0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICA6IGAke21lLmlkfV9fdGltZV9fJHtyZWNvcmRLZXl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZXZlbnQtdGl0bGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogcmVjb3JkLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgOiBgJHttZS5pZH1fX3RpdGxlX18ke3JlY29yZEtleX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWV2ZW50LXRpbWUnLCAnbmVvLWV2ZW50LWVuZC10aW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgICAgIDogbWUuaW50bEZvcm1hdF90aW1lLmZvcm1hdChyZWNvcmQuZW5kRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogYCR7bWUuaWR9X19lbmRkYXRlX18ke3JlY29yZEtleX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVEb206ICFzaG93RXZlbnRFbmRUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGBjYWxjKCR7aGVpZ2h0fSUgLSAycHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBgY2FsYygke3RvcH0lICsgMXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogJ2NhbGMoMTAwJSAtIDFweCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWVbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSB2ZG9tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3JlYXRlPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICB1cGRhdGVIZWFkZXIoY3JlYXRlPWZhbHNlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRlICAgICAgICAgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgY29udGVudCAgICAgID0gbWUuZ2V0Q29sdW1uQ29udGFpbmVyKCksXG4gICAgICAgICAgICBoZWFkZXIgICAgICAgPSBtZS5nZXRIZWFkZXJDb250YWluZXIoKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBzaG93V2Vla2VuZHMgPSBtZS5zaG93V2Vla2VuZHMsXG4gICAgICAgICAgICBjb2x1bW5DbHMsIGN1cnJlbnREYXRlLCBjdXJyZW50RGF5LCBkYXRlQ2xzLCBoZWFkZXJJZCwgcmVtb3ZlRG9tO1xuXG4gICAgICAgIG1lLnNldEZpcnN0Q29sdW1uRGF0ZShkYXRlKTtcblxuICAgICAgICBtZS5maXJzdENvbHVtbkRhdGUgPSBEYXRlVXRpbC5jbG9uZShkYXRlKTtcblxuICAgICAgICBmb3IgKDsgaSA8IG1lLnRvdGFsQ29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5DbHMgICA9IFsnbmVvLWMtdy1jb2x1bW4nLCAnbmVvLWRyYWdnYWJsZSddO1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIGN1cnJlbnREYXkgID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgIGRhdGVDbHMgICAgID0gWyduZW8tZGF0ZSddO1xuICAgICAgICAgICAgcmVtb3ZlRG9tICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnREYXkgPT09IDAgfHwgY3VycmVudERheSA9PT0gNikge1xuICAgICAgICAgICAgICAgIGNvbHVtbkNscy5wdXNoKCduZW8td2Vla2VuZCcpO1xuICAgICAgICAgICAgICAgICFzaG93V2Vla2VuZHMgJiYgKHJlbW92ZURvbSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudERhdGUgPT09IHRvZGF5LmRheSAmJiBkYXRlLmdldE1vbnRoKCkgPT09IHRvZGF5Lm1vbnRoICYmIGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gdG9kYXkueWVhcikge1xuICAgICAgICAgICAgICAgIGRhdGVDbHMucHVzaCgnbmVvLXRvZGF5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcklkID0gbWUuZ2V0Q29sdW1uSGVhZGVySWQoZGF0ZSk7XG5cbiAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LmNuLnB1c2goe2NsczogY29sdW1uQ2xzLCBmbGFnOiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKSwgaWQ6IG1lLmdldENvbHVtbklkKGRhdGUpLCByZW1vdmVEb219KTtcblxuICAgICAgICAgICAgICAgIGhlYWRlci5jbi5wdXNoKFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWhlYWRlci1yb3ctaXRlbSddLCBpZDogaGVhZGVySWQsIHJlbW92ZURvbSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tZGF5J10sIGh0bWw6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKSwgaWQ6IGAke2hlYWRlcklkfV9kYXlgfSxcbiAgICAgICAgICAgICAgICAgICAge2NscyA6IGRhdGVDbHMsICAgIGh0bWw6IGN1cnJlbnREYXRlLCAgICAgICAgICAgICAgICAgICAgaWQ6IGAke2hlYWRlcklkfV9kYXRlYH1cbiAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGVudC5jbltpXSwge1xuICAgICAgICAgICAgICAgICAgICBjbHMgOiBjb2x1bW5DbHMsXG4gICAgICAgICAgICAgICAgICAgIGZsYWc6IERhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpZCAgOiBtZS5nZXRDb2x1bW5JZChkYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlci5jbltpXSwgICAgICAge2lkOiBoZWFkZXJJZCwgcmVtb3ZlRG9tfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXIuY25baV0uY25bMF0sIHtodG1sOiBtZS5pbnRsRm9ybWF0X2RheS5mb3JtYXQoZGF0ZSksIGlkOiBgJHtoZWFkZXJJZH1fZGF5YH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVyLmNuW2ldLmNuWzFdLCB7Y2xzOiBkYXRlQ2xzLCBodG1sOiBjdXJyZW50RGF0ZSwgaWQ6IGAke2hlYWRlcklkfV9kYXRlYH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5UaW1lQXhpc0NvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFRpbWVBeGlzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGludGVydmFsXG4gICAgICogQG1lbWJlciB7TnVtYmVyW119IGludGVydmFscz1bMTUsMzAsNjBdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJ2YWxzID0gWzE1LCAzMCwgNjBdXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LndlZWsuVGltZUF4aXNDb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LndlZWsuVGltZUF4aXNDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2FsZW5kYXItdGltZWF4aXMnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItdGltZWF4aXMnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgZW5kVGltZSAgOiBkYXRhID0+IGRhdGEuZW5kVGltZSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogZGF0YSA9PiBkYXRhLnN0YXJ0VGltZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBmdWxsIGhvdXJzIGFyZSB2YWxpZCBmb3Igbm93XG4gICAgICAgICAqIGZvcm1hdDogJ2hoOm1tJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGVuZFRpbWVfPScyNDowMCdcbiAgICAgICAgICovXG4gICAgICAgIGVuZFRpbWVfOiAnMjQ6MDAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgaW50ZXJ2YWwgaW4gbWludXRlcyB0byBkaXNwbGF5IGFzIHJvd3MuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogMTUsIDMwLCA2MFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGludGVydmFsXz0zMFxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJ2YWxfOiAzMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm93SGVpZ2h0Xz0yMFxuICAgICAgICAgKi9cbiAgICAgICAgcm93SGVpZ2h0XzogMjAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGZ1bGwgaG91cnMgYXJlIHZhbGlkIGZvciBub3dcbiAgICAgICAgICogZm9ybWF0OiAnaGg6bW0nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc3RhcnRUaW1lXz0nMDA6MDAnXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydFRpbWVfOiAnMDA6MDAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tXG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOlxuICAgICAgICB7c3R5bGU6IHt9fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY3JlYXRlSXRlbXMoKTtcbiAgICAgICAgbWUuYWZ0ZXJTZXRSb3dIZWlnaHQobWUucm93SGVpZ2h0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVuZFRpbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RW5kVGltZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIHRvZG86IGhhbmRsZSAyNDowMCBhcyAyMzo1OVxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLl9lbmRUaW1lID0gJzI0OjAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuYWZ0ZXJTZXRSb3dIZWlnaHQobWUucm93SGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyU2V0Um93SGVpZ2h0KHRoaXMucm93SGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy52ZG9tLmNuKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUgICAgID0gbWUuZ2V0VGltZShtZS5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgICA9IG1lLmdldFRpbWUobWUuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICB2ZG9tICAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0ICAgPSBtZS5yb3dIZWlnaHQsXG4gICAgICAgICAgICAgICAgcm93c1Blckl0ZW0gPSBtZS5nZXRSb3dzUGVySXRlbSgpLFxuICAgICAgICAgICAgICAgIGl0ZW1IZWlnaHQgID0gcm93c1Blckl0ZW0gKiByb3dIZWlnaHQgKyByb3dzUGVySXRlbSwgLy8gcm93c1Blckl0ZW0gKiAxcHggYm9yZGVyc1xuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0ID0gcm93SGVpZ2h0ICsgKChlbmRUaW1lIC0gc3RhcnRUaW1lKSAqIGl0ZW1IZWlnaHQpLFxuICAgICAgICAgICAgICAgIGksIGl0ZW1TdHlsZTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlICAgIDogYGxpbmVhci1ncmFkaWVudCh2YXIoLS1jLXctYmFja2dyb3VuZC1jb2xvcikgJHtpdGVtSGVpZ2h0IC0gMX1weCwgdmFyKC0tYy13LWJvcmRlci1jb2xvcikgMXB4KWAsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uWTogYCR7LWl0ZW1IZWlnaHQgKyAxfXB4YCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSAgICAgOiBgMC40ZW0gJHtpdGVtSGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgICAgICAgICAgICAgOiBgJHt0b3RhbEhlaWdodCAtIHJvd0hlaWdodCArIDF9cHhgLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodCAgICAgICAgICA6IGAke3RvdGFsSGVpZ2h0IC0gcm93SGVpZ2h0ICsgMX1weGBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7aXRlbUhlaWdodH1weGBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUubWFyZ2luVG9wID0gYCR7LTIgLSByb3dIZWlnaHQgKiAocm93c1Blckl0ZW0gPT09IDEgPyAwLjUgOiByb3dzUGVySXRlbSA9PT0gMiA/IDEgOiAyKX1weGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1TdHlsZS5tYXJnaW5Ub3A7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmRvbS5jbltpXS5zdHlsZSA9IGl0ZW1TdHlsZTtcblxuICAgICAgICAgICAgICAgIHZkb20uY25baV0ucmVtb3ZlRG9tID0gKGkgPCBzdGFydFRpbWUgfHwgaSAtIDEgPj0gZW5kVGltZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IG1lLFxuICAgICAgICAgICAgICAgIHJvd0hlaWdodCxcbiAgICAgICAgICAgICAgICByb3dzUGVySXRlbSxcbiAgICAgICAgICAgICAgICB0b3RhbEhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0YXJ0VGltZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdGFydFRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyU2V0Um93SGVpZ2h0KHRoaXMucm93SGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGludGVydmFsIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0SW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdpbnRlcnZhbCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCB2ZG9tID0gdGhpcy52ZG9tLFxuICAgICAgICAgICAgaHRtbCwgaTtcblxuICAgICAgICB2ZG9tLmNuID0gW107XG5cbiAgICAgICAgZm9yIChpPTA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICBodG1sID0gaSA9PT0gMjQgPyAnMDA6MDAnIDogKGkgPCAxMCA/ICcwJyA6ICcnKSArIGkgKyAnOjAwJztcblxuICAgICAgICAgICAgdmRvbS5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tYy13LXRpbWVheGlzLWl0ZW0nXSxcbiAgICAgICAgICAgICAgICBjbiAgIDogW3todG1sOiBodG1sfV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYW1vdW50IG9mIHJvd3MgcmVsYXRlZCB0byB0aGUgaW50ZXJ2YWwgY29uZmlnXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSb3dzUGVySXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWwgPT09IDYwID8gMSA6IHRoaXMuaW50ZXJ2YWwgPT09IDMwID8gMiA6IDQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdGltZSBmb3IgdGhlIGVuZC0gb3Igc3RhcnRUaW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRUaW1lKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpWzBdO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoVGltZUF4aXNDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBUaW1lQXhpc0NvbXBvbmVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==