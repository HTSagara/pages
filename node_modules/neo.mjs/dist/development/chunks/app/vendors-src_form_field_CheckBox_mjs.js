"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_field_CheckBox_mjs"],{

/***/ "./src/form/field/CheckBox.mjs":
/*!*************************************!*\
  !*** ./src/form/field/CheckBox.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * @class Neo.form.field.CheckBox
 * @extends Neo.form.field.Base
 */
class CheckBox extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for labelPosition
     * @member {String[]} labelPositions=['left','top']
     * @protected
     * @static
     */
    static labelPositions = ['left', 'top']

    static config = {
        /**
         * @member {String} className='Neo.form.field.CheckBox'
         * @protected
         */
        className: 'Neo.form.field.CheckBox',
        /**
         * @member {String} ntype='checkboxfield'
         * @protected
         */
        ntype: 'checkboxfield',
        /**
         * @member {String[]} baseCls=['neo-checkboxfield']
         */
        baseCls: ['neo-checkboxfield'],
        /**
         * @member {Boolean} checked_=false
         */
        checked_: false,
        /**
         * @member {String|null} error_=null
         */
        error_: null,
        /**
         * Useful for fields inside a css grid where errors should live outside the layout
         * @member {Boolean} errorPositionAbsolute_=false
         */
        errorPositionAbsolute_: false,
        /**
         * @member {Function} errorTextGroupRequired='Required'
         */
        errorTextGroupRequired: data => `Please check at least one item of the group: ${data.name}`,
        /**
         * @member {String} errorTextRequired='Required'
         */
        errorTextRequired: 'Required',
        /**
         * @member {Boolean} groupRequired_=false
         */
        groupRequired_: false,
        /**
         * @member {Boolean} hideLabel_=false
         */
        hideLabel_: false,
        /**
         * @member {String[]} iconCls=['far','fa-square']
         */
        iconCls: ['far', 'fa-square'],
        /**
         * @member {String[]} iconClsChecked=['fas','fa-check']
         */
        iconClsChecked: ['fas', 'fa-check'],
        /**
         * @member {String} inputType_='checkbox'
         */
        inputType_: 'checkbox',
        /**
         * @member {String[]} labelBaseCls=['neo-checkbox-label']
         */
        labelBaseCls: ['neo-checkbox-label'],
        /**
         * @member {String[]} labelCls_=[]
         */
        labelCls_: [],
        /**
         * Edge-case config in case we want to render leading content with their own selectors like:
         * <span class="my-label-id-cls">E10</span> · Firstname
         * @member {String|null} labelId_=null
         */
        labelId_: null,
        /**
         * CSS rules for labelId
         * @member {String[]} labelIdCls_=[]
         */
        labelIdCls_: [],
        /**
         * Separator between labelId & labelText
         * @member {String} labelIdSeparator_=' · '
         */
        labelIdSeparator_: ' · ',
        /**
         * Valid values: 'left', 'top'
         * @member {String} labelPosition_='left'
         */
        labelPosition_: 'left',
        /**
         * @member {String} labelText_='LabelText'
         */
        labelText_: 'LabelText',
        /**
         * defaults to px
         * @member {Number|String} labelWidth_=150
         */
        labelWidth_: 150,
        /**
         * @member {Boolean} required_=false
         */
        required_: false,
        /**
         * Use case: Set this config to false for all but one item with the same name.
         * @member {Boolean} showErrorTexts_=true
         */
        showErrorTexts_: true,
        /**
         * In case the CheckBox does not belong to a group (multiple fields with the same name),
         * you can pass a custom value for the unchecked state.
         * @member {*} uncheckedValue=false
         */
        uncheckedValue: false,
        /**
         * @member {Boolean|Number|String|null} value=true
         */
        value: true,
        /**
         * @member {String|null} valueLabelText_=null
         */
        valueLabelText_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'label', cls: ['neo-checkbox-label'], cn: [
                {tag: 'span',  cls: []},
                {tag: 'input', cls: ['neo-checkbox-input']},
                {tag: 'i',     cls: ['neo-checkbox-icon']},
                {tag: 'span',  cls: ['neo-checkbox-value-label']}
            ]},
            {cls: ['neo-error-wrapper'], removeDom: true, cn: [
                {cls: ['neo-error']}
            ]}
        ]}
    }

    /**
     * Set this value to false, in case a field should display errors up front.
     * Otherwise, errors will stay hidden on mounting, unless you trigger validate(false).
     * @member {Boolean} clean=true
     */
    clean = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners(
            {change: me.onInputValueChange, scope: me}
        )
    }

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetChecked(value, oldValue) {
        let me      = this,
            labelEl = me.vdom.cn[0],
            iconCls = labelEl.cn[2].cls,
            newCls  = value ? me.iconClsChecked : me.iconCls,
            oldCls  = value ? me.iconCls : me.iconClsChecked;

        if (oldValue) {
            me.clean = false;
        }

        me.validate(); // silent

        labelEl.cn[1].checked = value;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].removeAdd(iconCls, oldCls, newCls);

        me.update();

        if (oldValue !== undefined) {
            me.fireChangeEvent(me.getValue(), me.getOldValue())
        }
    }

    /**
     * Triggered after the error config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetError(value, oldValue) {
        this.updateError(value)
    }

    /**
     * Triggered after the errorPositionAbsolute config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetErrorPositionAbsolute(value, oldValue) {
        let me  = this,
            cls = me.vdom.cn[1].cn[0].cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-absolute');

        me.update()
    }

    /**
     * Triggered after the required groupRequired got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetGroupRequired(value, oldValue) {
        oldValue !== undefined && this.validate(false)
    }

    /**
     * Triggered after the hideLabel config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetHideLabel(value, oldValue) {
        this.vdom.cn[0].cn[0].removeDom = value;
        this.update()
    }

    /**
     * Triggered after the id config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me      = this,
            vdom    = me.vdom,
            labelEl = vdom.cn[0];

        labelEl.cn[0].id = me.getLabelId();
        labelEl.cn[1].id = me.getInputElId();
        labelEl.cn[2].id = me.getIconElId();
        labelEl.cn[3].id = me.getValueLabelId();

        // silent vdom update, the super call will trigger the engine
        super.afterSetId(value, oldValue)
    }

    /**
     * Triggered after the inputType config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetInputType(value, oldValue) {
        this.changeInputElKey('type', value)
    }

    /**
     * Triggered after the labelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetLabelCls(value, oldValue) {
        let me  = this,
            cls = me.vdom.cn[0].cn[0].cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(cls, value);

        me.update()
    }

    /**
     * Triggered after the labelPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelPosition(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, 'neo-label-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(   cls, 'neo-label-' + value);
        me.cls = cls
    }

    /**
     * Triggered after the labelText config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelText(value, oldValue) {
        let me = this;

        if (me.labelId) {
            value = `<span class="${me.labelIdCls.join(',')}">${me.labelId}</span>${me.labelIdSeparator + value}`
        }

        me.vdom.cn[0].cn[0].innerHTML = value;
        me.update()
    }

    /**
     * Triggered after the labelWidth config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetLabelWidth(value, oldValue) {
        let me = this;

        if (!me.hideLabel) {
            me.vdom.cn[0].cn[0].width = value;
            me.update()
        }
    }

    /**
     * Triggered after the required config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRequired(value, oldValue) {
        oldValue !== undefined && this.validate(false)
    }

    /**
     * Triggered after the showErrorTexts config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowErrorTexts(value, oldValue) {
        oldValue !== undefined && this.validate(false)
    }

    /**
     * Triggered after the value config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        this.changeInputElKey('value', value)
    }

    /**
     * Triggered after the valueLabel config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValueLabelText(value, oldValue) {
        let me         = this,
            valueLabel = me.vdom.cn[0].cn[3],
            showLabel  = !!value; // hide the label, in case value === null || value === ''

        if (showLabel) {
            valueLabel.innerHTML = value;
        }

        valueLabel.removeDom = !showLabel;
        me.update()
    }

    /**
     * Triggered before the groupRequired config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    beforeSetGroupRequired(value, oldValue) {
        if (value && this.required) {
            console.warn('Do not use groupRequired & required at the same time. Switching to required.', this);
            return false
        }

        return value
    }

    /**
     * Triggered before the labelCls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].union(value || [], this.labelBaseCls)
    }

    /**
     * Triggered before the labelPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'labelPosition')
    }

    /**
     * Triggered before the renderName config gets changed.
     * CheckBoxes & radios rely on this flag being set to true
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    beforeSetRenderName(value, oldValue) {
        return true
    }

    /**
     * @returns {String[]}
     */
    getGroupValue() {
        let form   = this.getClosestForm(),
            fields = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find({path: this.getPath()}),
            value  = [];

        fields.forEach(field => {
            if (field.checked && field.getClosestForm() === form) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(value, field.value)
            }
        });

        return value
    }

    /**
     * @returns {String}
     */
    getIconElId() {
        return `${this.id}__icon`
    }

    /**
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom.cn[0].cn[1]
    }

    /**
     * @returns {String}
     */
    getInputElId() {
        return `${this.id}__input`
    }

    /**
     * @returns {String}
     */
    getLabelId() {
        return `${this.id}__label`
    }

    /**
     * Counterpart to getValue(), returning the uncheckedValue if checked
     * @returns {String|null}
     */
    getOldValue() {
        let me = this;

        return me.checked ? me.uncheckedValue : me.value
    }

    /**
     * Returns this.value if checked, otherwise this.uncheckedValue
     * @returns {String|null}
     */
    getValue() {
        let me = this;

        return me.checked ? me.value : me.uncheckedValue
    }

    /**
     * @returns {String}
     */
    getValueLabelId() {
        return `${this.id}__value-label`
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        this.validate(true); // silent

        return this.error ? false : super.isValid()
    }

    /**
     * Gets triggered when a user checks a checkbox input.
     * @param {Object} data
     */
    onInputValueChange(data) {
        let me      = this,
            checked = data.target.checked;

        // keep the vdom & vnode in sync for future updates
        me.vnode.childNodes[0].childNodes[me.hideLabel ? 0 : 1].attributes.checked = `${checked}`;

        me.checked = checked;

        me.fireUserChangeEvent(me.getValue(), me.getOldValue())
    }

    /**
     @param {String|null} value
     @param {Boolean} silent=false
     */
    updateError(value, silent=false) {
        let me        = this,
            cls       = me.cls,
            showError = value && me.showErrorTexts,
            errorNode, errorWrapper;

        if (!(me.clean && !me.mounted)) {
            me._error = value; // silent update

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-invalid');
            me.cls = cls;

            errorWrapper = me.vdom.cn[1];
            errorNode    = errorWrapper.cn[0];

            if (showError) {
                errorNode.html = value;
            } else {
                delete errorNode.html;
            }

            errorWrapper.removeDom = !showError;

            !silent && me.update()
        }
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        let me          = this,
            name        = me.name,
            returnValue = true,
            checkBox, checkBoxes;

        if (!silent) {
            // in case we manually call validate(false) on a form or field before it is mounted, we do want to see errors.
            me.clean = false;
        }

        if (me.groupRequired) {
            returnValue = false;

            // discuss: we could limit this to checkBoxes / radios inside the same form, IF a top level form is used
            checkBoxes = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find({
                ntype: me.ntype,
                name : me.name
            });

            // get the group validity state first
            for (checkBox of checkBoxes) {
                if (checkBox.checked) {
                    returnValue = true;
                    break;
                }
            }

            // update all group items
            for (checkBox of checkBoxes) {
                if (checkBox.id !== me.id) {
                    if (!me.clean) {
                        checkBox.clean = false;
                    }

                    checkBox[me.clean ? '_error' : 'error'] = returnValue ? null : checkBox.errorTextGroupRequired({name})
                }
            }

            if (!returnValue) {
                me._error = me.errorTextGroupRequired({name});
            }
        } else if (me.required && !me.checked) {
            me._error = me.errorTextRequired;
            returnValue = false;
        }

        if (returnValue) {
            me._error = null;
        }

        !me.clean && me.updateError(me._error, silent);

        return !returnValue ? false : super.validate(silent)
    }
}

Neo.applyClassConfig(CheckBox);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CheckBox);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ2lCO0FBQ1A7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFJO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSx3RkFBd0YsVUFBVTtBQUNsRztBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFD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aUI7QUFDakI7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RixRQUFROztBQUVoRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CLFlBQVksdURBQVE7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsOERBQWdCO0FBQ3pDO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvSEFBb0gsS0FBSztBQUN6SDtBQUNBOztBQUVBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL0NoZWNrQm94Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLkNoZWNrQm94XG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5CYXNlXG4gKi9cbmNsYXNzIENoZWNrQm94IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBsYWJlbFBvc2l0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGxhYmVsUG9zaXRpb25zPVsnbGVmdCcsJ3RvcCddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgbGFiZWxQb3NpdGlvbnMgPSBbJ2xlZnQnLCAndG9wJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQ2hlY2tCb3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLkNoZWNrQm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NoZWNrYm94ZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2hlY2tib3hmaWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jaGVja2JveGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNoZWNrYm94ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNoZWNrZWRfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZXJyb3JfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGVycm9yXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgZmllbGRzIGluc2lkZSBhIGNzcyBncmlkIHdoZXJlIGVycm9ycyBzaG91bGQgbGl2ZSBvdXRzaWRlIHRoZSBsYXlvdXRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZXJyb3JQb3NpdGlvbkFic29sdXRlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JQb3NpdGlvbkFic29sdXRlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gZXJyb3JUZXh0R3JvdXBSZXF1aXJlZD0nUmVxdWlyZWQnXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvclRleHRHcm91cFJlcXVpcmVkOiBkYXRhID0+IGBQbGVhc2UgY2hlY2sgYXQgbGVhc3Qgb25lIGl0ZW0gb2YgdGhlIGdyb3VwOiAke2RhdGEubmFtZX1gLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBlcnJvclRleHRSZXF1aXJlZD0nUmVxdWlyZWQnXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvclRleHRSZXF1aXJlZDogJ1JlcXVpcmVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGdyb3VwUmVxdWlyZWRfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBncm91cFJlcXVpcmVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWRlTGFiZWxfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlTGFiZWxfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBpY29uQ2xzPVsnZmFyJywnZmEtc3F1YXJlJ11cbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6IFsnZmFyJywgJ2ZhLXNxdWFyZSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGljb25DbHNDaGVja2VkPVsnZmFzJywnZmEtY2hlY2snXVxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNsc0NoZWNrZWQ6IFsnZmFzJywgJ2ZhLWNoZWNrJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlucHV0VHlwZV89J2NoZWNrYm94J1xuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRUeXBlXzogJ2NoZWNrYm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBsYWJlbEJhc2VDbHM9WyduZW8tY2hlY2tib3gtbGFiZWwnXVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxCYXNlQ2xzOiBbJ25lby1jaGVja2JveC1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGxhYmVsQ2xzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVkZ2UtY2FzZSBjb25maWcgaW4gY2FzZSB3ZSB3YW50IHRvIHJlbmRlciBsZWFkaW5nIGNvbnRlbnQgd2l0aCB0aGVpciBvd24gc2VsZWN0b3JzIGxpa2U6XG4gICAgICAgICAqIDxzcGFuIGNsYXNzPVwibXktbGFiZWwtaWQtY2xzXCI+RTEwPC9zcGFuPiDCtyBGaXJzdG5hbWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGxhYmVsSWRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsSWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIHJ1bGVzIGZvciBsYWJlbElkXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBsYWJlbElkQ2xzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxJZENsc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VwYXJhdG9yIGJldHdlZW4gbGFiZWxJZCAmIGxhYmVsVGV4dFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxhYmVsSWRTZXBhcmF0b3JfPScgwrcgJ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxJZFNlcGFyYXRvcl86ICcgwrcgJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2xlZnQnLCAndG9wJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxhYmVsUG9zaXRpb25fPSdsZWZ0J1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxQb3NpdGlvbl86ICdsZWZ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGFiZWxUZXh0Xz0nTGFiZWxUZXh0J1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxUZXh0XzogJ0xhYmVsVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBsYWJlbFdpZHRoXz0xNTBcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsV2lkdGhfOiAxNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZXF1aXJlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgY2FzZTogU2V0IHRoaXMgY29uZmlnIHRvIGZhbHNlIGZvciBhbGwgYnV0IG9uZSBpdGVtIHdpdGggdGhlIHNhbWUgbmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0Vycm9yVGV4dHNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dFcnJvclRleHRzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2UgdGhlIENoZWNrQm94IGRvZXMgbm90IGJlbG9uZyB0byBhIGdyb3VwIChtdWx0aXBsZSBmaWVsZHMgd2l0aCB0aGUgc2FtZSBuYW1lKSxcbiAgICAgICAgICogeW91IGNhbiBwYXNzIGEgY3VzdG9tIHZhbHVlIGZvciB0aGUgdW5jaGVja2VkIHN0YXRlLlxuICAgICAgICAgKiBAbWVtYmVyIHsqfSB1bmNoZWNrZWRWYWx1ZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdW5jaGVja2VkVmFsdWU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHZhbHVlTGFiZWxUZXh0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZUxhYmVsVGV4dF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7dGFnOiAnbGFiZWwnLCBjbHM6IFsnbmVvLWNoZWNrYm94LWxhYmVsJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAge3RhZzogJ3NwYW4nLCAgY2xzOiBbXX0sXG4gICAgICAgICAgICAgICAge3RhZzogJ2lucHV0JywgY2xzOiBbJ25lby1jaGVja2JveC1pbnB1dCddfSxcbiAgICAgICAgICAgICAgICB7dGFnOiAnaScsICAgICBjbHM6IFsnbmVvLWNoZWNrYm94LWljb24nXX0sXG4gICAgICAgICAgICAgICAge3RhZzogJ3NwYW4nLCAgY2xzOiBbJ25lby1jaGVja2JveC12YWx1ZS1sYWJlbCddfVxuICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1lcnJvci13cmFwcGVyJ10sIHJlbW92ZURvbTogdHJ1ZSwgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1lcnJvciddfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyB2YWx1ZSB0byBmYWxzZSwgaW4gY2FzZSBhIGZpZWxkIHNob3VsZCBkaXNwbGF5IGVycm9ycyB1cCBmcm9udC5cbiAgICAgKiBPdGhlcndpc2UsIGVycm9ycyB3aWxsIHN0YXkgaGlkZGVuIG9uIG1vdW50aW5nLCB1bmxlc3MgeW91IHRyaWdnZXIgdmFsaWRhdGUoZmFsc2UpLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNsZWFuPXRydWVcbiAgICAgKi9cbiAgICBjbGVhbiA9IHRydWVcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFxuICAgICAgICAgICAge2NoYW5nZTogbWUub25JbnB1dFZhbHVlQ2hhbmdlLCBzY29wZTogbWV9XG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENoZWNrZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGxhYmVsRWwgPSBtZS52ZG9tLmNuWzBdLFxuICAgICAgICAgICAgaWNvbkNscyA9IGxhYmVsRWwuY25bMl0uY2xzLFxuICAgICAgICAgICAgbmV3Q2xzICA9IHZhbHVlID8gbWUuaWNvbkNsc0NoZWNrZWQgOiBtZS5pY29uQ2xzLFxuICAgICAgICAgICAgb2xkQ2xzICA9IHZhbHVlID8gbWUuaWNvbkNscyA6IG1lLmljb25DbHNDaGVja2VkO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUuY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnZhbGlkYXRlKCk7IC8vIHNpbGVudFxuXG4gICAgICAgIGxhYmVsRWwuY25bMV0uY2hlY2tlZCA9IHZhbHVlO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZUFkZChpY29uQ2xzLCBvbGRDbHMsIG5ld0Nscyk7XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lLmZpcmVDaGFuZ2VFdmVudChtZS5nZXRWYWx1ZSgpLCBtZS5nZXRPbGRWYWx1ZSgpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlcnJvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXJyb3IodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXJyb3IodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlcnJvclBvc2l0aW9uQWJzb2x1dGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFcnJvclBvc2l0aW9uQWJzb2x1dGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUudmRvbS5jblsxXS5jblswXS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tYWJzb2x1dGUnKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVxdWlyZWQgZ3JvdXBSZXF1aXJlZCBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0R3JvdXBSZXF1aXJlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbGlkYXRlKGZhbHNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZUxhYmVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhpZGVMYWJlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLmNuWzBdLmNuWzBdLnJlbW92ZURvbSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmRvbSAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICBsYWJlbEVsID0gdmRvbS5jblswXTtcblxuICAgICAgICBsYWJlbEVsLmNuWzBdLmlkID0gbWUuZ2V0TGFiZWxJZCgpO1xuICAgICAgICBsYWJlbEVsLmNuWzFdLmlkID0gbWUuZ2V0SW5wdXRFbElkKCk7XG4gICAgICAgIGxhYmVsRWwuY25bMl0uaWQgPSBtZS5nZXRJY29uRWxJZCgpO1xuICAgICAgICBsYWJlbEVsLmNuWzNdLmlkID0gbWUuZ2V0VmFsdWVMYWJlbElkKCk7XG5cbiAgICAgICAgLy8gc2lsZW50IHZkb20gdXBkYXRlLCB0aGUgc3VwZXIgY2FsbCB3aWxsIHRyaWdnZXIgdGhlIGVuZ2luZVxuICAgICAgICBzdXBlci5hZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlucHV0VHlwZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbnB1dFR5cGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgndHlwZScsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxDbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLnZkb20uY25bMF0uY25bMF0uY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIG9sZFZhbHVlKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgdmFsdWUpO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbFBvc2l0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tbGFiZWwtJyArIG9sZFZhbHVlKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKCAgIGNscywgJ25lby1sYWJlbC0nICsgdmFsdWUpO1xuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxhYmVsVGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRMYWJlbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmxhYmVsSWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYDxzcGFuIGNsYXNzPVwiJHttZS5sYWJlbElkQ2xzLmpvaW4oJywnKX1cIj4ke21lLmxhYmVsSWR9PC9zcGFuPiR7bWUubGFiZWxJZFNlcGFyYXRvciArIHZhbHVlfWBcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnZkb20uY25bMF0uY25bMF0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbFdpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmhpZGVMYWJlbCkge1xuICAgICAgICAgICAgbWUudmRvbS5jblswXS5jblswXS53aWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVxdWlyZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZXF1aXJlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbGlkYXRlKGZhbHNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0Vycm9yVGV4dHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93RXJyb3JUZXh0cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbGlkYXRlKGZhbHNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgndmFsdWUnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlTGFiZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlTGFiZWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2YWx1ZUxhYmVsID0gbWUudmRvbS5jblswXS5jblszXSxcbiAgICAgICAgICAgIHNob3dMYWJlbCAgPSAhIXZhbHVlOyAvLyBoaWRlIHRoZSBsYWJlbCwgaW4gY2FzZSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJydcblxuICAgICAgICBpZiAoc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICB2YWx1ZUxhYmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVMYWJlbC5yZW1vdmVEb20gPSAhc2hvd0xhYmVsO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGdyb3VwUmVxdWlyZWQgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRHcm91cFJlcXVpcmVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5yZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEbyBub3QgdXNlIGdyb3VwUmVxdWlyZWQgJiByZXF1aXJlZCBhdCB0aGUgc2FtZSB0aW1lLiBTd2l0Y2hpbmcgdG8gcmVxdWlyZWQuJywgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGxhYmVsQ2xzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRMYWJlbENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lb0FycmF5LnVuaW9uKHZhbHVlIHx8IFtdLCB0aGlzLmxhYmVsQmFzZUNscylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBsYWJlbFBvc2l0aW9uIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRMYWJlbFBvc2l0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnbGFiZWxQb3NpdGlvbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcmVuZGVyTmFtZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIENoZWNrQm94ZXMgJiByYWRpb3MgcmVseSBvbiB0aGlzIGZsYWcgYmVpbmcgc2V0IHRvIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRSZW5kZXJOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRHcm91cFZhbHVlKCkge1xuICAgICAgICBsZXQgZm9ybSAgID0gdGhpcy5nZXRDbG9zZXN0Rm9ybSgpLFxuICAgICAgICAgICAgZmllbGRzID0gQ29tcG9uZW50TWFuYWdlci5maW5kKHtwYXRoOiB0aGlzLmdldFBhdGgoKX0pLFxuICAgICAgICAgICAgdmFsdWUgID0gW107XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmNoZWNrZWQgJiYgZmllbGQuZ2V0Q2xvc2VzdEZvcm0oKSA9PT0gZm9ybSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZCh2YWx1ZSwgZmllbGQudmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWNvbkVsSWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9faWNvbmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0SW5wdXRFbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXS5jblsxXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SW5wdXRFbElkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2lucHV0YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TGFiZWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19sYWJlbGBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3VudGVycGFydCB0byBnZXRWYWx1ZSgpLCByZXR1cm5pbmcgdGhlIHVuY2hlY2tlZFZhbHVlIGlmIGNoZWNrZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0T2xkVmFsdWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLmNoZWNrZWQgPyBtZS51bmNoZWNrZWRWYWx1ZSA6IG1lLnZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzLnZhbHVlIGlmIGNoZWNrZWQsIG90aGVyd2lzZSB0aGlzLnVuY2hlY2tlZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBtZS5jaGVja2VkID8gbWUudmFsdWUgOiBtZS51bmNoZWNrZWRWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VmFsdWVMYWJlbElkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX3ZhbHVlLWxhYmVsYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodHJ1ZSk7IC8vIHNpbGVudFxuXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yID8gZmFsc2UgOiBzdXBlci5pc1ZhbGlkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIGEgdXNlciBjaGVja3MgYSBjaGVja2JveCBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSW5wdXRWYWx1ZUNoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNoZWNrZWQgPSBkYXRhLnRhcmdldC5jaGVja2VkO1xuXG4gICAgICAgIC8vIGtlZXAgdGhlIHZkb20gJiB2bm9kZSBpbiBzeW5jIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICBtZS52bm9kZS5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbbWUuaGlkZUxhYmVsID8gMCA6IDFdLmF0dHJpYnV0ZXMuY2hlY2tlZCA9IGAke2NoZWNrZWR9YDtcblxuICAgICAgICBtZS5jaGVja2VkID0gY2hlY2tlZDtcblxuICAgICAgICBtZS5maXJlVXNlckNoYW5nZUV2ZW50KG1lLmdldFZhbHVlKCksIG1lLmdldE9sZFZhbHVlKCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlRXJyb3IodmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyAgICAgICA9IG1lLmNscyxcbiAgICAgICAgICAgIHNob3dFcnJvciA9IHZhbHVlICYmIG1lLnNob3dFcnJvclRleHRzLFxuICAgICAgICAgICAgZXJyb3JOb2RlLCBlcnJvcldyYXBwZXI7XG5cbiAgICAgICAgaWYgKCEobWUuY2xlYW4gJiYgIW1lLm1vdW50ZWQpKSB7XG4gICAgICAgICAgICBtZS5fZXJyb3IgPSB2YWx1ZTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1pbnZhbGlkJyk7XG4gICAgICAgICAgICBtZS5jbHMgPSBjbHM7XG5cbiAgICAgICAgICAgIGVycm9yV3JhcHBlciA9IG1lLnZkb20uY25bMV07XG4gICAgICAgICAgICBlcnJvck5vZGUgICAgPSBlcnJvcldyYXBwZXIuY25bMF07XG5cbiAgICAgICAgICAgIGlmIChzaG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvck5vZGUuaHRtbCA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZXJyb3JOb2RlLmh0bWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yV3JhcHBlci5yZW1vdmVEb20gPSAhc2hvd0Vycm9yO1xuXG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGNsaWVudC1zaWRlIGZpZWxkIGVycm9yc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PXRydWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNsaWVudC1zaWRlIGVycm9yc1xuICAgICAqL1xuICAgIHZhbGlkYXRlKHNpbGVudD10cnVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuYW1lICAgICAgICA9IG1lLm5hbWUsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWUsXG4gICAgICAgICAgICBjaGVja0JveCwgY2hlY2tCb3hlcztcblxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBtYW51YWxseSBjYWxsIHZhbGlkYXRlKGZhbHNlKSBvbiBhIGZvcm0gb3IgZmllbGQgYmVmb3JlIGl0IGlzIG1vdW50ZWQsIHdlIGRvIHdhbnQgdG8gc2VlIGVycm9ycy5cbiAgICAgICAgICAgIG1lLmNsZWFuID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuZ3JvdXBSZXF1aXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gZGlzY3Vzczogd2UgY291bGQgbGltaXQgdGhpcyB0byBjaGVja0JveGVzIC8gcmFkaW9zIGluc2lkZSB0aGUgc2FtZSBmb3JtLCBJRiBhIHRvcCBsZXZlbCBmb3JtIGlzIHVzZWRcbiAgICAgICAgICAgIGNoZWNrQm94ZXMgPSBDb21wb25lbnRNYW5hZ2VyLmZpbmQoe1xuICAgICAgICAgICAgICAgIG50eXBlOiBtZS5udHlwZSxcbiAgICAgICAgICAgICAgICBuYW1lIDogbWUubmFtZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgZ3JvdXAgdmFsaWRpdHkgc3RhdGUgZmlyc3RcbiAgICAgICAgICAgIGZvciAoY2hlY2tCb3ggb2YgY2hlY2tCb3hlcykge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYWxsIGdyb3VwIGl0ZW1zXG4gICAgICAgICAgICBmb3IgKGNoZWNrQm94IG9mIGNoZWNrQm94ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tCb3guaWQgIT09IG1lLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuY2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQm94LmNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGVja0JveFttZS5jbGVhbiA/ICdfZXJyb3InIDogJ2Vycm9yJ10gPSByZXR1cm5WYWx1ZSA/IG51bGwgOiBjaGVja0JveC5lcnJvclRleHRHcm91cFJlcXVpcmVkKHtuYW1lfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtZS5fZXJyb3IgPSBtZS5lcnJvclRleHRHcm91cFJlcXVpcmVkKHtuYW1lfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWUucmVxdWlyZWQgJiYgIW1lLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIG1lLl9lcnJvciA9IG1lLmVycm9yVGV4dFJlcXVpcmVkO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgbWUuX2Vycm9yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgICFtZS5jbGVhbiAmJiBtZS51cGRhdGVFcnJvcihtZS5fZXJyb3IsIHNpbGVudCk7XG5cbiAgICAgICAgcmV0dXJuICFyZXR1cm5WYWx1ZSA/IGZhbHNlIDogc3VwZXIudmFsaWRhdGUoc2lsZW50KVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ2hlY2tCb3gpO1xuXG5leHBvcnQgZGVmYXVsdCBDaGVja0JveDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==