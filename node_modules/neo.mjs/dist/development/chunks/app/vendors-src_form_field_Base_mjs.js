"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_field_Base_mjs"],{

/***/ "./src/form/field/Base.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        fireChangeEvent    : {type: 'debounce', timer: 1000},
        fireUserChangeEvent: {type: 'debounce', timer: 1000}
    }
    /**
     * Valid values for isTouchedEvent
     * @member {String[]} isTouchedEvents=['focusEnter','focusLeave']
     * @protected
     * @static
     */
    static isTouchedEvents = ['focusEnter', 'focusLeave']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         */
        formGroup_: null,
        /**
         * True indicates that a user has interacted with the form field
         * @member {Boolean} isTouched_=false
         */
        isTouched_: false,
        /**
         * Event name which sets isTouched to true. Valid options are 'focusEnter' & 'focusLeave'
         * @member {String} isTouched_=false
         */
        isTouchedEvent_: 'focusLeave',
        /**
         * @member {String|null} name_=null
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * Base implementation to check if the fields value has changed.
     * Can get overridden in superclasses.
     * @returns {Boolean}
     */
    get isDirty() {
        let originalValue = this.originalConfig.value,
            value         = this.value;

        return value !== originalValue && Neo.isEmpty(value) !== Neo.isEmpty(originalValue)
    }
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * Triggered after the name isTouched got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetIsTouched(value, oldValue) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'neo-is-touched', value);
        this.cls = cls
    }

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.getInputEl().role = value;
        this.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {
        oldValue !== undefined && this.fireChangeEvent(value, oldValue)
    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Triggered before the isTouchedEvent config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetIsTouchedEvent(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'isTouchedEvent')
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value
        } else {
            delete me.getInputEl()[key]
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*}      value
     * @param {*}      oldValue
     * @param {String} eventName
     */
    doFireChangeEvent(value, oldValue, eventName) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            formEvent     = 'field' + Neo.capitalize(eventName),
            opts          = {component: me, oldValue, value};

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        me.fire(eventName, opts);

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire(formEvent, opts)
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'change')
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireUserChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'userChange')
    }

    /**
     * Forms in neo can be nested. This method will return the closest parent which is a form.Container or null.
     * @returns {Neo.form.Container|null}
     */
    getClosestForm() {
        let me            = this,
            FormContainer = Neo.form?.Container,
            parent;

        for (parent of _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me)) {
            if (FormContainer && parent instanceof FormContainer) {
                return parent
            }
        }

        return null
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        // fields could have formGroups, but no name.
        // returning the namespace can confuse form.Container.adjustTreeLeaves(),
        // since namespaces could be considered as field instances.
        if (!me.name) {
            return null
        }

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getSubmitValue() {
        return this.value
    }

    /**
     * @deprecated in v7.x
     * @returns {*}
     */
    getValue() {
        return this.getSubmitValue()
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        super.onFocusLeave(data);

        if (this.isTouchedEvent === 'focusEnter') {
            this.isTouched = true
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave(data);

        let me            = this,
            FormContainer = Neo.form?.Container,
            opts          = {...data, component: me, value: me.getSubmitValue()};

        if (me.isTouchedEvent === 'focusLeave') {
            me.isTouched = true
        }

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', opts)
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.originalConfig.value = value;
        this.value = value
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDRztBQUNQOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUFTO0FBQzVCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEdBQUc7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0EsYUFBYSxLQUFLOztBQUVsQixRQUFRLHVEQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLDhEQUFnQjtBQUN4QjtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSw4REFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qiw4REFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhEQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjs7QUFFQTs7QUFFQSxpRUFBZSxJQUFJLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvQmFzZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbXBvbmVudCAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZm9ybSBmaWVsZHNcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7XG4gICAgICAgIGZpcmVDaGFuZ2VFdmVudCAgICA6IHt0eXBlOiAnZGVib3VuY2UnLCB0aW1lcjogMTAwMH0sXG4gICAgICAgIGZpcmVVc2VyQ2hhbmdlRXZlbnQ6IHt0eXBlOiAnZGVib3VuY2UnLCB0aW1lcjogMTAwMH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBpc1RvdWNoZWRFdmVudFxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBpc1RvdWNoZWRFdmVudHM9Wydmb2N1c0VudGVyJywnZm9jdXNMZWF2ZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUb3VjaGVkRXZlbnRzID0gWydmb2N1c0VudGVyJywgJ2ZvY3VzTGVhdmUnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Jhc2VmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdiYXNlZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybSBncm91cHMgY2FuIGdldCBzZXQgb24gYW55IHBhcmVudCBjb21wb25lbnQgbGV2ZWwuXG4gICAgICAgICAqIEFuIGFsdGVybmF0aXZlIHdheSBmb3IgdXNpbmcgZG90cyBpbiBmaWVsZCBuYW1lcy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybUdyb3VwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaW5kaWNhdGVzIHRoYXQgYSB1c2VyIGhhcyBpbnRlcmFjdGVkIHdpdGggdGhlIGZvcm0gZmllbGRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNUb3VjaGVkXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNUb3VjaGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBuYW1lIHdoaWNoIHNldHMgaXNUb3VjaGVkIHRvIHRydWUuIFZhbGlkIG9wdGlvbnMgYXJlICdmb2N1c0VudGVyJyAmICdmb2N1c0xlYXZlJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlzVG91Y2hlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzVG91Y2hlZEV2ZW50XzogJ2ZvY3VzTGVhdmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IG5hbWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogTmVvIGl0c2VsZiBkb2VzIG5vdCBuZWVkIGZpZWxkIG5hbWVzIHRvIGdldCBtYXBwZWQgdG8gdGhlIERPTSAoaW5wdXQgbm9kZXMpLFxuICAgICAgICAgKiBleGNlcHQgZm9yIENoZWNrQm94ZXMgJiBSYWRpb3MgdG8gd29yay4gSXQgY2FuIGJlIHVzZWZ1bCBmb3IgdGVzdGluZyB0b29sc1xuICAgICAgICAgKiAmIGFjY2Vzc2liaWxpdHkgdGhvdWdoLCBzbyB0aGUgZGVmYXVsdCBnb3Qgc2V0IHRvIHRydWUuXG4gICAgICAgICAqIEZlZWwgZnJlZSB0byBjaGFuZ2UgaXQgdG8gZmFsc2UgdG8ga2VlcCB0aGUgRE9NIG1pbmltYWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlck5hbWVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlck5hbWVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gY2FzZSByZW5kZXJOYW1lIGlzIHNldCB0byB0cnVlLCB5b3UgY2FuIG9wdGlvbmFsbHkgcmVuZGVyIHRoZSBjb21iaW5hdGlvblxuICAgICAgICAgKiBvZiBhbGwgZm9ybUdyb3VwKHMpICYgdGhlIGZpZWxkIG5hbWUgaW50byB0aGUgRE9NID0+IGlucHV0IG5vZGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyUGF0aD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJQYXRoOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Kn0gdmFsdWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGNhY2hlIGZvciBmb3JtR3JvdXBzIG9mIGFsbCBwYXJlbnQgbGV2ZWxzXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cFN0cmluZz1udWxsXG4gICAgICovXG4gICAgZm9ybUdyb3VwU3RyaW5nID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEJhc2UgaW1wbGVtZW50YXRpb24gdG8gY2hlY2sgaWYgdGhlIGZpZWxkcyB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgKiBDYW4gZ2V0IG92ZXJyaWRkZW4gaW4gc3VwZXJjbGFzc2VzLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBpc0RpcnR5KCkge1xuICAgICAgICBsZXQgb3JpZ2luYWxWYWx1ZSA9IHRoaXMub3JpZ2luYWxDb25maWcudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgID0gdGhpcy52YWx1ZTtcblxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG9yaWdpbmFsVmFsdWUgJiYgTmVvLmlzRW1wdHkodmFsdWUpICE9PSBOZW8uaXNFbXB0eShvcmlnaW5hbFZhbHVlKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwKHMpIGFuZCB0aGUgZmllbGQgbmFtZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBwYXRoPW51bGxcbiAgICAgKi9cbiAgICBwYXRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuYW1lIGlzVG91Y2hlZCBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldElzVG91Y2hlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtjbHN9ID0gdGhpcztcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLWlzLXRvdWNoZWQnLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUucmVuZGVyTmFtZSAmJiBtZS5jaGFuZ2VJbnB1dEVsS2V5KCduYW1lJywgbWUucmVuZGVyUGF0aCA/IG1lLmdldFBhdGgoKSA6IHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm9sZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um9sZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRJbnB1dEVsKCkucm9sZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZm9ybUdyb3VwIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBwYXJlbnRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldEZvcm1Hcm91cCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JvdXAgPSBbXSxcbiAgICAgICAgICAgIHJldHVyblZhbHVlO1xuXG4gICAgICAgIGlmIChtZS5mb3JtR3JvdXBTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5mb3JtR3JvdXBTdHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICYmIGdyb3VwLnB1c2godmFsdWUpO1xuXG4gICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgcGFyZW50LmZvcm1Hcm91cCAmJiBncm91cC51bnNoaWZ0KHBhcmVudC5mb3JtR3JvdXApXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVyblZhbHVlID0gZ3JvdXAuam9pbignLicpO1xuXG4gICAgICAgIG1lLmZvcm1Hcm91cFN0cmluZyA9IHJldHVyblZhbHVlO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGlzVG91Y2hlZEV2ZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0SXNUb3VjaGVkRXZlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdpc1RvdWNoZWRFdmVudCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBpbnB1dEVsIHZkb20gb2JqZWN0IGF0dHJpYnV0ZSBvciByZW1vdmVzIGl0IGluIGNhc2UgaXQgaGFzIG5vIHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfE9iamVjdHxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIGNoYW5nZUlucHV0RWxLZXkoa2V5LCB2YWx1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlIHx8IE5lby5pc0Jvb2xlYW4odmFsdWUpIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBtZS5nZXRJbnB1dEVsKClba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbWUuZ2V0SW5wdXRFbCgpW2tleV1cbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICovXG4gICAgZG9GaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlLCBldmVudE5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICBmb3JtRXZlbnQgICAgID0gJ2ZpZWxkJyArIE5lby5jYXBpdGFsaXplKGV2ZW50TmFtZSksXG4gICAgICAgICAgICBvcHRzICAgICAgICAgID0ge2NvbXBvbmVudDogbWUsIG9sZFZhbHVlLCB2YWx1ZX07XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKG1lLmdldEdyb3VwVmFsdWUpKSB7XG4gICAgICAgICAgICBvcHRzLmdyb3VwVmFsdWUgPSBtZS5nZXRHcm91cFZhbHVlKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmZpcmUoZXZlbnROYW1lLCBvcHRzKTtcblxuICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZpcmUoZm9ybUV2ZW50LCBvcHRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb0ZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUsICdjaGFuZ2UnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZVVzZXJDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb0ZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUsICd1c2VyQ2hhbmdlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtcyBpbiBuZW8gY2FuIGJlIG5lc3RlZC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgcGFyZW50IHdoaWNoIGlzIGEgZm9ybS5Db250YWluZXIgb3IgbnVsbC5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmZvcm0uQ29udGFpbmVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q2xvc2VzdEZvcm0oKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyLFxuICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgIGZvciAocGFyZW50IG9mIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkpIHtcbiAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRJbnB1dEVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tYmluYXRpb24gb2YgdGhlIGZpZWxkIGZvcm1Hcm91cChzKSAmIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHBhdGg7XG5cbiAgICAgICAgLy8gZmllbGRzIGNvdWxkIGhhdmUgZm9ybUdyb3VwcywgYnV0IG5vIG5hbWUuXG4gICAgICAgIC8vIHJldHVybmluZyB0aGUgbmFtZXNwYWNlIGNhbiBjb25mdXNlIGZvcm0uQ29udGFpbmVyLmFkanVzdFRyZWVMZWF2ZXMoKSxcbiAgICAgICAgLy8gc2luY2UgbmFtZXNwYWNlcyBjb3VsZCBiZSBjb25zaWRlcmVkIGFzIGZpZWxkIGluc3RhbmNlcy5cbiAgICAgICAgaWYgKCFtZS5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5wYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gbWUuZm9ybUdyb3VwID8gbWUuZm9ybUdyb3VwLnNwbGl0KCcuJykgOiBbXTtcblxuICAgICAgICAgICAgbWUubmFtZSAmJiBwYXRoLnB1c2gobWUubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5wYXRoID0gcGF0aC5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnBhdGgpIHtcbiAgICAgICAgICAgIG1lLnBhdGggPSAnbm9uZSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5wYXRoID09PSAnbm9uZScgPyBudWxsOiBtZS5wYXRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3VibWl0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgaW4gdjcueFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdWJtaXRWYWx1ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXNFbnRlcihkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKTtcblxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoZWRFdmVudCA9PT0gJ2ZvY3VzRW50ZXInKSB7XG4gICAgICAgICAgICB0aGlzLmlzVG91Y2hlZCA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBGb3JtQ29udGFpbmVyID0gTmVvLmZvcm0/LkNvbnRhaW5lcixcbiAgICAgICAgICAgIG9wdHMgICAgICAgICAgPSB7Li4uZGF0YSwgY29tcG9uZW50OiBtZSwgdmFsdWU6IG1lLmdldFN1Ym1pdFZhbHVlKCl9O1xuXG4gICAgICAgIGlmIChtZS5pc1RvdWNoZWRFdmVudCA9PT0gJ2ZvY3VzTGVhdmUnKSB7XG4gICAgICAgICAgICBtZS5pc1RvdWNoZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24obWUuZ2V0R3JvdXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9wdHMuZ3JvdXBWYWx1ZSA9IG1lLmdldEdyb3VwVmFsdWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5zdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5maXJlKCdmaWVsZEZvY3VzTGVhdmUnLCBvcHRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGZpZWxkIHRvIGEgbmV3IHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlPW51bGxcbiAgICAgKi9cbiAgICByZXNldCh2YWx1ZT1udWxsKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDb25maWcudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBjbGllbnQtc2lkZSBmaWVsZCBlcnJvcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD10cnVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpbiBjYXNlIHRoZXJlIGFyZSBubyBjbGllbnQtc2lkZSBlcnJvcnNcbiAgICAgKi9cbiAgICB2YWxpZGF0ZShzaWxlbnQ9dHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgY2hhbmdlIGV2ZW50IGZpcmVzIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gKiBAZXZlbnQgY2hhbmdlXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbk5lby5zZXR1cENsYXNzKEJhc2UpO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9