"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_portal_view_learn_MainContainer_mjs"],{

/***/ "./apps/portal/model/Content.mjs":
/*!***************************************!*\
  !*** ./apps/portal/model/Content.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.Content
 * @extends Neo.data.Model
 */
class Content extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.Content'
         * @protected
         */
        className: 'Portal.model.Content',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'className',
            type: 'String'
        }, {
            name: 'collapsed',
            type: 'Boolean'
        }, {
            name: 'id',
            type: 'Integer'
        }, {
            name: 'isLeaf',
            type: 'Boolean'
        }, {
            name: 'name',
            type: 'String'
        }, {
            name: 'parentId',
            type: 'Integer'
        }, {
            name: 'path',
            type: 'String'
        }]
    }
}

Neo.applyClassConfig(Content);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Content);


/***/ }),

/***/ "./apps/portal/store/Content.mjs":
/*!***************************************!*\
  !*** ./apps/portal/store/Content.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_Content_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/Content.mjs */ "./apps/portal/model/Content.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class LearnNeo.store.Content
 * @extends Neo.data.Store
 */
class Content extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='LearnNeo.store.Content'
         * @protected
         */
        className: 'LearnNeo.store.Content',
        /**
         * @member {Neo.data.Model} model=ContentModel
         */
        model: _model_Content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
    }

    xonConstructed() {
        super.onConstructed();

        let me = this;

        // Neo.Main.getByPath({path: 'location.search'})
        //     .then(data => {
        //         const searchString = data?.substr(1) || '';
        //         const search = searchString ? JSON.parse(`{"${decodeURI(searchString.replace(/&/g, "\",\"").replace(/=/g, "\":\""))}"}`) : {};
        //         this.deck = search.deck || 'learnneo';
        //         this.url = `${this.contentPath}/tree.json`;
        //         this.load();
        //         // this.doLoadStore();
        //         console.log(search);
        //     });

    }
    xload() {
        this.model = _model_Content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];
        Neo.Main.getByPath({path: 'location.search'})
            .then(data => {
                const searchString = data?.substr(1) || '';
                const search = searchString ? JSON.parse(`{"${decodeURI(searchString.replace(/&/g, "\",\"").replace(/=/g, "\":\""))}"}`) : {};
                this.deck = search.deck || 'learnneo';
                this.url = `${this.contentPath}/tree.json`;
                // this.load();
                super.load();
                console.log(search);
            });
    }

    get contentPath() {
        return `../../../resources/data/deck/${this.deck}`;
    }
    doLoadStore() {
        debugger;
        const me = this;
        Neo.Xhr.promiseJson({
            url: `${this.contentPath}/tree.json`
        }).then(data => {
            // TODO: Tree lists should do this themselves when their store is loaded.
            me.data = data.json.data;
            // me.createItems(null, me.getListItemsRoot(), 0);
            // me.update();
        })
    }
}

Neo.applyClassConfig(Content);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Content);


/***/ }),

/***/ "./apps/portal/view/learn/ContentTreeList.mjs":
/*!****************************************************!*\
  !*** ./apps/portal/view/learn/ContentTreeList.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_Content_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/Content.mjs */ "./apps/portal/store/Content.mjs");
/* harmony import */ var _LivePreview_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LivePreview.mjs */ "./apps/portal/view/learn/LivePreview.mjs");
/* harmony import */ var _src_tree_List_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../src/tree/List.mjs */ "./src/tree/List.mjs");




/**
 * @class Portal.view.learn.ContentTreeList
 * @extends Neo.container.Base
 */
class ContentTreeList extends _src_tree_List_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.learn.ContentTreeList'
         * @protected
         */
        className: 'Portal.view.learn.ContentTreeList',
        /**
         * @member {String[]} cls=['topics-tree']
         */
        cls: ['topics-tree'],
        /**
         * @member {Boolean} showCollapseExpandAllIcons=false
         */
        showCollapseExpandAllIcons: false,
        /**
         * @member {Neo.data.Store} store=ContentStore
         */
        store: _store_Content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
    }

    get contentPath() {
        return `../../resources/data/deck/${this.deck}`
    }

    /**
     * @param {Object} record
     * @returns {Promise<void>}
     */
    async doFetchContent(record) {
        let me = this,
            path = `${me.contentPath}`;

        path += record.path ? `/pages/${record.path}` : `/p/${record.id}.md`;

        if (record.isLeaf && path) {
            const data = await fetch(path);
            const content = await data.text();
            let modifiedHtml = await this.highlightPreContent(content);

            // Replace <pre data-neo></neo> with <div id='neo-preview-1'/>
            // and creaet a map keyed by ID, whose value is the javascript
            // from the <pre>
            let neoDivs = {};

            modifiedHtml = this.extractNeoContent(modifiedHtml, neoDivs);



            await Neo.main.addon.Markdown.markdownToHtml(modifiedHtml)
                .then(
                    html => {
                        html = me.insertLabDivs(html);
                        me.fire('contentChange', {
                            component: me,
                            html,
                            record,
                            isLab: record.name?.startsWith('Lab:')
                        });
                    },
                    () => me.fire('contentChange', {component: me}));
            await this.timeout(50); // Do we need this?
            Object.keys(neoDivs).forEach(key => {
                // Create LivePreview for each iteration, set value to neoDivs[key]
                let foo = Neo.create(_LivePreview_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], {
                    value: neoDivs[key],
                    parentId: key,
                    appName: this.appName
                })
            });
        }
    }

    extractNeoContent(htmlString, map) {
        // 1. Replace <pre data-neo> with <div id='neo-preview-2'/>
        // and update map with key/value pairs, where the key is the ID and the value is the <pre> contents.

        // Define a regular expression to match <pre data-javascript> tags
        const preRegex = /<pre\s+data-neo\s*>([\s\S]*?)<\/pre>/g;

        let count = 0;
        // Replace the content with tokens, and create a promise to update the corresponding content
        var updatedHtml = htmlString.replace(preRegex, (match, preContent) => {
            const key = `pre-live-preview-${Neo.core.IdGenerator.getId()}-${count++}`;
            map[key] = preContent;
            return `<div id="${key}"></div>`;
        });
        return updatedHtml;

    }

    insertLabDivs(inputString) {
        // Replace <!-- lab --> with <div class="lab">
        let modifiedString = inputString.replace(/<!--\s*lab\s*-->/g, '<div class="lab">');

        // Replace <!-- /lab --> with </div>
        modifiedString = modifiedString.replace(/<!--\s*\/lab\s*-->/g, '</div>');

        return modifiedString;

    }

    async highlightPreContent(htmlString) {
        // 1. Replace <pre data-javascript> with unique tokens and create a HighlightJS.highlightAuto promise for each
        // 2. When all promises are resolved, use their values to replace the tokens.

        // Note that if we were to import HighlightJS directly, we wouldn't need all this async code.

        // Define a regular expression to match <pre data-javascript> tags
        const preRegex = /<pre\s+data-javascript\s*>([\s\S]*?)<\/pre>/g;

        // Create an array to store promises for each replacement
        const replacementPromises = [];
        let count = 0;
        // Replace the content with tokens, and create a promise to update the corresponding content
        var updatedHtml = htmlString.replace(preRegex, (match, preContent) => {
            const token = `__NEO-PRE-TOKEN-${++count}__`;
            replacementPromises.push(this.getHighlightPromise(preContent, token, `pre-preview-${Neo.core.IdGenerator.getId()}`));
            return token;
        });

        // Assert: updateHtml is the original, but with <pre data-javascript> replaced with tokens.

        // Wait for all replacement promises to resolve
        return Promise.all(replacementPromises)
            .then(replacements => {
                // Replace each token with the resolved content
                replacements.forEach((replacement) => updatedHtml = updatedHtml.replace(replacement.token, replacement.after));

                // Return the final updated HTML string
                return updatedHtml;
            });
    }

    getHighlightPromise(preContent, token, id) {
        // Resolves to an object of the form {after, token}, where after is the updated <pre> tag content
        return Neo.main.addon.HighlightJS.highlightAuto(preContent)
            .then(highlight => ({after: `<pre data-javascript id="${id}">${highlight.value}</pre>`, token}));
    }

    /**
     *
     */
    doLoadStore() {
        const me = this;
        Neo.Xhr.promiseJson({
            url: `${this.contentPath}/t.json`
        }).then(data => {
            // TODO: Tree lists should do this themselves when their store is loaded.
            me.store.data = data.json.data;
            me.createItems(null, me.getListItemsRoot(), 0);
            me.update()
        })
    }

    /**
     * todo: createItems() should get triggered onStoreLoad()
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        Neo.main.addon.HighlightJS.loadLibrary({
            appName: me.appName,
            highlightJsPath: '../../docs/resources/highlight/highlight.pack.js',
            themePath: '../../docs/resources/highlightjs-custom-github-theme.css'
        });

        Neo.Main.getByPath({path: 'location.search'})
            .then(data => {
                const searchString = data?.substr(1) || '';
                const search = searchString ? JSON.parse(`{"${decodeURI(searchString.replace(/&/g, "\",\"").replace(/=/g, "\":\""))}"}`) : {};
                me.deck = search.deck || 'learnneo';

                me.doLoadStore();
            })
    }

    /**
     * @param {Object} record
     */
    onLeafItemClick(record) {
        super.onLeafItemClick(record);
        this.doFetchContent(record)
    }
}

Neo.applyClassConfig(ContentTreeList);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ContentTreeList);


/***/ }),

/***/ "./apps/portal/view/learn/ContentView.mjs":
/*!************************************************!*\
  !*** ./apps/portal/view/learn/ContentView.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Portal.view.learn.ContentView
 * @extends Neo.component.Base
 */
class ContentView extends _src_component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.learn.ContentView'
         * @protected
         */
        className: 'Portal.view.learn.ContentView',
        /**
         * @member {String[]} baseCls=['learn-content']
         * @protected
         */
        baseCls: ['learn-content']
    }

    /**
     * @member {Object} record=null
     */
    record = null

    /**
     * @param {Object} data
     */
    onClick(data) {
        let me     = this,
            record = me.record;

        if (data.altKey && data.shiftKey && !data.metaKey) {
            me.fire('edit', {component: me, record})
        }
        // Command/windows shift click = refresh
        else if (!data.altKey && data.shiftKey && data.metaKey) {
            me.fire('refresh', {component: me, record})
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.addDomListeners({
            click: me.onClick,
            scope: me
        })
    }

}

Neo.applyClassConfig(ContentView);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ContentView);


/***/ }),

/***/ "./apps/portal/view/learn/LivePreview.mjs":
/*!************************************************!*\
  !*** ./apps/portal/view/learn/LivePreview.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _src_tab_Container_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../src/tab/Container.mjs */ "./src/tab/Container.mjs");
/* harmony import */ var _src_form_field_TextArea_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../src/form/field/TextArea.mjs */ "./src/form/field/TextArea.mjs");




/**
 * @class Portal.view.learn.LivePreview
 * @extends Neo.container.Base
 */
class LivePreview extends _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.learn.LivePreview'
         * @protected
         */
        className: 'Portal.view.learn.LivePreview',
        baseCls: ['learn-live-preview'],
        value_: null,
        autoMount: true,
        autoRender: true,
        height: 400,
        layout: 'fit',
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _src_tab_Container_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            reference: 'tab-container',
            cls: 'live-preview-container',
            items: [{
                module: _src_form_field_TextArea_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                hideLabel: true,
                style: {height: '100%'},
                reference: 'textArea',
                tabButtonConfig: {
                    text: 'Source'
                },
                listeners: {
                    change: data => data.component.up({className: 'Portal.view.learn.LivePreview'}).value = data.value
                }
            }, {
                tabButtonConfig: {
                    text: 'Preview'
                },
                reference: 'preview',
                ntype: 'container'
            }]
        }]
    }

    afterSetValue(value, oldValue) {
        if (value) {
            this.getItem('textArea').value = value;
        }
    }

    onConstructed() {
        super.onConstructed();

        let me = this;

        me.getReference('tab-container').on('activeIndexChange', me.onActiveIndexChange, me)
    }

    doRunSource() {
        let source = this.value;

        const importRegex = /import\s+([\w-]+)\s+from\s+['"]([^'"]+)['"]/;
        const exportRegex = /export\s+(?:default\s+)?(?:const|let|var|class|function|async\s+function|generator\s+function|async\s+generator\s+function|(\{[\s\S]*?\}))/g;


        const cleanLines = [];
        const importPromises = [];
        const importModuleNames = [];

        const moduleNameAndPath = [];

        const className = this.findLastClassName(source);

        source.split('\n').forEach(line => {
            let importMatch = line.match(importRegex);
            if (importMatch) {
                let moduleName = importMatch[1];
                let path = importMatch[2];
                moduleNameAndPath.push({
                    moduleName,
                    path
                });
                // importPromises.push(import(path));
                // importPromises.push(import(path).then(module => {
                //     eval(`const ${moduleName} = module.default;`)
                // }));
                importModuleNames.push(moduleName);
            } else if (line.match(exportRegex)) {
                // Skip export statements
            } else {
                cleanLines.push(line);
            }
        });
        var params = [];
        var vars = [];
        // Figure out the parts of the source we'll be running.
        // o The promises/import() corresponding to the user's import statements
        // o The vars holding the name of the imported module based on the module name for each import
        // o The rest of the user-provided source
        // It'll end up looking like this:
        // Promise.all([
        //     import('../../../node_modules/neo.mjs/src/container/Base.mjs'),
        //     import('../../../node_modules/neo.mjs/src/button/Base.mjs')
        //   ]).then(([BaseModule, ButtonModule]) => {
        //       const Base = BaseModule.default;
        //       const Button = ButtonModule.default;
        //       // Class declaration goes here...
        //   });
        // Making the promise part of the eval seems weird, but it made it easier to
        // set up the import vars.

        let promises = moduleNameAndPath.map(item => {
            params.push(`${item.moduleName}Module`);
            vars.push(`const ${item.moduleName} = ${item.moduleName}Module.default`);
            return `import("${item.path}")`;
        });
        const codeString = `
            Promise.all([
                ${promises.join(',\n')}
            ])
            .then(([${params.join(', ')}]) => {
                    ${vars.join('\n')}
                    ${cleanLines.join('\n')}
                    if (${className} && Neo.component.Base.isPrototypeOf(${className})) container.add({module:${className}});
                })
            .catch(error=>container.add({ntype:'component',html:error.message}));
        `;

        const container = this.getReference('preview');
        container.removeAll();
        try {
            const dynamicCode = new Function('container', codeString);
            dynamicCode(container);
        } catch (error) {
            container.add({
                ntype: 'component',
                html: error.message
            })
        }
    }

    /**
    * @param {String} reference
    * @returns {Object|Neo.component.Base|null}
    */
    getItem(reference, items = this.items) {
        let i = 0,
            len = items.length,
            item,
            childItem;

        for (; i < len; i++) {
            item = items[i];
            if (item.reference === reference) {
                return item
            } else if (item.items) {
                childItem = this.getItem(reference, item.items);

                if (childItem) {
                    return childItem;
                }
            }
        }
        return null
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.item
     * @param {Number} data.oldValue
     * @param {String} data.source
     * @param {Number} data.value
     */
    onActiveIndexChange(data) {
        if (data.item.reference !== 'preview') return;
        this.doRunSource();
    }
    findLastClassName(sourceCode) {
        // Define a regular expression to match class declarations
        const classDeclarationRegex = /class\s+([a-zA-Z$_][a-zA-Z0-9$_]*)\s*(?:extends\s+[a-zA-Z$_][a-zA-Z0-9$_]*)?\s*{[\s\S]*?}/g;

        let match;
        let lastClassName = null;

        // Iterate through all matches of the regular expression
        while ((match = classDeclarationRegex.exec(sourceCode)) !== null) {
            // Update the last class name found
            lastClassName = match[1];
        }

        return lastClassName;

    }
}

Neo.applyClassConfig(LivePreview);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LivePreview);


/***/ }),

/***/ "./apps/portal/view/learn/MainContainer.mjs":
/*!**************************************************!*\
  !*** ./apps/portal/view/learn/MainContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _ContentView_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ContentView.mjs */ "./apps/portal/view/learn/ContentView.mjs");
/* harmony import */ var _ContentTreeList_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ContentTreeList.mjs */ "./apps/portal/view/learn/ContentTreeList.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/portal/view/learn/MainContainerController.mjs");
/* harmony import */ var _MainContainerModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MainContainerModel.mjs */ "./apps/portal/view/learn/MainContainerModel.mjs");
/* harmony import */ var _src_component_Splitter_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../src/component/Splitter.mjs */ "./src/component/Splitter.mjs");







/**
 * @class Portal.view.learn.MainContainer
 * @extends Neo.container.Base
 */
class MainContainer extends _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.learn.MainContainer'
         * @protected
         */
        className: 'Portal.view.learn.MainContainer',
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
        /**
         * @member {String[]} cls=['learnneo-maincontainer']
         */
        cls: ['learnneo-maincontainer'],
        /**
         * @member {Object[]} items
         */
        items: [{
            module  : _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            layout  : 'fit',
            minWidth: 350,
            width   : 350,
            cls     : 'sidenav-container',
            items: [{
                module   : _ContentTreeList_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                reference: 'tree',
                listeners: {
                    contentChange: 'onContentChange',
                }
            }]
        }, {
            module      : _src_component_Splitter_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
            cls         : ['main-content-splitter'],
            resizeTarget: 'previous',
            size        : 4
        }, {
            module   : _ContentView_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            reference: 'content',
            listeners: {
                edit   : 'onContentEdit',
                refresh: 'onContentRefresh'
            }
        }],
        /**
         * @member {Object} layout={ntype:'hbox',align:'stretch'}
         */
        layout: {ntype: 'hbox', align: 'stretch'},
        /**
         * @member {Neo.model.Component} model=MainContainerModel
         */
        model: _MainContainerModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]
    }
}

Neo.applyClassConfig(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./apps/portal/view/learn/MainContainerController.mjs":
/*!************************************************************!*\
  !*** ./apps/portal/view/learn/MainContainerController.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Portal.view.learn.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.learn.MainContainerController'
         * @protected
         */
        className: 'Portal.view.learn.MainContainerController'
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        Neo.Main.getByPath({path: 'location.search'})
            .then(data => {
                const searchString = data?.substr(1) || '';
                const search = searchString ? JSON.parse(`{"${decodeURI(searchString.replace(/&/g, "\",\"").replace(/=/g, "\":\""))}"}`) : {};
                this.getModel().setData('deck', search.deck || 'learnneo');
            });

        fetch('../../../../resources/data/deck/EditorConfig.json')
            .then(response => response.json()
                .then(data =>
                    this.getModel().setData('editorConfig', data)
                ))
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onContentChange(data) {
        let me = this,
            content = me.getReference('content');

        content.toggleCls('lab', data.isLab);

        content.html = data.html;
        content.record = data.record;

    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onContentEdit(data) {
        const vm = this.getModel();
        console.log(data);
        const editorConfig = vm.getData('editorConfig');
        const subDir = vm.getData('deck')
        if (!editorConfig || !subDir) return;

        const filePath = `${editorConfig.root}/${subDir}/p/${data.record.id}.md`;

        await fetch('http://localhost:3000/openInEditor', {
            method: 'POST',
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({path: filePath, editor: editorConfig.editor})
        })
    }

    /**
     * @param {Object} data
     */
    onContentRefresh(data) {
        this.getReference('tree').doFetchContent(data.record)
    }
}

Neo.applyClassConfig(MainContainerController);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainerController);


/***/ }),

/***/ "./apps/portal/view/learn/MainContainerModel.mjs":
/*!*******************************************************!*\
  !*** ./apps/portal/view/learn/MainContainerModel.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_model_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/model/Component.mjs */ "./src/model/Component.mjs");
/* harmony import */ var _store_Content_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/Content.mjs */ "./apps/portal/store/Content.mjs");



/**
 * @class Portal.view.learn.MainContainerModel
 * @extends Neo.model.Component
 */
class MainContainerModel extends _src_model_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.learn.MainContainerModel'
         * @protected
         */
        className: 'Portal.view.learn.MainContainerModel',
        /**
         * @member {Object} data
         */
        data: {},
        /**
         * @member {Object} stores
         */
        stores: {
            tree: {
                module      : _store_Content_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                responseRoot: 'data'
            }
        }
    }
}

Neo.applyClassConfig(MainContainerModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainerModel);


/***/ }),

/***/ "./src/component/Splitter.mjs":
/*!************************************!*\
  !*** ./src/component/Splitter.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * Splitters can get put into containers to make siblings resizable via drag & drop
 * @class Neo.component.Splitter
 * @extends Neo.component.Base
 */
class Splitter extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for direction
     * @member {String[]} directions=['horizontal','vertical']
     * @protected
     * @static
     */
    static directions = ['horizontal', 'vertical']
    /**
     * Valid values for resizeTarget
     * @member {String[]} resizeTargets=['next','previous']
     * @protected
     * @static
     */
    static resizeTargets = ['next', 'previous']

    static config = {
        /**
         * @member {String} className='Neo.component.Splitter'
         * @protected
         */
        className: 'Neo.component.Splitter',
        /**
         * @member {String} ntype='splitter'
         * @protected
         */
        ntype: 'splitter',
        /**
         * @member {String[]} baseCls=['neo-splitter','neo-draggable']
         */
        baseCls: ['neo-splitter', 'neo-draggable'],
        /**
         * Either 'horizontal' or 'vertical'
         * @member {String} direction_='vertical'
         */
        direction_: 'vertical',
        /**
         * @member {Neo.draggable.DragZone|null} dragZone=null
         * @protected
         */
        dragZone: null,
        /**
         * @member {Object|null} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * Choose which sibling to resize
         * Valid values: 'next' or 'previous'
         * @member {String} resizeTarget_='next'
         */
        resizeTarget_: 'next',
        /**
         * Either height or with, depending on the direction.
         * Defaults to px
         * @member {Number} size_=10
         */
        size_: 10
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {'drag:end'  : me.onDragEnd,   scope: me},
            {'drag:start': me.onDragStart, scope: me}
        ])
    }

    /**
     * Triggered after the direction config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDirection(value, oldValue) {
        let me     = this,
            cls    = me.cls,
            height = value === 'vertical' ? null : me.size,
            width  = value !== 'vertical' ? null : me.size;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(cls, `neo-${value}`);

        if (oldValue) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, `neo-${oldValue}`)
        }

        me.set({
            cls,
            height,
            minHeight: height,
            minWidth : width,
            width
        })
    }

    /**
     * Triggered after the size config got changed
     * @param {Boolean|null} value
     * @param {Boolean|null} oldValue
     * @protected
     */
    afterSetSize(value, oldValue) {
        this[this.direction === 'vertical' ? 'width' : 'height'] = value
    }

    /**
     * Triggered before the direction config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetDirection(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'direction')
    }

    /**
     * Triggered before the resizeTarget config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetResizeTarget(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'resizeTarget')
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        let me         = this,
            style      = me.style || {},
            parent     = me.parent,
            parentId   = me.parentId,
            resizeNext = me.resizeTarget === 'next',
            size       = me.size,
            index, newSize, sibling;

        parent.disabled = false;

        me.dragZone.dragEnd(data);

        style.opacity = 1;

        me.style = style;

        me.getDomRect(parentId).then(parentRect => {
            index   = parent.indexOf(me);
            sibling = parent.items[resizeNext ? index + 1 :index - 1];
            style   = sibling.style || {};

            style.flex = 'none';

            if (me.direction === 'vertical') {
                newSize = data.clientX - data.offsetX - size - parentRect.left;

                if (resizeNext) {
                    newSize = parentRect.width - newSize -  2 * size
                } else {
                    newSize += size
                }

                newSize = Math.min(Math.max(newSize, 0), parentRect.width - size);

                style.width = `${newSize}px`
            } else {
                newSize = data.clientY - data.offsetY - size - parentRect.top;

                if (resizeNext) {
                    newSize = parentRect.height - newSize -  2 * size
                } else {
                    newSize += size
                }

                newSize = Math.min(Math.max(newSize, 0), parentRect.height - size);

                style.height = `${newSize}px`;
            }

            sibling.style = style
        })
    }

    /**
     * @param data
     */
    onDragStart(data) {
        let me       = this,
            style    = me.style || {},
            vertical = me.direction === 'vertical';

        me.parent.disabled = true;

        if (!me.dragZone) {
            me.dragZone = Neo.create({
                module             : _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                appName            : me.appName,
                bodyCursorStyle    : vertical ? 'ew-resize !important' : 'ns-resize !important',
                boundaryContainerId: me.parentId,
                dragElement        : me.vdom,
                moveHorizontal     : vertical,
                moveVertical       : !vertical,
                owner              : me,
                useProxyWrapper    : false,
                ...me.dragZoneConfig
            })
        } else {
            me.dragZone.set({
                bodyCursorStyle: vertical ? 'ew-resize !important' : 'ns-resize !important',
                moveHorizontal : vertical,
                moveVertical   : !vertical
            })
        }

        me.dragZone.dragStart(data);

        style.opacity = 0.5;

        me.style = style
    }
}

Neo.applyClassConfig(Splitter);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Splitter);


/***/ }),

/***/ "./src/form/field/TextArea.mjs":
/*!*************************************!*\
  !*** ./src/form/field/TextArea.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _Text_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Text.mjs */ "./src/form/field/Text.mjs");



/**
 *
 * @class Neo.form.field.TextArea
 * @extends Neo.form.field.Text
 * @abstract
 */
class TextArea extends _Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Valid values for wrap
     * @member {String[]} wrapValues=['hard', 'off', 'soft', null]
     * @protected
     * @static
     */
    static wrapValues = ['hard', 'off', 'soft', null]

    static config = {
        /**
         * @member {String} className='Neo.form.field.TextArea'
         * @protected
         */
        className: 'Neo.form.field.TextArea',
        /**
         * @member {String} ntype='textarea'
         * @protected
         */
        ntype: 'textarea',
        /**
         * Set this to `true` to have the text area grow and shrink to accommodate
         * any height of text. Bounds can be set using the `minHeight` and `maxHeight` settings.
         * @member {Boolean} autoGrow=false
         */
        autoGrow_: false,
        /**
         * @member {String[]} baseCls=['neo-textarea','neo-textfield']
         */
        baseCls: ['neo-textarea', 'neo-textfield'],
        /**
         * True shows a clear trigger in case the field has a non-empty value.
         * @member {Boolean} clearable=false
         */
        clearable: false,
        /**
         * The visible width of the text control, in average character widths.
         * If it is specified, it must be a positive integer.
         * If it is not specified, the default value is 20.
         * @member {Number|null} cols_=null
         */
        cols_: null,
        /**
         * @member {String} inputTag_='textarea'
         */
        inputTag_: 'textarea',
        /**
         * Disabling to set a type for the textarea tag
         * See: inputTag_
         * @member {String|null} inputType=null
         * @protected
         */
        inputType: null,
        /**
         * Use false to disable the browsers default resizing feature
         * @member {Boolean} resizable_=false
         */
        resizable_: false,
        /**
         * An integer > 0 or null
         * @member {Number|null} rows_=3
         */
        rows_: 3,
        /**
         * Indicates how the control wraps text. Possible values are: hard, soft, off
         * If this attribute is not specified, soft is its default value.
         * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea
         * @member {String|null} wrap_=null
         */
        wrap_: null
    }

    afterSetAutoGrow(autoGrow) {
        autoGrow && this.syncAutoGrowMonitor();

        // Restore any configured height if autoGrow turned off
        if (!autoGrow) {
            this.afterSetHeight(this._height);
        }
    }

    /**
     * Triggered after the cols config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetCols(value, oldValue) {
        this.changeInputElKey('cols', value);
    }

    /**
     * Triggered after the inputTag config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetInputTag(value, oldValue) {
        this.changeInputElKey('tag', value);
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        this.syncAutoGrowMonitor();
    }

    /**
     * Triggered after the resizable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetResizable(value, oldValue) {
        let me    = this,
            style = this.getInputEl().style;

        style.resize = value ? null : 'none';
        me.update();
    }

    /**
     * Triggered after the rows config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetRows(value, oldValue) {
        this.changeInputElKey('rows', value);
    }

    /**
     * Triggered after the value config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let inputEl = this.getInputEl();

        if (inputEl) {
            inputEl.html = _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].escapeHtml(value);
        }

        super.afterSetValue(value, oldValue);
    }

    /**
     * Triggered after the wrap config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWrap(value, oldValue) {
        this.changeInputElKey('wrap', value);
    }

    /**
     * Checks if the new wrap value matches a value of the static wrapValues config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetWrap(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'wrap', 'wrapValues');
    }

    async syncAutoGrowMonitor() {
        if (this.mounted && this.autoGrow) {
            // Delegate monitoring of sizes to the VDOM thread.
            Neo.main.DomAccess.monitorAutoGrow({
                appName  : this.appName,
                id       : this.getInputElId(),
                autoGrow : this.autoGrow
            });
        }
    }
}

Neo.applyClassConfig(TextArea);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextArea);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfcG9ydGFsX3ZpZXdfbGVhcm5fTWFpbkNvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFLO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsT0FBTyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNDeUI7QUFDTzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQUs7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLGVBQWUsMERBQVk7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQSw4REFBOEQsR0FBRyxzRUFBc0UsRUFBRTtBQUN6STtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EscUJBQXFCLDBEQUFZO0FBQ2pDLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBLDJEQUEyRCxHQUFHLHNFQUFzRSxFQUFFO0FBQ3RJO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL21vZGVsL0NvbnRlbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9zdG9yZS9Db250ZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9sZWFybi9Db250ZW50VHJlZUxpc3QubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L2xlYXJuL0NvbnRlbnRWaWV3Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9sZWFybi9MaXZlUHJldmlldy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbGVhcm4vTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbGVhcm4vTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L2xlYXJuL01haW5Db250YWluZXJNb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvU3BsaXR0ZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9UZXh0QXJlYS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5tb2RlbC5Db250ZW50XG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5Nb2RlbFxuICovXG5jbGFzcyBDb250ZW50IGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLm1vZGVsLkNvbnRlbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5tb2RlbC5Db250ZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdjbGFzc05hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2NvbGxhcHNlZCcsXG4gICAgICAgICAgICB0eXBlOiAnQm9vbGVhbidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICAgIHR5cGU6ICdJbnRlZ2VyJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaXNMZWFmJyxcbiAgICAgICAgICAgIHR5cGU6ICdCb29sZWFuJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnbmFtZScsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAncGFyZW50SWQnLFxuICAgICAgICAgICAgdHlwZTogJ0ludGVnZXInXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdwYXRoJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDb250ZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29udGVudDtcbiIsImltcG9ydCBDb250ZW50TW9kZWwgZnJvbSAnLi4vbW9kZWwvQ29udGVudC5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9TdG9yZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBMZWFybk5lby5zdG9yZS5Db250ZW50XG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5TdG9yZVxuICovXG5jbGFzcyBDb250ZW50IGV4dGVuZHMgU3RvcmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTGVhcm5OZW8uc3RvcmUuQ29udGVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTGVhcm5OZW8uc3RvcmUuQ29udGVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9Q29udGVudE1vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDogQ29udGVudE1vZGVsXG4gICAgfVxuXG4gICAgeG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIE5lby5NYWluLmdldEJ5UGF0aCh7cGF0aDogJ2xvY2F0aW9uLnNlYXJjaCd9KVxuICAgICAgICAvLyAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgY29uc3Qgc2VhcmNoU3RyaW5nID0gZGF0YT8uc3Vic3RyKDEpIHx8ICcnO1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IHNlYXJjaCA9IHNlYXJjaFN0cmluZyA/IEpTT04ucGFyc2UoYHtcIiR7ZGVjb2RlVVJJKHNlYXJjaFN0cmluZy5yZXBsYWNlKC8mL2csIFwiXFxcIixcXFwiXCIpLnJlcGxhY2UoLz0vZywgXCJcXFwiOlxcXCJcIikpfVwifWApIDoge307XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5kZWNrID0gc2VhcmNoLmRlY2sgfHwgJ2xlYXJubmVvJztcbiAgICAgICAgLy8gICAgICAgICB0aGlzLnVybCA9IGAke3RoaXMuY29udGVudFBhdGh9L3RyZWUuanNvbmA7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIC8vICAgICAgICAgLy8gdGhpcy5kb0xvYWRTdG9yZSgpO1xuICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKHNlYXJjaCk7XG4gICAgICAgIC8vICAgICB9KTtcblxuICAgIH1cbiAgICB4bG9hZCgpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IENvbnRlbnRNb2RlbDtcbiAgICAgICAgTmVvLk1haW4uZ2V0QnlQYXRoKHtwYXRoOiAnbG9jYXRpb24uc2VhcmNoJ30pXG4gICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hTdHJpbmcgPSBkYXRhPy5zdWJzdHIoMSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoU3RyaW5nID8gSlNPTi5wYXJzZShge1wiJHtkZWNvZGVVUkkoc2VhcmNoU3RyaW5nLnJlcGxhY2UoLyYvZywgXCJcXFwiLFxcXCJcIikucmVwbGFjZSgvPS9nLCBcIlxcXCI6XFxcIlwiKSl9XCJ9YCkgOiB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY2sgPSBzZWFyY2guZGVjayB8fCAnbGVhcm5uZW8nO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsID0gYCR7dGhpcy5jb250ZW50UGF0aH0vdHJlZS5qc29uYDtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmxvYWQoKTtcbiAgICAgICAgICAgICAgICBzdXBlci5sb2FkKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc2VhcmNoKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCBjb250ZW50UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGAuLi8uLi8uLi9yZXNvdXJjZXMvZGF0YS9kZWNrLyR7dGhpcy5kZWNrfWA7XG4gICAgfVxuICAgIGRvTG9hZFN0b3JlKCkge1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICBOZW8uWGhyLnByb21pc2VKc29uKHtcbiAgICAgICAgICAgIHVybDogYCR7dGhpcy5jb250ZW50UGF0aH0vdHJlZS5qc29uYFxuICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETzogVHJlZSBsaXN0cyBzaG91bGQgZG8gdGhpcyB0aGVtc2VsdmVzIHdoZW4gdGhlaXIgc3RvcmUgaXMgbG9hZGVkLlxuICAgICAgICAgICAgbWUuZGF0YSA9IGRhdGEuanNvbi5kYXRhO1xuICAgICAgICAgICAgLy8gbWUuY3JlYXRlSXRlbXMobnVsbCwgbWUuZ2V0TGlzdEl0ZW1zUm9vdCgpLCAwKTtcbiAgICAgICAgICAgIC8vIG1lLnVwZGF0ZSgpO1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ29udGVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRlbnQ7XG4iLCJpbXBvcnQgQ29udGVudFN0b3JlIGZyb20gJy4uLy4uL3N0b3JlL0NvbnRlbnQubWpzJ1xuaW1wb3J0IExpdmVQcmV2aWV3IGZyb20gJy4vTGl2ZVByZXZpZXcubWpzJztcbmltcG9ydCBUcmVlTGlzdCBmcm9tICcuLi8uLi8uLi8uLi9zcmMvdHJlZS9MaXN0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3LmxlYXJuLkNvbnRlbnRUcmVlTGlzdFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIENvbnRlbnRUcmVlTGlzdCBleHRlbmRzIFRyZWVMaXN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3LmxlYXJuLkNvbnRlbnRUcmVlTGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubGVhcm4uQ29udGVudFRyZWVMaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wyd0b3BpY3MtdHJlZSddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsndG9waWNzLXRyZWUnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dDb2xsYXBzZUV4cGFuZEFsbEljb25zPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29uczogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZX0gc3RvcmU9Q29udGVudFN0b3JlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZTogQ29udGVudFN0b3JlXG4gICAgfVxuXG4gICAgZ2V0IGNvbnRlbnRQYXRoKCkge1xuICAgICAgICByZXR1cm4gYC4uLy4uL3Jlc291cmNlcy9kYXRhL2RlY2svJHt0aGlzLmRlY2t9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBkb0ZldGNoQ29udGVudChyZWNvcmQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHBhdGggPSBgJHttZS5jb250ZW50UGF0aH1gO1xuXG4gICAgICAgIHBhdGggKz0gcmVjb3JkLnBhdGggPyBgL3BhZ2VzLyR7cmVjb3JkLnBhdGh9YCA6IGAvcC8ke3JlY29yZC5pZH0ubWRgO1xuXG4gICAgICAgIGlmIChyZWNvcmQuaXNMZWFmICYmIHBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaChwYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBkYXRhLnRleHQoKTtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEh0bWwgPSBhd2FpdCB0aGlzLmhpZ2hsaWdodFByZUNvbnRlbnQoY29udGVudCk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgPHByZSBkYXRhLW5lbz48L25lbz4gd2l0aCA8ZGl2IGlkPSduZW8tcHJldmlldy0xJy8+XG4gICAgICAgICAgICAvLyBhbmQgY3JlYWV0IGEgbWFwIGtleWVkIGJ5IElELCB3aG9zZSB2YWx1ZSBpcyB0aGUgamF2YXNjcmlwdFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgPHByZT5cbiAgICAgICAgICAgIGxldCBuZW9EaXZzID0ge307XG5cbiAgICAgICAgICAgIG1vZGlmaWVkSHRtbCA9IHRoaXMuZXh0cmFjdE5lb0NvbnRlbnQobW9kaWZpZWRIdG1sLCBuZW9EaXZzKTtcblxuXG5cbiAgICAgICAgICAgIGF3YWl0IE5lby5tYWluLmFkZG9uLk1hcmtkb3duLm1hcmtkb3duVG9IdG1sKG1vZGlmaWVkSHRtbClcbiAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gbWUuaW5zZXJ0TGFiRGl2cyhodG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2NvbnRlbnRDaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xhYjogcmVjb3JkLm5hbWU/LnN0YXJ0c1dpdGgoJ0xhYjonKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICgpID0+IG1lLmZpcmUoJ2NvbnRlbnRDaGFuZ2UnLCB7Y29tcG9uZW50OiBtZX0pKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudGltZW91dCg1MCk7IC8vIERvIHdlIG5lZWQgdGhpcz9cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG5lb0RpdnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgTGl2ZVByZXZpZXcgZm9yIGVhY2ggaXRlcmF0aW9uLCBzZXQgdmFsdWUgdG8gbmVvRGl2c1trZXldXG4gICAgICAgICAgICAgICAgbGV0IGZvbyA9IE5lby5jcmVhdGUoTGl2ZVByZXZpZXcsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5lb0RpdnNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5hcHBOYW1lXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXh0cmFjdE5lb0NvbnRlbnQoaHRtbFN0cmluZywgbWFwKSB7XG4gICAgICAgIC8vIDEuIFJlcGxhY2UgPHByZSBkYXRhLW5lbz4gd2l0aCA8ZGl2IGlkPSduZW8tcHJldmlldy0yJy8+XG4gICAgICAgIC8vIGFuZCB1cGRhdGUgbWFwIHdpdGgga2V5L3ZhbHVlIHBhaXJzLCB3aGVyZSB0aGUga2V5IGlzIHRoZSBJRCBhbmQgdGhlIHZhbHVlIGlzIHRoZSA8cHJlPiBjb250ZW50cy5cblxuICAgICAgICAvLyBEZWZpbmUgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggPHByZSBkYXRhLWphdmFzY3JpcHQ+IHRhZ3NcbiAgICAgICAgY29uc3QgcHJlUmVnZXggPSAvPHByZVxccytkYXRhLW5lb1xccyo+KFtcXHNcXFNdKj8pPFxcL3ByZT4vZztcblxuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBjb250ZW50IHdpdGggdG9rZW5zLCBhbmQgY3JlYXRlIGEgcHJvbWlzZSB0byB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgY29udGVudFxuICAgICAgICB2YXIgdXBkYXRlZEh0bWwgPSBodG1sU3RyaW5nLnJlcGxhY2UocHJlUmVnZXgsIChtYXRjaCwgcHJlQ29udGVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYHByZS1saXZlLXByZXZpZXctJHtOZW8uY29yZS5JZEdlbmVyYXRvci5nZXRJZCgpfS0ke2NvdW50Kyt9YDtcbiAgICAgICAgICAgIG1hcFtrZXldID0gcHJlQ29udGVudDtcbiAgICAgICAgICAgIHJldHVybiBgPGRpdiBpZD1cIiR7a2V5fVwiPjwvZGl2PmA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXBkYXRlZEh0bWw7XG5cbiAgICB9XG5cbiAgICBpbnNlcnRMYWJEaXZzKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgPCEtLSBsYWIgLS0+IHdpdGggPGRpdiBjbGFzcz1cImxhYlwiPlxuICAgICAgICBsZXQgbW9kaWZpZWRTdHJpbmcgPSBpbnB1dFN0cmluZy5yZXBsYWNlKC88IS0tXFxzKmxhYlxccyotLT4vZywgJzxkaXYgY2xhc3M9XCJsYWJcIj4nKTtcblxuICAgICAgICAvLyBSZXBsYWNlIDwhLS0gL2xhYiAtLT4gd2l0aCA8L2Rpdj5cbiAgICAgICAgbW9kaWZpZWRTdHJpbmcgPSBtb2RpZmllZFN0cmluZy5yZXBsYWNlKC88IS0tXFxzKlxcL2xhYlxccyotLT4vZywgJzwvZGl2PicpO1xuXG4gICAgICAgIHJldHVybiBtb2RpZmllZFN0cmluZztcblxuICAgIH1cblxuICAgIGFzeW5jIGhpZ2hsaWdodFByZUNvbnRlbnQoaHRtbFN0cmluZykge1xuICAgICAgICAvLyAxLiBSZXBsYWNlIDxwcmUgZGF0YS1qYXZhc2NyaXB0PiB3aXRoIHVuaXF1ZSB0b2tlbnMgYW5kIGNyZWF0ZSBhIEhpZ2hsaWdodEpTLmhpZ2hsaWdodEF1dG8gcHJvbWlzZSBmb3IgZWFjaFxuICAgICAgICAvLyAyLiBXaGVuIGFsbCBwcm9taXNlcyBhcmUgcmVzb2x2ZWQsIHVzZSB0aGVpciB2YWx1ZXMgdG8gcmVwbGFjZSB0aGUgdG9rZW5zLlxuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBpZiB3ZSB3ZXJlIHRvIGltcG9ydCBIaWdobGlnaHRKUyBkaXJlY3RseSwgd2Ugd291bGRuJ3QgbmVlZCBhbGwgdGhpcyBhc3luYyBjb2RlLlxuXG4gICAgICAgIC8vIERlZmluZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCA8cHJlIGRhdGEtamF2YXNjcmlwdD4gdGFnc1xuICAgICAgICBjb25zdCBwcmVSZWdleCA9IC88cHJlXFxzK2RhdGEtamF2YXNjcmlwdFxccyo+KFtcXHNcXFNdKj8pPFxcL3ByZT4vZztcblxuICAgICAgICAvLyBDcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgcHJvbWlzZXMgZm9yIGVhY2ggcmVwbGFjZW1lbnRcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnRQcm9taXNlcyA9IFtdO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBjb250ZW50IHdpdGggdG9rZW5zLCBhbmQgY3JlYXRlIGEgcHJvbWlzZSB0byB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgY29udGVudFxuICAgICAgICB2YXIgdXBkYXRlZEh0bWwgPSBodG1sU3RyaW5nLnJlcGxhY2UocHJlUmVnZXgsIChtYXRjaCwgcHJlQ29udGVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBgX19ORU8tUFJFLVRPS0VOLSR7Kytjb3VudH1fX2A7XG4gICAgICAgICAgICByZXBsYWNlbWVudFByb21pc2VzLnB1c2godGhpcy5nZXRIaWdobGlnaHRQcm9taXNlKHByZUNvbnRlbnQsIHRva2VuLCBgcHJlLXByZXZpZXctJHtOZW8uY29yZS5JZEdlbmVyYXRvci5nZXRJZCgpfWApKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXNzZXJ0OiB1cGRhdGVIdG1sIGlzIHRoZSBvcmlnaW5hbCwgYnV0IHdpdGggPHByZSBkYXRhLWphdmFzY3JpcHQ+IHJlcGxhY2VkIHdpdGggdG9rZW5zLlxuXG4gICAgICAgIC8vIFdhaXQgZm9yIGFsbCByZXBsYWNlbWVudCBwcm9taXNlcyB0byByZXNvbHZlXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXBsYWNlbWVudFByb21pc2VzKVxuICAgICAgICAgICAgLnRoZW4ocmVwbGFjZW1lbnRzID0+IHtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGVhY2ggdG9rZW4gd2l0aCB0aGUgcmVzb2x2ZWQgY29udGVudFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50cy5mb3JFYWNoKChyZXBsYWNlbWVudCkgPT4gdXBkYXRlZEh0bWwgPSB1cGRhdGVkSHRtbC5yZXBsYWNlKHJlcGxhY2VtZW50LnRva2VuLCByZXBsYWNlbWVudC5hZnRlcikpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBmaW5hbCB1cGRhdGVkIEhUTUwgc3RyaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIdG1sO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0SGlnaGxpZ2h0UHJvbWlzZShwcmVDb250ZW50LCB0b2tlbiwgaWQpIHtcbiAgICAgICAgLy8gUmVzb2x2ZXMgdG8gYW4gb2JqZWN0IG9mIHRoZSBmb3JtIHthZnRlciwgdG9rZW59LCB3aGVyZSBhZnRlciBpcyB0aGUgdXBkYXRlZCA8cHJlPiB0YWcgY29udGVudFxuICAgICAgICByZXR1cm4gTmVvLm1haW4uYWRkb24uSGlnaGxpZ2h0SlMuaGlnaGxpZ2h0QXV0byhwcmVDb250ZW50KVxuICAgICAgICAgICAgLnRoZW4oaGlnaGxpZ2h0ID0+ICh7YWZ0ZXI6IGA8cHJlIGRhdGEtamF2YXNjcmlwdCBpZD1cIiR7aWR9XCI+JHtoaWdobGlnaHQudmFsdWV9PC9wcmU+YCwgdG9rZW59KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkb0xvYWRTdG9yZSgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICBOZW8uWGhyLnByb21pc2VKc29uKHtcbiAgICAgICAgICAgIHVybDogYCR7dGhpcy5jb250ZW50UGF0aH0vdC5qc29uYFxuICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETzogVHJlZSBsaXN0cyBzaG91bGQgZG8gdGhpcyB0aGVtc2VsdmVzIHdoZW4gdGhlaXIgc3RvcmUgaXMgbG9hZGVkLlxuICAgICAgICAgICAgbWUuc3RvcmUuZGF0YSA9IGRhdGEuanNvbi5kYXRhO1xuICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMobnVsbCwgbWUuZ2V0TGlzdEl0ZW1zUm9vdCgpLCAwKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9kbzogY3JlYXRlSXRlbXMoKSBzaG91bGQgZ2V0IHRyaWdnZXJlZCBvblN0b3JlTG9hZCgpXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uSGlnaGxpZ2h0SlMubG9hZExpYnJhcnkoe1xuICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGhpZ2hsaWdodEpzUGF0aDogJy4uLy4uL2RvY3MvcmVzb3VyY2VzL2hpZ2hsaWdodC9oaWdobGlnaHQucGFjay5qcycsXG4gICAgICAgICAgICB0aGVtZVBhdGg6ICcuLi8uLi9kb2NzL3Jlc291cmNlcy9oaWdobGlnaHRqcy1jdXN0b20tZ2l0aHViLXRoZW1lLmNzcydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgTmVvLk1haW4uZ2V0QnlQYXRoKHtwYXRoOiAnbG9jYXRpb24uc2VhcmNoJ30pXG4gICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hTdHJpbmcgPSBkYXRhPy5zdWJzdHIoMSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoU3RyaW5nID8gSlNPTi5wYXJzZShge1wiJHtkZWNvZGVVUkkoc2VhcmNoU3RyaW5nLnJlcGxhY2UoLyYvZywgXCJcXFwiLFxcXCJcIikucmVwbGFjZSgvPS9nLCBcIlxcXCI6XFxcIlwiKSl9XCJ9YCkgOiB7fTtcbiAgICAgICAgICAgICAgICBtZS5kZWNrID0gc2VhcmNoLmRlY2sgfHwgJ2xlYXJubmVvJztcblxuICAgICAgICAgICAgICAgIG1lLmRvTG9hZFN0b3JlKCk7XG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKi9cbiAgICBvbkxlYWZJdGVtQ2xpY2socmVjb3JkKSB7XG4gICAgICAgIHN1cGVyLm9uTGVhZkl0ZW1DbGljayhyZWNvcmQpO1xuICAgICAgICB0aGlzLmRvRmV0Y2hDb250ZW50KHJlY29yZClcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbnRlbnRUcmVlTGlzdCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRlbnRUcmVlTGlzdDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3LmxlYXJuLkNvbnRlbnRWaWV3XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQ29udGVudFZpZXcgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubGVhcm4uQ29udGVudFZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3LmxlYXJuLkNvbnRlbnRWaWV3JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbGVhcm4tY29udGVudCddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbGVhcm4tY29udGVudCddXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSByZWNvcmQ9bnVsbFxuICAgICAqL1xuICAgIHJlY29yZCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUucmVjb3JkO1xuXG4gICAgICAgIGlmIChkYXRhLmFsdEtleSAmJiBkYXRhLnNoaWZ0S2V5ICYmICFkYXRhLm1ldGFLZXkpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2VkaXQnLCB7Y29tcG9uZW50OiBtZSwgcmVjb3JkfSlcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21tYW5kL3dpbmRvd3Mgc2hpZnQgY2xpY2sgPSByZWZyZXNoXG4gICAgICAgIGVsc2UgaWYgKCFkYXRhLmFsdEtleSAmJiBkYXRhLnNoaWZ0S2V5ICYmIGRhdGEubWV0YUtleSkge1xuICAgICAgICAgICAgbWUuZmlyZSgncmVmcmVzaCcsIHtjb21wb25lbnQ6IG1lLCByZWNvcmR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgY2xpY2s6IG1lLm9uQ2xpY2ssXG4gICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ29udGVudFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBDb250ZW50VmlldztcbiIsImltcG9ydCBCYXNlICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgVGFiQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uL3NyYy90YWIvQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgVGV4dEFyZWEgICAgIGZyb20gJy4uLy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL1RleHRBcmVhLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3LmxlYXJuLkxpdmVQcmV2aWV3XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgTGl2ZVByZXZpZXcgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3LmxlYXJuLkxpdmVQcmV2aWV3J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5sZWFybi5MaXZlUHJldmlldycsXG4gICAgICAgIGJhc2VDbHM6IFsnbGVhcm4tbGl2ZS1wcmV2aWV3J10sXG4gICAgICAgIHZhbHVlXzogbnVsbCxcbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICBhdXRvUmVuZGVyOiB0cnVlLFxuICAgICAgICBoZWlnaHQ6IDQwMCxcbiAgICAgICAgbGF5b3V0OiAnZml0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBpdGVtc1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICBtb2R1bGU6IFRhYkNvbnRhaW5lcixcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ3RhYi1jb250YWluZXInLFxuICAgICAgICAgICAgY2xzOiAnbGl2ZS1wcmV2aWV3LWNvbnRhaW5lcicsXG4gICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICBtb2R1bGU6IFRleHRBcmVhLFxuICAgICAgICAgICAgICAgIGhpZGVMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdHlsZToge2hlaWdodDogJzEwMCUnfSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6ICd0ZXh0QXJlYScsXG4gICAgICAgICAgICAgICAgdGFiQnV0dG9uQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdTb3VyY2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBkYXRhID0+IGRhdGEuY29tcG9uZW50LnVwKHtjbGFzc05hbWU6ICdQb3J0YWwudmlldy5sZWFybi5MaXZlUHJldmlldyd9KS52YWx1ZSA9IGRhdGEudmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdGFiQnV0dG9uQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdQcmV2aWV3J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAncHJldmlldycsXG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb250YWluZXInXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XVxuICAgIH1cblxuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5nZXRJdGVtKCd0ZXh0QXJlYScpLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5nZXRSZWZlcmVuY2UoJ3RhYi1jb250YWluZXInKS5vbignYWN0aXZlSW5kZXhDaGFuZ2UnLCBtZS5vbkFjdGl2ZUluZGV4Q2hhbmdlLCBtZSlcbiAgICB9XG5cbiAgICBkb1J1blNvdXJjZSgpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMudmFsdWU7XG5cbiAgICAgICAgY29uc3QgaW1wb3J0UmVnZXggPSAvaW1wb3J0XFxzKyhbXFx3LV0rKVxccytmcm9tXFxzK1snXCJdKFteJ1wiXSspWydcIl0vO1xuICAgICAgICBjb25zdCBleHBvcnRSZWdleCA9IC9leHBvcnRcXHMrKD86ZGVmYXVsdFxccyspPyg/OmNvbnN0fGxldHx2YXJ8Y2xhc3N8ZnVuY3Rpb258YXN5bmNcXHMrZnVuY3Rpb258Z2VuZXJhdG9yXFxzK2Z1bmN0aW9ufGFzeW5jXFxzK2dlbmVyYXRvclxccytmdW5jdGlvbnwoXFx7W1xcc1xcU10qP1xcfSkpL2c7XG5cblxuICAgICAgICBjb25zdCBjbGVhbkxpbmVzID0gW107XG4gICAgICAgIGNvbnN0IGltcG9ydFByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IGltcG9ydE1vZHVsZU5hbWVzID0gW107XG5cbiAgICAgICAgY29uc3QgbW9kdWxlTmFtZUFuZFBhdGggPSBbXTtcblxuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLmZpbmRMYXN0Q2xhc3NOYW1lKHNvdXJjZSk7XG5cbiAgICAgICAgc291cmNlLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgbGV0IGltcG9ydE1hdGNoID0gbGluZS5tYXRjaChpbXBvcnRSZWdleCk7XG4gICAgICAgICAgICBpZiAoaW1wb3J0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW9kdWxlTmFtZSA9IGltcG9ydE1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGxldCBwYXRoID0gaW1wb3J0TWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZUFuZFBhdGgucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnRQcm9taXNlcy5wdXNoKGltcG9ydChwYXRoKSk7XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0UHJvbWlzZXMucHVzaChpbXBvcnQocGF0aCkudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICBldmFsKGBjb25zdCAke21vZHVsZU5hbWV9ID0gbW9kdWxlLmRlZmF1bHQ7YClcbiAgICAgICAgICAgICAgICAvLyB9KSk7XG4gICAgICAgICAgICAgICAgaW1wb3J0TW9kdWxlTmFtZXMucHVzaChtb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5tYXRjaChleHBvcnRSZWdleCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGV4cG9ydCBzdGF0ZW1lbnRzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFuTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIHZhcnMgPSBbXTtcbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgcGFydHMgb2YgdGhlIHNvdXJjZSB3ZSdsbCBiZSBydW5uaW5nLlxuICAgICAgICAvLyBvIFRoZSBwcm9taXNlcy9pbXBvcnQoKSBjb3JyZXNwb25kaW5nIHRvIHRoZSB1c2VyJ3MgaW1wb3J0IHN0YXRlbWVudHNcbiAgICAgICAgLy8gbyBUaGUgdmFycyBob2xkaW5nIHRoZSBuYW1lIG9mIHRoZSBpbXBvcnRlZCBtb2R1bGUgYmFzZWQgb24gdGhlIG1vZHVsZSBuYW1lIGZvciBlYWNoIGltcG9ydFxuICAgICAgICAvLyBvIFRoZSByZXN0IG9mIHRoZSB1c2VyLXByb3ZpZGVkIHNvdXJjZVxuICAgICAgICAvLyBJdCdsbCBlbmQgdXAgbG9va2luZyBsaWtlIHRoaXM6XG4gICAgICAgIC8vIFByb21pc2UuYWxsKFtcbiAgICAgICAgLy8gICAgIGltcG9ydCgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL2NvbnRhaW5lci9CYXNlLm1qcycpLFxuICAgICAgICAvLyAgICAgaW1wb3J0KCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmVvLm1qcy9zcmMvYnV0dG9uL0Jhc2UubWpzJylcbiAgICAgICAgLy8gICBdKS50aGVuKChbQmFzZU1vZHVsZSwgQnV0dG9uTW9kdWxlXSkgPT4ge1xuICAgICAgICAvLyAgICAgICBjb25zdCBCYXNlID0gQmFzZU1vZHVsZS5kZWZhdWx0O1xuICAgICAgICAvLyAgICAgICBjb25zdCBCdXR0b24gPSBCdXR0b25Nb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgLy8gICAgICAgLy8gQ2xhc3MgZGVjbGFyYXRpb24gZ29lcyBoZXJlLi4uXG4gICAgICAgIC8vICAgfSk7XG4gICAgICAgIC8vIE1ha2luZyB0aGUgcHJvbWlzZSBwYXJ0IG9mIHRoZSBldmFsIHNlZW1zIHdlaXJkLCBidXQgaXQgbWFkZSBpdCBlYXNpZXIgdG9cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBpbXBvcnQgdmFycy5cblxuICAgICAgICBsZXQgcHJvbWlzZXMgPSBtb2R1bGVOYW1lQW5kUGF0aC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgJHtpdGVtLm1vZHVsZU5hbWV9TW9kdWxlYCk7XG4gICAgICAgICAgICB2YXJzLnB1c2goYGNvbnN0ICR7aXRlbS5tb2R1bGVOYW1lfSA9ICR7aXRlbS5tb2R1bGVOYW1lfU1vZHVsZS5kZWZhdWx0YCk7XG4gICAgICAgICAgICByZXR1cm4gYGltcG9ydChcIiR7aXRlbS5wYXRofVwiKWA7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb2RlU3RyaW5nID0gYFxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICR7cHJvbWlzZXMuam9pbignLFxcbicpfVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIC50aGVuKChbJHtwYXJhbXMuam9pbignLCAnKX1dKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICR7dmFycy5qb2luKCdcXG4nKX1cbiAgICAgICAgICAgICAgICAgICAgJHtjbGVhbkxpbmVzLmpvaW4oJ1xcbicpfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHtjbGFzc05hbWV9ICYmIE5lby5jb21wb25lbnQuQmFzZS5pc1Byb3RvdHlwZU9mKCR7Y2xhc3NOYW1lfSkpIGNvbnRhaW5lci5hZGQoe21vZHVsZToke2NsYXNzTmFtZX19KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yPT5jb250YWluZXIuYWRkKHtudHlwZTonY29tcG9uZW50JyxodG1sOmVycm9yLm1lc3NhZ2V9KSk7XG4gICAgICAgIGA7XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUFsbCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0NvZGUgPSBuZXcgRnVuY3Rpb24oJ2NvbnRhaW5lcicsIGNvZGVTdHJpbmcpO1xuICAgICAgICAgICAgZHluYW1pY0NvZGUoY29udGFpbmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGQoe1xuICAgICAgICAgICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICBodG1sOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVmZXJlbmNlXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fE5lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICovXG4gICAgZ2V0SXRlbShyZWZlcmVuY2UsIGl0ZW1zID0gdGhpcy5pdGVtcykge1xuICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgY2hpbGRJdGVtO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtLnJlZmVyZW5jZSA9PT0gcmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IHRoaXMuZ2V0SXRlbShyZWZlcmVuY2UsIGl0ZW0uaXRlbXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRJdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuc291cmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudmFsdWVcbiAgICAgKi9cbiAgICBvbkFjdGl2ZUluZGV4Q2hhbmdlKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaXRlbS5yZWZlcmVuY2UgIT09ICdwcmV2aWV3JykgcmV0dXJuO1xuICAgICAgICB0aGlzLmRvUnVuU291cmNlKCk7XG4gICAgfVxuICAgIGZpbmRMYXN0Q2xhc3NOYW1lKHNvdXJjZUNvZGUpIHtcbiAgICAgICAgLy8gRGVmaW5lIGEgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGNsYXNzIGRlY2xhcmF0aW9uc1xuICAgICAgICBjb25zdCBjbGFzc0RlY2xhcmF0aW9uUmVnZXggPSAvY2xhc3NcXHMrKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcXHMqKD86ZXh0ZW5kc1xccytbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopP1xccyp7W1xcc1xcU10qP30vZztcblxuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGxldCBsYXN0Q2xhc3NOYW1lID0gbnVsbDtcblxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG1hdGNoZXMgb2YgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gY2xhc3NEZWNsYXJhdGlvblJlZ2V4LmV4ZWMoc291cmNlQ29kZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgY2xhc3MgbmFtZSBmb3VuZFxuICAgICAgICAgICAgbGFzdENsYXNzTmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhc3RDbGFzc05hbWU7XG5cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKExpdmVQcmV2aWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgTGl2ZVByZXZpZXc7XG4iLCJpbXBvcnQgQ29udGFpbmVyICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ29udGVudFZpZXcgICAgICAgICAgICAgZnJvbSAnLi9Db250ZW50Vmlldy5tanMnO1xuaW1wb3J0IENvbnRlbnRUcmVlTGlzdCAgICAgICAgIGZyb20gJy4vQ29udGVudFRyZWVMaXN0Lm1qcyc7XG5pbXBvcnQgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJNb2RlbCAgICAgIGZyb20gJy4vTWFpbkNvbnRhaW5lck1vZGVsLm1qcyc7XG5pbXBvcnQgU3BsaXR0ZXIgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudC9TcGxpdHRlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5sZWFybi5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5sZWFybi5NYWluQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5sZWFybi5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudH0gY29udHJvbGxlcj1NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbGxlcjogTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsnbGVhcm5uZW8tbWFpbmNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnbGVhcm5uZW8tbWFpbmNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZSAgOiBDb250YWluZXIsXG4gICAgICAgICAgICBsYXlvdXQgIDogJ2ZpdCcsXG4gICAgICAgICAgICBtaW5XaWR0aDogMzUwLFxuICAgICAgICAgICAgd2lkdGggICA6IDM1MCxcbiAgICAgICAgICAgIGNscyAgICAgOiAnc2lkZW5hdi1jb250YWluZXInLFxuICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgOiBDb250ZW50VHJlZUxpc3QsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAndHJlZScsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRDaGFuZ2U6ICdvbkNvbnRlbnRDaGFuZ2UnLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgIDogU3BsaXR0ZXIsXG4gICAgICAgICAgICBjbHMgICAgICAgICA6IFsnbWFpbi1jb250ZW50LXNwbGl0dGVyJ10sXG4gICAgICAgICAgICByZXNpemVUYXJnZXQ6ICdwcmV2aW91cycsXG4gICAgICAgICAgICBzaXplICAgICAgICA6IDRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDb250ZW50VmlldyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ2NvbnRlbnQnLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgZWRpdCAgIDogJ29uQ29udGVudEVkaXQnLFxuICAgICAgICAgICAgICAgIHJlZnJlc2g6ICdvbkNvbnRlbnRSZWZyZXNoJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PXtudHlwZTonaGJveCcsYWxpZ246J3N0cmV0Y2gnfVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICdoYm94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8ubW9kZWwuQ29tcG9uZW50fSBtb2RlbD1NYWluQ29udGFpbmVyTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBNYWluQ29udGFpbmVyTW9kZWxcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKE1haW5Db250YWluZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBNYWluQ29udGFpbmVyO1xuIiwiaW1wb3J0IENvbnRyb2xsZXIgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3LmxlYXJuLk1haW5Db250YWluZXJDb250cm9sbGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3LmxlYXJuLk1haW5Db250YWluZXJDb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5sZWFybi5NYWluQ29udGFpbmVyQ29udHJvbGxlcidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBOZW8uTWFpbi5nZXRCeVBhdGgoe3BhdGg6ICdsb2NhdGlvbi5zZWFyY2gnfSlcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaFN0cmluZyA9IGRhdGE/LnN1YnN0cigxKSB8fCAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2ggPSBzZWFyY2hTdHJpbmcgPyBKU09OLnBhcnNlKGB7XCIke2RlY29kZVVSSShzZWFyY2hTdHJpbmcucmVwbGFjZSgvJi9nLCBcIlxcXCIsXFxcIlwiKS5yZXBsYWNlKC89L2csIFwiXFxcIjpcXFwiXCIpKX1cIn1gKSA6IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TW9kZWwoKS5zZXREYXRhKCdkZWNrJywgc2VhcmNoLmRlY2sgfHwgJ2xlYXJubmVvJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBmZXRjaCgnLi4vLi4vLi4vLi4vcmVzb3VyY2VzL2RhdGEvZGVjay9FZGl0b3JDb25maWcuanNvbicpXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TW9kZWwoKS5zZXREYXRhKCdlZGl0b3JDb25maWcnLCBkYXRhKVxuICAgICAgICAgICAgICAgICkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvbkNvbnRlbnRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY29udGVudCA9IG1lLmdldFJlZmVyZW5jZSgnY29udGVudCcpO1xuXG4gICAgICAgIGNvbnRlbnQudG9nZ2xlQ2xzKCdsYWInLCBkYXRhLmlzTGFiKTtcblxuICAgICAgICBjb250ZW50Lmh0bWwgPSBkYXRhLmh0bWw7XG4gICAgICAgIGNvbnRlbnQucmVjb3JkID0gZGF0YS5yZWNvcmQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG9uQ29udGVudEVkaXQoZGF0YSkge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXMuZ2V0TW9kZWwoKTtcbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgIGNvbnN0IGVkaXRvckNvbmZpZyA9IHZtLmdldERhdGEoJ2VkaXRvckNvbmZpZycpO1xuICAgICAgICBjb25zdCBzdWJEaXIgPSB2bS5nZXREYXRhKCdkZWNrJylcbiAgICAgICAgaWYgKCFlZGl0b3JDb25maWcgfHwgIXN1YkRpcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7ZWRpdG9yQ29uZmlnLnJvb3R9LyR7c3ViRGlyfS9wLyR7ZGF0YS5yZWNvcmQuaWR9Lm1kYDtcblxuICAgICAgICBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL29wZW5JbkVkaXRvcicsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtwYXRoOiBmaWxlUGF0aCwgZWRpdG9yOiBlZGl0b3JDb25maWcuZWRpdG9yfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29udGVudFJlZnJlc2goZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgndHJlZScpLmRvRmV0Y2hDb250ZW50KGRhdGEucmVjb3JkKVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBNYWluQ29udGFpbmVyQ29udHJvbGxlcjtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL21vZGVsL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IFN0b3JlICAgICBmcm9tICcuLi8uLi9zdG9yZS9Db250ZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3LmxlYXJuLk1haW5Db250YWluZXJNb2RlbFxuICogQGV4dGVuZHMgTmVvLm1vZGVsLkNvbXBvbmVudFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyTW9kZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubGVhcm4uTWFpbkNvbnRhaW5lck1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5sZWFybi5NYWluQ29udGFpbmVyTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3RvcmVzXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZXM6IHtcbiAgICAgICAgICAgIHRyZWU6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICA6IFN0b3JlLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlUm9vdDogJ2RhdGEnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKE1haW5Db250YWluZXJNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5Db250YWluZXJNb2RlbDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ1pvbmUgIGZyb20gJy4uL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogU3BsaXR0ZXJzIGNhbiBnZXQgcHV0IGludG8gY29udGFpbmVycyB0byBtYWtlIHNpYmxpbmdzIHJlc2l6YWJsZSB2aWEgZHJhZyAmIGRyb3BcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LlNwbGl0dGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgU3BsaXR0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgZGlyZWN0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRpcmVjdGlvbnM9Wydob3Jpem9udGFsJywndmVydGljYWwnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRpcmVjdGlvbnMgPSBbJ2hvcml6b250YWwnLCAndmVydGljYWwnXVxuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgcmVzaXplVGFyZ2V0XG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHJlc2l6ZVRhcmdldHM9WyduZXh0JywncHJldmlvdXMnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHJlc2l6ZVRhcmdldHMgPSBbJ25leHQnLCAncHJldmlvdXMnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LlNwbGl0dGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LlNwbGl0dGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NwbGl0dGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NwbGl0dGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXNwbGl0dGVyJywnbmVvLWRyYWdnYWJsZSddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1zcGxpdHRlcicsICduZW8tZHJhZ2dhYmxlJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFaXRoZXIgJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXJlY3Rpb25fPSd2ZXJ0aWNhbCdcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbl86ICd2ZXJ0aWNhbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLkRyYWdab25lfG51bGx9IGRyYWdab25lPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJhZ1pvbmVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaG9vc2Ugd2hpY2ggc2libGluZyB0byByZXNpemVcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnbmV4dCcgb3IgJ3ByZXZpb3VzJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlc2l6ZVRhcmdldF89J25leHQnXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemVUYXJnZXRfOiAnbmV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFaXRoZXIgaGVpZ2h0IG9yIHdpdGgsIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNpemVfPTEwXG4gICAgICAgICAqL1xuICAgICAgICBzaXplXzogMTBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkRyYWdFbmQsICAgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uRHJhZ1N0YXJ0LCBzY29wZTogbWV9XG4gICAgICAgIF0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkaXJlY3Rpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyAgICA9IG1lLmNscyxcbiAgICAgICAgICAgIGhlaWdodCA9IHZhbHVlID09PSAndmVydGljYWwnID8gbnVsbCA6IG1lLnNpemUsXG4gICAgICAgICAgICB3aWR0aCAgPSB2YWx1ZSAhPT0gJ3ZlcnRpY2FsJyA/IG51bGwgOiBtZS5zaXplO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsIGBuZW8tJHt2YWx1ZX1gKTtcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIGBuZW8tJHtvbGRWYWx1ZX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuc2V0KHtcbiAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIG1pbkhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgbWluV2lkdGggOiB3aWR0aCxcbiAgICAgICAgICAgIHdpZHRoXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNpemUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXNbdGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCddID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBkaXJlY3Rpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNldERpcmVjdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RpcmVjdGlvbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcmVzaXplVGFyZ2V0IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRSZXNpemVUYXJnZXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdyZXNpemVUYXJnZXQnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3R5bGUgICAgICA9IG1lLnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgcGFyZW50ICAgICA9IG1lLnBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudElkICAgPSBtZS5wYXJlbnRJZCxcbiAgICAgICAgICAgIHJlc2l6ZU5leHQgPSBtZS5yZXNpemVUYXJnZXQgPT09ICduZXh0JyxcbiAgICAgICAgICAgIHNpemUgICAgICAgPSBtZS5zaXplLFxuICAgICAgICAgICAgaW5kZXgsIG5ld1NpemUsIHNpYmxpbmc7XG5cbiAgICAgICAgcGFyZW50LmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgbWUuZHJhZ1pvbmUuZHJhZ0VuZChkYXRhKTtcblxuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMTtcblxuICAgICAgICBtZS5zdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgIG1lLmdldERvbVJlY3QocGFyZW50SWQpLnRoZW4ocGFyZW50UmVjdCA9PiB7XG4gICAgICAgICAgICBpbmRleCAgID0gcGFyZW50LmluZGV4T2YobWUpO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5pdGVtc1tyZXNpemVOZXh0ID8gaW5kZXggKyAxIDppbmRleCAtIDFdO1xuICAgICAgICAgICAgc3R5bGUgICA9IHNpYmxpbmcuc3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIHN0eWxlLmZsZXggPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIGlmIChtZS5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICBuZXdTaXplID0gZGF0YS5jbGllbnRYIC0gZGF0YS5vZmZzZXRYIC0gc2l6ZSAtIHBhcmVudFJlY3QubGVmdDtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNpemVOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NpemUgPSBwYXJlbnRSZWN0LndpZHRoIC0gbmV3U2l6ZSAtICAyICogc2l6ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NpemUgKz0gc2l6ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld1NpemUgPSBNYXRoLm1pbihNYXRoLm1heChuZXdTaXplLCAwKSwgcGFyZW50UmVjdC53aWR0aCAtIHNpemUpO1xuXG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHtuZXdTaXplfXB4YFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTaXplID0gZGF0YS5jbGllbnRZIC0gZGF0YS5vZmZzZXRZIC0gc2l6ZSAtIHBhcmVudFJlY3QudG9wO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2l6ZSA9IHBhcmVudFJlY3QuaGVpZ2h0IC0gbmV3U2l6ZSAtICAyICogc2l6ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NpemUgKz0gc2l6ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld1NpemUgPSBNYXRoLm1pbihNYXRoLm1heChuZXdTaXplLCAwKSwgcGFyZW50UmVjdC5oZWlnaHQgLSBzaXplKTtcblxuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGAke25ld1NpemV9cHhgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaWJsaW5nLnN0eWxlID0gc3R5bGVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0eWxlICAgID0gbWUuc3R5bGUgfHwge30sXG4gICAgICAgICAgICB2ZXJ0aWNhbCA9IG1lLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJztcblxuICAgICAgICBtZS5wYXJlbnQuZGlzYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICghbWUuZHJhZ1pvbmUpIHtcbiAgICAgICAgICAgIG1lLmRyYWdab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogRHJhZ1pvbmUsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBib2R5Q3Vyc29yU3R5bGUgICAgOiB2ZXJ0aWNhbCA/ICdldy1yZXNpemUgIWltcG9ydGFudCcgOiAnbnMtcmVzaXplICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG1lLnBhcmVudElkLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgICAgICA6IG1lLnZkb20sXG4gICAgICAgICAgICAgICAgbW92ZUhvcml6b250YWwgICAgIDogdmVydGljYWwsXG4gICAgICAgICAgICAgICAgbW92ZVZlcnRpY2FsICAgICAgIDogIXZlcnRpY2FsLFxuICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgIHVzZVByb3h5V3JhcHBlciAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC4uLm1lLmRyYWdab25lQ29uZmlnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuZHJhZ1pvbmUuc2V0KHtcbiAgICAgICAgICAgICAgICBib2R5Q3Vyc29yU3R5bGU6IHZlcnRpY2FsID8gJ2V3LXJlc2l6ZSAhaW1wb3J0YW50JyA6ICducy1yZXNpemUgIWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgbW92ZUhvcml6b250YWwgOiB2ZXJ0aWNhbCxcbiAgICAgICAgICAgICAgICBtb3ZlVmVydGljYWwgICA6ICF2ZXJ0aWNhbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRyYWdab25lLmRyYWdTdGFydChkYXRhKTtcblxuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC41O1xuXG4gICAgICAgIG1lLnN0eWxlID0gc3R5bGVcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKFNwbGl0dGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgU3BsaXR0ZXI7XG4iLCJpbXBvcnQgU3RyaW5nVXRpbCBmcm9tICcuLi8uLi91dGlsL1N0cmluZy5tanMnO1xuaW1wb3J0IFRleHQgICAgICAgZnJvbSAnLi9UZXh0Lm1qcyc7XG5cbi8qKlxuICpcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5UZXh0QXJlYVxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuVGV4dFxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFRleHRBcmVhIGV4dGVuZHMgVGV4dCB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciB3cmFwXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHdyYXBWYWx1ZXM9WydoYXJkJywgJ29mZicsICdzb2Z0JywgbnVsbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyB3cmFwVmFsdWVzID0gWydoYXJkJywgJ29mZicsICdzb2Z0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuVGV4dEFyZWEnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLlRleHRBcmVhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RleHRhcmVhJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RleHRhcmVhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIGB0cnVlYCB0byBoYXZlIHRoZSB0ZXh0IGFyZWEgZ3JvdyBhbmQgc2hyaW5rIHRvIGFjY29tbW9kYXRlXG4gICAgICAgICAqIGFueSBoZWlnaHQgb2YgdGV4dC4gQm91bmRzIGNhbiBiZSBzZXQgdXNpbmcgdGhlIGBtaW5IZWlnaHRgIGFuZCBgbWF4SGVpZ2h0YCBzZXR0aW5ncy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0dyb3c9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Hcm93XzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10ZXh0YXJlYScsJ25lby10ZXh0ZmllbGQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdGV4dGFyZWEnLCAnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBzaG93cyBhIGNsZWFyIHRyaWdnZXIgaW4gY2FzZSB0aGUgZmllbGQgaGFzIGEgbm9uLWVtcHR5IHZhbHVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjbGVhcmFibGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyYWJsZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlzaWJsZSB3aWR0aCBvZiB0aGUgdGV4dCBjb250cm9sLCBpbiBhdmVyYWdlIGNoYXJhY3RlciB3aWR0aHMuXG4gICAgICAgICAqIElmIGl0IGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXG4gICAgICAgICAqIElmIGl0IGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IHZhbHVlIGlzIDIwLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gY29sc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlucHV0VGFnXz0ndGV4dGFyZWEnXG4gICAgICAgICAqL1xuICAgICAgICBpbnB1dFRhZ186ICd0ZXh0YXJlYScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxpbmcgdG8gc2V0IGEgdHlwZSBmb3IgdGhlIHRleHRhcmVhIHRhZ1xuICAgICAgICAgKiBTZWU6IGlucHV0VGFnX1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaW5wdXRUeXBlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRUeXBlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGZhbHNlIHRvIGRpc2FibGUgdGhlIGJyb3dzZXJzIGRlZmF1bHQgcmVzaXppbmcgZmVhdHVyZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZXNpemFibGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVnZXIgPiAwIG9yIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHJvd3NfPTNcbiAgICAgICAgICovXG4gICAgICAgIHJvd3NfOiAzLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGhvdyB0aGUgY29udHJvbCB3cmFwcyB0ZXh0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBoYXJkLCBzb2Z0LCBvZmZcbiAgICAgICAgICogSWYgdGhpcyBhdHRyaWJ1dGUgaXMgbm90IHNwZWNpZmllZCwgc29mdCBpcyBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3RleHRhcmVhXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB3cmFwXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwXzogbnVsbFxuICAgIH1cblxuICAgIGFmdGVyU2V0QXV0b0dyb3coYXV0b0dyb3cpIHtcbiAgICAgICAgYXV0b0dyb3cgJiYgdGhpcy5zeW5jQXV0b0dyb3dNb25pdG9yKCk7XG5cbiAgICAgICAgLy8gUmVzdG9yZSBhbnkgY29uZmlndXJlZCBoZWlnaHQgaWYgYXV0b0dyb3cgdHVybmVkIG9mZlxuICAgICAgICBpZiAoIWF1dG9Hcm93KSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyU2V0SGVpZ2h0KHRoaXMuX2hlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnY29scycsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlucHV0VGFnIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElucHV0VGFnKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ3RhZycsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgdGhpcy5zeW5jQXV0b0dyb3dNb25pdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZXNpemFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZXNpemFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdHlsZSA9IHRoaXMuZ2V0SW5wdXRFbCgpLnN0eWxlO1xuXG4gICAgICAgIHN0eWxlLnJlc2l6ZSA9IHZhbHVlID8gbnVsbCA6ICdub25lJztcbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3dzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3dzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ3Jvd3MnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGlucHV0RWwgPSB0aGlzLmdldElucHV0RWwoKTtcblxuICAgICAgICBpZiAoaW5wdXRFbCkge1xuICAgICAgICAgICAgaW5wdXRFbC5odG1sID0gU3RyaW5nVXRpbC5lc2NhcGVIdG1sKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdyYXAgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdyYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnd3JhcCcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyB3cmFwIHZhbHVlIG1hdGNoZXMgYSB2YWx1ZSBvZiB0aGUgc3RhdGljIHdyYXBWYWx1ZXMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0V3JhcCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3dyYXAnLCAnd3JhcFZhbHVlcycpO1xuICAgIH1cblxuICAgIGFzeW5jIHN5bmNBdXRvR3Jvd01vbml0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQgJiYgdGhpcy5hdXRvR3Jvdykge1xuICAgICAgICAgICAgLy8gRGVsZWdhdGUgbW9uaXRvcmluZyBvZiBzaXplcyB0byB0aGUgVkRPTSB0aHJlYWQuXG4gICAgICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3MubW9uaXRvckF1dG9Hcm93KHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lICA6IHRoaXMuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IHRoaXMuZ2V0SW5wdXRFbElkKCksXG4gICAgICAgICAgICAgICAgYXV0b0dyb3cgOiB0aGlzLmF1dG9Hcm93XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoVGV4dEFyZWEpO1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0QXJlYTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==