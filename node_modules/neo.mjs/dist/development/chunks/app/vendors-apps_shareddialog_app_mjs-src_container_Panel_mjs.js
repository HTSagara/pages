"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_shareddialog_app_mjs-src_container_Panel_mjs"],{

/***/ "./apps/shareddialog/app.mjs":
/*!***********************************!*\
  !*** ./apps/shareddialog/app.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/MainContainer.mjs */ "./apps/shareddialog/view/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'SharedDialog'
});


/***/ }),

/***/ "./apps/shareddialog/view/DemoDialog.mjs":
/*!***********************************************!*\
  !*** ./apps/shareddialog/view/DemoDialog.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_dialog_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/dialog/Base.mjs */ "./src/dialog/Base.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");



/**
 * @class SharedDialog.view.DemoDialog
 * @extends Neo.dialog.Base
 */
class DemoDialog extends _src_dialog_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.DemoDialog'
         * @protected
         */
        className: 'SharedDialog.view.DemoDialog',
        /**
         * @member {String} title='Drag me across Windows!'
         */
        title: 'Drag me across Windows!',
        /**
         * @member {Object} containerConfig={style:padding:'20px}}
         */
        containerConfig: {
            style: {
                padding: '20px'
            }
        },
        /**
         * @member {Object} itemDefaults={labelWidth:70}
         */
        itemDefaults: {
            labelWidth: 70
        },
        /**
         * @member {Object[]} items
         */
        items: [{
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 'none',
            labelText: 'Field 1'
        }, {
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 'none',
            labelText: 'Field 2'
        }],
        /**
         * @member {Object} wrapperStyle={height:'40%',width:'40%'}
         */
        wrapperStyle: {
            height: '40%',
            width : '40%'
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DemoDialog));


/***/ }),

/***/ "./apps/shareddialog/view/MainContainer.mjs":
/*!**************************************************!*\
  !*** ./apps/shareddialog/view/MainContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_form_field_Radio_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/Radio.mjs */ "./src/form/field/Radio.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/shareddialog/view/MainContainerController.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");






/**
 * @class SharedDialog.view.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.MainContainer'
         * @protected
         */
        className: 'SharedDialog.view.MainContainer',
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex  : 'none',
            items :[{
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                flag   : 'open-dialog-button',
                handler: 'onCreateDialogButtonClick',
                iconCls: 'far fa-window-maximize',
                text   : 'Create Dialog',
            }, '->', {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'switchTheme',
                iconCls: 'fa fa-moon',
                text   : 'Theme Dark'
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'openDockedWindow',
                iconCls: 'far fa-window-restore',
                style  : {marginLeft: '1em'},
                text   : 'Open docked Window'
            }]
        }, {
            ntype : 'container',
            flex  : 'none',
            layout: 'hbox',

            style: {
                height     : '72px',
                marginRight: '1em',
                marginTop  : '1em'
            },

            items : [{
                ntype: 'component',
                flex : 1
            }, {
                ntype: 'container',
                flex : 'none',

                itemDefaults: {
                    module        : _src_form_field_Radio_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    hideValueLabel: false,
                    labelText     : '',
                    labelWidth    : 50,
                    name          : 'dockedPosition',

                    listeners: {
                        change: 'onDockedPositionChange'
                    }
                },

                items: [{
                    labelText     : 'Dock',
                    valueLabelText: 'Top',
                    value         : 'top'
                }, {
                    checked       : true,
                    valueLabelText: 'Right',
                    value         : 'right'
                }, {
                    valueLabelText: 'Bottom',
                    value         : 'bottom'
                }, {
                    valueLabelText: 'Left',
                    value         : 'left'
                }]
            }]
        }, {
            ntype: 'component',
            flex : 1,
            html : '#1',

            style: {
                alignItems    : 'center',
                color         : '#bbb',
                display       : 'flex',
                fontSize      : '200px',
                justifyContent: 'center',
                marginBottom  : '88px',
                userSelect    : 'none'
            }
        }],
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Object} style={padding:'20px'}
         */
        style: {padding: '20px'}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./apps/shareddialog/view/MainContainerController.mjs":
/*!************************************************************!*\
  !*** ./apps/shareddialog/view/MainContainerController.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _src_manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _DemoDialog_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DemoDialog.mjs */ "./apps/shareddialog/view/DemoDialog.mjs");
/* harmony import */ var _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../src/util/Rectangle.mjs */ "./src/util/Rectangle.mjs");







/**
 * @class SharedDialog.view.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.MainContainerController'
         * @protected
         */
        className: 'SharedDialog.view.MainContainerController',
        /**
         * @member {String[]} connectedApps=[]
         */
        connectedApps: [],
        /**
         * @member {String} currentTheme='neo-theme-light'
         */
        currentTheme: 'neo-theme-light',
        /**
         * @member {String} dockedWindowAppName='SharedDialog2'
         */
        dockedWindowAppName: 'SharedDialog2',
        /**
         * @member {Number|null} dockedWindowId=null
         */
        dockedWindowId: null,
        /**
         * @member {Neo.component.Base|null} dockedWindowProxy=null
         */
        dockedWindowProxy: null,
        /**
         * Valid values: bottom, left, right, top
         * @member {String} dockedWindowSide_='right'
         */
        dockedWindowSide_: 'right',
        /**
         * @member {Number} dockedWindowSize=500
         */
        dockedWindowSize: 620,
        /**
         * @member {Object} dialogRect=null
         */
        dialogRect: null,
        /**
         * @member {Object} dragStartWindowRect=null
         */
        dragStartWindowRect: null,
        /**
         * @member {Number|null} targetWindowSize=0
         */
        targetWindowSize: 0
    }

    /**
     * The App worker will receive connect & disconnect events inside the SharedWorkers context
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onAppConnect,
            disconnect: me.onAppDisconnect,
            scope     : me
        })
    }

    /**
     * Triggered after the dockedWindowSide config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDockedWindowSide(value, oldValue) {
        if (this.hasDockedWindow()) {
            Neo.main.addon.WindowPosition.setDock({
                name: this.dockedWindowAppName,
                dock: value
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} appName
     */
    createDialog(data, appName) {
        let me         = this,
            {windowId} = me;

        me.enableOpenDialogButtons(false);

        me.dialog = Neo.create(_DemoDialog_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
            animateTargetId    : data.component.id,
            appName,
            boundaryContainerId: null,
            cls                : [me.currentTheme, 'neo-dialog', 'neo-panel', 'neo-container'],
            windowId,

            dragZoneConfig: {
                alwaysFireDragMove: true
            },

            listeners: {
                close          : me.onDialogClose,
                dragZoneCreated: me.onDragZoneCreated,
                scope          : me
            }
        })
    }

    /**
     *
     */
    destroyDockedWindowProxy() {
        let me = this;

        if (me.dockedWindowProxy) {
            me.dockedWindowProxy.destroy(true);
            me.dockedWindowProxy = null;
        }
    }

    /**
     * @param {Object} proxyRect
     */
    dropDialogBetweenWindows(proxyRect) {
        let me           = this,
            dialog       = me.dialog,
            intersection = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersectionDetails(me.dragStartWindowRect, proxyRect),
            side         = me.dockedWindowSide,
            size         = proxyRect.height * proxyRect.width,
            wrapperStyle;

        if (intersection.area > size / 2) { // drop the dialog fully into the dragStart window
            me.destroyDockedWindowProxy();

            wrapperStyle = dialog.wrapperStyle;

            if (dialog.appName === me.dockedWindowAppName) {
                side = me.getOppositeSide(side);
            }

            switch (side) {
                case 'bottom':
                    wrapperStyle.top = `${me.dragStartWindowRect.height - proxyRect.height}px`;
                    break;
                case 'left':
                    wrapperStyle.left = '0px';
                    break;
                case 'right':
                    wrapperStyle.left = `${me.dragStartWindowRect.width - proxyRect.width}px`;
                    break;
                case 'top':
                    wrapperStyle.top = '0px';
                    break;
            }

            dialog.wrapperStyle = wrapperStyle;
        } else { // drop the dialog fully into the dragEnd window
            me.mountDialogInOtherWindow({
                fullyIncludeIntoWindow: true,
                proxyRect             : proxyRect
            })
        }
    }

    /**
     * @param {Boolean} enable
     */
    enableOpenDialogButtons(enable) {
        this.getOpenDialogButtons().forEach(button => {
            button.disabled = !enable
        })
    }

    /**
     * @return {Neo.button.Base}
     */
    getOpenDockedWindowButton() {
        return this.component.down({iconCls: 'far fa-window-restore'})
    }

    /**
     *
     */
    getOpenDialogButtons() {
        return _src_manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find({
            flag: 'open-dialog-button'
        })
    }

    /**
     * @param {String} side
     * @return {String}
     */
    getOppositeSide(side) {
        return {
            bottom: 'top',
            left  : 'right',
            right : 'left',
            top   : 'bottom'
        }[side]
    }

    /**
     * @param {Object} proxyRect
     * @param {String} side
     * @param {Boolean} [fullyIncludeIntoWindow=false]
     * @return {{left: String, top: String}}
     */
    getProxyPosition(proxyRect, side, fullyIncludeIntoWindow=false) {
        let me                  = this,
            dragStartWindowRect = me.dragStartWindowRect,
            targetWindowSize    = me.targetWindowSize,
            left, top;

        switch(side) {
            case 'bottom':
                left = `${proxyRect.left}px`;
                top  = `${fullyIncludeIntoWindow ? 0 : proxyRect.top - dragStartWindowRect.height}px`;
                break;
            case 'left':
                left = `${fullyIncludeIntoWindow ? targetWindowSize - proxyRect.width : targetWindowSize + proxyRect.left}px`;
                top  = `${proxyRect.top}px`;
                break;
            case 'right':
                left = `${fullyIncludeIntoWindow ? 0 : proxyRect.left - dragStartWindowRect.width}px`;
                top  = `${proxyRect.top}px`;
                break;
            case 'top':
                left = `${proxyRect.left}px`;
                top  = `${fullyIncludeIntoWindow ? targetWindowSize - proxyRect.height : targetWindowSize + proxyRect.top}px`;
                break;
        }

        return {left, top}
    }

    /**
     * @return {Boolean}
     */
    hasDockedWindow() {
        return this.connectedApps.includes(this.dockedWindowAppName)
    }

    /**
     * @param {Object} data
     * @param {Object} data.proxyRect
     * @param {Boolean} [data.fullyIncludeIntoWindow]
     */
    mountDialogInOtherWindow(data) {
        let me                   = this,
            appName              = me.component.appName,
            dialog               = me.dialog,
            dragEndWindowAppName = me.dockedWindowAppName,
            side                 = me.dockedWindowSide,
            proxyPosition, wrapperStyle;

        if (dialog.appName === dragEndWindowAppName) {
            dragEndWindowAppName = me.component.appName;
            side                 = me.getOppositeSide(me.dockedWindowSide)
        }

        proxyPosition = me.getProxyPosition(data.proxyRect, side, data.fullyIncludeIntoWindow);

        dialog.unmount();

        // we need a delay to ensure dialog.Base: onDragEnd() is done.
        // we could use the dragEnd event of the dragZone instead.
        me.timeout(70).then(() => {
            dialog.appName = dialog.appName === dragEndWindowAppName ? appName : dragEndWindowAppName;

            // todo: windowI

            me.getOpenDialogButtons().forEach(button => {
                if (button.appName === dialog.appName) {
                    dialog.animateTargetId = button.id
                }
            });

            wrapperStyle = dialog.wrapperStyle;

            wrapperStyle.left = proxyPosition.left;
            wrapperStyle.top  = proxyPosition.top;

            dialog.wrapperStyle = wrapperStyle;

            me.destroyDockedWindowProxy();

            dialog.mount()
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Number} data.windowId
     */
    onAppConnect(data) {
        let me   = this,
            name = data.appName;

        _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(me.connectedApps, name);

        if (name !== 'SharedDialog' && me.currentTheme !== 'neo-theme-light') {
            me.switchThemeForApp(name, me.currentTheme)
        }

        if (name === me.dockedWindowAppName) {
            me.dockedWindowId = data.windowId;
            me.getOpenDockedWindowButton().disabled = true
        }

        me.enableOpenDialogButtons(!me.dialog)
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     */
    onAppDisconnect(data) {
        let me   = this,
            name = data.appName;

        if (name === 'SharedDialog') {
            // we want to close all popup windows, which equals to all connected apps minus the main app
            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(me.connectedApps, 'SharedDialog');

            Neo.Main.windowClose({
                names: me.connectedApps
            })
        } else {
            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(me.connectedApps, name);

            Neo.main.addon.WindowPosition.unregisterWindow({
                name: name
            })
        }

        if (name === me.dockedWindowAppName) {
            me.getOpenDockedWindowButton().disabled = false
        }
    }

    /**
     * @param {Object} data
     */
    onCreateDialogButtonClick(data) {
        this.createDialog(data, this.component.appName)
    }

    /**
     *
     */
    onDialogClose() {
        this.enableOpenDialogButtons(true)
    }

    /**
     * @param {Object} data
     */
    onDockedPositionChange(data) {
        if (data.value === true) {
            this.dockedWindowSide = data.component.value
        }
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.hasDockedWindow()) {
            let me                  = this,
                dialog              = me.dialog,
                dragStartWindowRect = me.dragStartWindowRect,
                proxyRect           = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].moveTo(me.dialogRect, data.clientX - data.offsetX, data.clientY - data.offsetY),
                side                = me.dockedWindowSide;

            if (dialog.appName === me.dockedWindowAppName) {
                side = me.getOppositeSide(me.dockedWindowSide)
            }

            if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].leavesSide(dragStartWindowRect, proxyRect, side)) {
                if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].excludes(dragStartWindowRect, proxyRect)) {
                    console.log('mountDialogInOtherWindow');
                    me.mountDialogInOtherWindow({proxyRect})
                } else {
                    me.dropDialogBetweenWindows(proxyRect)
                }
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragMove(data) {
        if (this.hasDockedWindow()) {
            let me        = this,
                 {dialogRect, dragStartWindowRect, dockedWindowAppName, dockedWindowId} = me,
                proxyRect = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].moveTo(dialogRect, data.clientX - data.offsetX, data.clientY - data.offsetY),
                side      = me.dockedWindowSide,
                proxyPosition, vdom;

            // in case we trigger the drag:start inside the docked window,
            // we can keep the same logic with just flipping the side.
            if (me.dialog.appName === dockedWindowAppName) {
                dockedWindowAppName = me.component.appName;
                dockedWindowId      = me.component.windowId;
                side                = me.getOppositeSide(me.dockedWindowSide);
            }

            if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].leavesSide(dragStartWindowRect, proxyRect, side)) {
                proxyPosition = me.getProxyPosition(proxyRect, side);

                if (!me.dockedWindowProxy) {
                    vdom = Neo.clone(me.dialog.dragZone.dragProxy.vdom, true);

                    delete vdom.id;

                    Object.assign(vdom.style, {
                        ...proxyPosition,
                        transform         : 'none',
                        transitionProperty: 'none'
                    });

                    me.dockedWindowProxy = Neo.create({
                        module    : _src_component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                        appName   : dockedWindowAppName,
                        autoMount : true,
                        autoRender: true,
                        cls       : ['neo-dialog', 'neo-dragproxy'],
                        parentId  : 'document.body',
                        vdom      : vdom,
                        windowId  : dockedWindowId
                    });
console.log(me.windowId, dockedWindowId);
                    // The other window has most likely not loaded The dialog JS module yet,
                    // but the drag proxy is using some CSS rules of it.
                    Neo.currentWorker.insertThemeFiles(dockedWindowId, Neo.dialog.Base.prototype);
                    Neo.currentWorker.insertThemeFiles(dockedWindowId, Neo.draggable.DragProxyComponent.prototype)
                } else {
                    me.updateDockedWindowProxyStyle({
                        ...proxyPosition,
                        visibility: null
                    })
                }
            } else {
                me.updateDockedWindowProxyStyle({visibility: 'hidden'})
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragStart(data) {
        if (this.hasDockedWindow()) {
            let me               = this,
                appName          = me.component.appName,
                dockedHorizontal = me.dockedWindowSide === 'left' || me.dockedWindowSide === 'right';

            me.dialogRect = data.dragElementRect;

            for (let item of data.eventData.path) {
                if (item.tagName === 'body') {
                    me.dragStartWindowRect = item.rect;
                    break
                }
            }

            if (me.hasDockedWindow()) {
                Neo.Main.getWindowData({
                    appName: me.dialog.appName === appName ? me.dockedWindowAppName : appName
                }).then(data => {
                    me.targetWindowSize = dockedHorizontal ? data.innerWidth : data.innerHeight
                })
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragZoneCreated(data) {
        let me = this;

        data.dragZone.on({
            dragEnd  : me.onDragEnd,
            dragMove : me.onDragMove,
            dragStart: me.onDragStart,
            scope    : me
        })
    }

    /**
     * Creates a new popup window, which is initially docked to this.dockedWindowSide of the main window
     * @param {Object} handlerData
     */
    openDockedWindow(handlerData) {
        Neo.Main.getWindowData().then(data => {
            let me     = this,
                dock   = me.dockedWindowSide,
                size   = me.dockedWindowSize,
                height, left, top, width;

            switch (dock) {
                case 'bottom':
                    height = size;
                    left   = data.screenLeft;
                    top    = data.outerHeight + data.screenTop - 52;
                    width  = data.outerWidth;
                    break
                case 'left':
                    height = data.outerHeight - 78;
                    left   = data.screenLeft  - size;
                    top    = data.screenTop   + 28;
                    width  = size;
                    break
                case 'right':
                    height = data.outerHeight - 78;
                    left   = data.outerWidth  + data.screenLeft;
                    top    = data.screenTop   + 28;
                    width  = size;
                    break
                case 'top':
                    height = size;
                    left   = data.screenLeft;
                    top    = data.screenTop - size + 28;
                    width  = data.outerWidth;
                    break
            }

            Neo.Main.windowOpen({
                url           : 'childapps/shareddialog2/index.html',
                windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
                windowName    : me.dockedWindowAppName
            });

            Neo.main.addon.WindowPosition.registerWindow({
                dock: dock,
                name: me.dockedWindowAppName,
                size: size
            })
        })
    }

    /**
     * Switches the theme for all connected apps
     * @param {Object} data
     */
    switchTheme(data) {
        let me         = this,
            button     = data.component,
            buttonText = 'Theme Light',
            dialog     = me.dialog,
            iconCls    = 'fa fa-sun',
            theme      = 'neo-theme-dark',
            cls;

        if (button.text === 'Theme Light') {
            buttonText = 'Theme Dark';
            iconCls    = 'fa fa-moon';
            theme      = 'neo-theme-light';
        }

        me.connectedApps.forEach(appName => {
            me.switchThemeForApp(appName, theme)
        });

        button.set({
            iconCls: iconCls,
            text   : buttonText
        });

        if (dialog) {
            cls = dialog.cls;

            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].removeAdd(cls, me.currentTheme, theme);

            dialog.cls = cls
        }

        me.currentTheme = theme
    }

    /**
     * @param {String} appName
     * @param {String} theme
     */
    switchThemeForApp(appName, theme) {
        Neo.main.DomAccess.setBodyCls({
            appName: appName,
            add    : [theme],
            remove : [this.currentTheme]
        })
    }

    /**
     * @param {Object} style
     */
    updateDockedWindowProxyStyle(style) {
        let dockedWindowProxy = this.dockedWindowProxy;

        if (dockedWindowProxy) {
            dockedWindowProxy.style = Object.assign(dockedWindowProxy.style || {}, style)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} text_=''
         */
        text_: '',
        /**
         * @member {Object} _vdom={tag: 'label'}
         */
        _vdom:
        {tag: 'label', draggable: false}
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        this.vdom.html = value;
        this.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ }),

/***/ "./src/container/Panel.mjs":
/*!*********************************!*\
  !*** ./src/container/Panel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");



/**
 * An extended Container supporting multiple docked header toolbars
 * @class Neo.container.Panel
 * @extends Neo.container.Base
 */
class Panel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Panel'
         * @protected
         */
        className: 'Neo.container.Panel',
        /**
         * @member {String} ntype='panel'
         * @protected
         */
        ntype: 'panel',
        /**
         * @member {String[]} baseCls=['neo-panel','neo-container']
         */
        baseCls: ['neo-panel', 'neo-container'],
        /**
         * @member {Object} containerConfig=null
         */
        containerConfig: null,
        /**
         * @member {Object} headerDefaults=null
         */
        headerDefaults: null,
        /**
         * @member {Array} headers=null
         */
        headers: null,
        /**
         * @member {Object} items={ntype: 'vbox', align: 'stretch'}
         */
        _layout: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Boolean} verticalHeadersFirst=false
         */
        verticalHeadersFirst: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.hasHeaders() && me.verticalHeadersFirst === true) {
            me.layout = {
                ntype: 'hbox',
                align: 'stretch'
            };
        }
    }

    /**
     * @param {Object} header the header config
     * @returns {Object}
     */
    static createHeaderConfig(header) {
        if (Neo.typeOf(header) === 'NeoInstance') {
            return header;
        }

        let config = {
            flex: '0 1 auto'
        };

        if (!header.module && !header.ntype) {
            config.cls   = ['neo-panel-header-toolbar', 'neo-toolbar'];
            config.ntype = 'toolbar';
        }

        if (header.text) {
            config.items = [{
                ntype: 'label',
                cls  : ['neo-panel-header-text', 'neo-label'],
                text : header.text
            }];

            delete header.text;
        }

        // assuming all labels inside a Panel Header are meant to be titles -> look the same way
        if (Array.isArray(header.items)) {
            header.items.forEach(item => {
                if (item.ntype === 'label') {
                    item.cls = ['neo-panel-header-text', 'neo-label'];
                }
            });
        }

        return {...config, ...header}
    }

    /**
     *
     */
    createItems() {
        let me              = this,
            containerConfig = me.containerConfig;

        if (!me.hasHeaders()) {
            containerConfig && me.set(containerConfig);
            super.createItems();
        } else {
            let hf                   = me.verticalHeadersFirst === false,
                headers              = me.headers || [],
                bottomHeaders        = headers.filter(header => {return header.dock === (hf ?'bottom': 'right')}),
                leftHeaders          = headers.filter(header => {return header.dock === (hf ?'left'  : 'top')}),
                rightHeaders         = headers.filter(header => {return header.dock === (hf ?'right' : 'bottom')}),
                topHeaders           = headers.filter(header => {return header.dock === (hf ?'top'   : 'left')}),
                hasHorizontalHeaders = bottomHeaders.length > 0 || topHeaders  .length > 0,
                hasVerticalHeaders   = leftHeaders  .length > 0 || rightHeaders.length > 0,
                {items}              = me,
                horizontalItems      = [],
                verticalItems        = [],
                config;

            topHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            if (hasVerticalHeaders && (hf && hasHorizontalHeaders || !hf && hasHorizontalHeaders)) {
                leftHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                horizontalItems.push({...me.headerDefaults, ...config});

                rightHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                verticalItems.push({
                    ntype : 'container',
                    items : horizontalItems,
                    layout: {
                        ntype: (hf ? 'hbox' : 'vbox'),
                        align: 'stretch'
                    }
                });
            } else {
                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                verticalItems.push({...me.headerDefaults, ...config})
            }

            bottomHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            me.items = verticalItems;

            me.itemDefaults = null;

            super.createItems()
        }
    }

    /**
     * @returns {Boolean}
     */
    hasHeaders() {
        return Array.isArray(this.headers) && this.headers.length > 0
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Panel));


/***/ }),

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {appName, windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName,
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");




/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me,
            listenerId;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            listenerId = component.on('constructed', () => {
                component.un('constructed', listenerId);
                me.onComponentConstructed()
            })
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            const handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * sameLevelOnly=false will return the closest VM inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getModel(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.model : component.getModel()
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut for accessing model.Component based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getModel().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me = this,
            {handler, listeners, reference, validator} = component,
            eventHandler, handlerScope;

        if (handler && typeof handler === 'string') {
            handlerScope = me.getHandlerScope(handler, component);

            // If the handler name was not resolved in the Component itself, bind it
            if (handlerScope !== true) {
                component.handler = handlerScope[handler].bind(component.handlerScope || handlerScope);
            }
        }

        listeners && Object.entries(listeners).forEach(([key, value]) => {
            if (key !== 'scope' && key !== 'delegate') {
                if (Neo.isString(value)) {
                    eventHandler = value;
                    handlerScope = me.getHandlerScope(eventHandler, component);

                    if (!handlerScope) {
                        _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].logError('Unknown event handler for', eventHandler, component)
                    } else if (handlerScope !== true) {
                        listeners[key] = {};
                        listeners[key].fn = handlerScope[eventHandler].bind(handlerScope)
                    }
                } else {
                    value.forEach(listener => {
                        if (Neo.isObject(listener) && listener.hasOwnProperty('fn') && Neo.isString(listener.fn)) {
                            eventHandler = listener.fn;
                            handlerScope = me.getHandlerScope(eventHandler, component);

                            if (!handlerScope) {
                                console.error('Unknown event handler for', eventHandler, component)
                            } else if (handlerScope !== true) {
                                listener.fn = handlerScope[eventHandler].bind(handlerScope)
                            }
                        }
                    })
                }
            }
        });

        if (Neo.isString(validator)) {
            handlerScope = me.getHandlerScope(validator);

            if (!handlerScope) {
                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].logError('Unknown validator for', component.id, component)
            } else {
                component.validator = handlerScope[validator].bind(handlerScope)
            }
        }

        if (reference) {
            me.references[reference] = component
        }
    }

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseDomListeners(component=this.component) {
        let me             = this,
            {domListeners} = component,
            eventHandler, scope;

        domListeners?.forEach(domListener => {
            Object.entries(domListener).forEach(([key, value]) => {
                eventHandler = null;

                if (key !== 'scope' && key !== 'delegate') {
                    if (Neo.isString(value)) {
                        eventHandler = value;
                    } else if (Neo.isObject(value) && value.hasOwnProperty('fn') && Neo.isString(value.fn)) {
                        eventHandler = value.fn;
                    }

                    if (eventHandler) {
                        scope = me.getHandlerScope(eventHandler);

                        // There can be string based listeners like 'up.onClick', which will resolved inside manager.DomEvents
                        // => Do nothing in case there is no match inside the controller hierarchy.
                        if (scope) {
                            domListener[key] = scope[eventHandler].bind(scope)
                        }
                    }
                }
            })
        })
    }

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/form/field/Radio.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Radio.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.form.field.Radio
 * @extends Neo.form.field.CheckBox
 */
class Radio extends _CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Radio'
         * @protected
         */
        className: 'Neo.form.field.Radio',
        /**
         * @member {String} ntype='radiofield'
         * @protected
         */
        ntype: 'radiofield',
        /**
         * @member {String[]} baseCls=['neo-radiofield','neo-checkboxfield']
         */
        baseCls: ['neo-radiofield', 'neo-checkboxfield'],
        /**
         * @member {String[]} iconCls=['far','fa-circle']
         */
        iconCls: ['far', 'fa-circle'],
        /**
         * @member {String} inputType='radio'
         */
        inputType: 'radio'
    }

    /**
     * Triggered after the checked config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetChecked(value, oldValue) {
        super.afterSetChecked(value, oldValue);

        // update radios with the same name to be unchecked
        value && this.uncheckGroupItems()
    }

    /**
     * Radios should only fire change & fieldChange events if checked.
     * If there was just 1 radio, you can not uncheck it.
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.checked && super.fireChangeEvent(value, oldValue)
    }

    /**
     * @returns {String[]}
     */
    getGroupValue() {
        let value = super.getGroupValue();

        return value.length > 0 ? value[0] : []
    }

    /**
     * Radios do not fire a change event for "uncheck", so we need to iterate over other radios with the same name.
     */
    uncheckGroupItems() {
        let me = this,
            radios;

        // discuss: we could limit this to radios inside the same form, IF a top level form is used
        radios = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find({
            ntype: 'radiofield',
            name : me.name
        });

        radios.forEach(item => {
            if (item.id !== me.id && item._checked) {
                item.checked = false
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Radio));


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Base extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype: 'hbox', align: 'center', pack : 'start'}
         */
        layout: {
            ntype: 'hbox',
            align: 'center',
            pack : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions');

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][key === value ? 'add' : 'remove'](cls, 'neo-dock-' + key)
        });

        me.cls    = cls;
        me.layout = me.getLayoutConfig()
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    windowId           : me.windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (this.sortZone) {
            this.sortZone.windowId = value
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            items.forEach((item, index) => {
                if (item === '->') {
                    items[index] = Neo.create({
                        module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                        flex  : 1
                    })
                }
            })
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch(me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        ntype: 'hbox',
                        align: 'center',
                        pack : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        ntype    : 'vbox',
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        ntype    : 'vbox',
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfc2hhcmVkZGlhbG9nX2FwcF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7O0FBRTlDO0FBQ1AsY0FBYywrREFBYTtBQUMzQjtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTG9EO0FBQ0k7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFFBQVEsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFTO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLGdFQUFTO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsUUFBUSxjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDBCQUEwQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3REeUI7QUFDSztBQUNKO0FBQ0E7QUFDTTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUVBQVE7QUFDcEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLG9CQUFvQixvRUFBdUI7QUFDM0M7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFPO0FBQzNCO0FBQ0E7QUFDQSx5QkFBeUIsNERBQU07QUFDL0I7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUFTO0FBQ3pDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9hcHBzL3NoYXJlZGRpYWxvZy9hcHAubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3NoYXJlZGRpYWxvZy92aWV3L0RlbW9EaWFsb2cubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3NoYXJlZGRpYWxvZy92aWV3L01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3NoYXJlZGRpYWxvZy92aWV3L01haW5Db250YWluZXJDb250cm9sbGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9MYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvUGFuZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvUmFkaW8ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdG9vbGJhci9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL3ZpZXcvTWFpbkNvbnRhaW5lci5tanMnO1xuXG5leHBvcnQgY29uc3Qgb25TdGFydCA9ICgpID0+IE5lby5hcHAoe1xuICAgIG1haW5WaWV3OiBNYWluQ29udGFpbmVyLFxuICAgIG5hbWUgICAgOiAnU2hhcmVkRGlhbG9nJ1xufSk7XG4iLCJpbXBvcnQgRGlhbG9nICAgIGZyb20gJy4uLy4uLy4uL3NyYy9kaWFsb2cvQmFzZS5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFNoYXJlZERpYWxvZy52aWV3LkRlbW9EaWFsb2dcbiAqIEBleHRlbmRzIE5lby5kaWFsb2cuQmFzZVxuICovXG5jbGFzcyBEZW1vRGlhbG9nIGV4dGVuZHMgRGlhbG9nIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1NoYXJlZERpYWxvZy52aWV3LkRlbW9EaWFsb2cnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1NoYXJlZERpYWxvZy52aWV3LkRlbW9EaWFsb2cnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aXRsZT0nRHJhZyBtZSBhY3Jvc3MgV2luZG93cyEnXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZTogJ0RyYWcgbWUgYWNyb3NzIFdpbmRvd3MhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY29udGFpbmVyQ29uZmlnPXtzdHlsZTpwYWRkaW5nOicyMHB4fX1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNvbmZpZzoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMjBweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtsYWJlbFdpZHRoOjcwfVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbURlZmF1bHRzOiB7XG4gICAgICAgICAgICBsYWJlbFdpZHRoOiA3MFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgZmxleCAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdGaWVsZCAxJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgIGZsZXggICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnRmllbGQgMidcbiAgICAgICAgfV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHdyYXBwZXJTdHlsZT17aGVpZ2h0Oic0MCUnLHdpZHRoOic0MCUnfVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlclN0eWxlOiB7XG4gICAgICAgICAgICBoZWlnaHQ6ICc0MCUnLFxuICAgICAgICAgICAgd2lkdGggOiAnNDAlJ1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEZW1vRGlhbG9nKTtcbiIsImltcG9ydCBCdXR0b24gICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBSYWRpbyAgICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9SYWRpby5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJDb250cm9sbGVyIGZyb20gJy4vTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzJztcbmltcG9ydCBUb29sYmFyICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvdG9vbGJhci9CYXNlLm1qcyc7XG5pbXBvcnQgVmlld3BvcnQgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBTaGFyZWREaWFsb2cudmlldy5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdTaGFyZWREaWFsb2cudmlldy5NYWluQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdTaGFyZWREaWFsb2cudmlldy5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudH0gY29udHJvbGxlcj1NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbGxlcjogTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBUb29sYmFyLFxuICAgICAgICAgICAgZmxleCAgOiAnbm9uZScsXG4gICAgICAgICAgICBpdGVtcyA6W3tcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBCdXR0b24sXG4gICAgICAgICAgICAgICAgZmxhZyAgIDogJ29wZW4tZGlhbG9nLWJ1dHRvbicsXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogJ29uQ3JlYXRlRGlhbG9nQnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYXIgZmEtd2luZG93LW1heGltaXplJyxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnQ3JlYXRlIERpYWxvZycsXG4gICAgICAgICAgICB9LCAnLT4nLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6ICdzd2l0Y2hUaGVtZScsXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLW1vb24nLFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdUaGVtZSBEYXJrJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiAnb3BlbkRvY2tlZFdpbmRvdycsXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhciBmYS13aW5kb3ctcmVzdG9yZScsXG4gICAgICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpbkxlZnQ6ICcxZW0nfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnT3BlbiBkb2NrZWQgV2luZG93J1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbnR5cGUgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgIGZsZXggIDogJ25vbmUnLFxuICAgICAgICAgICAgbGF5b3V0OiAnaGJveCcsXG5cbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICA6ICc3MnB4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzFlbScsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wICA6ICcxZW0nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpdGVtcyA6IFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIGZsZXggOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgIGZsZXggOiAnbm9uZScsXG5cbiAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IFJhZGlvLFxuICAgICAgICAgICAgICAgICAgICBoaWRlVmFsdWVMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxXaWR0aCAgICA6IDUwLFxuICAgICAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgIDogJ2RvY2tlZFBvc2l0aW9uJyxcblxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogJ29uRG9ja2VkUG9zaXRpb25DaGFuZ2UnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgOiAnRG9jaycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTGFiZWxUZXh0OiAnVG9wJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICA6ICd0b3AnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMYWJlbFRleHQ6ICdSaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiAncmlnaHQnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogJ0JvdHRvbScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiAnYm90dG9tJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMYWJlbFRleHQ6ICdMZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICA6ICdsZWZ0J1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgICAgICBmbGV4IDogMSxcbiAgICAgICAgICAgIGh0bWwgOiAnIzEnLFxuXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGFsaWduSXRlbXMgICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBjb2xvciAgICAgICAgIDogJyNiYmInLFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgICAgICAgOiAnZmxleCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemUgICAgICA6ICcyMDBweCcsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSAgOiAnODhweCcsXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdCAgICA6ICdub25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PXtudHlwZTondmJveCcsYWxpZ246J3N0cmV0Y2gnfVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlPXtwYWRkaW5nOicyMHB4J31cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiB7cGFkZGluZzogJzIwcHgnfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgQ29tcG9uZW50ICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRDb250cm9sbGVyIGZyb20gJy4uLy4uLy4uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgICAgZnJvbSAnLi4vLi4vLi4vc3JjL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgRGVtb0RpYWxvZyAgICAgICAgICBmcm9tICcuL0RlbW9EaWFsb2cubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvdXRpbC9SZWN0YW5nbGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgU2hhcmVkRGlhbG9nLnZpZXcuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyQ29udHJvbGxlciBleHRlbmRzIENvbXBvbmVudENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nU2hhcmVkRGlhbG9nLnZpZXcuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1NoYXJlZERpYWxvZy52aWV3Lk1haW5Db250YWluZXJDb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjb25uZWN0ZWRBcHBzPVtdXG4gICAgICAgICAqL1xuICAgICAgICBjb25uZWN0ZWRBcHBzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY3VycmVudFRoZW1lPSduZW8tdGhlbWUtbGlnaHQnXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50VGhlbWU6ICduZW8tdGhlbWUtbGlnaHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkb2NrZWRXaW5kb3dBcHBOYW1lPSdTaGFyZWREaWFsb2cyJ1xuICAgICAgICAgKi9cbiAgICAgICAgZG9ja2VkV2luZG93QXBwTmFtZTogJ1NoYXJlZERpYWxvZzInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGRvY2tlZFdpbmRvd0lkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tlZFdpbmRvd0lkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGRvY2tlZFdpbmRvd1Byb3h5PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tlZFdpbmRvd1Byb3h5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiBib3R0b20sIGxlZnQsIHJpZ2h0LCB0b3BcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkb2NrZWRXaW5kb3dTaWRlXz0ncmlnaHQnXG4gICAgICAgICAqL1xuICAgICAgICBkb2NrZWRXaW5kb3dTaWRlXzogJ3JpZ2h0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZG9ja2VkV2luZG93U2l6ZT01MDBcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tlZFdpbmRvd1NpemU6IDYyMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGlhbG9nUmVjdD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkaWFsb2dSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcmFnU3RhcnRXaW5kb3dSZWN0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdTdGFydFdpbmRvd1JlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gdGFyZ2V0V2luZG93U2l6ZT0wXG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXRXaW5kb3dTaXplOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIEFwcCB3b3JrZXIgd2lsbCByZWNlaXZlIGNvbm5lY3QgJiBkaXNjb25uZWN0IGV2ZW50cyBpbnNpZGUgdGhlIFNoYXJlZFdvcmtlcnMgY29udGV4dFxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uQXBwQ29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uQXBwRGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkb2NrZWRXaW5kb3dTaWRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERvY2tlZFdpbmRvd1NpZGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0RvY2tlZFdpbmRvdygpKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5XaW5kb3dQb3NpdGlvbi5zZXREb2NrKHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmRvY2tlZFdpbmRvd0FwcE5hbWUsXG4gICAgICAgICAgICAgICAgZG9jazogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBOYW1lXG4gICAgICovXG4gICAgY3JlYXRlRGlhbG9nKGRhdGEsIGFwcE5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1lO1xuXG4gICAgICAgIG1lLmVuYWJsZU9wZW5EaWFsb2dCdXR0b25zKGZhbHNlKTtcblxuICAgICAgICBtZS5kaWFsb2cgPSBOZW8uY3JlYXRlKERlbW9EaWFsb2csIHtcbiAgICAgICAgICAgIGFuaW1hdGVUYXJnZXRJZCAgICA6IGRhdGEuY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgICAgOiBbbWUuY3VycmVudFRoZW1lLCAnbmVvLWRpYWxvZycsICduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAgICAgd2luZG93SWQsXG5cbiAgICAgICAgICAgIGRyYWdab25lQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlOiB0cnVlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICBjbG9zZSAgICAgICAgICA6IG1lLm9uRGlhbG9nQ2xvc2UsXG4gICAgICAgICAgICAgICAgZHJhZ1pvbmVDcmVhdGVkOiBtZS5vbkRyYWdab25lQ3JlYXRlZCxcbiAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgICA6IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95RG9ja2VkV2luZG93UHJveHkoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmRvY2tlZFdpbmRvd1Byb3h5KSB7XG4gICAgICAgICAgICBtZS5kb2NrZWRXaW5kb3dQcm94eS5kZXN0cm95KHRydWUpO1xuICAgICAgICAgICAgbWUuZG9ja2VkV2luZG93UHJveHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3h5UmVjdFxuICAgICAqL1xuICAgIGRyb3BEaWFsb2dCZXR3ZWVuV2luZG93cyhwcm94eVJlY3QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkaWFsb2cgICAgICAgPSBtZS5kaWFsb2csXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBSZWN0YW5nbGUuZ2V0SW50ZXJzZWN0aW9uRGV0YWlscyhtZS5kcmFnU3RhcnRXaW5kb3dSZWN0LCBwcm94eVJlY3QpLFxuICAgICAgICAgICAgc2lkZSAgICAgICAgID0gbWUuZG9ja2VkV2luZG93U2lkZSxcbiAgICAgICAgICAgIHNpemUgICAgICAgICA9IHByb3h5UmVjdC5oZWlnaHQgKiBwcm94eVJlY3Qud2lkdGgsXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgaWYgKGludGVyc2VjdGlvbi5hcmVhID4gc2l6ZSAvIDIpIHsgLy8gZHJvcCB0aGUgZGlhbG9nIGZ1bGx5IGludG8gdGhlIGRyYWdTdGFydCB3aW5kb3dcbiAgICAgICAgICAgIG1lLmRlc3Ryb3lEb2NrZWRXaW5kb3dQcm94eSgpO1xuXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSBkaWFsb2cud3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICBpZiAoZGlhbG9nLmFwcE5hbWUgPT09IG1lLmRvY2tlZFdpbmRvd0FwcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBzaWRlID0gbWUuZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUudG9wID0gYCR7bWUuZHJhZ1N0YXJ0V2luZG93UmVjdC5oZWlnaHQgLSBwcm94eVJlY3QuaGVpZ2h0fXB4YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBgJHttZS5kcmFnU3RhcnRXaW5kb3dSZWN0LndpZHRoIC0gcHJveHlSZWN0LndpZHRofXB4YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlhbG9nLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZHJvcCB0aGUgZGlhbG9nIGZ1bGx5IGludG8gdGhlIGRyYWdFbmQgd2luZG93XG4gICAgICAgICAgICBtZS5tb3VudERpYWxvZ0luT3RoZXJXaW5kb3coe1xuICAgICAgICAgICAgICAgIGZ1bGx5SW5jbHVkZUludG9XaW5kb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJveHlSZWN0ICAgICAgICAgICAgIDogcHJveHlSZWN0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVcbiAgICAgKi9cbiAgICBlbmFibGVPcGVuRGlhbG9nQnV0dG9ucyhlbmFibGUpIHtcbiAgICAgICAgdGhpcy5nZXRPcGVuRGlhbG9nQnV0dG9ucygpLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9ICFlbmFibGVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtOZW8uYnV0dG9uLkJhc2V9XG4gICAgICovXG4gICAgZ2V0T3BlbkRvY2tlZFdpbmRvd0J1dHRvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmRvd24oe2ljb25DbHM6ICdmYXIgZmEtd2luZG93LXJlc3RvcmUnfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldE9wZW5EaWFsb2dCdXR0b25zKCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5maW5kKHtcbiAgICAgICAgICAgIGZsYWc6ICdvcGVuLWRpYWxvZy1idXR0b24nXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpZGVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJvdHRvbTogJ3RvcCcsXG4gICAgICAgICAgICBsZWZ0ICA6ICdyaWdodCcsXG4gICAgICAgICAgICByaWdodCA6ICdsZWZ0JyxcbiAgICAgICAgICAgIHRvcCAgIDogJ2JvdHRvbSdcbiAgICAgICAgfVtzaWRlXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm94eVJlY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Z1bGx5SW5jbHVkZUludG9XaW5kb3c9ZmFsc2VdXG4gICAgICogQHJldHVybiB7e2xlZnQ6IFN0cmluZywgdG9wOiBTdHJpbmd9fVxuICAgICAqL1xuICAgIGdldFByb3h5UG9zaXRpb24ocHJveHlSZWN0LCBzaWRlLCBmdWxseUluY2x1ZGVJbnRvV2luZG93PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRyYWdTdGFydFdpbmRvd1JlY3QgPSBtZS5kcmFnU3RhcnRXaW5kb3dSZWN0LFxuICAgICAgICAgICAgdGFyZ2V0V2luZG93U2l6ZSAgICA9IG1lLnRhcmdldFdpbmRvd1NpemUsXG4gICAgICAgICAgICBsZWZ0LCB0b3A7XG5cbiAgICAgICAgc3dpdGNoKHNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGAke3Byb3h5UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgICAgICB0b3AgID0gYCR7ZnVsbHlJbmNsdWRlSW50b1dpbmRvdyA/IDAgOiBwcm94eVJlY3QudG9wIC0gZHJhZ1N0YXJ0V2luZG93UmVjdC5oZWlnaHR9cHhgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGAke2Z1bGx5SW5jbHVkZUludG9XaW5kb3cgPyB0YXJnZXRXaW5kb3dTaXplIC0gcHJveHlSZWN0LndpZHRoIDogdGFyZ2V0V2luZG93U2l6ZSArIHByb3h5UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgICAgICB0b3AgID0gYCR7cHJveHlSZWN0LnRvcH1weGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGAke2Z1bGx5SW5jbHVkZUludG9XaW5kb3cgPyAwIDogcHJveHlSZWN0LmxlZnQgLSBkcmFnU3RhcnRXaW5kb3dSZWN0LndpZHRofXB4YDtcbiAgICAgICAgICAgICAgICB0b3AgID0gYCR7cHJveHlSZWN0LnRvcH1weGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBgJHtwcm94eVJlY3QubGVmdH1weGA7XG4gICAgICAgICAgICAgICAgdG9wICA9IGAke2Z1bGx5SW5jbHVkZUludG9XaW5kb3cgPyB0YXJnZXRXaW5kb3dTaXplIC0gcHJveHlSZWN0LmhlaWdodCA6IHRhcmdldFdpbmRvd1NpemUgKyBwcm94eVJlY3QudG9wfXB4YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7bGVmdCwgdG9wfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzRG9ja2VkV2luZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRBcHBzLmluY2x1ZGVzKHRoaXMuZG9ja2VkV2luZG93QXBwTmFtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnByb3h5UmVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuZnVsbHlJbmNsdWRlSW50b1dpbmRvd11cbiAgICAgKi9cbiAgICBtb3VudERpYWxvZ0luT3RoZXJXaW5kb3coZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgICAgICAgPSBtZS5jb21wb25lbnQuYXBwTmFtZSxcbiAgICAgICAgICAgIGRpYWxvZyAgICAgICAgICAgICAgID0gbWUuZGlhbG9nLFxuICAgICAgICAgICAgZHJhZ0VuZFdpbmRvd0FwcE5hbWUgPSBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lLFxuICAgICAgICAgICAgc2lkZSAgICAgICAgICAgICAgICAgPSBtZS5kb2NrZWRXaW5kb3dTaWRlLFxuICAgICAgICAgICAgcHJveHlQb3NpdGlvbiwgd3JhcHBlclN0eWxlO1xuXG4gICAgICAgIGlmIChkaWFsb2cuYXBwTmFtZSA9PT0gZHJhZ0VuZFdpbmRvd0FwcE5hbWUpIHtcbiAgICAgICAgICAgIGRyYWdFbmRXaW5kb3dBcHBOYW1lID0gbWUuY29tcG9uZW50LmFwcE5hbWU7XG4gICAgICAgICAgICBzaWRlICAgICAgICAgICAgICAgICA9IG1lLmdldE9wcG9zaXRlU2lkZShtZS5kb2NrZWRXaW5kb3dTaWRlKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJveHlQb3NpdGlvbiA9IG1lLmdldFByb3h5UG9zaXRpb24oZGF0YS5wcm94eVJlY3QsIHNpZGUsIGRhdGEuZnVsbHlJbmNsdWRlSW50b1dpbmRvdyk7XG5cbiAgICAgICAgZGlhbG9nLnVubW91bnQoKTtcblxuICAgICAgICAvLyB3ZSBuZWVkIGEgZGVsYXkgdG8gZW5zdXJlIGRpYWxvZy5CYXNlOiBvbkRyYWdFbmQoKSBpcyBkb25lLlxuICAgICAgICAvLyB3ZSBjb3VsZCB1c2UgdGhlIGRyYWdFbmQgZXZlbnQgb2YgdGhlIGRyYWdab25lIGluc3RlYWQuXG4gICAgICAgIG1lLnRpbWVvdXQoNzApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGlhbG9nLmFwcE5hbWUgPSBkaWFsb2cuYXBwTmFtZSA9PT0gZHJhZ0VuZFdpbmRvd0FwcE5hbWUgPyBhcHBOYW1lIDogZHJhZ0VuZFdpbmRvd0FwcE5hbWU7XG5cbiAgICAgICAgICAgIC8vIHRvZG86IHdpbmRvd0lcblxuICAgICAgICAgICAgbWUuZ2V0T3BlbkRpYWxvZ0J1dHRvbnMoKS5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi5hcHBOYW1lID09PSBkaWFsb2cuYXBwTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuYW5pbWF0ZVRhcmdldElkID0gYnV0dG9uLmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IGRpYWxvZy53cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gcHJveHlQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnRvcCAgPSBwcm94eVBvc2l0aW9uLnRvcDtcblxuICAgICAgICAgICAgZGlhbG9nLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgbWUuZGVzdHJveURvY2tlZFdpbmRvd1Byb3h5KCk7XG5cbiAgICAgICAgICAgIGRpYWxvZy5tb3VudCgpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbkFwcENvbm5lY3QoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBuYW1lID0gZGF0YS5hcHBOYW1lO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChtZS5jb25uZWN0ZWRBcHBzLCBuYW1lKTtcblxuICAgICAgICBpZiAobmFtZSAhPT0gJ1NoYXJlZERpYWxvZycgJiYgbWUuY3VycmVudFRoZW1lICE9PSAnbmVvLXRoZW1lLWxpZ2h0Jykge1xuICAgICAgICAgICAgbWUuc3dpdGNoVGhlbWVGb3JBcHAobmFtZSwgbWUuY3VycmVudFRoZW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgPT09IG1lLmRvY2tlZFdpbmRvd0FwcE5hbWUpIHtcbiAgICAgICAgICAgIG1lLmRvY2tlZFdpbmRvd0lkID0gZGF0YS53aW5kb3dJZDtcbiAgICAgICAgICAgIG1lLmdldE9wZW5Eb2NrZWRXaW5kb3dCdXR0b24oKS5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmVuYWJsZU9wZW5EaWFsb2dCdXR0b25zKCFtZS5kaWFsb2cpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5hcHBOYW1lXG4gICAgICovXG4gICAgb25BcHBEaXNjb25uZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgbmFtZSA9IGRhdGEuYXBwTmFtZTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ1NoYXJlZERpYWxvZycpIHtcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gY2xvc2UgYWxsIHBvcHVwIHdpbmRvd3MsIHdoaWNoIGVxdWFscyB0byBhbGwgY29ubmVjdGVkIGFwcHMgbWludXMgdGhlIG1haW4gYXBwXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobWUuY29ubmVjdGVkQXBwcywgJ1NoYXJlZERpYWxvZycpO1xuXG4gICAgICAgICAgICBOZW8uTWFpbi53aW5kb3dDbG9zZSh7XG4gICAgICAgICAgICAgICAgbmFtZXM6IG1lLmNvbm5lY3RlZEFwcHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobWUuY29ubmVjdGVkQXBwcywgbmFtZSk7XG5cbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLldpbmRvd1Bvc2l0aW9uLnVucmVnaXN0ZXJXaW5kb3coe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSA9PT0gbWUuZG9ja2VkV2luZG93QXBwTmFtZSkge1xuICAgICAgICAgICAgbWUuZ2V0T3BlbkRvY2tlZFdpbmRvd0J1dHRvbigpLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DcmVhdGVEaWFsb2dCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlRGlhbG9nKGRhdGEsIHRoaXMuY29tcG9uZW50LmFwcE5hbWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRpYWxvZ0Nsb3NlKCkge1xuICAgICAgICB0aGlzLmVuYWJsZU9wZW5EaWFsb2dCdXR0b25zKHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRvY2tlZFBvc2l0aW9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9ja2VkV2luZG93U2lkZSA9IGRhdGEuY29tcG9uZW50LnZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0RvY2tlZFdpbmRvdygpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGlhbG9nICAgICAgICAgICAgICA9IG1lLmRpYWxvZyxcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnRXaW5kb3dSZWN0ID0gbWUuZHJhZ1N0YXJ0V2luZG93UmVjdCxcbiAgICAgICAgICAgICAgICBwcm94eVJlY3QgICAgICAgICAgID0gUmVjdGFuZ2xlLm1vdmVUbyhtZS5kaWFsb2dSZWN0LCBkYXRhLmNsaWVudFggLSBkYXRhLm9mZnNldFgsIGRhdGEuY2xpZW50WSAtIGRhdGEub2Zmc2V0WSksXG4gICAgICAgICAgICAgICAgc2lkZSAgICAgICAgICAgICAgICA9IG1lLmRvY2tlZFdpbmRvd1NpZGU7XG5cbiAgICAgICAgICAgIGlmIChkaWFsb2cuYXBwTmFtZSA9PT0gbWUuZG9ja2VkV2luZG93QXBwTmFtZSkge1xuICAgICAgICAgICAgICAgIHNpZGUgPSBtZS5nZXRPcHBvc2l0ZVNpZGUobWUuZG9ja2VkV2luZG93U2lkZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFJlY3RhbmdsZS5sZWF2ZXNTaWRlKGRyYWdTdGFydFdpbmRvd1JlY3QsIHByb3h5UmVjdCwgc2lkZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoUmVjdGFuZ2xlLmV4Y2x1ZGVzKGRyYWdTdGFydFdpbmRvd1JlY3QsIHByb3h5UmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ21vdW50RGlhbG9nSW5PdGhlcldpbmRvdycpO1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudERpYWxvZ0luT3RoZXJXaW5kb3coe3Byb3h5UmVjdH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJvcERpYWxvZ0JldHdlZW5XaW5kb3dzKHByb3h5UmVjdClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oYXNEb2NrZWRXaW5kb3coKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgIHtkaWFsb2dSZWN0LCBkcmFnU3RhcnRXaW5kb3dSZWN0LCBkb2NrZWRXaW5kb3dBcHBOYW1lLCBkb2NrZWRXaW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgICAgICBwcm94eVJlY3QgPSBSZWN0YW5nbGUubW92ZVRvKGRpYWxvZ1JlY3QsIGRhdGEuY2xpZW50WCAtIGRhdGEub2Zmc2V0WCwgZGF0YS5jbGllbnRZIC0gZGF0YS5vZmZzZXRZKSxcbiAgICAgICAgICAgICAgICBzaWRlICAgICAgPSBtZS5kb2NrZWRXaW5kb3dTaWRlLFxuICAgICAgICAgICAgICAgIHByb3h5UG9zaXRpb24sIHZkb207XG5cbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgdHJpZ2dlciB0aGUgZHJhZzpzdGFydCBpbnNpZGUgdGhlIGRvY2tlZCB3aW5kb3csXG4gICAgICAgICAgICAvLyB3ZSBjYW4ga2VlcCB0aGUgc2FtZSBsb2dpYyB3aXRoIGp1c3QgZmxpcHBpbmcgdGhlIHNpZGUuXG4gICAgICAgICAgICBpZiAobWUuZGlhbG9nLmFwcE5hbWUgPT09IGRvY2tlZFdpbmRvd0FwcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBkb2NrZWRXaW5kb3dBcHBOYW1lID0gbWUuY29tcG9uZW50LmFwcE5hbWU7XG4gICAgICAgICAgICAgICAgZG9ja2VkV2luZG93SWQgICAgICA9IG1lLmNvbXBvbmVudC53aW5kb3dJZDtcbiAgICAgICAgICAgICAgICBzaWRlICAgICAgICAgICAgICAgID0gbWUuZ2V0T3Bwb3NpdGVTaWRlKG1lLmRvY2tlZFdpbmRvd1NpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoUmVjdGFuZ2xlLmxlYXZlc1NpZGUoZHJhZ1N0YXJ0V2luZG93UmVjdCwgcHJveHlSZWN0LCBzaWRlKSkge1xuICAgICAgICAgICAgICAgIHByb3h5UG9zaXRpb24gPSBtZS5nZXRQcm94eVBvc2l0aW9uKHByb3h5UmVjdCwgc2lkZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1lLmRvY2tlZFdpbmRvd1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20gPSBOZW8uY2xvbmUobWUuZGlhbG9nLmRyYWdab25lLmRyYWdQcm94eS52ZG9tLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmRvbS5pZDtcblxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHZkb20uc3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3h5UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLmRvY2tlZFdpbmRvd1Byb3h5ID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICAgOiBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgOiBkb2NrZWRXaW5kb3dBcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b01vdW50IDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9SZW5kZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICAgOiBbJ25lby1kaWFsb2cnLCAnbmVvLWRyYWdwcm94eSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgIDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmRvbSAgICAgIDogdmRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICA6IGRvY2tlZFdpbmRvd0lkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuY29uc29sZS5sb2cobWUud2luZG93SWQsIGRvY2tlZFdpbmRvd0lkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG90aGVyIHdpbmRvdyBoYXMgbW9zdCBsaWtlbHkgbm90IGxvYWRlZCBUaGUgZGlhbG9nIEpTIG1vZHVsZSB5ZXQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgZHJhZyBwcm94eSBpcyB1c2luZyBzb21lIENTUyBydWxlcyBvZiBpdC5cbiAgICAgICAgICAgICAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyhkb2NrZWRXaW5kb3dJZCwgTmVvLmRpYWxvZy5CYXNlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXMoZG9ja2VkV2luZG93SWQsIE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50LnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVEb2NrZWRXaW5kb3dQcm94eVN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3h5UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVEb2NrZWRXaW5kb3dQcm94eVN0eWxlKHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRG9ja2VkV2luZG93KCkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgID0gbWUuY29tcG9uZW50LmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgZG9ja2VkSG9yaXpvbnRhbCA9IG1lLmRvY2tlZFdpbmRvd1NpZGUgPT09ICdsZWZ0JyB8fCBtZS5kb2NrZWRXaW5kb3dTaWRlID09PSAncmlnaHQnO1xuXG4gICAgICAgICAgICBtZS5kaWFsb2dSZWN0ID0gZGF0YS5kcmFnRWxlbWVudFJlY3Q7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgZGF0YS5ldmVudERhdGEucGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhZ05hbWUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgICAgICBtZS5kcmFnU3RhcnRXaW5kb3dSZWN0ID0gaXRlbS5yZWN0O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLmhhc0RvY2tlZFdpbmRvdygpKSB7XG4gICAgICAgICAgICAgICAgTmVvLk1haW4uZ2V0V2luZG93RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWU6IG1lLmRpYWxvZy5hcHBOYW1lID09PSBhcHBOYW1lID8gbWUuZG9ja2VkV2luZG93QXBwTmFtZSA6IGFwcE5hbWVcbiAgICAgICAgICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS50YXJnZXRXaW5kb3dTaXplID0gZG9ja2VkSG9yaXpvbnRhbCA/IGRhdGEuaW5uZXJXaWR0aCA6IGRhdGEuaW5uZXJIZWlnaHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdab25lQ3JlYXRlZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgZGF0YS5kcmFnWm9uZS5vbih7XG4gICAgICAgICAgICBkcmFnRW5kICA6IG1lLm9uRHJhZ0VuZCxcbiAgICAgICAgICAgIGRyYWdNb3ZlIDogbWUub25EcmFnTW92ZSxcbiAgICAgICAgICAgIGRyYWdTdGFydDogbWUub25EcmFnU3RhcnQsXG4gICAgICAgICAgICBzY29wZSAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwb3B1cCB3aW5kb3csIHdoaWNoIGlzIGluaXRpYWxseSBkb2NrZWQgdG8gdGhpcy5kb2NrZWRXaW5kb3dTaWRlIG9mIHRoZSBtYWluIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyRGF0YVxuICAgICAqL1xuICAgIG9wZW5Eb2NrZWRXaW5kb3coaGFuZGxlckRhdGEpIHtcbiAgICAgICAgTmVvLk1haW4uZ2V0V2luZG93RGF0YSgpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkb2NrICAgPSBtZS5kb2NrZWRXaW5kb3dTaWRlLFxuICAgICAgICAgICAgICAgIHNpemUgICA9IG1lLmRvY2tlZFdpbmRvd1NpemUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LCBsZWZ0LCB0b3AsIHdpZHRoO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGRvY2spIHtcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgPSBkYXRhLnNjcmVlbkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICA9IGRhdGEub3V0ZXJIZWlnaHQgKyBkYXRhLnNjcmVlblRvcCAtIDUyO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgPSBkYXRhLm91dGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGRhdGEub3V0ZXJIZWlnaHQgLSA3ODtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgID0gZGF0YS5zY3JlZW5MZWZ0ICAtIHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICA9IGRhdGEuc2NyZWVuVG9wICAgKyAyODtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGRhdGEub3V0ZXJIZWlnaHQgLSA3ODtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgID0gZGF0YS5vdXRlcldpZHRoICArIGRhdGEuc2NyZWVuTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgID0gZGF0YS5zY3JlZW5Ub3AgICArIDI4O1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICA9IGRhdGEuc2NyZWVuTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgID0gZGF0YS5zY3JlZW5Ub3AgLSBzaXplICsgMjg7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICA9IGRhdGEub3V0ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvLk1haW4ud2luZG93T3Blbih7XG4gICAgICAgICAgICAgICAgdXJsICAgICAgICAgICA6ICdjaGlsZGFwcHMvc2hhcmVkZGlhbG9nMi9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICAgICB3aW5kb3dGZWF0dXJlczogYGhlaWdodD0ke2hlaWdodH0sbGVmdD0ke2xlZnR9LHRvcD0ke3RvcH0sd2lkdGg9JHt3aWR0aH1gLFxuICAgICAgICAgICAgICAgIHdpbmRvd05hbWUgICAgOiBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb24ucmVnaXN0ZXJXaW5kb3coe1xuICAgICAgICAgICAgICAgIGRvY2s6IGRvY2ssXG4gICAgICAgICAgICAgICAgbmFtZTogbWUuZG9ja2VkV2luZG93QXBwTmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRoZSB0aGVtZSBmb3IgYWxsIGNvbm5lY3RlZCBhcHBzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBzd2l0Y2hUaGVtZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1dHRvbiAgICAgPSBkYXRhLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGJ1dHRvblRleHQgPSAnVGhlbWUgTGlnaHQnLFxuICAgICAgICAgICAgZGlhbG9nICAgICA9IG1lLmRpYWxvZyxcbiAgICAgICAgICAgIGljb25DbHMgICAgPSAnZmEgZmEtc3VuJyxcbiAgICAgICAgICAgIHRoZW1lICAgICAgPSAnbmVvLXRoZW1lLWRhcmsnLFxuICAgICAgICAgICAgY2xzO1xuXG4gICAgICAgIGlmIChidXR0b24udGV4dCA9PT0gJ1RoZW1lIExpZ2h0Jykge1xuICAgICAgICAgICAgYnV0dG9uVGV4dCA9ICdUaGVtZSBEYXJrJztcbiAgICAgICAgICAgIGljb25DbHMgICAgPSAnZmEgZmEtbW9vbic7XG4gICAgICAgICAgICB0aGVtZSAgICAgID0gJ25lby10aGVtZS1saWdodCc7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5jb25uZWN0ZWRBcHBzLmZvckVhY2goYXBwTmFtZSA9PiB7XG4gICAgICAgICAgICBtZS5zd2l0Y2hUaGVtZUZvckFwcChhcHBOYW1lLCB0aGVtZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnV0dG9uLnNldCh7XG4gICAgICAgICAgICBpY29uQ2xzOiBpY29uQ2xzLFxuICAgICAgICAgICAgdGV4dCAgIDogYnV0dG9uVGV4dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGlhbG9nKSB7XG4gICAgICAgICAgICBjbHMgPSBkaWFsb2cuY2xzO1xuXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmVBZGQoY2xzLCBtZS5jdXJyZW50VGhlbWUsIHRoZW1lKTtcblxuICAgICAgICAgICAgZGlhbG9nLmNscyA9IGNsc1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuY3VycmVudFRoZW1lID0gdGhlbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0aGVtZVxuICAgICAqL1xuICAgIHN3aXRjaFRoZW1lRm9yQXBwKGFwcE5hbWUsIHRoZW1lKSB7XG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zZXRCb2R5Q2xzKHtcbiAgICAgICAgICAgIGFwcE5hbWU6IGFwcE5hbWUsXG4gICAgICAgICAgICBhZGQgICAgOiBbdGhlbWVdLFxuICAgICAgICAgICAgcmVtb3ZlIDogW3RoaXMuY3VycmVudFRoZW1lXVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqL1xuICAgIHVwZGF0ZURvY2tlZFdpbmRvd1Byb3h5U3R5bGUoc3R5bGUpIHtcbiAgICAgICAgbGV0IGRvY2tlZFdpbmRvd1Byb3h5ID0gdGhpcy5kb2NrZWRXaW5kb3dQcm94eTtcblxuICAgICAgICBpZiAoZG9ja2VkV2luZG93UHJveHkpIHtcbiAgICAgICAgICAgIGRvY2tlZFdpbmRvd1Byb3h5LnN0eWxlID0gT2JqZWN0LmFzc2lnbihkb2NrZWRXaW5kb3dQcm94eS5zdHlsZSB8fCB7fSwgc3R5bGUpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXJDb250cm9sbGVyKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGEgbGFiZWwgd2l0aCBhIHRleHRcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkxhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTGFiZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5MYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5MYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0ZXh0Xz0nJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dF86ICcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17dGFnOiAnbGFiZWwnfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdsYWJlbCcsIGRyYWdnYWJsZTogZmFsc2V9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0ZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmRvbS5odG1sID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExhYmVsKTtcbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgIGZyb20gJy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFuIGV4dGVuZGVkIENvbnRhaW5lciBzdXBwb3J0aW5nIG11bHRpcGxlIGRvY2tlZCBoZWFkZXIgdG9vbGJhcnNcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlBhbmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgUGFuZWwgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5QYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5QYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1wYW5lbCcsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjb250YWluZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBoZWFkZXJEZWZhdWx0cz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJEZWZhdWx0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBoZWFkZXJzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1zPXtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgICAgICAgKi9cbiAgICAgICAgX2xheW91dDoge1xuICAgICAgICAgICAgbnR5cGU6ICd2Ym94JyxcbiAgICAgICAgICAgIGFsaWduOiAnc3RyZXRjaCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHZlcnRpY2FsSGVhZGVyc0ZpcnN0PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB2ZXJ0aWNhbEhlYWRlcnNGaXJzdDogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5oYXNIZWFkZXJzKCkgJiYgbWUudmVydGljYWxIZWFkZXJzRmlyc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lLmxheW91dCA9IHtcbiAgICAgICAgICAgICAgICBudHlwZTogJ2hib3gnLFxuICAgICAgICAgICAgICAgIGFsaWduOiAnc3RyZXRjaCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyIHRoZSBoZWFkZXIgY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZihoZWFkZXIpID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGZsZXg6ICcwIDEgYXV0bydcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWhlYWRlci5tb2R1bGUgJiYgIWhlYWRlci5udHlwZSkge1xuICAgICAgICAgICAgY29uZmlnLmNscyAgID0gWyduZW8tcGFuZWwtaGVhZGVyLXRvb2xiYXInLCAnbmVvLXRvb2xiYXInXTtcbiAgICAgICAgICAgIGNvbmZpZy5udHlwZSA9ICd0b29sYmFyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWFkZXIudGV4dCkge1xuICAgICAgICAgICAgY29uZmlnLml0ZW1zID0gW3tcbiAgICAgICAgICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tcGFuZWwtaGVhZGVyLXRleHQnLCAnbmVvLWxhYmVsJ10sXG4gICAgICAgICAgICAgICAgdGV4dCA6IGhlYWRlci50ZXh0XG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgZGVsZXRlIGhlYWRlci50ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzdW1pbmcgYWxsIGxhYmVscyBpbnNpZGUgYSBQYW5lbCBIZWFkZXIgYXJlIG1lYW50IHRvIGJlIHRpdGxlcyAtPiBsb29rIHRoZSBzYW1lIHdheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXIuaXRlbXMpKSB7XG4gICAgICAgICAgICBoZWFkZXIuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5udHlwZSA9PT0gJ2xhYmVsJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNscyA9IFsnbmVvLXBhbmVsLWhlYWRlci10ZXh0JywgJ25lby1sYWJlbCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi5jb25maWcsIC4uLmhlYWRlcn1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbnRhaW5lckNvbmZpZyA9IG1lLmNvbnRhaW5lckNvbmZpZztcblxuICAgICAgICBpZiAoIW1lLmhhc0hlYWRlcnMoKSkge1xuICAgICAgICAgICAgY29udGFpbmVyQ29uZmlnICYmIG1lLnNldChjb250YWluZXJDb25maWcpO1xuICAgICAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBoZiAgICAgICAgICAgICAgICAgICA9IG1lLnZlcnRpY2FsSGVhZGVyc0ZpcnN0ID09PSBmYWxzZSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzICAgICAgICAgICAgICA9IG1lLmhlYWRlcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgYm90dG9tSGVhZGVycyAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8nYm90dG9tJzogJ3JpZ2h0Jyl9KSxcbiAgICAgICAgICAgICAgICBsZWZ0SGVhZGVycyAgICAgICAgICA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7cmV0dXJuIGhlYWRlci5kb2NrID09PSAoaGYgPydsZWZ0JyAgOiAndG9wJyl9KSxcbiAgICAgICAgICAgICAgICByaWdodEhlYWRlcnMgICAgICAgICA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7cmV0dXJuIGhlYWRlci5kb2NrID09PSAoaGYgPydyaWdodCcgOiAnYm90dG9tJyl9KSxcbiAgICAgICAgICAgICAgICB0b3BIZWFkZXJzICAgICAgICAgICA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7cmV0dXJuIGhlYWRlci5kb2NrID09PSAoaGYgPyd0b3AnICAgOiAnbGVmdCcpfSksXG4gICAgICAgICAgICAgICAgaGFzSG9yaXpvbnRhbEhlYWRlcnMgPSBib3R0b21IZWFkZXJzLmxlbmd0aCA+IDAgfHwgdG9wSGVhZGVycyAgLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgaGFzVmVydGljYWxIZWFkZXJzICAgPSBsZWZ0SGVhZGVycyAgLmxlbmd0aCA+IDAgfHwgcmlnaHRIZWFkZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAge2l0ZW1zfSAgICAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMgICAgICAgID0gW10sXG4gICAgICAgICAgICAgICAgY29uZmlnO1xuXG4gICAgICAgICAgICB0b3BIZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zLnB1c2goUGFuZWwuY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGhhc1ZlcnRpY2FsSGVhZGVycyAmJiAoaGYgJiYgaGFzSG9yaXpvbnRhbEhlYWRlcnMgfHwgIWhmICYmIGhhc0hvcml6b250YWxIZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGxlZnRIZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zLnB1c2goUGFuZWwuY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgICAgIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGZsZXggICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EZWZhdWx0czogbWUuaXRlbURlZmF1bHRzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250YWluZXJDb25maWdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zLnB1c2goey4uLm1lLmhlYWRlckRlZmF1bHRzLCAuLi5jb25maWd9KTtcblxuICAgICAgICAgICAgICAgIHJpZ2h0SGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgOiBob3Jpem9udGFsSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnR5cGU6IChoZiA/ICdoYm94JyA6ICd2Ym94JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICAgICA6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICBmbGV4ICAgICAgICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IG1lLml0ZW1EZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaCh7Li4ubWUuaGVhZGVyRGVmYXVsdHMsIC4uLmNvbmZpZ30pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdHRvbUhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IHZlcnRpY2FsSXRlbXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1EZWZhdWx0cyA9IG51bGw7XG5cbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0hlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuaGVhZGVycykgJiYgdGhpcy5oZWFkZXJzLmxlbmd0aCA+IDBcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBhbmVsKTtcbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBWaWV3cG9ydCBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udGFpbmVyLlZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udGFpbmVyLlZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3ZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3ZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyAnbmVvLWJvZHktdmlld3BvcnQnIHRvIHRoZSBkb2N1bWVudC5ib2R5XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFwcGx5Qm9keUNscz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWluZyB0aGF0IGEgVmlld3BvcnQgaXMgdGhlIHRvcCBsZXZlbCB2aWV3IG9mIHlvdXIgYXBwLCBhbmQgeW91IHdhbnQgdG8gbW91bnQgaXQgcmlnaHQgYXdheS5cbiAgICAgICAgICogQ291bGQgYmUgd2l0aG91dCBhbnkgaXRlbXMuIFVzZSBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby12aWV3cG9ydCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby12aWV3cG9ydCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzIGEgbWFpbi5hZGRvbi5SZXNpemVPYnNlcnZlciBhbmQgZmlyZXMgYSBjdXN0b20gcmVzaXplIGV2ZW50XG4gICAgICAgICAqIHdoaWNoIG90aGVyIGluc3RhbmNlcyBjYW4gc3Vic2NyaWJlIHRvLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb25pdG9yU2l6ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIG1vbml0b3JTaXplXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5tb25pdG9yU2l6ZSkge1xuICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFt7cmVzaXplOiBtZS5vbkRvbVJlc2l6ZSwgc2NvcGU6IG1lfV0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQge2FwcE5hbWUsIHdpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5hcHBseUJvZHlDbHMgJiYgTmVvLm1haW4uRG9tQWNjZXNzLmFwcGx5Qm9keUNscyh7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgY2xzOiBbJ25lby1ib2R5LXZpZXdwb3J0J10sXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Eb21SZXNpemUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3Jlc2l6ZScsIGRhdGEpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQge3Jlc29sdmVDYWxsYmFja30gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuaW1wb3J0IExvZ2dlciAgICAgICAgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1jb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1jb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZWZlcmVuY2VzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29tcG9uZW50fSA9IG1lLFxuICAgICAgICAgICAgbGlzdGVuZXJJZDtcblxuICAgICAgICBtZS5yZWZlcmVuY2VzID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVySWQgPSBjb21wb25lbnQub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bignY29uc3RydWN0ZWQnLCBsaXN0ZW5lcklkKTtcbiAgICAgICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwYXJlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGFyZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgdGhpcy5nZXRQYXJlbnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVyTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBbY29tcG9uZW50XVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8Qm9vbGVhbnxudWxsfVxuICAgICAqL1xuICAgIGdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIHRocyBmdW5jdGlvbiAqbmFtZSogZmlyc3QgaW4gdGhlIENvbXBvbmVudCBpdHNlbGYuXG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGl0LCByZXR1cm4gdHJ1ZSBzbyBjYWxsaW5nIGNvZGUga25vd3Mgbm90IHRvIGNvbnRpbnVlIHRvIHNlYXJjaC5cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJDYiA9IHJlc29sdmVDYWxsYmFjayhoYW5kbGVyTmFtZSwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBmbiBpcyByZXNvbHZlZCBpbiB0aGUgQ29tcG9uZW50IG9yIGl0cyBvd24gcGFyZW50IGNoYWluLlxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3RhdHVzIGluZGljYXRpbmcgdGhhdCB3ZSBkbyBub3QgbmVlZCBhbiBlYXJseSBiaW5kaW5nXG4gICAgICAgICAgICBpZiAoaGFuZGxlckNiLmZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZW8uaXNGdW5jdGlvbihtZVtoYW5kbGVyTmFtZV0pID9cbiAgICAgICAgICAgIG1lIDogcGFyZW50Py5nZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYW1lTGV2ZWxPbmx5PWZhbHNlIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFZNIGluc2lkZSB0aGUgY29tcG9uZW50IHBhcmVudCB0cmVlLFxuICAgICAqIGluIGNhc2UgdGhlcmUgaXMgbm9uZSBvbiB0aGUgc2FtZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW1lTGV2ZWxPbmx5PWZhbHNlXVxuICAgICAqL1xuICAgIGdldE1vZGVsKHNhbWVMZXZlbE9ubHk9ZmFsc2UpIHtcbiAgICAgICAgbGV0IHtjb21wb25lbnR9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNhbWVMZXZlbE9ubHkgPyBjb21wb25lbnQubW9kZWwgOiBjb21wb25lbnQuZ2V0TW9kZWwoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBjb250cm9sbGVyIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5jb21wb25lbnQucGFyZW50Py5nZXRDb250cm9sbGVyKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHVwZGF0ZSBjaGFuZ2VkIHJlZmVyZW5jZXMgKGUuZy4gY29udGFpbmVyLnJlbW92ZSgpIHRoZW4gY29udGFpbmVyLmFkZCgpIHVzaW5nIHRoZSBzYW1lIGtleSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUucmVmZXJlbmNlc1tuYW1lXTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LmRvd24oe3JlZmVyZW5jZTogbmFtZX0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tuYW1lXSA9IGNvbXBvbmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudCB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIGFjY2Vzc2luZyBtb2RlbC5Db21wb25lbnQgYmFzZWQgZGF0YS5TdG9yZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge05lby5kYXRhLlN0b3JlfVxuICAgICAqL1xuICAgIGdldFN0b3JlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb2RlbCgpLmdldFN0b3JlKGtleSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbnNpZGUgeW91ciB2aWV3IGNvbnRyb2xsZXJzIGFzIGEgc3RhcnRpbmcgcG9pbnQgaW4gY2FzZSB5b3UgbmVlZCByZWZlcmVuY2VzXG4gICAgICogKGluc3RlYWQgb2YgdXNpbmcgb25Db25zdHJ1Y3RlZCgpIGluc2lkZSB5b3VyIGNvbnRyb2xsZXIpXG4gICAgICovXG4gICAgb25Db21wb25lbnRDb25zdHJ1Y3RlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50PXRoaXMuY29tcG9uZW50XG4gICAgICovXG4gICAgcGFyc2VDb25maWcoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7aGFuZGxlciwgbGlzdGVuZXJzLCByZWZlcmVuY2UsIHZhbGlkYXRvcn0gPSBjb21wb25lbnQsXG4gICAgICAgICAgICBldmVudEhhbmRsZXIsIGhhbmRsZXJTY29wZTtcblxuICAgICAgICBpZiAoaGFuZGxlciAmJiB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGhhbmRsZXJTY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShoYW5kbGVyLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgaGFuZGxlciBuYW1lIHdhcyBub3QgcmVzb2x2ZWQgaW4gdGhlIENvbXBvbmVudCBpdHNlbGYsIGJpbmQgaXRcbiAgICAgICAgICAgIGlmIChoYW5kbGVyU2NvcGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaGFuZGxlciA9IGhhbmRsZXJTY29wZVtoYW5kbGVyXS5iaW5kKGNvbXBvbmVudC5oYW5kbGVyU2NvcGUgfHwgaGFuZGxlclNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycyAmJiBPYmplY3QuZW50cmllcyhsaXN0ZW5lcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3Njb3BlJyAmJiBrZXkgIT09ICdkZWxlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlciwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgZm9yJywgZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlclNjb3BlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0uZm4gPSBoYW5kbGVyU2NvcGVbZXZlbnRIYW5kbGVyXS5iaW5kKGhhbmRsZXJTY29wZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdChsaXN0ZW5lcikgJiYgbGlzdGVuZXIuaGFzT3duUHJvcGVydHkoJ2ZuJykgJiYgTmVvLmlzU3RyaW5nKGxpc3RlbmVyLmZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IGxpc3RlbmVyLmZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJTY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShldmVudEhhbmRsZXIsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgZm9yJywgZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyU2NvcGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZm4gPSBoYW5kbGVyU2NvcGVbZXZlbnRIYW5kbGVyXS5iaW5kKGhhbmRsZXJTY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICAgIGhhbmRsZXJTY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZSh2YWxpZGF0b3IpO1xuXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXJTY29wZSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignVW5rbm93biB2YWxpZGF0b3IgZm9yJywgY29tcG9uZW50LmlkLCBjb21wb25lbnQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC52YWxpZGF0b3IgPSBoYW5kbGVyU2NvcGVbdmFsaWRhdG9yXS5iaW5kKGhhbmRsZXJTY29wZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIG1lLnJlZmVyZW5jZXNbcmVmZXJlbmNlXSA9IGNvbXBvbmVudFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudD10aGlzLmNvbXBvbmVudFxuICAgICAqL1xuICAgIHBhcnNlRG9tTGlzdGVuZXJzKGNvbXBvbmVudD10aGlzLmNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RvbUxpc3RlbmVyc30gPSBjb21wb25lbnQsXG4gICAgICAgICAgICBldmVudEhhbmRsZXIsIHNjb3BlO1xuXG4gICAgICAgIGRvbUxpc3RlbmVycz8uZm9yRWFjaChkb21MaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkb21MaXN0ZW5lcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdzY29wZScgJiYga2V5ICE9PSAnZGVsZWdhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdmbicpICYmIE5lby5pc1N0cmluZyh2YWx1ZS5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHZhbHVlLmZuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUoZXZlbnRIYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgY2FuIGJlIHN0cmluZyBiYXNlZCBsaXN0ZW5lcnMgbGlrZSAndXAub25DbGljaycsIHdoaWNoIHdpbGwgcmVzb2x2ZWQgaW5zaWRlIG1hbmFnZXIuRG9tRXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA9PiBEbyBub3RoaW5nIGluIGNhc2UgdGhlcmUgaXMgbm8gbWF0Y2ggaW5zaWRlIHRoZSBjb250cm9sbGVyIGhpZXJhcmNoeS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbUxpc3RlbmVyW2tleV0gPSBzY29wZVtldmVudEhhbmRsZXJdLmJpbmQoc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgZ2V0IGNhbGxlZCBieSBjb21wb25lbnQuQmFzZTogZGVzdHJveSgpIGluIGNhc2UgdGhlIGNvbXBvbmVudCBoYXMgYSByZWZlcmVuY2UgY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVmZXJlbmNlc30gPSBtZSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSByZWZlcmVuY2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVmZXJlbmNlc1trZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRQYXJlbnQoKT8ucmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQ2hlY2tCb3ggICAgICAgICBmcm9tICcuL0NoZWNrQm94Lm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5SYWRpb1xuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuQ2hlY2tCb3hcbiAqL1xuY2xhc3MgUmFkaW8gZXh0ZW5kcyBDaGVja0JveCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5SYWRpbydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuUmFkaW8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncmFkaW9maWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdyYWRpb2ZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXJhZGlvZmllbGQnLCduZW8tY2hlY2tib3hmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1yYWRpb2ZpZWxkJywgJ25lby1jaGVja2JveGZpZWxkJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaWNvbkNscz1bJ2ZhcicsJ2ZhLWNpcmNsZSddXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiBbJ2ZhcicsICdmYS1jaXJjbGUnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaW5wdXRUeXBlPSdyYWRpbydcbiAgICAgICAgICovXG4gICAgICAgIGlucHV0VHlwZTogJ3JhZGlvJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2hlY2tlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENoZWNrZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0Q2hlY2tlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSByYWRpb3Mgd2l0aCB0aGUgc2FtZSBuYW1lIHRvIGJlIHVuY2hlY2tlZFxuICAgICAgICB2YWx1ZSAmJiB0aGlzLnVuY2hlY2tHcm91cEl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSYWRpb3Mgc2hvdWxkIG9ubHkgZmlyZSBjaGFuZ2UgJiBmaWVsZENoYW5nZSBldmVudHMgaWYgY2hlY2tlZC5cbiAgICAgKiBJZiB0aGVyZSB3YXMganVzdCAxIHJhZGlvLCB5b3UgY2FuIG5vdCB1bmNoZWNrIGl0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgJiYgc3VwZXIuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0R3JvdXBWYWx1ZSgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gc3VwZXIuZ2V0R3JvdXBWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwID8gdmFsdWVbMF0gOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJhZGlvcyBkbyBub3QgZmlyZSBhIGNoYW5nZSBldmVudCBmb3IgXCJ1bmNoZWNrXCIsIHNvIHdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIG90aGVyIHJhZGlvcyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gICAgICovXG4gICAgdW5jaGVja0dyb3VwSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICByYWRpb3M7XG5cbiAgICAgICAgLy8gZGlzY3Vzczogd2UgY291bGQgbGltaXQgdGhpcyB0byByYWRpb3MgaW5zaWRlIHRoZSBzYW1lIGZvcm0sIElGIGEgdG9wIGxldmVsIGZvcm0gaXMgdXNlZFxuICAgICAgICByYWRpb3MgPSBDb21wb25lbnRNYW5hZ2VyLmZpbmQoe1xuICAgICAgICAgICAgbnR5cGU6ICdyYWRpb2ZpZWxkJyxcbiAgICAgICAgICAgIG5hbWUgOiBtZS5uYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJhZGlvcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG1lLmlkICYmIGl0ZW0uX2NoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNoZWNrZWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUmFkaW8pO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExhYmVsICAgICBmcm9tICcuLi9jb21wb25lbnQvTGFiZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udG9vbGJhci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBkb2NrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRvY2tQb3NpdGlvbnM9Wyd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnLCBudWxsXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9ja1Bvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2xiYXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2xiYXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZG9ja189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZG9ja186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1EZWZhdWx0cz17bnR5cGU6J2J1dHRvbid9XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOiAnaGJveCcsIGFsaWduOiAnY2VudGVyJywgcGFjayA6ICdzdGFydCd9XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlOiAnaGJveCcsXG4gICAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICBwYWNrIDogJ3N0YXJ0J1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc29ydGFibGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS50b29sYmFyLlNvcnRab25lfG51bGx9IHNvcnRab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzb3J0Wm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZUNvbmZpZzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXBwTmFtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFpvbmUuYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRvY2sgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgZG9ja1Bvc2l0aW9ucyA9IG1lLmdldFN0YXRpY0NvbmZpZygnZG9ja1Bvc2l0aW9ucycpO1xuXG4gICAgICAgIGRvY2tQb3NpdGlvbnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5ICE9PSBudWxsICYmIE5lb0FycmF5W2tleSA9PT0gdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tZG9jay0nICsga2V5KVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5jbHMgICAgPSBjbHM7XG4gICAgICAgIG1lLmxheW91dCA9IG1lLmdldExheW91dENvbmZpZygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5zb3J0Wm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyBkb2NrIHBvc2l0aW9uIG1hdGNoZXMgYSB2YWx1ZSBvZiB0aGUgc3RhdGljIGRvY2tQb3NpdGlvbnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RvY2snLCAnZG9ja1Bvc2l0aW9ucycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSAnLT4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2luZGV4XSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4ICA6IDFcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF5b3V0IGNvbmZpZyBkZXBlbmRpbmcgb24gdGhpcy5kb2NrXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5b3V0Q29uZmlnXG4gICAgICovXG4gICAgZ2V0TGF5b3V0Q29uZmlnKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnO1xuXG4gICAgICAgIGlmIChtZS5kb2NrKSB7XG4gICAgICAgICAgICBzd2l0Y2gobWUuZG9jaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnR5cGU6ICdoYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG50eXBlICAgIDogJ3Zib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgOiAndmJveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheW91dENvbmZpZyB8fCBtZS5sYXlvdXRcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9