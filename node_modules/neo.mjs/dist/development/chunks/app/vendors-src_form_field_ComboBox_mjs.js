"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_field_ComboBox_mjs"],{

/***/ "./src/form/field/ComboBox.mjs":
/*!*************************************!*\
  !*** ./src/form/field/ComboBox.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../list/Base.mjs */ "./src/list/Base.mjs");
/* harmony import */ var _Picker_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Picker.mjs */ "./src/form/field/Picker.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");








/**
 * Provides a dropdown list to select one or multiple items.
 *
 * Conforms to ARIA accessibility standards outlines in https://www.w3.org/WAI/ARIA/apg/patterns/combobox/
 * @class Neo.form.field.ComboBox
 * @extends Neo.form.field.Picker
 */
class ComboBox extends _Picker_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    /**
     * Valid values for triggerAction
     * @member {String[]} triggerActions=['all','filtered']
     * @protected
     * @static
     */
    static triggerActions = ['all', 'filtered']

    static config = {
        /**
         * @member {String} className='Neo.form.field.ComboBox'
         * @protected
         */
        className: 'Neo.form.field.ComboBox',
        /**
         * @member {String} ntype='combobox'
         * @protected
         */
        ntype: 'combobox',
        /**
         * @member {String|Number|null} activeRecordId=null
         */
        activeRecordId: null,
        /**
         * @member {String[]} baseCls=['neo-combobox','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-combobox', 'neo-pickerfield', 'neo-textfield'],
        /**
         * @member {String} displayField='name'
         */
        displayField: 'name',
        /**
         * The millisecond time to delay between input field mutation and applying the input field's
         * new value to the filter
         * @member {Number} filterDelay=50
         */
        filterDelay : 50,
        /**
         * @member {String} filterOperator_='like'
         */
        filterOperator_: 'like',
        /**
         * True will only fire a change event, in case the TextField input value matches a record.
         * onFocusLeave() will try to select a hint record, if needed and possible.
         * @member {Boolean} forceSelection=true
         */
        forceSelection: true,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {
            Down  : 'onKeyDownDown',
            Escape: 'onKeyDownEscape'
        },
        /**
         * @member {String|null} lastManualInput=null
         * @protected
         */
        lastManualInput: null,
        /**
         * @member {Neo.list.Base} list=null
         * @protected
         */
        list: null,
        /**
         * @member {Object|null} listConfig_=null
         */
        listConfig_: null,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerHeight=null
         */
        pickerHeight: null,
        /**
         * @member {String|null} role='combobox'
         */
        role: 'combobox',
        /**
         * @member {Neo.data.Store|null} store_=null
         */
        store_: null,
        /**
         * Showing the list via the down trigger can either show all list items or only show items which
         * match the filter string inside the input field.
         * Valid values: all, filtered
         * @member {String} triggerAction_='all'
         */
        triggerAction_: 'all',
        /**
         * Display the first matching result while typing
         * @member {Boolean} typeAhead_=true
         */
        typeAhead_: true,
        /**
         * Set this config to false, in case typing into the input field should not filter list items
         * @member {Boolean} useFilter_=true
         */
        useFilter_: true,
        /**
         * This config should point to the store keyProperty or a different model field,
         * which you want to submit instead
         * @member {Number|String} valueField='id'
         */
        valueField: 'id'
    }

    /**
     * Internal flag to store the value, in case it was set before the store was loaded
     * @member {Number|String} preStoreLoadValue=null
     */
    preStoreLoadValue = null
    /**
     * Internal flag to not show a picker when non user-based input value changes happen
     * @member {Boolean} programmaticValueChange=false
     */
    programmaticValueChange = false

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // Create buffered function to respond to input field mutation
        me.filterOnInput = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.buffer)(me.filterOnInput, me, me.filterDelay);

        me.typeAhead && me.updateTypeAhead()
    }

    /**
     * Triggered after the inputValue config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetInputValue(value, oldValue) {
        super.afterSetInputValue(value, oldValue);
        this.updateTypeAheadValue(value);
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me = this,
            filters;

        if (value) {
            if (me.useFilter) {
                filters = value.filters || [];

                filters.push({
                    includeEmptyValues: true,
                    operator          : me.filterOperator,
                    property          : me.displayField,
                    value             : value?.[me.displayField] || null
                });

                value.filters = filters
            }

            if (me.list) {
                me.list.store = value
            }

            value.on('load', me.onStoreLoad, me)
        }
    }

    /**
     * Triggered after the typeAhead config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetTypeAhead(value, oldValue) {
        this.rendered && this.updateTypeAhead()
    }

    /**
     * Triggered after the value config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this;

        // input value changes (super call) need a flag to prevent showing the picker
        me.programmaticValueChange = true;
        super.afterSetValue(value, oldValue);
        me.programmaticValueChange = false;

        if (me._picker?.isVisible) {
            let selectionModel = me.list?.selectionModel;

            if (value) {
                oldValue && selectionModel?.deselect(oldValue);
                selectionModel?.select(value)
            } else {
                selectionModel.deselectAll()
            }
        }
    }

    /**
     * Triggered before the listConfig config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetListConfig(value, oldValue) {
        value && this.parseItemConfigs(value);
        return value
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store|null} value
     * @param {Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        const
            me                          = this,
            { valueField, displayField} = me;

        oldValue?.destroy();

        // Promote an array of items to be a Store
        if (Array.isArray(value)) {
            value = {
                data: value.map((v, i) => {
                    // Simplest case is just picking string values.
                    if (typeof v === 'string') {
                        v = {
                            [displayField]: v,
                            [valueField]  : v
                        }
                    }

                    return v
                })
            }
        }

        // to reduce boilerplate code, a store config object without a defined model should default
        // to displayField & valueField defaults
        if (Neo.typeOf(value) === 'Object' && !value.model && !value.module && !value.ntype) {
            value.model = {
                fields: [
                    {name: displayField, type: 'String'},
                    {name: valueField,   type: 'String'}
                ]
            }
        }

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"])
    }

    /**
     * Triggered before the triggerAction config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTriggerAction(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'triggerAction')
    }

    /**
     * Triggered before the value config gets changed.
     * @param {Number|Object|String} value
     * @param {Number|Object|String} oldValue
     * @returns {Number|Object|String}
     * @protected
     */
    beforeSetValue(value, oldValue) {
        let me           = this,
            displayField = me.displayField,
            store        = me.store,
            record;

        // getting a record, nothing to do
        if (Neo.isRecord(value)) {
            return value
        }

        if (value === null) {
            return null
        }

        // we can only match record ids or display values in case the store is loaded
        if (store.getCount() > 0) {
            record = store.isFiltered() ? store.allItems.get(value) : store.get(value);

            if (record) {
                return record
            }

            return store.find(displayField, value)[0] || null
        } else {
            // store not loaded yet
            me.preStoreLoadValue = value;
            return null
        }
    }

    /**
     * @returns {Neo.list.Base}
     */
    createPickerComponent() {
        const me = this;

        me.list = Neo.create({
            module        : _list_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            appName       : me.appName,
            displayField  : me.displayField,
            itemRole      : 'option',
            itemsFocusable: false,
            keepFocusIndex: true,
            navigator     : {eventSource: me.getInputElId()},
            parentId      : me.id,
            role          : 'listbox',
            selectionModel: {stayInList: false},
            store         : me.store,
            ...me.listConfig
        });

        me.getInputEl()['aria-controls'] = me.list.id;

        me.list.addDomListeners({
            neonavigate: {
                fn   : me.onListItemNavigate,
                scope: me
            }
        });

        me.list.selectionModel.on({
            noChange       : me.onListItemSelectionNoChange,
            selectionChange: me.onListItemSelectionChange,
            scope          : me
        });

        return me.list
    }

    /**
     * All routes which expect to open the picker route through here. This updates the
     * filter and ensures that the picker is visible and reflecting the state of the filter.
     *
     * Input event processing passes the current input field value in as the filter value.
     *
     * Invocation of the expand trigger passes `null` so as to clear filtering.
     * @private
     * @param {String|null} value The value to filter the picker by
     */
    doFilter(value) {
        let me     = this,
            store  = me.store,
            filter = store.getFilter(me.displayField),
            picker = me.picker,
            record = me.value;

        if (filter) {
            filter.value = value
        }

        // Filter resulting in something to show
        if (store.getCount()) {
            me.showPicker();

            // List might not exist until the picker is created
            const
                { list }           = me,
                { selectionModel } = list;

            // On show, set the active item to be the current selected record or the first
            if (record) {
                // We do not want to hear back about our own selection
                selectionModel.suspendEvents = true;
                selectionModel.select(record);
                selectionModel.suspendEvents = false
            }
            setTimeout(() => {
                const index = store.indexOf(record);
                list._focusIndex = -1; // silent update to ensure afterSetFocusIndex() always gets called
                list.focusIndex  = index > -1 ? index : 0
            }, 100)
        }
        // Filtered down to nothing - hide picker if it has been created.
        else {
            picker?.hide()
        }
    }

    /**
     * @param {String} value
     */
    filterOnInput(value) {
        if (value) {
            this.doFilter(value)
        } else {
            this.picker?.hide()
        }
    }

    /**
     * Overrides form.field.Base
     * @param {*} value
     * @param {*} oldValue
     * @override
     */
    fireChangeEvent(value, oldValue) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            params;

        if (!(me.forceSelection && !value)) {
            params = {component: me, oldValue, value};

            me.fire('change', params);

            if (!me.suspendEvents) {
                _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(me).forEach(parent => {
                    if (FormContainer && parent instanceof FormContainer) {
                        parent.fire('fieldChange', params)
                    }
                })
            }
        }
    }

    /**
     * @returns {Object}
     */
    getInputHintEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].findVdomChild(this.vdom, this.getInputHintId())?.vdom
    }

    /**
     * @returns {String}
     */
    getInputHintId() {
        return this.id + '__input-hint'
    }

    /**
     * Returns the first selected record or null
     * @returns {Object}
     */
    getRecord() {
        let list      = this.list,
            recordKey = list.selectionModel.getSelection()[0];

        return recordKey && this.store.get(list.getItemRecordId(recordKey)) || null
    }

    /**
     * @returns {Number|String}
     */
    getSubmitValue() {
        let me = this;

        return me.value?.[me.valueField] || me.emptyValue
    }

    /**
     *
     */
    onConstructed() {
        const inputEl = this.getInputEl();

        inputEl['aria-activedescendant'] = '';
        inputEl['aria-expanded']         = false;
        inputEl['aria-haspopup']         = 'listbox';

        super.onConstructed(...arguments)
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        let me = this;

        /*
         * If we are leaving the field, using forceSelection=true and the field does not have a selected record,
         * we do want to pick the closest match => the focussed record (honoring filters).
         * If no record is found, we will clear the field instead.
         */
        if (me.forceSelection && !me.value) {
            me.programmaticValueChange = true;
            me.value                   = me.store.get(me.activeRecordId);
            me.programmaticValueChange = false;
        }

        me.updateTypeAheadValue(null);

        super.onFocusLeave(data)
    }

    /**
     * @param {Object} data
     * @protected
     */
    onKeyDownDown(data) {
        let me = this;

        if (!me.picker || me.picker?.hidden) {
            me.onPickerTriggerClick()
        }
    }

    /**
     * todo:
     * When we are using a `Collection` as our `valueCollection`, and that `Collection` is the
     * `items` of the List's `selectionModel`, then this will be `onValueCollectionChange`,
     * a `mutate` listener on our own `valueCollection` which backs our `value` field which
     * will be implemented by a getter which accesses `valueCollection`.
     * This will become important for implementing multiSelect
     * @param {Object} selectionChangeEvent
     * @param {Object[]} selectionChangeEvent.selection
     * @protected
     */
    async onListItemSelectionChange({ selection }) {
        if (selection?.length) {
            const
                me       = this,
                selected = selection[0],
                record   = typeof selected === 'string' ? me.store.get(me.list.getItemRecordId(selected)) : selected;

            me.hintRecordId = null;

            me.updateTypeAheadValue(null, true);

            me.preventFiltering = true;
            me.value            = record;
            me.preventFiltering = false;

            me.fire('select', {
                value: record
            });

            // Short delay to let selection DOM updates get applied.
            // Alternatively, we could hide the picker before the selection happen and limit updates to the vdom.
            await me.timeout(20);

            await me.hidePicker()
        }
    }

    /**
     * Selection was attempted to be changed but resulted in no action.
     * For example clicking on already selected list item.
     */
    onListItemSelectionNoChange() {
        this.hidePicker()
    }

    /**
     * @param {Object} record
     * @protected
     */
    onListItemNavigate(record) {
        let {activeIndex} = record;

        if (activeIndex >= 0) {
            const
                me      = this,
                {store} = me;

            me.activeRecord   = store.getAt(activeIndex);
            me.activeRecordId = me.activeRecord[store.keyProperty || model.keyProperty];

            // Update typeahead hint (which updates DOM), or update DOM
            me.typeAhead ? me.updateTypeAheadValue(me.lastManualInput) : me.update();
        }
    }

    /**
     * @param {Object} data
     */
    onPickerHiddenChange({ value }) {
        const inputEl = this.getInputEl();

        super.onPickerHiddenChange(...arguments);

        if (value) {
            inputEl['aria-activedescendant'] = ''
        }

        inputEl['aria-expanded'] = !value;
        this.update()
    }

    /**
     * Selecting a record, if required
     * @param {Object[]} items
     */
    onStoreLoad(items) {
        let me    = this,
            value = me.preStoreLoadValue;

        if (value !== null) {
            me._value = undefined; // silent update
            me.value  = value
        }
    }

    /**
     *
     */
    selectFirstListItem() {
        this.selectListItem(0)
    }

    /**
     *
     */
    selectLastListItem() {
        this.selectListItem(this.store.getCount() -1)
    }

    /**
     * If no index is passed, the index matching to the field input will get used (0 if none)
     * @param {Number} [index]
     */
    selectListItem(index) {
        let me = this;

        if (!Neo.isNumber(index)) {
            if (me.activeRecordId) {
                index = me.store.indexOfKey(me.activeRecordId)
            } else {
                index = 0
            }
        }

        me.list.selectItem(index)
    }

    /**
     * @override
     */
    togglePicker() {
        let me       = this,
            {picker} = me;

        if (picker?.hidden === false) {
            picker.hidden = true
        } else if (!me.disabled && !me.readOnly) {
            me.doFilter(null)
        }
    }

    /**
     * Override this method as needed inside class extensions.
     * @param {*} value
     * @protected
     */
    updateInputValueFromValue(value) {
        let inputValue = null;

        if (Neo.isRecord(value)) {
            inputValue = value[this.displayField]
        }

        this.inputValue = inputValue
    }

    /**
     * @param {Boolean} [silent=false]
     * @protected
     */
    updateTypeAhead(silent=false) {
        let me      = this,
            inputEl = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].findVdomChild(me.vdom, {flag: 'neo-real-input'}),
            vdom    = me.vdom;

        if (me.typeAhead) {
            inputEl.parentNode.cn[inputEl.index] = {
                tag: 'span',
                cls: ['neo-input-field-wrapper'],
                cn : [{
                    tag         : 'input',
                    autocomplete: 'no', // while "off" is the correct value, browser vendors ignore it. Arbitrary strings do the trick.
                    autocorrect : 'off',
                    cls         : ['neo-textfield-input', 'neo-typeahead-input'],
                    disabled    : true,
                    id          : me.getInputHintId(),
                    spellcheck  : 'false'
                }, inputEl.vdom]
            }
        } else {
            _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].replaceVdomChild(vdom, inputEl.parentNode.id, inputEl.vdom)
        }

        !silent && me.update()
    }

    /**
     * @param {String|null} value=this.lastManualInput
     * @param {Boolean} silent=false
     * @protected
     */
    updateTypeAheadValue(value=this.lastManualInput, silent=false) {
        let me                    = this,
            match                 = false,
            inputHintEl           = me.getInputHintEl(),
            {displayField, store} = me;

        if (me.typeAhead) {
            if (!me.value && value?.length > 0) {
                const search = value.toLocaleLowerCase();
                match = store.items.find(r => r[displayField]?.toLowerCase?.()?.startsWith(search));

                if (match && inputHintEl) {
                    inputHintEl.value = value + match[displayField].substr(value.length);
                    me.activeRecord   = match;
                    me.activeRecordId = match[store.keyProperty || store.model.keyProperty]
                }
            }

            if (!match && inputHintEl) {
                inputHintEl.value = me.activeRecord = me.activeRecordId = null;
            }

            !silent && me.update()
        }
    }
    /**
     * @param {String} inputValue
     * @protected
     */
    updateValueFromInputValue(inputValue) {
        let me = this;

        me.lastManualInput = inputValue;

        if (!me.programmaticValueChange) {
            // changing the input => silent record reset
            me._value = null;
            me.list?.selectionModel.deselectAll();

            me.filterOnInput(inputValue)
        }
    }
}

/**
 * The select event fires when a list item gets selected
 * @event select
 * @param {Object} record
 * @param {value} record[store.keyProperty]
 * @returns {Object}
 */

Neo.setupClass(ComboBox);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ComboBox);


/***/ }),

/***/ "./src/form/field/Picker.mjs":
/*!***********************************!*\
  !*** ./src/form/field/Picker.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _trigger_Picker_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trigger/Picker.mjs */ "./src/form/field/trigger/Picker.mjs");
/* harmony import */ var _Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Text.mjs */ "./src/form/field/Text.mjs");





/**
 * The abstract picker field provides an arrow down trigger which opens a floating container to provide
 * more data selection options
 * @class Neo.form.field.Picker
 * @extends Neo.form.field.Text
 * @abstract
 */
class Picker extends _Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Picker'
         * @protected
         */
        className: 'Neo.form.field.Picker',
        /**
         * @member {String} ntype='pickerfield'
         * @protected
         */
        ntype: 'pickerfield',
        /**
         * @member {String[]} baseCls=['neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-pickerfield', 'neo-textfield'],
        /**
         * Stores the data from the getBoundingClientRect() call (picker & body DomRects)
         * @member {Array} clientRects=null
         * @protected
         */
        clientRects: null,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {
            Enter : 'onKeyDownEnter',
            Escape: 'onKeyDownEscape'
        },
        /**
         * @member {Neo.container.Base|null} picker=null
         * @protected
         */
        picker: null,
        /**
         * Configs to pass to the picker container
         * @member {Object|null} pickerConfig=null
         */
        pickerConfig: null,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerHeight=100
         */
        pickerHeight: 100,
        /**
         * @member {Boolean} pickerIsMounted_=false
         * @protected
         */
        pickerIsMounted_: false,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerMaxHeight=200
         */
        pickerMaxHeight: 200,
        /**
         * The width of the picker container. Defaults to px.
         * By default, the width of the picker matches the width of the input wrap element.
         * @member {Number|null} pickerWidth=null
         */
        pickerWidth: null,
        /**
         * @member {Boolean} showPickerOnFocus=false
         * @protected
         */
        showPickerOnFocus: false,
        /**
         * @member {Object|Object[]} triggers=[]
         * @protected
         */
        triggers: [{
            module: _trigger_Picker_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]
        }]
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            click: me.onInputClick,
            scope: me
        })
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (value === false && oldValue && this.pickerIsMounted) {
            this.picker.hide()
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        if (this.picker) {
            this.picker.theme = value
        }
    }

    /**
     * @returns {Neo.container.Base}
     */
    createPicker() {
        const
            me              = this,
            { pickerWidth } = me,
            pickerComponent = me.createPickerComponent();

        me.picker =  Neo.create(_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], {
            parentId : 'document.body',
            floating : true,
            align    : {
                edgeAlign : pickerWidth ? 't0-b0' : 't-b',
                matchSize : !pickerWidth,
                axisLock  : true,
                target    : me.getInputWrapperId()
            },
            appName  : me.appName,
            cls      : ['neo-picker-container', 'neo-container'],
            height   : me.pickerHeight,
            hidden   : true,
            id       : me.getPickerId(),
            items    : pickerComponent ? [pickerComponent] : [],
            maxHeight: me.pickerMaxHeight,
            theme    : me.theme,
            width    : pickerWidth,
            ...me.pickerConfig,

            // scoped to the field instance
            onFocusLeave: data => {
                let insideField = false,
                    item;

                for (item of data.oldPath) {
                    if (item.id === me.id) {
                        insideField = true;
                        break
                    }
                }

                if (!insideField) {
                    me.hidePicker();
                    super.onFocusLeave(data)
                }
            }
        });

        me.picker.on('hiddenChange', me.onPickerHiddenChange, me);

        return me.picker
    }

    /**
     * Override this method to create your picker content as needed
     * @returns {Neo.component.Base|null}
     */
    createPickerComponent() {
        return null
    }

    /**
     * @param args
     */
    destroy(...args) {
        let picker = this.picker;

        if (picker?.hidden === false) {
            picker.unmount()
        }

        picker?.destroy();
        super.destroy(...args)
    }

    /**
     * Returns the picker instance and creates it in case it does not exist yet
     * @returns {Neo.container.Base}
     */
    getPicker() {
        return this.picker || this.createPicker()
    }

    /**
     * @returns {String}
     */
    getPickerId() {
        return `${this.id}__picker`
    }

    /**
     *
     */
    async hidePicker() {
        if (this.picker) {
            this.picker.hidden = true
        }
    }

    /**
     * @param {Object} data
     * @protected
     */
    onFocusEnter(data) {
        super.onFocusEnter(data);

        let me = this;

        me.showPickerOnFocus && me.showPicker()
    }

    /**
     * @param {Object} data
     * @protected
     */
    onFocusLeave(data) {
        let me           = this,
            insidePicker = false,
            item;

        for (item of data.oldPath) {
            if (item.id === me.getPickerId()) {
                insidePicker = true;
                break
            }
        }

        if (!insidePicker) {
            me.hidePicker();
            super.onFocusLeave(data)
        }
    }

    /**
     * @param {Object} data
     */
    onInputClick(data) {
        !this.editable && this.togglePicker()
    }

    /**
     * @param {Object} data
     * @param {Function} [callback]
     * @param {Object} [callbackScope]
     * @protected
     */
    onKeyDownEnter(data, callback, callbackScope) {
        !this.pickerIsMounted && this.showPicker(callback, callbackScope)
    }

    /**
     * @param {Object} data
     * @protected
     */
    onKeyDownEscape(data) {
        if (this.pickerIsMounted) {
            this.hidePicker();

            // We processed this event, and it should not proceed to ancestor components
            data.cancelBubble = true;

            // And no further listeners should be notified
            return false
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Boolean} data.oldValue
     * @param {Boolean} data.value
     * @protected
     */
    onPickerHiddenChange(data) {
        this.pickerIsMounted = !data.value
    }

    /**
     * Called by form.field.trigger.Picker
     * @protected
     */
    onPickerTriggerClick() {
        this.editable && this.togglePicker()
    }

    /**
     *
     */
    showPicker() {
        this.getPicker().hidden = false
    }

    /**
     *
     */
    togglePicker() {
        let picker = this.getPicker();
        picker.hidden = !picker.hidden
    }
}

Neo.setupClass(Picker);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Picker);


/***/ }),

/***/ "./src/form/field/trigger/Picker.mjs":
/*!*******************************************!*\
  !*** ./src/form/field/trigger/Picker.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");


/**
 * Used by form.field.Picker
 * @class Neo.form.field.trigger.Picker
 * @extends Neo.form.field.trigger.Base
 */
class Picker extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Picker'
         * @protected
         */
        className: 'Neo.form.field.trigger.Picker',
        /**
         * @member {String} ntype='trigger-picker'
         * @protected
         */
        ntype: 'trigger-picker',
        /**
         * @member {String|null} iconCls='fa fa-caret-down'
         */
        iconCls: 'fa fa-caret-down',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='picker'
         * @protected
         */
        type: 'picker'
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        this.field.onPickerTriggerClick();
    } 
}

Neo.setupClass(Picker);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Picker);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNHO0FBQ0M7QUFDUjtBQUNQO0FBQ1E7QUFDRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbURBQU07QUFDN0I7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7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ZC9Db21ib0JveC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL1BpY2tlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL3RyaWdnZXIvUGlja2VyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidWZmZXIgfSAgICAgICBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi8uLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IExpc3QgICAgICAgICAgICAgZnJvbSAnLi4vLi4vbGlzdC9CYXNlLm1qcyc7XG5pbXBvcnQgUGlja2VyICAgICAgICAgICBmcm9tICcuL1BpY2tlci5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICAgZnJvbSAnLi4vLi4vZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBkcm9wZG93biBsaXN0IHRvIHNlbGVjdCBvbmUgb3IgbXVsdGlwbGUgaXRlbXMuXG4gKlxuICogQ29uZm9ybXMgdG8gQVJJQSBhY2Nlc3NpYmlsaXR5IHN0YW5kYXJkcyBvdXRsaW5lcyBpbiBodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2NvbWJvYm94L1xuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLkNvbWJvQm94XG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5QaWNrZXJcbiAqL1xuY2xhc3MgQ29tYm9Cb3ggZXh0ZW5kcyBQaWNrZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgdHJpZ2dlckFjdGlvblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB0cmlnZ2VyQWN0aW9ucz1bJ2FsbCcsJ2ZpbHRlcmVkJ11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyB0cmlnZ2VyQWN0aW9ucyA9IFsnYWxsJywgJ2ZpbHRlcmVkJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQ29tYm9Cb3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLkNvbWJvQm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbWJvYm94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbWJvYm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xOdW1iZXJ8bnVsbH0gYWN0aXZlUmVjb3JkSWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlUmVjb3JkSWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jb21ib2JveCcsJ25lby1waWNrZXJmaWVsZCcsJ25lby10ZXh0ZmllbGQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY29tYm9ib3gnLCAnbmVvLXBpY2tlcmZpZWxkJywgJ25lby10ZXh0ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGlzcGxheUZpZWxkPSduYW1lJ1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGxheUZpZWxkOiAnbmFtZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWlsbGlzZWNvbmQgdGltZSB0byBkZWxheSBiZXR3ZWVuIGlucHV0IGZpZWxkIG11dGF0aW9uIGFuZCBhcHBseWluZyB0aGUgaW5wdXQgZmllbGQnc1xuICAgICAgICAgKiBuZXcgdmFsdWUgdG8gdGhlIGZpbHRlclxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGZpbHRlckRlbGF5PTUwXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJEZWxheSA6IDUwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmaWx0ZXJPcGVyYXRvcl89J2xpa2UnXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJPcGVyYXRvcl86ICdsaWtlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgd2lsbCBvbmx5IGZpcmUgYSBjaGFuZ2UgZXZlbnQsIGluIGNhc2UgdGhlIFRleHRGaWVsZCBpbnB1dCB2YWx1ZSBtYXRjaGVzIGEgcmVjb3JkLlxuICAgICAgICAgKiBvbkZvY3VzTGVhdmUoKSB3aWxsIHRyeSB0byBzZWxlY3QgYSBoaW50IHJlY29yZCwgaWYgbmVlZGVkIGFuZCBwb3NzaWJsZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZm9yY2VTZWxlY3Rpb249dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9yY2VTZWxlY3Rpb246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHVzZWQga2V5cyBmb3IgdGhlIHNlbGVjdGlvbiBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGtleXNcbiAgICAgICAgICovXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICAgIERvd24gIDogJ29uS2V5RG93bkRvd24nLFxuICAgICAgICAgICAgRXNjYXBlOiAnb25LZXlEb3duRXNjYXBlJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGxhc3RNYW51YWxJbnB1dD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxhc3RNYW51YWxJbnB1dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5saXN0LkJhc2V9IGxpc3Q9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxpc3RDb25maWdfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb25maWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgcGlja2VyIGNvbnRhaW5lci4gRGVmYXVsdHMgdG8gcHguXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBwaWNrZXJIZWlnaHQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VySGVpZ2h0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHJvbGU9J2NvbWJvYm94J1xuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogJ2NvbWJvYm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLlN0b3JlfG51bGx9IHN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93aW5nIHRoZSBsaXN0IHZpYSB0aGUgZG93biB0cmlnZ2VyIGNhbiBlaXRoZXIgc2hvdyBhbGwgbGlzdCBpdGVtcyBvciBvbmx5IHNob3cgaXRlbXMgd2hpY2hcbiAgICAgICAgICogbWF0Y2ggdGhlIGZpbHRlciBzdHJpbmcgaW5zaWRlIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiBhbGwsIGZpbHRlcmVkXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHJpZ2dlckFjdGlvbl89J2FsbCdcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXJBY3Rpb25fOiAnYWxsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGZpcnN0IG1hdGNoaW5nIHJlc3VsdCB3aGlsZSB0eXBpbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdHlwZUFoZWFkXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlQWhlYWRfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgY29uZmlnIHRvIGZhbHNlLCBpbiBjYXNlIHR5cGluZyBpbnRvIHRoZSBpbnB1dCBmaWVsZCBzaG91bGQgbm90IGZpbHRlciBsaXN0IGl0ZW1zXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZUZpbHRlcl89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlRmlsdGVyXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY29uZmlnIHNob3VsZCBwb2ludCB0byB0aGUgc3RvcmUga2V5UHJvcGVydHkgb3IgYSBkaWZmZXJlbnQgbW9kZWwgZmllbGQsXG4gICAgICAgICAqIHdoaWNoIHlvdSB3YW50IHRvIHN1Ym1pdCBpbnN0ZWFkXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IHZhbHVlRmllbGQ9J2lkJ1xuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVGaWVsZDogJ2lkJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcmUgdGhlIHZhbHVlLCBpbiBjYXNlIGl0IHdhcyBzZXQgYmVmb3JlIHRoZSBzdG9yZSB3YXMgbG9hZGVkXG4gICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ30gcHJlU3RvcmVMb2FkVmFsdWU9bnVsbFxuICAgICAqL1xuICAgIHByZVN0b3JlTG9hZFZhbHVlID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZsYWcgdG8gbm90IHNob3cgYSBwaWNrZXIgd2hlbiBub24gdXNlci1iYXNlZCBpbnB1dCB2YWx1ZSBjaGFuZ2VzIGhhcHBlblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHByb2dyYW1tYXRpY1ZhbHVlQ2hhbmdlPWZhbHNlXG4gICAgICovXG4gICAgcHJvZ3JhbW1hdGljVmFsdWVDaGFuZ2UgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBDcmVhdGUgYnVmZmVyZWQgZnVuY3Rpb24gdG8gcmVzcG9uZCB0byBpbnB1dCBmaWVsZCBtdXRhdGlvblxuICAgICAgICBtZS5maWx0ZXJPbklucHV0ID0gYnVmZmVyKG1lLmZpbHRlck9uSW5wdXQsIG1lLCBtZS5maWx0ZXJEZWxheSk7XG5cbiAgICAgICAgbWUudHlwZUFoZWFkICYmIG1lLnVwZGF0ZVR5cGVBaGVhZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpbnB1dFZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbnB1dFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldElucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVUeXBlQWhlYWRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBmaWx0ZXJzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1lLnVzZUZpbHRlcikge1xuICAgICAgICAgICAgICAgIGZpbHRlcnMgPSB2YWx1ZS5maWx0ZXJzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUVtcHR5VmFsdWVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciAgICAgICAgICA6IG1lLmZpbHRlck9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgICAgICAgICA6IG1lLmRpc3BsYXlGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgOiB2YWx1ZT8uW21lLmRpc3BsYXlGaWVsZF0gfHwgbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVycyA9IGZpbHRlcnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLmxpc3QpIHtcbiAgICAgICAgICAgICAgICBtZS5saXN0LnN0b3JlID0gdmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUub24oJ2xvYWQnLCBtZS5vblN0b3JlTG9hZCwgbWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHR5cGVBaGVhZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFR5cGVBaGVhZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnVwZGF0ZVR5cGVBaGVhZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBpbnB1dCB2YWx1ZSBjaGFuZ2VzIChzdXBlciBjYWxsKSBuZWVkIGEgZmxhZyB0byBwcmV2ZW50IHNob3dpbmcgdGhlIHBpY2tlclxuICAgICAgICBtZS5wcm9ncmFtbWF0aWNWYWx1ZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgbWUucHJvZ3JhbW1hdGljVmFsdWVDaGFuZ2UgPSBmYWxzZTtcblxuICAgICAgICBpZiAobWUuX3BpY2tlcj8uaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uTW9kZWwgPSBtZS5saXN0Py5zZWxlY3Rpb25Nb2RlbDtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgJiYgc2VsZWN0aW9uTW9kZWw/LmRlc2VsZWN0KG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uc2VsZWN0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdEFsbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBsaXN0Q29uZmlnIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TGlzdENvbmZpZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5wYXJzZUl0ZW1Db25maWdzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5kYXRhLlN0b3JlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7IHZhbHVlRmllbGQsIGRpc3BsYXlGaWVsZH0gPSBtZTtcblxuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIFByb21vdGUgYW4gYXJyYXkgb2YgaXRlbXMgdG8gYmUgYSBTdG9yZVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGVzdCBjYXNlIGlzIGp1c3QgcGlja2luZyBzdHJpbmcgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNwbGF5RmllbGRdOiB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZUZpZWxkXSAgOiB2XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0byByZWR1Y2UgYm9pbGVycGxhdGUgY29kZSwgYSBzdG9yZSBjb25maWcgb2JqZWN0IHdpdGhvdXQgYSBkZWZpbmVkIG1vZGVsIHNob3VsZCBkZWZhdWx0XG4gICAgICAgIC8vIHRvIGRpc3BsYXlGaWVsZCAmIHZhbHVlRmllbGQgZGVmYXVsdHNcbiAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0JyAmJiAhdmFsdWUubW9kZWwgJiYgIXZhbHVlLm1vZHVsZSAmJiAhdmFsdWUubnR5cGUpIHtcbiAgICAgICAgICAgIHZhbHVlLm1vZGVsID0ge1xuICAgICAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTogZGlzcGxheUZpZWxkLCB0eXBlOiAnU3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiB2YWx1ZUZpZWxkLCAgIHR5cGU6ICdTdHJpbmcnfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFN0b3JlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHRyaWdnZXJBY3Rpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRUcmlnZ2VyQWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAndHJpZ2dlckFjdGlvbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgdmFsdWUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdHxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcnxPYmplY3R8U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkaXNwbGF5RmllbGQgPSBtZS5kaXNwbGF5RmllbGQsXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgPSBtZS5zdG9yZSxcbiAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICAvLyBnZXR0aW5nIGEgcmVjb3JkLCBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmIChOZW8uaXNSZWNvcmQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGNhbiBvbmx5IG1hdGNoIHJlY29yZCBpZHMgb3IgZGlzcGxheSB2YWx1ZXMgaW4gY2FzZSB0aGUgc3RvcmUgaXMgbG9hZGVkXG4gICAgICAgIGlmIChzdG9yZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuaXNGaWx0ZXJlZCgpID8gc3RvcmUuYWxsSXRlbXMuZ2V0KHZhbHVlKSA6IHN0b3JlLmdldCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdG9yZS5maW5kKGRpc3BsYXlGaWVsZCwgdmFsdWUpWzBdIHx8IG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIG5vdCBsb2FkZWQgeWV0XG4gICAgICAgICAgICBtZS5wcmVTdG9yZUxvYWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8ubGlzdC5CYXNlfVxuICAgICAqL1xuICAgIGNyZWF0ZVBpY2tlckNvbXBvbmVudCgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmxpc3QgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgOiBMaXN0LFxuICAgICAgICAgICAgYXBwTmFtZSAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBkaXNwbGF5RmllbGQgIDogbWUuZGlzcGxheUZpZWxkLFxuICAgICAgICAgICAgaXRlbVJvbGUgICAgICA6ICdvcHRpb24nLFxuICAgICAgICAgICAgaXRlbXNGb2N1c2FibGU6IGZhbHNlLFxuICAgICAgICAgICAga2VlcEZvY3VzSW5kZXg6IHRydWUsXG4gICAgICAgICAgICBuYXZpZ2F0b3IgICAgIDoge2V2ZW50U291cmNlOiBtZS5nZXRJbnB1dEVsSWQoKX0sXG4gICAgICAgICAgICBwYXJlbnRJZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICByb2xlICAgICAgICAgIDogJ2xpc3Rib3gnLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw6IHtzdGF5SW5MaXN0OiBmYWxzZX0sXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgIDogbWUuc3RvcmUsXG4gICAgICAgICAgICAuLi5tZS5saXN0Q29uZmlnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmdldElucHV0RWwoKVsnYXJpYS1jb250cm9scyddID0gbWUubGlzdC5pZDtcblxuICAgICAgICBtZS5saXN0LmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBuZW9uYXZpZ2F0ZToge1xuICAgICAgICAgICAgICAgIGZuICAgOiBtZS5vbkxpc3RJdGVtTmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmxpc3Quc2VsZWN0aW9uTW9kZWwub24oe1xuICAgICAgICAgICAgbm9DaGFuZ2UgICAgICAgOiBtZS5vbkxpc3RJdGVtU2VsZWN0aW9uTm9DaGFuZ2UsXG4gICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2U6IG1lLm9uTGlzdEl0ZW1TZWxlY3Rpb25DaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtZS5saXN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsIHJvdXRlcyB3aGljaCBleHBlY3QgdG8gb3BlbiB0aGUgcGlja2VyIHJvdXRlIHRocm91Z2ggaGVyZS4gVGhpcyB1cGRhdGVzIHRoZVxuICAgICAqIGZpbHRlciBhbmQgZW5zdXJlcyB0aGF0IHRoZSBwaWNrZXIgaXMgdmlzaWJsZSBhbmQgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIGZpbHRlci5cbiAgICAgKlxuICAgICAqIElucHV0IGV2ZW50IHByb2Nlc3NpbmcgcGFzc2VzIHRoZSBjdXJyZW50IGlucHV0IGZpZWxkIHZhbHVlIGluIGFzIHRoZSBmaWx0ZXIgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJbnZvY2F0aW9uIG9mIHRoZSBleHBhbmQgdHJpZ2dlciBwYXNzZXMgYG51bGxgIHNvIGFzIHRvIGNsZWFyIGZpbHRlcmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWx0ZXIgdGhlIHBpY2tlciBieVxuICAgICAqL1xuICAgIGRvRmlsdGVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RvcmUgID0gbWUuc3RvcmUsXG4gICAgICAgICAgICBmaWx0ZXIgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGlzcGxheUZpZWxkKSxcbiAgICAgICAgICAgIHBpY2tlciA9IG1lLnBpY2tlcixcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLnZhbHVlO1xuXG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIGZpbHRlci52YWx1ZSA9IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWx0ZXIgcmVzdWx0aW5nIGluIHNvbWV0aGluZyB0byBzaG93XG4gICAgICAgIGlmIChzdG9yZS5nZXRDb3VudCgpKSB7XG4gICAgICAgICAgICBtZS5zaG93UGlja2VyKCk7XG5cbiAgICAgICAgICAgIC8vIExpc3QgbWlnaHQgbm90IGV4aXN0IHVudGlsIHRoZSBwaWNrZXIgaXMgY3JlYXRlZFxuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICB7IGxpc3QgfSAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgICAgICB7IHNlbGVjdGlvbk1vZGVsIH0gPSBsaXN0O1xuXG4gICAgICAgICAgICAvLyBPbiBzaG93LCBzZXQgdGhlIGFjdGl2ZSBpdGVtIHRvIGJlIHRoZSBjdXJyZW50IHNlbGVjdGVkIHJlY29yZCBvciB0aGUgZmlyc3RcbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBoZWFyIGJhY2sgYWJvdXQgb3VyIG93biBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5zdXNwZW5kRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5zZWxlY3QocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5zdXNwZW5kRXZlbnRzID0gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3RvcmUuaW5kZXhPZihyZWNvcmQpO1xuICAgICAgICAgICAgICAgIGxpc3QuX2ZvY3VzSW5kZXggPSAtMTsgLy8gc2lsZW50IHVwZGF0ZSB0byBlbnN1cmUgYWZ0ZXJTZXRGb2N1c0luZGV4KCkgYWx3YXlzIGdldHMgY2FsbGVkXG4gICAgICAgICAgICAgICAgbGlzdC5mb2N1c0luZGV4ICA9IGluZGV4ID4gLTEgPyBpbmRleCA6IDBcbiAgICAgICAgICAgIH0sIDEwMClcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWx0ZXJlZCBkb3duIHRvIG5vdGhpbmcgLSBoaWRlIHBpY2tlciBpZiBpdCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBpY2tlcj8uaGlkZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBmaWx0ZXJPbklucHV0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kb0ZpbHRlcih2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyPy5oaWRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBmb3JtLmZpZWxkLkJhc2VcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICBwYXJhbXM7XG5cbiAgICAgICAgaWYgKCEobWUuZm9yY2VTZWxlY3Rpb24gJiYgIXZhbHVlKSkge1xuICAgICAgICAgICAgcGFyYW1zID0ge2NvbXBvbmVudDogbWUsIG9sZFZhbHVlLCB2YWx1ZX07XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHBhcmFtcyk7XG5cbiAgICAgICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZmlyZSgnZmllbGRDaGFuZ2UnLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRJbnB1dEhpbnRFbCgpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQodGhpcy52ZG9tLCB0aGlzLmdldElucHV0SGludElkKCkpPy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJbnB1dEhpbnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyAnX19pbnB1dC1oaW50J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IHNlbGVjdGVkIHJlY29yZCBvciBudWxsXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmQoKSB7XG4gICAgICAgIGxldCBsaXN0ICAgICAgPSB0aGlzLmxpc3QsXG4gICAgICAgICAgICByZWNvcmRLZXkgPSBsaXN0LnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbigpWzBdO1xuXG4gICAgICAgIHJldHVybiByZWNvcmRLZXkgJiYgdGhpcy5zdG9yZS5nZXQobGlzdC5nZXRJdGVtUmVjb3JkSWQocmVjb3JkS2V5KSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN1Ym1pdFZhbHVlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBtZS52YWx1ZT8uW21lLnZhbHVlRmllbGRdIHx8IG1lLmVtcHR5VmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0RWwgPSB0aGlzLmdldElucHV0RWwoKTtcblxuICAgICAgICBpbnB1dEVsWydhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnXSA9ICcnO1xuICAgICAgICBpbnB1dEVsWydhcmlhLWV4cGFuZGVkJ10gICAgICAgICA9IGZhbHNlO1xuICAgICAgICBpbnB1dEVsWydhcmlhLWhhc3BvcHVwJ10gICAgICAgICA9ICdsaXN0Ym94JztcblxuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKC4uLmFyZ3VtZW50cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIElmIHdlIGFyZSBsZWF2aW5nIHRoZSBmaWVsZCwgdXNpbmcgZm9yY2VTZWxlY3Rpb249dHJ1ZSBhbmQgdGhlIGZpZWxkIGRvZXMgbm90IGhhdmUgYSBzZWxlY3RlZCByZWNvcmQsXG4gICAgICAgICAqIHdlIGRvIHdhbnQgdG8gcGljayB0aGUgY2xvc2VzdCBtYXRjaCA9PiB0aGUgZm9jdXNzZWQgcmVjb3JkIChob25vcmluZyBmaWx0ZXJzKS5cbiAgICAgICAgICogSWYgbm8gcmVjb3JkIGlzIGZvdW5kLCB3ZSB3aWxsIGNsZWFyIHRoZSBmaWVsZCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG1lLmZvcmNlU2VsZWN0aW9uICYmICFtZS52YWx1ZSkge1xuICAgICAgICAgICAgbWUucHJvZ3JhbW1hdGljVmFsdWVDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbWUudmFsdWUgICAgICAgICAgICAgICAgICAgPSBtZS5zdG9yZS5nZXQobWUuYWN0aXZlUmVjb3JkSWQpO1xuICAgICAgICAgICAgbWUucHJvZ3JhbW1hdGljVmFsdWVDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZVR5cGVBaGVhZFZhbHVlKG51bGwpO1xuXG4gICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uS2V5RG93bkRvd24oZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUucGlja2VyIHx8IG1lLnBpY2tlcj8uaGlkZGVuKSB7XG4gICAgICAgICAgICBtZS5vblBpY2tlclRyaWdnZXJDbGljaygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOlxuICAgICAqIFdoZW4gd2UgYXJlIHVzaW5nIGEgYENvbGxlY3Rpb25gIGFzIG91ciBgdmFsdWVDb2xsZWN0aW9uYCwgYW5kIHRoYXQgYENvbGxlY3Rpb25gIGlzIHRoZVxuICAgICAqIGBpdGVtc2Agb2YgdGhlIExpc3QncyBgc2VsZWN0aW9uTW9kZWxgLCB0aGVuIHRoaXMgd2lsbCBiZSBgb25WYWx1ZUNvbGxlY3Rpb25DaGFuZ2VgLFxuICAgICAqIGEgYG11dGF0ZWAgbGlzdGVuZXIgb24gb3VyIG93biBgdmFsdWVDb2xsZWN0aW9uYCB3aGljaCBiYWNrcyBvdXIgYHZhbHVlYCBmaWVsZCB3aGljaFxuICAgICAqIHdpbGwgYmUgaW1wbGVtZW50ZWQgYnkgYSBnZXR0ZXIgd2hpY2ggYWNjZXNzZXMgYHZhbHVlQ29sbGVjdGlvbmAuXG4gICAgICogVGhpcyB3aWxsIGJlY29tZSBpbXBvcnRhbnQgZm9yIGltcGxlbWVudGluZyBtdWx0aVNlbGVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3Rpb25DaGFuZ2VFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHNlbGVjdGlvbkNoYW5nZUV2ZW50LnNlbGVjdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBvbkxpc3RJdGVtU2VsZWN0aW9uQ2hhbmdlKHsgc2VsZWN0aW9uIH0pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbj8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdGlvblswXSxcbiAgICAgICAgICAgICAgICByZWNvcmQgICA9IHR5cGVvZiBzZWxlY3RlZCA9PT0gJ3N0cmluZycgPyBtZS5zdG9yZS5nZXQobWUubGlzdC5nZXRJdGVtUmVjb3JkSWQoc2VsZWN0ZWQpKSA6IHNlbGVjdGVkO1xuXG4gICAgICAgICAgICBtZS5oaW50UmVjb3JkSWQgPSBudWxsO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVUeXBlQWhlYWRWYWx1ZShudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgbWUucHJldmVudEZpbHRlcmluZyA9IHRydWU7XG4gICAgICAgICAgICBtZS52YWx1ZSAgICAgICAgICAgID0gcmVjb3JkO1xuICAgICAgICAgICAgbWUucHJldmVudEZpbHRlcmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNob3J0IGRlbGF5IHRvIGxldCBzZWxlY3Rpb24gRE9NIHVwZGF0ZXMgZ2V0IGFwcGxpZWQuXG4gICAgICAgICAgICAvLyBBbHRlcm5hdGl2ZWx5LCB3ZSBjb3VsZCBoaWRlIHRoZSBwaWNrZXIgYmVmb3JlIHRoZSBzZWxlY3Rpb24gaGFwcGVuIGFuZCBsaW1pdCB1cGRhdGVzIHRvIHRoZSB2ZG9tLlxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMCk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLmhpZGVQaWNrZXIoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0aW9uIHdhcyBhdHRlbXB0ZWQgdG8gYmUgY2hhbmdlZCBidXQgcmVzdWx0ZWQgaW4gbm8gYWN0aW9uLlxuICAgICAqIEZvciBleGFtcGxlIGNsaWNraW5nIG9uIGFscmVhZHkgc2VsZWN0ZWQgbGlzdCBpdGVtLlxuICAgICAqL1xuICAgIG9uTGlzdEl0ZW1TZWxlY3Rpb25Ob0NoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5oaWRlUGlja2VyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uTGlzdEl0ZW1OYXZpZ2F0ZShyZWNvcmQpIHtcbiAgICAgICAgbGV0IHthY3RpdmVJbmRleH0gPSByZWNvcmQ7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge3N0b3JlfSA9IG1lO1xuXG4gICAgICAgICAgICBtZS5hY3RpdmVSZWNvcmQgICA9IHN0b3JlLmdldEF0KGFjdGl2ZUluZGV4KTtcbiAgICAgICAgICAgIG1lLmFjdGl2ZVJlY29yZElkID0gbWUuYWN0aXZlUmVjb3JkW3N0b3JlLmtleVByb3BlcnR5IHx8IG1vZGVsLmtleVByb3BlcnR5XTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHR5cGVhaGVhZCBoaW50ICh3aGljaCB1cGRhdGVzIERPTSksIG9yIHVwZGF0ZSBET01cbiAgICAgICAgICAgIG1lLnR5cGVBaGVhZCA/IG1lLnVwZGF0ZVR5cGVBaGVhZFZhbHVlKG1lLmxhc3RNYW51YWxJbnB1dCkgOiBtZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25QaWNrZXJIaWRkZW5DaGFuZ2UoeyB2YWx1ZSB9KSB7XG4gICAgICAgIGNvbnN0IGlucHV0RWwgPSB0aGlzLmdldElucHV0RWwoKTtcblxuICAgICAgICBzdXBlci5vblBpY2tlckhpZGRlbkNoYW5nZSguLi5hcmd1bWVudHMpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaW5wdXRFbFsnYXJpYS1hY3RpdmVkZXNjZW5kYW50J10gPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRFbFsnYXJpYS1leHBhbmRlZCddID0gIXZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0aW5nIGEgcmVjb3JkLCBpZiByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoaXRlbXMpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHZhbHVlID0gbWUucHJlU3RvcmVMb2FkVmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZS5fdmFsdWUgPSB1bmRlZmluZWQ7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgICAgIG1lLnZhbHVlICA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdEZpcnN0TGlzdEl0ZW0oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0TGlzdEl0ZW0oMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdExhc3RMaXN0SXRlbSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RMaXN0SXRlbSh0aGlzLnN0b3JlLmdldENvdW50KCkgLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgbm8gaW5kZXggaXMgcGFzc2VkLCB0aGUgaW5kZXggbWF0Y2hpbmcgdG8gdGhlIGZpZWxkIGlucHV0IHdpbGwgZ2V0IHVzZWQgKDAgaWYgbm9uZSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XVxuICAgICAqL1xuICAgIHNlbGVjdExpc3RJdGVtKGluZGV4KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFOZW8uaXNOdW1iZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICBpZiAobWUuYWN0aXZlUmVjb3JkSWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1lLnN0b3JlLmluZGV4T2ZLZXkobWUuYWN0aXZlUmVjb3JkSWQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUubGlzdC5zZWxlY3RJdGVtKGluZGV4KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHRvZ2dsZVBpY2tlcigpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwaWNrZXJ9ID0gbWU7XG5cbiAgICAgICAgaWYgKHBpY2tlcj8uaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcGlja2VyLmhpZGRlbiA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmICghbWUuZGlzYWJsZWQgJiYgIW1lLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBtZS5kb0ZpbHRlcihudWxsKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkIGluc2lkZSBjbGFzcyBleHRlbnNpb25zLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlSW5wdXRWYWx1ZUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBsZXQgaW5wdXRWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKE5lby5pc1JlY29yZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSB2YWx1ZVt0aGlzLmRpc3BsYXlGaWVsZF1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVR5cGVBaGVhZChzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5wdXRFbCA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQobWUudmRvbSwge2ZsYWc6ICduZW8tcmVhbC1pbnB1dCd9KSxcbiAgICAgICAgICAgIHZkb20gICAgPSBtZS52ZG9tO1xuXG4gICAgICAgIGlmIChtZS50eXBlQWhlYWQpIHtcbiAgICAgICAgICAgIGlucHV0RWwucGFyZW50Tm9kZS5jbltpbnB1dEVsLmluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLWlucHV0LWZpZWxkLXdyYXBwZXInXSxcbiAgICAgICAgICAgICAgICBjbiA6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRhZyAgICAgICAgIDogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiAnbm8nLCAvLyB3aGlsZSBcIm9mZlwiIGlzIHRoZSBjb3JyZWN0IHZhbHVlLCBicm93c2VyIHZlbmRvcnMgaWdub3JlIGl0LiBBcmJpdHJhcnkgc3RyaW5ncyBkbyB0aGUgdHJpY2suXG4gICAgICAgICAgICAgICAgICAgIGF1dG9jb3JyZWN0IDogJ29mZicsXG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgICAgIDogWyduZW8tdGV4dGZpZWxkLWlucHV0JywgJ25lby10eXBlYWhlYWQtaW5wdXQnXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICA6IG1lLmdldElucHV0SGludElkKCksXG4gICAgICAgICAgICAgICAgICAgIHNwZWxsY2hlY2sgIDogJ2ZhbHNlJ1xuICAgICAgICAgICAgICAgIH0sIGlucHV0RWwudmRvbV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFZEb21VdGlsLnJlcGxhY2VWZG9tQ2hpbGQodmRvbSwgaW5wdXRFbC5wYXJlbnROb2RlLmlkLCBpbnB1dEVsLnZkb20pXG4gICAgICAgIH1cblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWU9dGhpcy5sYXN0TWFudWFsSW5wdXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVUeXBlQWhlYWRWYWx1ZSh2YWx1ZT10aGlzLmxhc3RNYW51YWxJbnB1dCwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbWF0Y2ggICAgICAgICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBpbnB1dEhpbnRFbCAgICAgICAgICAgPSBtZS5nZXRJbnB1dEhpbnRFbCgpLFxuICAgICAgICAgICAge2Rpc3BsYXlGaWVsZCwgc3RvcmV9ID0gbWU7XG5cbiAgICAgICAgaWYgKG1lLnR5cGVBaGVhZCkge1xuICAgICAgICAgICAgaWYgKCFtZS52YWx1ZSAmJiB2YWx1ZT8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaCA9IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzdG9yZS5pdGVtcy5maW5kKHIgPT4gcltkaXNwbGF5RmllbGRdPy50b0xvd2VyQ2FzZT8uKCk/LnN0YXJ0c1dpdGgoc2VhcmNoKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgaW5wdXRIaW50RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRIaW50RWwudmFsdWUgPSB2YWx1ZSArIG1hdGNoW2Rpc3BsYXlGaWVsZF0uc3Vic3RyKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZVJlY29yZCAgID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZVJlY29yZElkID0gbWF0Y2hbc3RvcmUua2V5UHJvcGVydHkgfHwgc3RvcmUubW9kZWwua2V5UHJvcGVydHldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hdGNoICYmIGlucHV0SGludEVsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRIaW50RWwudmFsdWUgPSBtZS5hY3RpdmVSZWNvcmQgPSBtZS5hY3RpdmVSZWNvcmRJZCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVWYWx1ZUZyb21JbnB1dFZhbHVlKGlucHV0VmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5sYXN0TWFudWFsSW5wdXQgPSBpbnB1dFZhbHVlO1xuXG4gICAgICAgIGlmICghbWUucHJvZ3JhbW1hdGljVmFsdWVDaGFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGNoYW5naW5nIHRoZSBpbnB1dCA9PiBzaWxlbnQgcmVjb3JkIHJlc2V0XG4gICAgICAgICAgICBtZS5fdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgbWUubGlzdD8uc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3RBbGwoKTtcblxuICAgICAgICAgICAgbWUuZmlsdGVyT25JbnB1dChpbnB1dFZhbHVlKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBzZWxlY3QgZXZlbnQgZmlyZXMgd2hlbiBhIGxpc3QgaXRlbSBnZXRzIHNlbGVjdGVkXG4gKiBAZXZlbnQgc2VsZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gKiBAcGFyYW0ge3ZhbHVlfSByZWNvcmRbc3RvcmUua2V5UHJvcGVydHldXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbk5lby5zZXR1cENsYXNzKENvbWJvQm94KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29tYm9Cb3g7XG4iLCJpbXBvcnQgQ29udGFpbmVyICAgICBmcm9tICcuLi8uLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFBpY2tlclRyaWdnZXIgZnJvbSAnLi90cmlnZ2VyL1BpY2tlci5tanMnO1xuaW1wb3J0IFRleHQgICAgICAgICAgZnJvbSAnLi9UZXh0Lm1qcyc7XG5cbi8qKlxuICogVGhlIGFic3RyYWN0IHBpY2tlciBmaWVsZCBwcm92aWRlcyBhbiBhcnJvdyBkb3duIHRyaWdnZXIgd2hpY2ggb3BlbnMgYSBmbG9hdGluZyBjb250YWluZXIgdG8gcHJvdmlkZVxuICogbW9yZSBkYXRhIHNlbGVjdGlvbiBvcHRpb25zXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuUGlja2VyXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5UZXh0XG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgUGlja2VyIGV4dGVuZHMgVGV4dCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5QaWNrZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLlBpY2tlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwaWNrZXJmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwaWNrZXJmaWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1waWNrZXJmaWVsZCcsJ25lby10ZXh0ZmllbGQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcGlja2VyZmllbGQnLCAnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIHRoZSBkYXRhIGZyb20gdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGNhbGwgKHBpY2tlciAmIGJvZHkgRG9tUmVjdHMpXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBjbGllbnRSZWN0cz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsaWVudFJlY3RzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7XG4gICAgICAgICAgICBFbnRlciA6ICdvbktleURvd25FbnRlcicsXG4gICAgICAgICAgICBFc2NhcGU6ICdvbktleURvd25Fc2NhcGUnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udGFpbmVyLkJhc2V8bnVsbH0gcGlja2VyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlncyB0byBwYXNzIHRvIHRoZSBwaWNrZXIgY29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBwaWNrZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgcGlja2VyIGNvbnRhaW5lci4gRGVmYXVsdHMgdG8gcHguXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBwaWNrZXJIZWlnaHQ9MTAwXG4gICAgICAgICAqL1xuICAgICAgICBwaWNrZXJIZWlnaHQ6IDEwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHBpY2tlcklzTW91bnRlZF89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VySXNNb3VudGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBwaWNrZXIgY29udGFpbmVyLiBEZWZhdWx0cyB0byBweC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHBpY2tlck1heEhlaWdodD0yMDBcbiAgICAgICAgICovXG4gICAgICAgIHBpY2tlck1heEhlaWdodDogMjAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBwaWNrZXIgY29udGFpbmVyLiBEZWZhdWx0cyB0byBweC5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIHdpZHRoIG9mIHRoZSBwaWNrZXIgbWF0Y2hlcyB0aGUgd2lkdGggb2YgdGhlIGlucHV0IHdyYXAgZWxlbWVudC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHBpY2tlcldpZHRoPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBpY2tlcldpZHRoOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd1BpY2tlck9uRm9jdXM9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1BpY2tlck9uRm9jdXM6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fE9iamVjdFtdfSB0cmlnZ2Vycz1bXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyczogW3tcbiAgICAgICAgICAgIG1vZHVsZTogUGlja2VyVHJpZ2dlclxuICAgICAgICB9XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGNsaWNrOiBtZS5vbklucHV0Q2xpY2ssXG4gICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlICYmIG9sZFZhbHVlICYmIHRoaXMucGlja2VySXNNb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlci5oaWRlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aGVtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5waWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLnRoZW1lID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udGFpbmVyLkJhc2V9XG4gICAgICovXG4gICAgY3JlYXRlUGlja2VyKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHsgcGlja2VyV2lkdGggfSA9IG1lLFxuICAgICAgICAgICAgcGlja2VyQ29tcG9uZW50ID0gbWUuY3JlYXRlUGlja2VyQ29tcG9uZW50KCk7XG5cbiAgICAgICAgbWUucGlja2VyID0gIE5lby5jcmVhdGUoQ29udGFpbmVyLCB7XG4gICAgICAgICAgICBwYXJlbnRJZCA6ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgICAgIGZsb2F0aW5nIDogdHJ1ZSxcbiAgICAgICAgICAgIGFsaWduICAgIDoge1xuICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IHBpY2tlcldpZHRoID8gJ3QwLWIwJyA6ICd0LWInLFxuICAgICAgICAgICAgICAgIG1hdGNoU2l6ZSA6ICFwaWNrZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBheGlzTG9jayAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICA6IG1lLmdldElucHV0V3JhcHBlcklkKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLXBpY2tlci1jb250YWluZXInLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAgICAgaGVpZ2h0ICAgOiBtZS5waWNrZXJIZWlnaHQsXG4gICAgICAgICAgICBoaWRkZW4gICA6IHRydWUsXG4gICAgICAgICAgICBpZCAgICAgICA6IG1lLmdldFBpY2tlcklkKCksXG4gICAgICAgICAgICBpdGVtcyAgICA6IHBpY2tlckNvbXBvbmVudCA/IFtwaWNrZXJDb21wb25lbnRdIDogW10sXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IG1lLnBpY2tlck1heEhlaWdodCxcbiAgICAgICAgICAgIHRoZW1lICAgIDogbWUudGhlbWUsXG4gICAgICAgICAgICB3aWR0aCAgICA6IHBpY2tlcldpZHRoLFxuICAgICAgICAgICAgLi4ubWUucGlja2VyQ29uZmlnLFxuXG4gICAgICAgICAgICAvLyBzY29wZWQgdG8gdGhlIGZpZWxkIGluc3RhbmNlXG4gICAgICAgICAgICBvbkZvY3VzTGVhdmU6IGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbnNpZGVGaWVsZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpdGVtIG9mIGRhdGEub2xkUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gbWUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZUZpZWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluc2lkZUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmhpZGVQaWNrZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5waWNrZXIub24oJ2hpZGRlbkNoYW5nZScsIG1lLm9uUGlja2VySGlkZGVuQ2hhbmdlLCBtZSk7XG5cbiAgICAgICAgcmV0dXJuIG1lLnBpY2tlclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSB5b3VyIHBpY2tlciBjb250ZW50IGFzIG5lZWRlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBjcmVhdGVQaWNrZXJDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHBpY2tlciA9IHRoaXMucGlja2VyO1xuXG4gICAgICAgIGlmIChwaWNrZXI/LmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHBpY2tlci51bm1vdW50KClcbiAgICAgICAgfVxuXG4gICAgICAgIHBpY2tlcj8uZGVzdHJveSgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGlja2VyIGluc3RhbmNlIGFuZCBjcmVhdGVzIGl0IGluIGNhc2UgaXQgZG9lcyBub3QgZXhpc3QgeWV0XG4gICAgICogQHJldHVybnMge05lby5jb250YWluZXIuQmFzZX1cbiAgICAgKi9cbiAgICBnZXRQaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlciB8fCB0aGlzLmNyZWF0ZVBpY2tlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRQaWNrZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19waWNrZXJgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBoaWRlUGlja2VyKCkge1xuICAgICAgICBpZiAodGhpcy5waWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLmhpZGRlbiA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNFbnRlcihkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uRm9jdXNFbnRlcihkYXRhKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNob3dQaWNrZXJPbkZvY3VzICYmIG1lLnNob3dQaWNrZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5zaWRlUGlja2VyID0gZmFsc2UsXG4gICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgIGZvciAoaXRlbSBvZiBkYXRhLm9sZFBhdGgpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmlkID09PSBtZS5nZXRQaWNrZXJJZCgpKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlUGlja2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnNpZGVQaWNrZXIpIHtcbiAgICAgICAgICAgIG1lLmhpZGVQaWNrZXIoKTtcbiAgICAgICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbklucHV0Q2xpY2soZGF0YSkge1xuICAgICAgICAhdGhpcy5lZGl0YWJsZSAmJiB0aGlzLnRvZ2dsZVBpY2tlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja1Njb3BlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbktleURvd25FbnRlcihkYXRhLCBjYWxsYmFjaywgY2FsbGJhY2tTY29wZSkge1xuICAgICAgICAhdGhpcy5waWNrZXJJc01vdW50ZWQgJiYgdGhpcy5zaG93UGlja2VyKGNhbGxiYWNrLCBjYWxsYmFja1Njb3BlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uS2V5RG93bkVzY2FwZShkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlcklzTW91bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlUGlja2VyKCk7XG5cbiAgICAgICAgICAgIC8vIFdlIHByb2Nlc3NlZCB0aGlzIGV2ZW50LCBhbmQgaXQgc2hvdWxkIG5vdCBwcm9jZWVkIHRvIGFuY2VzdG9yIGNvbXBvbmVudHNcbiAgICAgICAgICAgIGRhdGEuY2FuY2VsQnViYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQW5kIG5vIGZ1cnRoZXIgbGlzdGVuZXJzIHNob3VsZCBiZSBub3RpZmllZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLnZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUGlja2VySGlkZGVuQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5waWNrZXJJc01vdW50ZWQgPSAhZGF0YS52YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBmb3JtLmZpZWxkLnRyaWdnZXIuUGlja2VyXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUGlja2VyVHJpZ2dlckNsaWNrKCkge1xuICAgICAgICB0aGlzLmVkaXRhYmxlICYmIHRoaXMudG9nZ2xlUGlja2VyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dQaWNrZXIoKSB7XG4gICAgICAgIHRoaXMuZ2V0UGlja2VyKCkuaGlkZGVuID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZVBpY2tlcigpIHtcbiAgICAgICAgbGV0IHBpY2tlciA9IHRoaXMuZ2V0UGlja2VyKCk7XG4gICAgICAgIHBpY2tlci5oaWRkZW4gPSAhcGlja2VyLmhpZGRlblxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoUGlja2VyKTtcblxuZXhwb3J0IGRlZmF1bHQgUGlja2VyO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogVXNlZCBieSBmb3JtLmZpZWxkLlBpY2tlclxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuUGlja2VyXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkJhc2VcbiAqL1xuY2xhc3MgUGlja2VyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLlBpY2tlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQudHJpZ2dlci5QaWNrZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndHJpZ2dlci1waWNrZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndHJpZ2dlci1waWNrZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGljb25DbHM9J2ZhIGZhLWNhcmV0LWRvd24nXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY2FyZXQtZG93bicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHVzZWQgYnkgZmllbGQuZ2V0VHJpZ2dlcigpXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0ncGlja2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAncGlja2VyJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25UcmlnZ2VyQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmZpZWxkLm9uUGlja2VyVHJpZ2dlckNsaWNrKCk7XG4gICAgfSBcbn1cblxuTmVvLnNldHVwQ2xhc3MoUGlja2VyKTtcblxuZXhwb3J0IGRlZmF1bHQgUGlja2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9