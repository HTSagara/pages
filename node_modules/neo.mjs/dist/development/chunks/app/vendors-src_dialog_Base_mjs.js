"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_dialog_Base_mjs"],{

/***/ "./src/dialog/Base.mjs":
/*!*****************************!*\
  !*** ./src/dialog/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Panel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Panel.mjs */ "./src/container/Panel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _header_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./header/Toolbar.mjs */ "./src/dialog/header/Toolbar.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");





let DragZone;

/**
 * @class Neo.dialog.Base
 * @extends Neo.container.Panel
 */
class Base extends _container_Panel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for closeAction
     * @member {String[]} closeActions=['close','hide']
     * @protected
     * @static
     */
    static closeActions = ['close', 'hide']

    static config = {
        /**
         * @member {String} className='Neo.dialog.Base'
         * @protected
         */
        className: 'Neo.dialog.Base',
        /**
         * @member {String} ntype='dialog'
         * @protected
         */
        ntype: 'dialog',
        /**
         * @member {Boolean} animateOnDragEnd=false
         */
        animateOnDragEnd: false,
        /**
         * @member {String|null} animateTargetId_=null
         */
        animateTargetId_: null,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {Boolean} autoRender=true
         */
        autoRender: true,
        /**
         * @member {String[]} baseCls=['neo-dialog','neo-panel','neo-container']
         * @protected
         */
        baseCls: ['neo-dialog', 'neo-panel', 'neo-container'],
        /**
         * Either a dom node id, 'document.body' or null
         * @member {String|null} boundaryContainerId='document.body'
         */
        boundaryContainerId: 'document.body',
        /**
         * Define what happens in case you click on the close button
         * close will destroy the instance, hide will keep it for later re-use.
         * Valid values: close, hide
         * @member {String} closeAction='close'
         */
        closeAction: 'close',
        /**
         * @member {Boolean} draggable_=true
         */
        draggable_: true,
        /**
         * @member {Boolean} dragListenersAdded=false
         * @protected
         */
        dragListenersAdded: false,
        /**
         * @member {Neo.draggable.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * @member {Object} headerConfig=null
         */
        headerConfig: null,
        /**
         * @member {Neo.toolbar.Base|null} headerToolbar=null
         */
        headerToolbar: null,
        /**
         * @member {Boolean} isDragging=false
         * @protected
         */
        isDragging: false,
        /**
         * @member {String} maximizeCls='far fa-window-maximize'
         */
        maximizeCls: 'far fa-window-maximize',
        /**
         * @member {Boolean} maximized_=false
         */
        maximized_: false,
        /**
         * @member {String} minimizeCls='far fa-window-minimize'
         */
        minimizeCls: 'far fa-window-minimize',
        /**
         * @member {Boolean} resizable_=true
         */
        resizable_: true,
        /**
         * @member {Object} resizablePluginConfig=null
         */
        resizablePluginConfig: null,
        /**
         * @member {String|null} title_=null
         */
        title_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cls: ['neo-dialog-wrapper'], cn: [
            {cn: []}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.vdom.id = me.getWrapperId();

        me.createHeader();

        me.animateTargetId && me.animateShow();
    }

    /**
     * Triggered after the animateTargetId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAnimateTargetId(value, oldValue) {
        this.autoMount  = !value;
        this.autoRender = !value;
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        let me        = this,
            resizable = me.getPlugin({flag: 'resizable'});

        if (me.dragZone) {
            me.dragZone.appName = value;
        }

        if (resizable) {
            resizable.appName = value;
        }

        super.afterSetAppName(value, oldValue);
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me           = this,
            domListeners = me.domListeners,
            cls;

        if (oldValue !== undefined && me.headerToolbar) {
            cls = me.headerToolbar.cls;
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value ? 'add' : 'remove'](cls, 'neo-draggable');
            me.headerToolbar.cls = cls;
        }

        value && __webpack_require__.e(/*! import() */ "vendors-src_draggable_DragZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs")).then(module => {
            DragZone = module.default;

            if (!me.dragListenersAdded) {
                domListeners.push(
                    {'drag:end'  : me.onDragEnd,   scope: me, delegate: '.neo-header-toolbar'},
                    {'drag:start': me.onDragStart, scope: me, delegate: '.neo-header-toolbar'}
                );

                if (me.dragZoneConfig?.alwaysFireDragMove) {
                    domListeners.push(
                        {'drag:move': me.onDragMove, scope: me, delegate: '.neo-header-toolbar'}
                    );
                }

                me.domListeners       = domListeners;
                me.dragListenersAdded = true;
            }
        });
    }

    /**
     * Triggered after the maximized config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMaximized(value, oldValue) {
        let me   = this,
            cls  = me.vdom.cls; // todo: using wrapperCls

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value ? 'add' : 'remove'](cls, 'neo-maximized');
        me.update();
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.animateTargetId) {
            Neo.applyDeltas(me.appName, {
                action: 'removeNode',
                id    : me.getAnimateTargetId()
            })
        }
    }

    /**
     * Triggered after the resizable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetResizable(value, oldValue) {
        value && Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_plugin_Resizable_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../plugin/Resizable.mjs */ "./src/plugin/Resizable.mjs")).then(module => {
            let me      = this,
                plugins = me.plugins || [];

            if (!me.getPlugin({flag: 'resizable'})) {
                plugins.push({
                    module       : module.default,
                    appName      : me.appName,
                    delegationCls: 'neo-dialog',
                    flag         : 'resizable',
                    ...me.resizablePluginConfig
                });

                me.plugins = plugins;
            }
        });
    }

    /**
     * Triggered after the title config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTitle(value, oldValue) {
        if (this.headerToolbar) {
            this.headerToolbar.title = value;
        }
    }

    /**
     *
     */
    async animateHide() {
        let me      = this,
            appName = me.appName,
            id      = me.getAnimateTargetId(),
            rects   = await me.getDomRect([me.id, me.animateTargetId]);

        await Neo.currentWorker.promiseMessage('main', {
            action  : 'mountDom',
            appName,
            html    : `<div id="${id}" class="neo-animate-dialog neo-hide" style="height:${rects[0].height}px;left:${rects[0].left}px;top:${rects[0].top}px;width:${rects[0].width}px;"></div>`,
            parentId: 'document.body'
        });

        me.closeOrHide(false);

        await me.timeout(30);

        await Neo.currentWorker.promiseMessage('main', {
            action: 'updateDom',
            appName,
            deltas: [{
                id,
                style: {
                    height: `${rects[1].height}px`,
                    left  : `${rects[1].left  }px`,
                    top   : `${rects[1].top   }px`,
                    width : `${rects[1].width }px`
                }
            }]
        });

        await me.timeout(250);

        await Neo.currentWorker.promiseMessage('main', {
            action: 'updateDom',
            appName,
            deltas: [{action: 'removeNode', id}]
        });
    }

    /**
     *
     */
    async animateShow() {
        let me           = this,
            appName      = me.appName,
            id           = me.getAnimateTargetId(),
            wrapperStyle = me.wrapperStyle,
            rect         = await me.getDomRect(me.animateTargetId);

        await Neo.currentWorker.promiseMessage('main', {
            action  : 'mountDom',
            appName,
            html    : `<div id="${id}" class="neo-animate-dialog" style="height:${rect.height}px;left:${rect.left}px;top:${rect.top}px;width:${rect.width}px;"></div>`,
            parentId: 'document.body'
        });

        await me.timeout(30);

        await Neo.currentWorker.promiseMessage('main', {
            action: 'updateDom',
            appName,
            deltas: [{
                id,
                style: {
                    height   : wrapperStyle?.height    || '50%',
                    left     : wrapperStyle?.left      || '50%',
                    top      : wrapperStyle?.top       || '50%',
                    transform: wrapperStyle?.transform || 'translate(-50%, -50%)',
                    width    : wrapperStyle?.width     || '50%'
                }
            }]
        });

        await me.timeout(200);

        me.show(false)
    }

    /**
     * Triggered before the closeAction config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetCloseAction(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'closeAction');
    }

    /**
     * @param {Boolean} [animate=!!this.animateTargetId]
     */
    close(animate=!!this.animateTargetId) {
        let me = this;

        if (animate) {
            me.animateHide();
        } else {
            me.fire('close');
            me.destroy(true);
        }
    }

    /**
     * @param {Boolean} [animate=!!this.animateTargetId]
     */
    closeOrHide(animate=!!this.animateTargetId) {
        this[this.closeAction](animate);
    }

    /**
     *
     */
    createHeader() {
        let me      = this,
            cls     = ['neo-header-toolbar', 'neo-toolbar'],
            headers = me.headers || [];

        me.draggable && cls.push('neo-draggable');

        me.headerToolbar = Neo.create({
            module   : _header_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName  : me.appName,
            cls,
            dock     : 'top',
            flex     : 'none',
            id       : me.getHeaderToolbarId(),
            listeners: {headerAction: me.executeHeaderAction, scope: me},
            title    : me.title,
            ...me.headerConfig
        });

        headers.unshift(me.headerToolbar);

        me.headers = headers;
    }

    /**
     * {Object} data
     */
    executeHeaderAction(data) {
        let me = this,

        map = {
            close   : me.closeOrHide,
            maximize: me.maximize
        };

        map[data.action]?.call(me, data);

        me.fire('headerAction', {
            dialog: me,
            ...data
        })
    }

    /**
     * Returns the id of the animation node
     * @returns {String}
     */
    getAnimateTargetId() {
        return this.id + '-animate';
    }

    /**
     * Returns the id of the header toolbar
     * @returns {String}
     */
    getHeaderToolbarId() {
        return this.id + '-header-toolbar';
    }

    /**
     * @returns {Object} vdom
     */
    getProxyVdom() {
        let vdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(this.vdom);

        // this call expects a fixed dialog structure
        // todo: a panel content container could get a flag which we can query for instead
        vdom.cn[0].cn[1].cn = [];

        return vdom;
    }

    /**
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[0];
    }

    /**
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0];
    }

    /**
     * Returns the id of the header toolbar
     * @returns {String}
     */
    getWrapperId() {
        return this.id + '-wrapper';
    }

    /**
     * @param {Boolean} [animate=!!this.animateTargetId]
     */
    hide(animate=!!this.animateTargetId) {
        let me = this;

        if (animate) {
            me.animateHide();
        } else {
            me.unmount();
            me.fire('hide');
        }
    }

    /**
     * @param {Object} [data]
     */
    maximize(data) {
        let me = this;

        data.component.iconCls = me.maximized ? me.maximizeCls : me.minimizeCls;

        me.maximized = !me.maximized;
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.headerToolbar = me.down({
            id: me.getHeaderToolbarId()
        });
    }

    /**
     * @param data
     */
    onDragEnd(data) {
        let me = this,
            initialTransitionProperty, wrapperStyle;

        if (!me.maximized) {
            me.getDomRect(me.dragZone.dragProxy.id).then(rect => {
                wrapperStyle = me.wrapperStyle;

                Object.assign(wrapperStyle, {
                    height   : `${rect.height}px`,
                    left     : `${rect.left}px`,
                    opacity  : 1,
                    top      : `${rect.top}px`,
                    transform: 'none',
                    width    : `${rect.width}px`
                });

                if (!me.animateOnDragEnd) {
                    initialTransitionProperty = wrapperStyle.transitionProperty || null;

                    wrapperStyle.transitionProperty = 'none';

                    setTimeout(() => {
                        wrapperStyle = me.wrapperStyle;

                        wrapperStyle.transitionProperty = initialTransitionProperty;

                        me.wrapperStyle = wrapperStyle;
                    }, 50);
                }

                me.wrapperStyle = wrapperStyle;

                me.dragZone.dragEnd(data);

                // we need a reset, otherwise we do not get a change event for the next onDragStart() call
                me.dragZone.boundaryContainerId = null;
                me.isDragging                   = false;
            });
        }
    }

    /**
     * This method will only get triggered in case alwaysFireDragMove is included inside the dragZoneConfig
     * @param data
     */
    onDragMove(data) {
        this.dragZone.dragMove(data);
    }

    /**
     * @param data
     */
    onDragStart(data) {
        let me           = this,
            wrapperStyle = me.wrapperStyle || {},
            resizablePlugin;

        if (!me.maximized) {
            me.isDragging = true;

            resizablePlugin = me.getPlugin({flag: 'resizable'});

            if (resizablePlugin) {
                resizablePlugin.removeAllNodes();
            }

            if (!me.dragZone) {
                me.dragZone = Neo.create({
                    module             : DragZone,
                    appName            : me.appName,
                    bodyCursorStyle    : 'move !important',
                    boundaryContainerId: me.boundaryContainerId,
                    dragElement        : me.vdom,
                    dragProxyConfig    : {vdom: me.getProxyVdom()},
                    owner              : me,
                    useProxyWrapper    : false,
                    ...me.dragZoneConfig
                });

                me.fire('dragZoneCreated', {
                    dragZone: me.dragZone,
                    id      : me.id
                });
            } else {
                me.dragZone.boundaryContainerId = me.boundaryContainerId;
            }

            me.dragZone.dragStart(data);

            wrapperStyle.opacity = 0.7;

            me.wrapperStyle = wrapperStyle;
        }
    }

    /**
     * @param {Boolean} [animate=!!this.animateTargetId]
     */
    show(animate=!!this.animateTargetId) {
        let me = this;

        if (animate) {
            me.animateShow();
        } else {
            me.render(true);
            me.fire('show');
        }
    }
}

Neo.applyClassConfig(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/dialog/header/Toolbar.mjs":
/*!***************************************!*\
  !*** ./src/dialog/header/Toolbar.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.dialog.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.dialog.header.Toolbar'
         * @protected
         */
        className: 'Neo.dialog.header.Toolbar',
        /**
         * @member {String|null} title=null
         */
        title_: null
    }

    /**
     * @member {Object} actionMap
     */
    actionMap = {
        close   : () => ({action: 'close',    iconCls: 'far fa-window-close'}),
        maximize: () => ({action: 'maximize', iconCls: 'far fa-window-maximize'})
    }
    /**
     * You can define the action order and directly add custom actions.
     * @example
     * {
     *     actions: [
     *         'close',
     *         'maximize',
     *         {action: 'help', iconCls: 'far fa-circle-question'}
     *     ]
     * }
     *
     * You can also extend the actionMap if needed.
     * @member {Object[]|String[]|null} actions=['maximize','close']
     */
    actions = ['maximize', 'close']

    /**
     * Triggered after the title config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTitle(value, oldValue) {
        this.down({flag: 'title-label'})?.set({
            hidden: !value,
            text  : value
        })
    }

    /**
     *
     */
    createItems() {
        let me      = this,
            handler = me.fireAction.bind(me),
            items   = me.items || [];

        items.push({
            ntype : 'label',
            cls   : ['neo-panel-header-text', 'neo-label'],
            flag  : 'title-label',
            hidden: !me.title,
            text  : me.title
        });

        if (me.actions) {
            items.push('->');

            me.actions.forEach(action => {
                if (Neo.typeOf(action) !== 'Object') {
                    action = me.actionMap[action]()
                }

                items.push({handler, ...action})
            })
        }

        me.items = items;

        super.createItems();
    }

    /**
     * @param {Object} data
     */
    fireAction(data) {
        let component = data.component;

        this.fire('headerAction', {
            action: component.action,
            component,
            scope : this
        })
    }
}

Neo.applyClassConfig(Toolbar);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Toolbar);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kaWFsb2dfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDTDtBQUNHO0FBQ0o7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUFLO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNB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QkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUJBQW1CO0FBQy9DLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLGlFQUFlLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZGlhbG9nL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZGlhbG9nL2hlYWRlci9Ub29sYmFyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGFuZWwgICAgZnJvbSAnLi4vY29udGFpbmVyL1BhbmVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFRvb2xiYXIgIGZyb20gJy4vaGVhZGVyL1Rvb2xiYXIubWpzJztcbmltcG9ydCBWRG9tVXRpbCBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcblxubGV0IERyYWdab25lO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGlhbG9nLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuUGFuZWxcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIFBhbmVsIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGNsb3NlQWN0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGNsb3NlQWN0aW9ucz1bJ2Nsb3NlJywnaGlkZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2xvc2VBY3Rpb25zID0gWydjbG9zZScsICdoaWRlJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRpYWxvZy5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGlhbG9nLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZGlhbG9nJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RpYWxvZycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbmltYXRlT25EcmFnRW5kPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlT25EcmFnRW5kOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhbmltYXRlVGFyZ2V0SWRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVUYXJnZXRJZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b1JlbmRlcj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvUmVuZGVyOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZGlhbG9nJywnbmVvLXBhbmVsJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRpYWxvZycsICduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogRWl0aGVyIGEgZG9tIG5vZGUgaWQsICdkb2N1bWVudC5ib2R5JyBvciBudWxsXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBib3VuZGFyeUNvbnRhaW5lcklkPSdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgKi9cbiAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIHdoYXQgaGFwcGVucyBpbiBjYXNlIHlvdSBjbGljayBvbiB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgICAqIGNsb3NlIHdpbGwgZGVzdHJveSB0aGUgaW5zdGFuY2UsIGhpZGUgd2lsbCBrZWVwIGl0IGZvciBsYXRlciByZS11c2UuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogY2xvc2UsIGhpZGVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbG9zZUFjdGlvbj0nY2xvc2UnXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZUFjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyYWdnYWJsZV89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyYWdMaXN0ZW5lcnNBZGRlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTGlzdGVuZXJzQWRkZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS5EcmFnWm9uZXxudWxsfSBkcmFnWm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnWm9uZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZHJhZ1pvbmVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGhlYWRlckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8udG9vbGJhci5CYXNlfG51bGx9IGhlYWRlclRvb2xiYXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyVG9vbGJhcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzRHJhZ2dpbmc9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG1heGltaXplQ2xzPSdmYXIgZmEtd2luZG93LW1heGltaXplJ1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4aW1pemVDbHM6ICdmYXIgZmEtd2luZG93LW1heGltaXplJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1heGltaXplZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIG1heGltaXplZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBtaW5pbWl6ZUNscz0nZmFyIGZhLXdpbmRvdy1taW5pbWl6ZSdcbiAgICAgICAgICovXG4gICAgICAgIG1pbmltaXplQ2xzOiAnZmFyIGZhLXdpbmRvdy1taW5pbWl6ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZXNpemFibGVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6YWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlc2l6YWJsZVBsdWdpbkNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemFibGVQbHVnaW5Db25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdGl0bGVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRpdGxlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y2xzOiBbJ25lby1kaWFsb2ctd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAge2NuOiBbXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZkb20uaWQgPSBtZS5nZXRXcmFwcGVySWQoKTtcblxuICAgICAgICBtZS5jcmVhdGVIZWFkZXIoKTtcblxuICAgICAgICBtZS5hbmltYXRlVGFyZ2V0SWQgJiYgbWUuYW5pbWF0ZVNob3coKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFuaW1hdGVUYXJnZXRJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QW5pbWF0ZVRhcmdldElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmF1dG9Nb3VudCAgPSAhdmFsdWU7XG4gICAgICAgIHRoaXMuYXV0b1JlbmRlciA9ICF2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVzaXphYmxlID0gbWUuZ2V0UGx1Z2luKHtmbGFnOiAncmVzaXphYmxlJ30pO1xuXG4gICAgICAgIGlmIChtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgbWUuZHJhZ1pvbmUuYXBwTmFtZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc2l6YWJsZSkge1xuICAgICAgICAgICAgcmVzaXphYmxlLmFwcE5hbWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZHJhZ2dhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RHJhZ2dhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IG1lLmRvbUxpc3RlbmVycyxcbiAgICAgICAgICAgIGNscztcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtZS5oZWFkZXJUb29sYmFyKSB7XG4gICAgICAgICAgICBjbHMgPSBtZS5oZWFkZXJUb29sYmFyLmNscztcbiAgICAgICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWRyYWdnYWJsZScpO1xuICAgICAgICAgICAgbWUuaGVhZGVyVG9vbGJhci5jbHMgPSBjbHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAmJiBpbXBvcnQoJy4uL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBEcmFnWm9uZSA9IG1vZHVsZS5kZWZhdWx0O1xuXG4gICAgICAgICAgICBpZiAoIW1lLmRyYWdMaXN0ZW5lcnNBZGRlZCkge1xuICAgICAgICAgICAgICAgIGRvbUxpc3RlbmVycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkRyYWdFbmQsICAgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8taGVhZGVyLXRvb2xiYXInfSxcbiAgICAgICAgICAgICAgICAgICAgeydkcmFnOnN0YXJ0JzogbWUub25EcmFnU3RhcnQsIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLWhlYWRlci10b29sYmFyJ31cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmRyYWdab25lQ29uZmlnPy5hbHdheXNGaXJlRHJhZ01vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTGlzdGVuZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB7J2RyYWc6bW92ZSc6IG1lLm9uRHJhZ01vdmUsIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLWhlYWRlci10b29sYmFyJ31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5kb21MaXN0ZW5lcnMgICAgICAgPSBkb21MaXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ0xpc3RlbmVyc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXhpbWl6ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhpbWl6ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyAgPSBtZS52ZG9tLmNsczsgLy8gdG9kbzogdXNpbmcgd3JhcHBlckNsc1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLW1heGltaXplZCcpO1xuICAgICAgICBtZS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5hbmltYXRlVGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVtb3ZlTm9kZScsXG4gICAgICAgICAgICAgICAgaWQgICAgOiBtZS5nZXRBbmltYXRlVGFyZ2V0SWQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVzaXphYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVzaXphYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiBpbXBvcnQoJy4uL3BsdWdpbi9SZXNpemFibGUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHBsdWdpbnMgPSBtZS5wbHVnaW5zIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmdldFBsdWdpbih7ZmxhZzogJ3Jlc2l6YWJsZSd9KSkge1xuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0aW9uQ2xzOiAnbmVvLWRpYWxvZycsXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgICAgICAgICA6ICdyZXNpemFibGUnLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5yZXNpemFibGVQbHVnaW5Db25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLnBsdWdpbnMgPSBwbHVnaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRpdGxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaXRsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyVG9vbGJhcikge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJUb29sYmFyLnRpdGxlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGFuaW1hdGVIaWRlKCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhcHBOYW1lID0gbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGlkICAgICAgPSBtZS5nZXRBbmltYXRlVGFyZ2V0SWQoKSxcbiAgICAgICAgICAgIHJlY3RzICAgPSBhd2FpdCBtZS5nZXREb21SZWN0KFttZS5pZCwgbWUuYW5pbWF0ZVRhcmdldElkXSk7XG5cbiAgICAgICAgYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIucHJvbWlzZU1lc3NhZ2UoJ21haW4nLCB7XG4gICAgICAgICAgICBhY3Rpb24gIDogJ21vdW50RG9tJyxcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICBodG1sICAgIDogYDxkaXYgaWQ9XCIke2lkfVwiIGNsYXNzPVwibmVvLWFuaW1hdGUtZGlhbG9nIG5lby1oaWRlXCIgc3R5bGU9XCJoZWlnaHQ6JHtyZWN0c1swXS5oZWlnaHR9cHg7bGVmdDoke3JlY3RzWzBdLmxlZnR9cHg7dG9wOiR7cmVjdHNbMF0udG9wfXB4O3dpZHRoOiR7cmVjdHNbMF0ud2lkdGh9cHg7XCI+PC9kaXY+YCxcbiAgICAgICAgICAgIHBhcmVudElkOiAnZG9jdW1lbnQuYm9keSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuY2xvc2VPckhpZGUoZmFsc2UpO1xuXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApO1xuXG4gICAgICAgIGF3YWl0IE5lby5jdXJyZW50V29ya2VyLnByb21pc2VNZXNzYWdlKCdtYWluJywge1xuICAgICAgICAgICAgYWN0aW9uOiAndXBkYXRlRG9tJyxcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICBkZWx0YXM6IFt7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtyZWN0c1sxXS5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICA6IGAke3JlY3RzWzFdLmxlZnQgIH1weGAsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgIDogYCR7cmVjdHNbMV0udG9wICAgfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBgJHtyZWN0c1sxXS53aWR0aCB9cHhgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgyNTApO1xuXG4gICAgICAgIGF3YWl0IE5lby5jdXJyZW50V29ya2VyLnByb21pc2VNZXNzYWdlKCdtYWluJywge1xuICAgICAgICAgICAgYWN0aW9uOiAndXBkYXRlRG9tJyxcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICBkZWx0YXM6IFt7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkfV1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBhbmltYXRlU2hvdygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhcHBOYW1lICAgICAgPSBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgaWQgICAgICAgICAgID0gbWUuZ2V0QW5pbWF0ZVRhcmdldElkKCksXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSBtZS53cmFwcGVyU3R5bGUsXG4gICAgICAgICAgICByZWN0ICAgICAgICAgPSBhd2FpdCBtZS5nZXREb21SZWN0KG1lLmFuaW1hdGVUYXJnZXRJZCk7XG5cbiAgICAgICAgYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIucHJvbWlzZU1lc3NhZ2UoJ21haW4nLCB7XG4gICAgICAgICAgICBhY3Rpb24gIDogJ21vdW50RG9tJyxcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICBodG1sICAgIDogYDxkaXYgaWQ9XCIke2lkfVwiIGNsYXNzPVwibmVvLWFuaW1hdGUtZGlhbG9nXCIgc3R5bGU9XCJoZWlnaHQ6JHtyZWN0LmhlaWdodH1weDtsZWZ0OiR7cmVjdC5sZWZ0fXB4O3RvcDoke3JlY3QudG9wfXB4O3dpZHRoOiR7cmVjdC53aWR0aH1weDtcIj48L2Rpdj5gLFxuICAgICAgICAgICAgcGFyZW50SWQ6ICdkb2N1bWVudC5ib2R5J1xuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTtcblxuICAgICAgICBhd2FpdCBOZW8uY3VycmVudFdvcmtlci5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3VwZGF0ZURvbScsXG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgZGVsdGFzOiBbe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAgIDogd3JhcHBlclN0eWxlPy5oZWlnaHQgICAgfHwgJzUwJScsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogd3JhcHBlclN0eWxlPy5sZWZ0ICAgICAgfHwgJzUwJScsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICAgIDogd3JhcHBlclN0eWxlPy50b3AgICAgICAgfHwgJzUwJScsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogd3JhcHBlclN0eWxlPy50cmFuc2Zvcm0gfHwgJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICAgIDogd3JhcHBlclN0eWxlPy53aWR0aCAgICAgfHwgJzUwJSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwMCk7XG5cbiAgICAgICAgbWUuc2hvdyhmYWxzZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjbG9zZUFjdGlvbiBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldENsb3NlQWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnY2xvc2VBY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWRdXG4gICAgICovXG4gICAgY2xvc2UoYW5pbWF0ZT0hIXRoaXMuYW5pbWF0ZVRhcmdldElkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGVIaWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5maXJlKCdjbG9zZScpO1xuICAgICAgICAgICAgbWUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FuaW1hdGU9ISF0aGlzLmFuaW1hdGVUYXJnZXRJZF1cbiAgICAgKi9cbiAgICBjbG9zZU9ySGlkZShhbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpc1t0aGlzLmNsb3NlQWN0aW9uXShhbmltYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUhlYWRlcigpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzICAgICA9IFsnbmVvLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ10sXG4gICAgICAgICAgICBoZWFkZXJzID0gbWUuaGVhZGVycyB8fCBbXTtcblxuICAgICAgICBtZS5kcmFnZ2FibGUgJiYgY2xzLnB1c2goJ25lby1kcmFnZ2FibGUnKTtcblxuICAgICAgICBtZS5oZWFkZXJUb29sYmFyID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFRvb2xiYXIsXG4gICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICBkb2NrICAgICA6ICd0b3AnLFxuICAgICAgICAgICAgZmxleCAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBpZCAgICAgICA6IG1lLmdldEhlYWRlclRvb2xiYXJJZCgpLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7aGVhZGVyQWN0aW9uOiBtZS5leGVjdXRlSGVhZGVyQWN0aW9uLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgdGl0bGUgICAgOiBtZS50aXRsZSxcbiAgICAgICAgICAgIC4uLm1lLmhlYWRlckNvbmZpZ1xuICAgICAgICB9KTtcblxuICAgICAgICBoZWFkZXJzLnVuc2hpZnQobWUuaGVhZGVyVG9vbGJhcik7XG5cbiAgICAgICAgbWUuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICoge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGV4ZWN1dGVIZWFkZXJBY3Rpb24oZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgIGNsb3NlICAgOiBtZS5jbG9zZU9ySGlkZSxcbiAgICAgICAgICAgIG1heGltaXplOiBtZS5tYXhpbWl6ZVxuICAgICAgICB9O1xuXG4gICAgICAgIG1hcFtkYXRhLmFjdGlvbl0/LmNhbGwobWUsIGRhdGEpO1xuXG4gICAgICAgIG1lLmZpcmUoJ2hlYWRlckFjdGlvbicsIHtcbiAgICAgICAgICAgIGRpYWxvZzogbWUsXG4gICAgICAgICAgICAuLi5kYXRhXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGFuaW1hdGlvbiBub2RlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBbmltYXRlVGFyZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJy1hbmltYXRlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgaGVhZGVyIHRvb2xiYXJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEhlYWRlclRvb2xiYXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyAnLWhlYWRlci10b29sYmFyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tXG4gICAgICovXG4gICAgZ2V0UHJveHlWZG9tKCkge1xuICAgICAgICBsZXQgdmRvbSA9IFZEb21VdGlsLmNsb25lKHRoaXMudmRvbSk7XG5cbiAgICAgICAgLy8gdGhpcyBjYWxsIGV4cGVjdHMgYSBmaXhlZCBkaWFsb2cgc3RydWN0dXJlXG4gICAgICAgIC8vIHRvZG86IGEgcGFuZWwgY29udGVudCBjb250YWluZXIgY291bGQgZ2V0IGEgZmxhZyB3aGljaCB3ZSBjYW4gcXVlcnkgZm9yIGluc3RlYWRcbiAgICAgICAgdmRvbS5jblswXS5jblsxXS5jbiA9IFtdO1xuXG4gICAgICAgIHJldHVybiB2ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdmRvbSByb290XG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2bm9kZSByb290XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBoZWFkZXIgdG9vbGJhclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0V3JhcHBlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCArICctd3JhcHBlcic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYW5pbWF0ZT0hIXRoaXMuYW5pbWF0ZVRhcmdldElkXVxuICAgICAqL1xuICAgIGhpZGUoYW5pbWF0ZT0hIXRoaXMuYW5pbWF0ZVRhcmdldElkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGVIaWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS51bm1vdW50KCk7XG4gICAgICAgICAgICBtZS5maXJlKCdoaWRlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICovXG4gICAgbWF4aW1pemUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGRhdGEuY29tcG9uZW50Lmljb25DbHMgPSBtZS5tYXhpbWl6ZWQgPyBtZS5tYXhpbWl6ZUNscyA6IG1lLm1pbmltaXplQ2xzO1xuXG4gICAgICAgIG1lLm1heGltaXplZCA9ICFtZS5tYXhpbWl6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5oZWFkZXJUb29sYmFyID0gbWUuZG93bih7XG4gICAgICAgICAgICBpZDogbWUuZ2V0SGVhZGVyVG9vbGJhcklkKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaW5pdGlhbFRyYW5zaXRpb25Qcm9wZXJ0eSwgd3JhcHBlclN0eWxlO1xuXG4gICAgICAgIGlmICghbWUubWF4aW1pemVkKSB7XG4gICAgICAgICAgICBtZS5nZXREb21SZWN0KG1lLmRyYWdab25lLmRyYWdQcm94eS5pZCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSBtZS53cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHdyYXBwZXJTdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgICA6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBgJHtyZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICAgIDogYCR7cmVjdC50b3B9cHhgLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5hbmltYXRlT25EcmFnRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxUcmFuc2l0aW9uUHJvcGVydHkgPSB3cmFwcGVyU3R5bGUudHJhbnNpdGlvblByb3BlcnR5IHx8IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdub25lJztcblxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IG1lLndyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IGluaXRpYWxUcmFuc2l0aW9uUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgICAgIG1lLmRyYWdab25lLmRyYWdFbmQoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGEgcmVzZXQsIG90aGVyd2lzZSB3ZSBkbyBub3QgZ2V0IGEgY2hhbmdlIGV2ZW50IGZvciB0aGUgbmV4dCBvbkRyYWdTdGFydCgpIGNhbGxcbiAgICAgICAgICAgICAgICBtZS5kcmFnWm9uZS5ib3VuZGFyeUNvbnRhaW5lcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBtZS5pc0RyYWdnaW5nICAgICAgICAgICAgICAgICAgID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgb25seSBnZXQgdHJpZ2dlcmVkIGluIGNhc2UgYWx3YXlzRmlyZURyYWdNb3ZlIGlzIGluY2x1ZGVkIGluc2lkZSB0aGUgZHJhZ1pvbmVDb25maWdcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ01vdmUoZGF0YSkge1xuICAgICAgICB0aGlzLmRyYWdab25lLmRyYWdNb3ZlKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IG1lLndyYXBwZXJTdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIHJlc2l6YWJsZVBsdWdpbjtcblxuICAgICAgICBpZiAoIW1lLm1heGltaXplZCkge1xuICAgICAgICAgICAgbWUuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHJlc2l6YWJsZVBsdWdpbiA9IG1lLmdldFBsdWdpbih7ZmxhZzogJ3Jlc2l6YWJsZSd9KTtcblxuICAgICAgICAgICAgaWYgKHJlc2l6YWJsZVBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJlc2l6YWJsZVBsdWdpbi5yZW1vdmVBbGxOb2RlcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1lLmRyYWdab25lKSB7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogRHJhZ1pvbmUsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGJvZHlDdXJzb3JTdHlsZSAgICA6ICdtb3ZlICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5ib3VuZGFyeUNvbnRhaW5lcklkLFxuICAgICAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCAgICAgICAgOiBtZS52ZG9tLFxuICAgICAgICAgICAgICAgICAgICBkcmFnUHJveHlDb25maWcgICAgOiB7dmRvbTogbWUuZ2V0UHJveHlWZG9tKCl9LFxuICAgICAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlUHJveHlXcmFwcGVyICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmRyYWdab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdkcmFnWm9uZUNyZWF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdab25lOiBtZS5kcmFnWm9uZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmRyYWdab25lLmJvdW5kYXJ5Q29udGFpbmVySWQgPSBtZS5ib3VuZGFyeUNvbnRhaW5lcklkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5kcmFnWm9uZS5kcmFnU3RhcnQoZGF0YSk7XG5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5vcGFjaXR5ID0gMC43O1xuXG4gICAgICAgICAgICBtZS53cmFwcGVyU3R5bGUgPSB3cmFwcGVyU3R5bGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWRdXG4gICAgICovXG4gICAgc2hvdyhhbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgICAgbWUuYW5pbWF0ZVNob3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlbmRlcih0cnVlKTtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3Nob3cnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQmFzZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi90b29sYmFyL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRpYWxvZy5oZWFkZXIuVG9vbGJhclxuICogQGV4dGVuZHMgTmVvLnRvb2xiYXIuQmFzZVxuICovXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGlhbG9nLmhlYWRlci5Ub29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGlhbG9nLmhlYWRlci5Ub29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0aXRsZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGFjdGlvbk1hcFxuICAgICAqL1xuICAgIGFjdGlvbk1hcCA9IHtcbiAgICAgICAgY2xvc2UgICA6ICgpID0+ICh7YWN0aW9uOiAnY2xvc2UnLCAgICBpY29uQ2xzOiAnZmFyIGZhLXdpbmRvdy1jbG9zZSd9KSxcbiAgICAgICAgbWF4aW1pemU6ICgpID0+ICh7YWN0aW9uOiAnbWF4aW1pemUnLCBpY29uQ2xzOiAnZmFyIGZhLXdpbmRvdy1tYXhpbWl6ZSd9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGRlZmluZSB0aGUgYWN0aW9uIG9yZGVyIGFuZCBkaXJlY3RseSBhZGQgY3VzdG9tIGFjdGlvbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB7XG4gICAgICogICAgIGFjdGlvbnM6IFtcbiAgICAgKiAgICAgICAgICdjbG9zZScsXG4gICAgICogICAgICAgICAnbWF4aW1pemUnLFxuICAgICAqICAgICAgICAge2FjdGlvbjogJ2hlbHAnLCBpY29uQ2xzOiAnZmFyIGZhLWNpcmNsZS1xdWVzdGlvbid9XG4gICAgICogICAgIF1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gZXh0ZW5kIHRoZSBhY3Rpb25NYXAgaWYgbmVlZGVkLlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfFN0cmluZ1tdfG51bGx9IGFjdGlvbnM9WydtYXhpbWl6ZScsJ2Nsb3NlJ11cbiAgICAgKi9cbiAgICBhY3Rpb25zID0gWydtYXhpbWl6ZScsICdjbG9zZSddXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRpdGxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRpdGxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRvd24oe2ZsYWc6ICd0aXRsZS1sYWJlbCd9KT8uc2V0KHtcbiAgICAgICAgICAgIGhpZGRlbjogIXZhbHVlLFxuICAgICAgICAgICAgdGV4dCAgOiB2YWx1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBtZS5maXJlQWN0aW9uLmJpbmQobWUpLFxuICAgICAgICAgICAgaXRlbXMgICA9IG1lLml0ZW1zIHx8IFtdO1xuXG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgbnR5cGUgOiAnbGFiZWwnLFxuICAgICAgICAgICAgY2xzICAgOiBbJ25lby1wYW5lbC1oZWFkZXItdGV4dCcsICduZW8tbGFiZWwnXSxcbiAgICAgICAgICAgIGZsYWcgIDogJ3RpdGxlLWxhYmVsJyxcbiAgICAgICAgICAgIGhpZGRlbjogIW1lLnRpdGxlLFxuICAgICAgICAgICAgdGV4dCAgOiBtZS50aXRsZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWUuYWN0aW9ucykge1xuICAgICAgICAgICAgaXRlbXMucHVzaCgnLT4nKTtcblxuICAgICAgICAgICAgbWUuYWN0aW9ucy5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoYWN0aW9uKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gbWUuYWN0aW9uTWFwW2FjdGlvbl0oKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe2hhbmRsZXIsIC4uLmFjdGlvbn0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXRlbXMgPSBpdGVtcztcblxuICAgICAgICBzdXBlci5jcmVhdGVJdGVtcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZmlyZUFjdGlvbihkYXRhKSB7XG4gICAgICAgIGxldCBjb21wb25lbnQgPSBkYXRhLmNvbXBvbmVudDtcblxuICAgICAgICB0aGlzLmZpcmUoJ2hlYWRlckFjdGlvbicsIHtcbiAgICAgICAgICAgIGFjdGlvbjogY29tcG9uZW50LmFjdGlvbixcbiAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIHNjb3BlIDogdGhpc1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoVG9vbGJhcik7XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2xiYXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=