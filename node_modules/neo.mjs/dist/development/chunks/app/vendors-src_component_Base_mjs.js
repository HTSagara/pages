"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_Base_mjs"],{

/***/ "./src/component/Base.mjs":
/*!********************************!*\
  !*** ./src/component/Base.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/KeyNavigation.mjs */ "./src/util/KeyNavigation.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_Style_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Style.mjs */ "./src/util/Style.mjs");
/* harmony import */ var _core_Util_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/Util.mjs */ "./src/core/Util.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");














const
    addUnits          = value => value == null ? value : isNaN(value) ? value : `${value}px`,
    closestController = Symbol.for('closestController'),
    closestModel      = Symbol.for('closestModel'),
    lengthRE          = /^\d+\w+$/;

/**
 * @class Neo.component.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for hideMode
     * @member {String[]} hideModes=['removeDom','visibility']
     * @protected
     * @static
     */
    static hideModes = ['removeDom', 'visibility']
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.component.Base'
         * @protected
         */
        className: 'Neo.component.Base',
        /**
         * @member {String} ntype='component'
         * @protected
         */
        ntype: 'component',
        /**
         * The default alignment specification to position this Component relative to some other
         * Component, or Element or Rectangle. Only applies in case floating = true.
         * @member {Object|String} align_={edgeAlign:'t-b',constrainTo:'document.body'}
         */
        align_: {
            edgeAlign  : 't-b',
            constrainTo: 'document.body'
        },
        /**
         * The name of the App this component belongs to
         * @member {String|null} appName_=null
         */
        appName_: null,
        /**
         * True automatically mounts a component after being rendered.
         * Use this for the top level component of your app.
         * @member {Boolean} autoMount=false
         * @tutorial 02_ClassSystem
         */
        autoMount: false,
        /**
         * True automatically renders a component after being created inside the init call.
         * Use this for the top level component of your app.
         * @member {Boolean} autoRender=false
         * @see {@link Neo.component.Base#init init}
         * @tutorial 02_ClassSystem
         */
        autoRender: false,
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=[]
         */
        baseCls: [],
        /**
         * Bind configs to model.Component data properties.
         * Example for a button.Base:
         * @example
         * bind: {
         *     iconCls: data => `fa fa-{$data.icon}`,
         *     text   : data => data.foo.bar
         * }
         * @see https://github.com/neomjs/neo/blob/dev/examples/model
         * @member {Object|null} bind=null
         */
        bind: null,
        /**
         * Custom CSS selectors to apply to the root level node of this component
         * You can override baseCls to remove default selectors.
         * @member {String[]} cls_=null
         */
        cls_: null,
        /**
         * manager.Focus will change this flag on focusin & out dom events
         * @member {Boolean} containsFocus_=false
         * @protected
         */
        containsFocus_: false,
        /**
         * Assign a component controller to this component (pass an imported module or the string based class name)
         * @member {Neo.controller.Component|String} controller_=null
         */
        controller_: null,
        /**
         * Convenience shortcut to access the data config of the closest model.Component.
         * Read only.
         * @member {Object} data_=null
         * @protected
         */
        data_: null,
        /**
         * Disabled components will get the neo-disabled cls applied and won't receive DOM events
         * @member {Boolean} disabled_=false
         */
        disabled_: false,
        /**
         * An array of domListener configs
         * @member {Object[]|null} domListeners_=null
         * @example
         * afterSetStayOnHover(value, oldValue) {
         *     if (value) {
         *         let me = this;
         *
         *         me.addDomListeners(
         *             {mouseenter: me.onMouseEnter, scope: me},
         *             {mouseleave: me.onMouseLeave, scope: me}
         *         )
         *    }
         *}
         */
        domListeners_: null,
        /**
         * Set this config to true to dynamically import a DropZone module & create an instance
         * @member {Boolean} droppable_=false
         */
        droppable_: false,
        /**
         * @member {Neo.draggable.DropZone|null} dropZone=null
         */
        dropZone: null,
        /**
         * @member {Object} dropZoneConfig=null
         */
        dropZoneConfig: null,
        /**
         * True to render this component into the viewport outside of the document flow
         * @member {Boolean} floating
         */
        floating: false,
        /**
         * Internal flag which will get set to true on mount
         * @member {Boolean} hasBeenMounted=false
         * @protected
         */
        hasBeenMounted: false,
        /**
         * Internal flag
         * @member {Boolean} hasRenderingListener=false
         * @protected
         */
        hasRenderingListener: false,
        /**
         * Internal flag for vdom changes after a component got unmounted
         * (delta updates can no longer get applied & a new render call is required before re-mounting)
         * @member {Boolean} hasUnmountedVdomChanges_=false
         * @protected
         */
        hasUnmountedVdomChanges_: false,
        /**
         * Shortcut for style.height, defaults to px
         * @member {Number|String|null} height_=null
         */
        height_: null,
        /**
         * Initial setting to hide or show the component and
         * you can use either hide()/show() or change this config directly to change the hidden state
         * @member {Boolean} hidden_=false
         */
        hidden_: false,
        /**
         * Used for hide and show and defines if the component
         * should use css visibility:'hidden' or vdom:removeDom
         * @member {String} hideMode_='removeDom'
         */
        hideMode_: 'removeDom',
        /**
         * The top level innerHTML of the component
         * @member {String|null} html_=null
         */
        html_: null,
        /**
         * Set to `true` to show a spinner centered in the component.
         * Set to a string to show a message next to a spinner centered in the component.
         * @member {Boolean|String} isLoading=false
         */
        isLoading_: false,
        /**
         * Internal flag which will get set to true while an update request (worker messages) is in progress
         * @member {Boolean} isVdomUpdating=false
         * @protected
         */
        isVdomUpdating: false,
        /**
         * Using the keys config will create an instance of Neo.util.KeyNavigation.
         * @see {@link Neo.util.KeyNavigation KeyNavigation}
         * @member {Object} keys_=null
         */
        keys_: null,
        /**
         * Gets used inside afterSetIsLoading() to define the CSS for the loading spinner icon
         * @member {String[]} loadingSpinnerCls_=['fa','fa-spinner','fa-spin']
         */
        loadingSpinnerCls_: ['fa', 'fa-spinner', 'fa-spin'],
        /**
         * Shortcut for style.maxHeight, defaults to px
         * @member {Number|String|null} maxHeight_=null
         */
        maxHeight_: null,
        /**
         * Shortcut for style.maxWidth, defaults to px
         * @member {Number|String|null} maxWidth_=null
         */
        maxWidth_: null,
        /**
         * Shortcut for style.minHeight, defaults to px
         * @member {Number|String|null} minHeight_=null
         */
        minHeight_: null,
        /**
         * Shortcut for style.minWidth, defaults to px
         * @member {Number|String|null} minWidth_=null
         */
        minWidth_: null,
        /**
         * Optionally add a model.Component
         * @member {Object|null} model_=null
         */
        model_: null,
        /**
         * Override specific model data properties.
         * This will merge the content.
         * @member {Object|null} model_=null
         */
        modelData: null,
        /**
         * True in case the component is mounted to the DOM
         * @member {Boolean} mounted_=false
         * @protected
         */
        mounted_: false,
        /**
         * Internal flag which will get set to true in case an update call arrives while another update is running
         * @member {Boolean} needsVdomUpdate_=false
         * @protected
         */
        needsVdomUpdate_: false,
        /**
         * If the parentId does not match a neo component id, you can manually set this value for finding
         * view controllers or models.
         * Use case: manually dropping components into a vdom structure
         * @member {Neo.component.Base|null} parentComponent_=null
         * @protected
         */
        parentComponent_: null,
        /**
         * The parent component id or document.body
         * @member {String} parentId='document.body'
         */
        parentId: 'document.body',
        /**
         * Array of Plugin Modules and / or config objects
         * @member {Array|null} plugins_=null
         * @protected
         */
        plugins_: null,
        /**
         * Set a reference for accessing the component inside view controllers.
         * References will also get mapped into the vdom root (data-ref: value).
         * @member {String|null} reference_=null
         * @protected
         */
        reference_: null,
        /**
         * Make the view Responsive by adding alternative configs.
         * The definition happens via responsiveCfg
         * @member {Object} responsive=null
         * @protected
         */
        responsive_: null,
        /**
         * True in case the component is rendering the vnode
         * @member {Boolean} rendering_=false
         * @protected
         */
        rendering_: false,
        /**
         * Specify a role tag attribute for the vdom root.
         * See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles
         * @member {String|null} role_=null
         */
        role_: null,
        /**
         * Set this to true for style 'overflow:auto'.
         * Set this to 'x' or 'y' to add style 'overflow-x' or 'overflow-y' to 'auto'
         * Other than false this will add cls 'neo-scrollable'.
         * @member {Boolean|"x"|"y"} scrollable_=false
         */
        scrollable_: false,
        /**
         * Set this to true for bulk updates. Ensure to set it back to false afterwards.
         * Internally the value will get saved as a number to ensure that child methods won't stop the silent mode too early.
         * @member {Boolean} silentVdomUpdate_=false
         */
        silentVdomUpdate_: false,
        /**
         * Style attributes added to this vdom root. see: getVdomRoot()
         * @member {Object} style_=null
         */
        style_: null,
        /**
         * You can pass an used theme directly to any component,
         * to style specific component trees differently from your main view.
         * @member {String|null} theme_=null
         */
        theme_: null,
        /**
         * Add tooltip config object or a string containing the display text
         * See tooltip/Base.mjs
         *
         * By default, a single, shared Tooltip instance is used for all widgets which request
         * a tooltip. It reconfigures itself from the widget's definition just before showing.
         *
         * If a widget needs its own instance for any reason, inslude the property `ownInstance : true`
         * in the tooltip config object.
         * @member {Object|String} tooltip_=null
         */
        tooltip_: null,
        /**
         * Add 'primary' and other attributes to make it an outstanding design
         * @member {String|null} ui_=null
         */
        ui_: null,
        /**
         * The component vnode tree. Available after the component got rendered.
         * @member {Object} vnode_=null
         * @protected
         */
        vnode_: null,
        /**
         * Shortcut for style.width, defaults to px
         * @member {Number|String|null} width_=null
         */
        width_: null,
        /**
         * The custom windowIs (timestamp) this component belongs to
         * @member {Number|null} windowId_=null
         */
        windowId_: null,
        /**
         * @member {String[]|null} wrapperCls_=null
         */
        wrapperCls_: null,
        /**
         * Top level style attributes. Useful in case getVdomRoot() does not point to the top level DOM node.
         * @member {Object|null} wrapperStyle_=null
         */
        wrapperStyle_: null,
        /**
         * The vdom markup for this component.
         * @member {Object} _vdom={}
         */
        _vdom: {}
    }

    /**
     * @member {String[]} childUpdateCache=[]
     */
    childUpdateCache = []
    /**
     * @member {Function[]} resolveUpdateCache=[]
     */
    resolveUpdateCache = []

    /**
     * Convenience shortcut to access the App this component belongs to
     * @returns {Neo.controller.Application|null}
     */
    get app() {
        return Neo.apps[this.appName] || null
    }

    /**
     * Returns true if this Component is fully visible, that is it is not hidden and has no hidden ancestors
     */
    get isVisible() {
        return this.mounted && !this.hidden && (!this.parent || this.parent.isVisible);
    }

    /**
     * Apply component based listeners
     * @member {Object} listeners={}
     */
    get listeners() {
        return this._listeners || {}
    }
    set listeners(value) {
        this._listeners = value
    }

    /**
     * Convenience method to access the parent component
     * @returns {Neo.component.Base|null}
     */
    get parent() {
        let me = this;

        return me.parentComponent || me.parentId === 'document.body' ? null : Neo.getComponent(me.parentId)
    }

    /**
     * True after the component render() method was called. Also fires the rendered event.
     * @member {Boolean} rendered=false
     * @protected
     */
    get rendered() {
        return this._rendered || false
    }
    set rendered(value) {
        let me = this;

        me._rendered = value;

        if (value === true) {
            me.fire('rendered', me.id)
        }
    }

    /**
     * The setter will handle vdom updates automatically
     * @member {Object} vdom=this._vdom
     */
    get vdom() {
        return this._vdom
    }
    set vdom(value) {
        this.afterSetVdom(value, value)
    }

    /**
     * Add a new cls to the vdomRoot
     * @param {String} value
     */
    addCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);
        this.cls = cls
    }

    /**
     * Convenience shortcut to add additional dom listeners
     * @param {Object|Object[]} value
     */
    addDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let domListeners = this.domListeners;

        domListeners.push(...value);

        this.domListeners = domListeners
    }

    /**
     * Either a string like 'color: red; background-color: blue;'
     * or an object containing style attributes
     * @param {String|Object} value
     * @returns {Object} all styles of this.el
     */
    addStyle(value) {
        if (typeof value === 'string') {
            value = _core_Util_mjs__WEBPACK_IMPORTED_MODULE_10__["default"].createStyleObject(value);
        }

        // todo: add a check if something has changed

        return this.style = Object.assign(this.style, value)
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.windowId, this.__proto__)
    }

    /**
     * Triggered after the cls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetCls(value, oldValue) {
        oldValue = oldValue || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls;

        if (vdom !== vdomRoot) {
            // we are using a wrapper node
            vdomRoot.cls = [...value]
        } else {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(me.wrapperCls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldValue, value));
            vdom.cls = cls
        }

        if (me.isVdomUpdating || me.silentVdomUpdate) {
            me.needsVdomUpdate = true
        } else if (me.mounted && me.vnode) {
            me.updateCls(value, oldValue, vdomRoot.id)
        }
    }

    /**
     * Triggered after any config got changed
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     * @protected
     */
    afterSetConfig(key, value, oldValue) {
        if (Neo.currentWorker.isUsingViewModels && oldValue !== undefined) {
            let binding = this.bind?.[key];

            if (binding?.twoWay) {
                this.getModel()?.setData(key, value)
            }
        }
    }

    /**
     * Triggered after the disabled config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisabled(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"][value ? 'add' : 'remove'](cls, 'neo-disabled');
        this.cls = cls
    }

    /**
     * Registers the domListeners inside the Neo.manager.DomEvent
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetDomListeners(value, oldValue) {
        let me = this;

        if (value?.[0] || oldValue?.[0]) {
            me.getController()?.parseDomListeners(me);

            _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].updateDomListeners(me, value, oldValue)
        }
    }

    /**
     * Triggered after the droppable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDroppable(value, oldValue) {
        let me = this;

        if (value && !me.dropZone) {
            __webpack_require__.e(/*! import() */ "src_draggable_DropZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DropZone.mjs */ "./src/draggable/DropZone.mjs")).then(module => {
                me.dropZone = Neo.create({
                    module : module.default,
                    appName: me.appName,
                    owner  : me,
                    ...me.dropZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the flex config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetFlex(value, oldValue) {
        if (!isNaN(value)) {
            value = `${value} ${value} 0%`
        }

        this.configuredFlex = value;
        this.changeVdomRootKey('flex', value)
    }

    /**
     * Triggered after the hasUnmountedVdomChanges config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHasUnmountedVdomChanges(value, oldValue) {
        if (value || (!value && oldValue)) {
            let parentIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParentIds(this),
                i         = 0,
                len       = parentIds.length,
                parent;

            for (; i < len; i++) {
                parent = Neo.getComponent(parentIds[i]);

                if (parent) {
                    parent._hasUnmountedVdomChanges = value // silent update
                }
            }
        }
    }

    /**
     * Triggered after the height config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetHeight(value, oldValue) {
        this.configuredHeight = addUnits(value);
        this.changeVdomRootKey('height', value)
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let me    = this,
            state = value ? 'hide' : 'show';

        if (value && oldValue === undefined && me.hideMode === 'removeDom') {
            me.vdom.removeDom = true
        } else if (value || oldValue !== undefined) {
            me[state]()
        }

        if (!value) {
            me.revertFocus();
        }

        me.fire(state, {id: me.id});
        me.fire('hiddenChange', {id: me.id, oldValue, value})
    }

    /**
     * Triggered after the html config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetHtml(value, oldValue) {
        this.changeVdomRootKey('html', value)
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);
        this.changeVdomRootKey('id', value);

        oldValue && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unregister(oldValue);
        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].register(this)
    }

    /**
     * Triggered after the isLoading config got changed
     * @param {Boolean|String} value
     * @param {Boolean|String} oldValue
     * @protected
     */
    afterSetIsLoading(value, oldValue) {
        if (!(value === false && oldValue === undefined)) {
            let me          = this,
                {cls, vdom} = me,
                maskIndex;

            if (oldValue !== undefined && vdom.cn) {
                maskIndex = vdom.cn.findIndex(c => c.cls.includes('neo-load-mask'));

                // Remove the load mask
                if (maskIndex !== -1) {
                    vdom.cn.splice(maskIndex, 1)
                }
            }

            if (value) {
                vdom.cn.push(me.loadMask = {
                    cls: ['neo-load-mask'],
                    cn : [{
                        cls: ['neo-load-mask-body'],
                        cn : [{
                            cls: me.loadingSpinnerCls
                        }, {
                            cls      : ['neo-loading-message'],
                            html     : value,
                            removeDom: !Neo.isString(value)
                        }]
                    }]
                })
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].toggle(cls, 'neo-masked', value);
            me.set({cls, vdom})
        }
    }

    /**
     * Triggered after the maxHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxHeight(value, oldValue) {
        this.configuredMaxHeight = addUnits(value);
        this.changeVdomRootKey('maxHeight', value)
    }

    /**
     * Triggered after the maxWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxWidth(value, oldValue) {
        this.configuredMaxWidth = addUnits(value);
        this.changeVdomRootKey('maxWidth', value)
    }

    /**
     * Triggered after the minHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinHeight(value, oldValue) {
        this.configuredMinHeight = addUnits(value);
        this.changeVdomRootKey('minHeight', value)
    }

    /**
     * Triggered after the minWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinWidth(value, oldValue) {
        this.configuredMinWidth = addUnits(value);
        this.changeVdomRootKey('minWidth', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            let me             = this,
                {id, windowId} = me;

            if (value) {
                me.hasBeenMounted = true;

                if (me.domListeners?.length > 0) {
                    // todo: the main thread reply of mount arrives after pushing the task into the queue which does not ensure the dom is mounted
                    setTimeout(() => {
                        _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].mountDomListeners(me)
                    }, 150)
                }

                me.doResolveUpdateCache();

                if (me.floating) {
                    me.alignTo();

                    // Focus will be pushed into the first input field or other focusable item
                    Neo.main.DomAccess.focus({id, children: true, windowId})
                }

                me.fire('mounted', me.id)
            } else {
                me.revertFocus()
            }
        }
    }

    /**
     * Triggered after the reference config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetReference(value, oldValue) {
        value && this.changeVdomRootKey('data-ref', value)
    }

    /**
     * Triggered after the responsive config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    async afterSetResponsive(value, oldValue) {
        if (value && !this.getPlugin('responsive')) {
            let me      = this,
                module  = await __webpack_require__.e(/*! import() */ "src_plugin_Responsive_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../../src/plugin/Responsive.mjs */ "./src/plugin/Responsive.mjs")),
                plugins = me.plugins || [];

            plugins.push({
                module : module.default,
                appName: me.appName,
                value
            });

            me.plugins = plugins
        }
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.changeVdomRootKey('role', value)
    }

    /**
     * Triggered after the scrollable config got changed
     * @param {String|Boolean} value
     * @param {String|Boolean|null} oldValue
     * @protected
     */
    afterSetScrollable(value, oldValue) {
        if (oldValue === undefined && !value) {
            return
        }

        let me = this;

        if (oldValue) {
            let oldOverflowKey = 'overflow';

            if (!Neo.isBoolean(oldValue)) {
                oldOverflowKey += Neo.capitalize(oldValue)
            }

            me.removeStyle([oldOverflowKey])
        }

        if (!Neo.isEmpty(value)) {
            let overflowKey = 'overflow';

            if (value && !Neo.isBoolean(value)) {
                overflowKey += Neo.capitalize(value)
            }

            if (value) {
                me.addStyle(overflowKey + ':auto');
                me.addCls('neo-scrollable')
            } else {
                me.removeCls('neo-scrollable')
            }
        }
    }

    /**
     * Triggered after the style config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle(value, oldValue)
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        if (value || oldValue !== undefined) {
            let cls = this.cls;

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, oldValue);
            value && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);

            this.cls = cls
        }
    }

    /**
     * Triggered after the tooltip config got changed
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @protected
     */
    afterSetTooltip(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            if (Neo.ns('Neo.tooltip.Base')) {
                this.createTooltip(value);
            } else {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_container_Base_mjs"), __webpack_require__.e("vendors-src_tooltip_Base_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../tooltip/Base.mjs */ "./src/tooltip/Base.mjs")).then(() => {
                    this.createTooltip(value);
                });
            }
        }
    }

    /**
     * For styling purposes only.
     * To define button styles or component styles,
     * this will add a css class: neo-ntype-value
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetUi(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, `neo-${me.ntype}-${oldValue}`);

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, `neo-${me.ntype}-${value}`)
        }

        me.cls = cls
    }

    /**
     * Triggered after the vdom pseudo-config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVdom(value, oldValue) {
        this.updateVdom(value)
    }

    /**
     * Triggered after the vnode config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVnode(value, oldValue) {
        oldValue !== undefined && this.syncVnodeTree()
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        this.configuredWidth = addUnits(value);
        this.changeVdomRootKey('width', value)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        let controller = this.controller;

        if (controller && value) {
            controller.windowId = value
        }

        // If a component gets moved into a different window, an update cycle might still be running.
        // Since the update might no longer get mapped, we want to re-enable this instance for future updates.
        if (oldValue) {
            this.isVdomUpdating = false
        }
    }

    /**
     * Triggered after the wrapperCls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetWrapperCls(value, oldValue) {
        oldValue = oldValue || [];
        value    = value    || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls      = me.vdom?.cls || [];

        if (vdom === vdomRoot) {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(cls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldValue, value));
            vdom.cls = cls
        } else {
            // we are not using a wrapper => cls & wrapperCls share the same node
            value = value ? value : [];

            oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, oldValue);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);

            if (vdom) {
                vdom.cls = cls
            }
        }

        if (me.isVdomUpdating || me.silentVdomUpdate) {
            me.needsVdomUpdate = true
        } else if (me.mounted) {
            me.updateCls(value, oldValue)
        }
    }

    /**
     * Triggered after the wrapperStyle config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetWrapperStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            let me   = this,
                vdom = me.vdom;

            if (!vdom.id) {
                vdom.style = value;
                me.update()
            } else {
                me.updateStyle(value, oldValue, vdom.id)
            }
        }
    }

    /**
     * Aligns the top level node inside the main thread
     * @param {Object} spec={}
     * @returns {Promise<void>}
     */
    async alignTo(spec={}) {
        const
            me    = this,
            align = {
                ...me.align,
                ...spec,
                id                 : me.id,
                configuredFlex     : me.configuredFlex,
                configuredWidth    : me.configuredWidth,
                configuredHeight   : me.configuredHeight,
                configuredMinWidth : me.configuredMinWidth,
                configuredMinHeight: me.configuredMinHeight,
                configuredMaxWidth : me.configuredMaxWidth,
                configuredMaxHeight: me.configuredMaxHeight
            };

        if (align.target) {
            await Neo.main.DomAccess.align(align)
        }
    }

    /**
     * Triggered when accessing the cls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the data config
     * Convenience shortcut which is expensive to use,
     * since it will generate a merged parent model data map.
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getModel().getHierarchyData()
    }

    /**
     * Triggered when accessing the style config
     * @param {Object} value
     * @protected
     */
    beforeGetStyle(value) {
        return {...value}
    }

    /**
     * Triggered when accessing the wrapperCls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetWrapperCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the wrapperStyle config
     * @param {Object} value
     * @protected
     */
    beforeGetWrapperStyle(value) {
        return {...Object.assign(this.vdom.style || {}, value)}
    }

    /**
     * Triggered before the align config gets changed.
     * @param {Object|String} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        let me = this;

        // Just a simple 't-b'
        if (typeof value === 'string') {
            value = {
                edgeAlign: value
            }
        }

        // merge the incoming alignment specification into the configured default
        return Neo.merge({}, value, me.constructor.config.align)
    }

    /**
     * Triggered before the cls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(value || [], this.baseCls, this.getBaseClass());
    }

    /**
     * Triggered before the controller config gets changed.
     * Creates a controller.Component instance if needed.
     * @param {Neo.controller.Component|Object} value
     * @param {Neo.controller.Component|null} oldValue
     * @returns {Neo.controller.Component}
     * @protected
     */
    beforeSetController(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, null, {
                component: this,
                windowId : this.windowId
            })
        }

        return value
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Triggered before the hideMode config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetHideMode(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'hideMode')
    }

    /**
     * Triggered before the keys config gets changed.
     * Creates a KeyNavigation instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.util.KeyNavigation|null}
     * @protected
     */
    beforeSetKeys(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], {
                keyDownEventBubble: true,
                keys              : value
            })
        }

        return value
    }

    /**
     * Triggered before the model config gets changed.
     * Creates a model.Component instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.model.Component}
     * @protected
     */
    beforeSetModel(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me            = this,
                defaultValues = {component: me};

            if (me.modelData) {
                defaultValues.data = me.modelData
            }

            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, 'Neo.model.Component', defaultValues)
        }

        return null
    }

    /**
     * Triggered before the plugins config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @returns {Neo.plugin.Base[]}
     * @protected
     */
    beforeSetPlugins(value, oldValue) {
        if (Array.isArray(value)) {
            value.forEach((item, index) => {
                value[index] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(item, null, {
                    owner: this
                })
            })
        }

        return value
    }

    /**
     * Triggered before the silentVdomUpdate config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetSilentVdomUpdate(value, oldValue) {
        if (value === true) {
            return Neo.isNumber(oldValue) ? (oldValue + 1) : 1
        }

        return (Neo.isNumber(oldValue) && oldValue > 0) ? (oldValue - 1) : 0
    }

    /**
     * Changes the value of a vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     */
    changeVdomRootKey(key, value) {
        let me   = this,
            root = me.getVdomRoot();

        if (value) {
            root[key] = value
        } else {
            delete root[key]
        }

        me.update()
    }

    /**
     * Creates the tooltip instances
     * @param {Object|String} value
     * @protected
     */
    createTooltip(value) {
        if (typeof value === 'string') {
            value = {
                text: value
            };
        }

        let me = this;

        if (value.ownInstance) {
            me._tooltip = Neo.create('Neo.tooltip.Base', {
                ...value,
                appName    : me.appName,
                componentId: me.id,
                windowId   : me.windowId
            })
        } else {
            me._tooltip = value;
            Neo.tooltip.Base.createSingleton(me.app);
            me.addCls('neo-uses-shared-tooltip');
            me.update()
        }
    }

    /**
     * Unregister this instance from the ComponentManager
     * @param {Boolean} updateParentVdom=false true to remove the component from the parent vdom => real dom
     * @param {Boolean} silent=false true to update the vdom silently (useful for destroying multiple child items in a row)
     * todo: unregister events
     */
    destroy(updateParentVdom=false, silent=false) {
        let me                 = this,
            {parent, parentId} = me,
            parentModel        = parent?.getModel(),
            parentVdom;

        me.revertFocus();

        me.domListeners = [];

        me.controller = null; // triggers destroy()

        me.reference && me.getController()?.removeReference(me); // remove own reference from parent controllers

        me.model = null; // triggers destroy()

        me.bind && parentModel?.removeBindings(me.id);

        me.plugins?.forEach(plugin => {
            plugin.destroy()
        });

        if (updateParentVdom && parentId) {
            if (parentId === 'document.body') {
                Neo.applyDeltas(me.appName, {action: 'removeNode', id: me.vdom.id})
            } else {
                parentVdom = parent.vdom;

                _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].removeVdomChild(parentVdom, me.vdom.id);
                parent[silent ? '_vdom' : 'vdom'] = parentVdom
            }
        }

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unregister(me);

        super.destroy();

        // We do want to prevent delayed calls after a component instance got destroyed.
        me.onFocusLeave = Neo.emptyFn;
        me.unmount      = Neo.emptyFn
    }

    /**
     * Triggers all stored resolve() callbacks
     */
    doResolveUpdateCache() {
        let me = this;

        if (me.resolveUpdateCache) {
            me.resolveUpdateCache.forEach(item => item());
            me.resolveUpdateCache = []
        }
    }

    /**
     * Convenience shortcut for Neo.manager.Component.down
     * @param {Object|String} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    down(config, returnFirstMatch=true) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].down(this, config, returnFirstMatch)
    }

    /**
     * Internal method to send update requests to the vdom worker
     * @param {Object} vdom
     * @param {Neo.vdom.VNode} vnode
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @private
     */
    #executeVdomUpdate(vdom, vnode, resolve, reject) {
        let me   = this,
            opts = {vdom, vnode},
            deltas;

        if (Neo.currentWorker.isSharedWorker) {
            opts.appName  = me.appName;
            opts.windowId = me.windowId
        }

        me.isVdomUpdating = true;

        // we can not set the config directly => it could already be false,
        // and we still want to pass it further into subtrees
        me._needsVdomUpdate = false;
        me.afterSetNeedsVdomUpdate?.(false, true)

        Neo.vdom.Helper.update(opts).catch(err => {
            me.isVdomUpdating = false;
            console.log('Error attempting to update component dom', err, me);

            reject?.()
        }).then(data => {
            me.isVdomUpdating = false;
            // checking if the component got destroyed before the update cycle is done
            if (me.id) {
                // console.log('Component vnode updated', data);
                me.vnode = data.vnode;

                deltas = data.deltas;

                if (!Neo.config.useVdomWorker && deltas.length > 0) {
                    Neo.applyDeltas(me.appName, deltas).then(() => {
                        me.resolveVdomUpdate(resolve)
                    })
                } else {
                    me.resolveVdomUpdate(resolve)
                }
            }
        })
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} id=this.id
     */
    focus(id=this.id) {
        Neo.main.DomAccess.focus({id, windowId: this.windowId})
    }

    /**
     * Override this method to add dynamic values into this.cls
     * @returns {String[]}
     */
    getBaseClass() {
        const result = [];

        if (this.floating) {
            result.push('neo-floating')
        }

        return result
    }

    /**
     * Find an instance stored inside a config via optionally passing a ntype.
     * Returns this[configName] or the closest parent component with a match.
     * Used by getController() & getModel()
     * @param {String} configName
     * @param {String} [ntype]
     * @returns {Neo.core.Base|null}
     */
    getConfigInstanceByNtype(configName, ntype) {
        let me                = this,
            config            = me[configName],
            {parentComponent} = me;

        if (config && (!ntype || ntype === config.ntype)) {
            return config
        }

        if (!parentComponent && me.parentId) {
            parentComponent = me.parent || Neo.get(me.parentId);
        }

        if (parentComponent) {
            return parentComponent.getConfigInstanceByNtype(configName, ntype)
        }

        return null
    }

    /**
     * Returns this.controller or the closest parent controller
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        let me = this,
            controller;

        if (!ntype) {
            controller = me[closestController];

            if (controller) {
                return controller
            }
        }

        controller = me.getConfigInstanceByNtype('controller', ntype);

        if (!ntype) {
            me[closestController] = controller;
        }

        return controller
    }

    /**
     * Convenience shortcut
     * @param {String[]|String} id=this.id
     * @param {String} appName=this.appName
     * @returns {Promise<Neo.util.Rectangle>}
     */
    async getDomRect(id=this.id, appName=this.appName) {
        let result = await Neo.main.DomAccess.getBoundingClientRect({appName, id, windowId: this.windowId});

        if (Array.isArray(result)) {
            return result.map(rect => _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].clone(rect))
        }

        return _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].clone(result)
    }

    /**
     * Returns this.model or the closest parent model
     * @param {String} [ntype]
     * @returns {Neo.model.Component|null}
     */
    getModel(ntype) {
        if (!Neo.currentWorker.isUsingViewModels) {
            return null
        }

        let me = this,
            model;

        if (!ntype) {
            model = me[closestModel];

            if (model) {
                return model
            }
        }

        model = me.getConfigInstanceByNtype('model', ntype);

        if (!ntype) {
            me[closestModel] = model
        }

        return model
    }

    /**
     * Honors different item roots for mount / render OPs
     * @returns {String}
     */
    getMountedParentId() {
        let parentId  = this.parentId,
            parent    = Neo.getComponent(parentId),
            itemsRoot = parent?.getVdomItemsRoot?.();

        return itemsRoot ? itemsRoot.id : parentId
    }

    /**
     * Calculate the real parentIndex inside the DOM
     * @returns {Number|undefined}
     */
    getMountedParentIndex() {
        let parent = this.parent,
            items  = parent?.items || [],
            i      = 0,
            index  = 0,
            len    = items.length,
            item;

        for (; i < len; i++) {
            item = items[i];

            if (item === this) {
                return index
            }

            if (!item.hidden && item.hideMode === 'removeDom') {
                index++
            }
        }
    }

    /**
     * Get the parent components as an array
     * @returns {Neo.component.Base[]}
     */
    getParents() {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(this)
    }

    /**
     * @param {Object|String} opts
     * @returns {Neo.plugin.Base|null}
     */
    getPlugin(opts) {
        if (Neo.isString(opts)) {
            if (!opts.startsWith('plugin-')) {
                opts = 'plugin-' + opts
            }

            opts = {ntype: opts}
        }

        let me = this,
            hasMatch;

        for (const plugin of me.plugins || []) {
            hasMatch = true;

            for (const key in opts) {
                if (plugin[key] !== opts[key]) {
                    hasMatch = false;
                    break
                }
            }

            if (hasMatch) {
                return plugin
            }
        }

        return null
    }

    /**
     * convenience shortcut
     * @param {String} value
     * @returns {Neo.component.Base|null}
     */
    getReference(value) {
        return this.down({reference: value})
    }

    /**
     * Walks up the vdom tree and returns the closest theme found
     * @returns {String}
     */
    getTheme() {
        let me         = this,
            themeMatch = 'neo-theme-',
            mainView, parentNodes;

        for (const item of me.cls || []) {
            if (item.startsWith(themeMatch)) {
                return item
            }
        }

        mainView = me.app?.mainView;

        if (mainView) {
            parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].getParentNodes(mainView.vdom, me.id);

            for (const node of parentNodes || []) {
                for (const item of node.cls || []) {
                    if (item.startsWith(themeMatch)) {
                        return item
                    }
                }
            }
        }

        return Neo.config.themes?.[0]
    }

    /**
     * Search a vdom child node by id for a given vdom tree
     * @param {String} id
     * @param {Object} vdom=this.vdom
     * @returns {Object}
     */
    getVdomChild(id, vdom=this.vdom) {
        let node = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].findVdomChild(vdom, id);
        return node?.vdom
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode
    }

    /**
     * Hide the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     * If hideMode === 'removeDom' you can pass a timeout for custom css class hiding.
     * @param {Number} timeout
     */
    hide(timeout) {
        let me = this;

        if (me.hideMode !== 'visibility') {
            let removeFn = function () {
                if (me.parentId !== 'document.body') {
                    me.vdom.removeDom = true;
                    me.parent.update()
                } else {
                    me.unmount()
                }
            }

            if (timeout) {
                setTimeout(removeFn, timeout)
            } else {
                removeFn()
            }
        } else {
            let style = me.style;
            style.visibility = 'hidden';
            me.style = style;
        }

        me._hidden = true
    }

    /**
     *
     */
    init() {
        this.autoRender && this.render()
    }

    /**
     * We are using this method as a ctor hook here to add the initial model.Component & controller.Component parsing
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     */
    initConfig(config, preventOriginalConfig) {
        super.initConfig(config, preventOriginalConfig);

        let me = this;

        me.getController()?.parseConfig(me);
        me.getModel()     ?.parseConfig(me)
    }

    /**
     * Checks for vdom updates inside the parent chain and if found.
     * Registers the component for a vdom update once done.
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] gets passed by updateVdom()
     * @returns {Boolean}
     */
    isParentVdomUpdating(parentId=this.parentId, resolve) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                if (parent.isVdomUpdating) {
                    if (Neo.config.logVdomUpdateCollisions) {
                        console.warn('vdom parent update conflict with:', parent, 'for:', me)
                    }

                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(parent.childUpdateCache, me.id);

                    // Adding the resolve fn to its own cache, since the parent will trigger
                    // a new update() directly on this cmp
                    resolve && me.resolveUpdateCache.push(resolve)
                    return true
                } else {
                    return me.isParentVdomUpdating(parent.parentId, resolve)
                }
            }
        }

        return false
    }

    /**
     * @param {Number|String} value
     * @returns {Promise<number>}
     */
    async measure(value) {
        if (value != null) {
            if (value.endsWith('px')) {
                value = parseFloat(value)
            } else if (lengthRE.test(value)) {
                let {id, windowId} = this;
                value = await Neo.main.DomAccess.measure({id, value, windowId})
            } else if (!isNaN(value)) {
                value = parseFloat(value)
            }
        }

        return value
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let me     = this,
            config = super.mergeConfig(...args),

            // it should be possible to set custom configs for the vdom on instance level,
            // however there will be already added attributes (e.g. id), so a merge seems to be the best strategy.
            vdom = {...me._vdom || {}, ...config.vdom || {}};

        // avoid any interference on prototype level
        // does not clone existing Neo instances
        me._vdom = Neo.clone(vdom, true, true);

        if (config.style) {
            // If we are passed an object, merge it with the class's own style
            me.style = Neo.typeOf(config.style) === 'Object' ? {...config.style, ...me.constructor.config.style} : config.style
        }

        me.wrapperStyle = Neo.clone(config.wrapperStyle, false);

        delete config.style;
        delete config._vdom;
        delete config.vdom;
        delete config.wrapperStyle;

        return config
    }

    /**
     * Can get called after the component got rendered. See the autoMount config as well.
     */
    async mount() {
        let me = this,
            child, childIds;

        if (!me.vnode) {
            throw new Error('Component vnode must be generated before mounting, use Component.render()');
        }

        // In case the component was already mounted, got unmounted and received vdom changes afterwards,
        // a new render() call is mandatory since delta updates could not get applied.
        // We need to clear the hasUnmountedVdomChanges state for all child components
        if (me.hasUnmountedVdomChanges) {
            // todo: the hasUnmountedVdomChanges flag changes should happen on render
            me.hasUnmountedVdomChanges = false;

            childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildIds(me.vnode);

            childIds.forEach(id => {
                child = Neo.getComponent(id);

                if (child) {
                    child._hasUnmountedVdomChanges = false; // silent update
                }
            });
            // end todo

            me.render(true)
        } else {
            await Neo.currentWorker.promiseMessage('main', {
                action     : 'mountDom',
                appName    : me.appName,
                id         : me.id,
                html       : me.vnode.outerHTML,
                parentId   : me.getMountedParentId(),
                parentIndex: me.getMountedParentIndex()
            });

            delete me.vdom.removeDom;

            await me.timeout(30);

            me.mounted = true
        }
    }

    /**
     * Checks the needsVdomUpdate config inside the parent tree
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] gets passed by updateVdom()
     * @returns {Boolean}
     */
    needsParentUpdate(parentId=this.parentId, resolve) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                if (parent.needsVdomUpdate) {
                    parent.resolveUpdateCache.push(...me.resolveUpdateCache);
                    resolve && parent.resolveUpdateCache.push(resolve);
                    me.resolveUpdateCache = [];
                    return true
                } else {
                    return me.needsParentUpdate(parent.parentId)
                }
            }
        }

        return false
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.keys?.register(this)
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        // If we are hidden, or unmounted while we still contain focus, we have to revert
        // focus to where it came from if possible
        this.focusEnterData = data;
    }

    /**
     * @param {Object} data
     */
    onFocusLeave(data) {
        this.focusEnterData = null;
    }

    /**
     * Triggered by manager.Focus
     * @name onFocusEnter
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusLeave
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusMove
     * @function
     * @param {Object} opts
     * @param {Array}  opts.newPath dom element ids upwards
     * @param {Array}  opts.oldPath dom element ids upwards
     */

    /**
     * Gets called from the render() promise success handler
     * @param {Object} data
     * @param {Boolean} autoMount Mount the DOM after the vnode got created
     * @protected
     */
    onRender(data, autoMount) {
        let me    = this,
            {app} = me;

        me.rendering = false;

        // if app is a check to see if the Component got destroyed while rendering => before onRender got triggered
        if (app) {
            if (!app.rendered) {
                app.rendering = false;
                app.rendered = true;
                app.fire('render')
            }

            me.vnode = data;

            let childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildIds(data),
                i        = 0,
                len      = childIds.length,
                child;

            for (; i < len; i++) {
                child = Neo.getComponent(childIds[i]);

                if (child) {
                    child.rendered = true
                }
            }

            me._rendered = true; // silent update
            me.fire('rendered', me.id);

            // console.log('rendered: ' + me.appName + ' ' + me.id, me);

            if (autoMount) {
                me.mounted = true;

                if (!app.mounted) {
                    app.mounted = true;
                    app.fire('mounted')
                }
            }
        }
    }

    /**
     * Promise based vdom update
     * @param {Object} vdom=this.vdom
     * @param {Neo.vdom.VNode} vnode= this.vnode
     * @returns {Promise<any>}
     */
    promiseUpdate(vdom = this.vdom, vnode = this.vnode) {
        return new Promise((resolve, reject) => {
            this.updateVdom(vdom, vnode, resolve, reject)
        })
    }

    /**
     * Remove a cls from the vdomRoot
     * @param {String} value
     */
    removeCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, value);
        this.cls = cls
    }

    /**
     * @param {Array|Object} value
     */
    removeDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value];
        }

        let me             = this,
            {domListeners} = me,
            i, len;

        value.forEach(item => {
            i = 0;
            len = domListeners.length;

            for (; i < len; i++) {
                if (Neo.isEqual(item, domListeners[i])) {
                    domListeners.splice(i, 1);
                    break
                }
            }
        });

        me.domListeners = domListeners
    }

    /**
     * Either a string like 'color' or an array containing style attributes to remove
     * @param {String|Array} value camelCase only
     * @returns {Object} all styles of this.el
     */
    removeStyle(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let {style}  = this,
            doUpdate = false;

        Object.keys(style).forEach(key => {
            if (value.indexOf(key) > -1) {
                delete style[key];
                doUpdate = true
            }
        });

        if (doUpdate) {
            this.style = style
        }

        return style
    }

    /**
     * Creates the vnode tree for this component and mounts the component in case
     * - you pass true for the mount param
     * - or the autoMount config is set to true
     * @param {Boolean} [mount] Mount the DOM after the vnode got created
     */
    async render(mount) {
        let me            = this,
            autoMount     = mount || me.autoMount,
            app           = me.app,
            useVdomWorker = Neo.config.useVdomWorker;

        me.rendering = true;

        if (!app.rendered) {
            app.rendering = true
        }

        if (me.vdom) {
            me.isVdomUpdating = true;

            delete me.vdom.removeDom;

            me._needsVdomUpdate = false;
            me.afterSetNeedsVdomUpdate?.(false, true);

            const data = await Neo.vdom.Helper.create({
                appName    : me.appName,
                autoMount,
                parentId   : autoMount ? me.getMountedParentId()    : undefined,
                parentIndex: autoMount ? me.getMountedParentIndex() : undefined,
                windowId   : me.windowId,
                ...me.vdom
            });

            me.onRender(data, useVdomWorker ? autoMount : false);
            me.isVdomUpdating = false;

            autoMount && !useVdomWorker && me.mount();

            me.resolveVdomUpdate()
        }
    }

    /**
     * Internal helper fn to resolve the Promise for updateVdom()
     * @param {Function|undefined} resolve
     * @protected
     */
    resolveVdomUpdate(resolve) {
        let me = this;

        me.doResolveUpdateCache();

        resolve?.();

        if (me.needsVdomUpdate) {
            // if a new update is scheduled, we can clear the cache => these updates are included
            me.childUpdateCache = [];

            me.update()
        } else if (me.childUpdateCache) {
            [...me.childUpdateCache].forEach(id => {
                Neo.getComponent(id)?.update();
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(me.childUpdateCache, id)
            })
        }
    }

    /**
     *
     */
    revertFocus() {
        let relatedTarget = this.focusEnterData?.relatedTarget;

        if (this.containsFocus && relatedTarget) {
            Neo.getComponent(relatedTarget.id)?.focus()
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} [silent=false]
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        let me             = this,
            needsRendering = values.hidden === false && values.hidden !== me.hidden;

        me.silentVdomUpdate = true;

        super.set(values);

        me.silentVdomUpdate = false;

        if (silent || !me.needsVdomUpdate) {
            return Promise.resolve()
        } else {
            if (needsRendering) {
                me.show();
                return Promise.resolve()
            }

            return me.promiseUpdate()
        }
    }

    /**
     * Convenience shortcut calling set() with the silent flag
     * @param {Object} values={}
     */
    setSilent(values = {}) {
        return this.set(values, true)
    }

    /**
     * Show the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     */
    show() {
        const me = this;

        if (me.hideMode !== 'visibility') {
            delete me.vdom.removeDom;

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.parentId !== 'document.body') {
                me.parent.update()
            } else {
                !me.mounted && me.render(true)
            }
        } else {
            let style = me.style;
            delete style.visibility;
            me.style = style
        }

        me._hidden = false
    }

    /**
     * Placeholder method for util.VDom.syncVdomIds to allow overriding (disabling) it
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     * @param {Object} [vdom=this.vdom]
     * @param {Boolean} force=false
     */
    syncVdomIds(vnode = this.vnode, vdom = this.vdom, force = false) {
        _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].syncVdomIds(vnode, vdom, force)
    }

    /**
     * In case a component receives a new vnode, we want to do:
     * - sync the vdom ids
     * - setting rendered to true for child components
     * - updating the parent component to ensure that the vnode tree stays persistent
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     */
    syncVnodeTree(vnode=this.vnode) {
        let me    = this,
            debug = false,
            childVnode, start;

        if (debug) {
            start = performance.now()
        }

        me.syncVdomIds();

        // delegate the latest node updates to all possible child components found inside the vnode tree
        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildren(me).forEach(component => {
            childVnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].findChildVnode(me.vnode, component.vdom.id);

            if (childVnode) {
                component._vnode = childVnode.vnode; // silent update

                if (!component.rendered) {
                    component._rendered = true;
                    component.fire('rendered', component.id)
                }

                component.mounted = true
            } else {
                console.warn('syncVnodeTree: Could not replace the child vnode for', component.id)
            }
        });

        // console.log(me.vnode, me.mounted);

        // keep the vnode parent tree in sync
        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach((component, index) => {
            if (component.vnode) {
                if (!me.vnode) {
                    if (index === 0 && !_util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].removeChildVnode(component.vnode, me.id)) {
                        // This can fail, in case the vnode is already removed (not an issue, better safe than sorry)
                        // console.warn('syncVnodeTree: Could not remove the parent vnode for', me.id, component);
                    }
                }

                // check for dynamically rendered components which get inserted into the component tree
                else if (index === 0 && me.vnode.outerHTML) {
                    // console.log('dyn item', me.vnode, me.parentIndex);
                    component.vnode.childNodes.splice(me.parentIndex || 0, 0, me.vnode)
                } else if (!_util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].replaceChildVnode(component.vnode, me.vnode.id, me.vnode)) {
                    // todo: can happen for dynamically inserted container items
                    // console.warn('syncVnodeTree: Could not replace the parent vnode for', me.vnode.id, component);
                }
            }
        });

        debug && console.log('syncVnodeTree', me.id, performance.now() - start)
    }

    /**
     * Toggle a cls inside the vdomRoot of the component
     * @param {String} value
     * @param {Boolean} [add] Use this param to enforce an add() or remove() operation.
     */
    toggleCls(value, add) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].toggle(cls, value, add);
        this.cls = cls
    }

    /**
     * Removes the component DOM
     */
    unmount() {
        let me = this;

        me.vdom.removeDom = true;

        me._hidden = true; // silent update
        me.mounted = false;

        Neo.applyDeltas(me.appName, {action: 'removeNode', id: me.vdom.id})
    }

    /**
     * Convenience shortcut for Neo.manager.Component.up
     * @param {Object|String} config
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    up(config) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].up(this.id, config)
    }

    /**
     *
     */
    update() {
        this.afterSetVdom(this.vdom, null)
    }

    /**
     * Delta updates for the cls config. Gets called after the cls config gets changed in case the component is mounted.
     * @param {String[]} cls
     * @param {String[]} oldCls
     * @param {String} id=this.id
     * @protected
     */
    updateCls(cls, oldCls, id=this.id) {
        let me          = this,
            {vnode}     = me,
            vnodeTarget = vnode && _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].findChildVnode(me.vnode, {id})?.vnode;

        if (vnode && !Neo.isEqual(cls, oldCls)) {
            if (vnodeTarget) {
                vnodeTarget.className = cls; // keep the vnode in sync
                me.vnode = vnode;
            }

            Neo.applyDeltas(me.appName, {
                id,
                cls: {
                    add   : _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(cls, oldCls),
                    remove: _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldCls, cls)
                }
            })
        }
    }

    /**
     * Creates the style deltas for newValue & oldValue and applies them directly to the DOM.
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @param {String} [id=this.id]
     * @protected
     */
    updateStyle(value, oldValue, id=this.id) {
        let me    = this,
            delta = _util_Style_mjs__WEBPACK_IMPORTED_MODULE_9__["default"].compareStyles(value, oldValue),
            opts, vdom, vnode, vnodeStyle;

        if (delta) {
            vdom  = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].findVdomChild(me.vdom, id);
            vnode = me.vnode && _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].findChildVnode(me.vnode, id);

            if (!me.hasUnmountedVdomChanges) {
                me.hasUnmountedVdomChanges = !me.mounted && me.hasBeenMounted
            }

            vdom.vdom.style = value; // keep the vdom in sync

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.mounted) {
                vnodeStyle = vnode.vnode.style;

                // keep the vnode in sync
                // we need the iteration since vdom shortcuts (height, width,...) live within the vnode style
                // using vnode.vnode.style = style would lose them.
                Object.entries(delta).forEach(([key, value]) => {
                    if (value === null) {
                        delete vnode.vnode.style[key]
                    } else {
                        vnodeStyle[key] = value
                    }
                });

                opts = {
                    action: 'updateDom',
                    deltas: [{id, style: delta}]
                };

                if (Neo.currentWorker.isSharedWorker) {
                    opts.appName = me.appName
                }

                Neo.currentWorker.sendMessage('main', opts)
            }
        }
    }

    /**
     * Gets called after the vdom config gets changed in case the component is already mounted (delta updates).
     * @param {Object} vdom=this.vdom
     * @param {Neo.vdom.VNode} vnode=this.vnode
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @protected
     */
    updateVdom(vdom=this.vdom, vnode=this.vnode, resolve, reject) {
        let me                       = this,
            {app, mounted, parentId} = me,
            listenerId;

        // It is important to keep the vdom tree stable to ensure that containers do not lose the references to their
        // child vdom trees. The if case should not happen, but in case it does, keeping the reference and merging
        // the content over seems to be the best strategy
        if (me._vdom !== vdom) {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].warn('vdom got replaced for: ' + me.id + '. Copying the content into the reference holder object');

            Object.keys(me._vdom).forEach(key => {
                delete me._vdom[key]
            });

            vdom = Object.assign(me._vdom, vdom)
        }

        if (resolve && me.isVdomUpdating) {
            me.resolveUpdateCache.push(resolve)
        }

        if (me.isVdomUpdating || me.silentVdomUpdate) {
            me.needsVdomUpdate = true
        } else {
            if (!mounted && me.isConstructed && !me.hasRenderingListener && app?.rendering === true) {
                me.hasRenderingListener = true;

                listenerId = app.on('mounted', () => {
                    app.un('mounted', listenerId);

                    me.timeout(50).then(() => {
                        me.vnode && me.updateVdom(me.vdom, me.vnode, resolve, reject)
                    })
                })
            } else {
                if (resolve && (!mounted || !vnode)) {
                    me.resolveUpdateCache.push(resolve)
                }

                if (
                    !me.needsParentUpdate(parentId, resolve)
                    && !me.isParentVdomUpdating(parentId, resolve)
                    && mounted
                    && vnode
                ) {
                    me.#executeVdomUpdate(vdom, vnode, resolve, reject)
                }
            }
        }

        me.hasUnmountedVdomChanges = !mounted && me.hasBeenMounted
    }
}

/**
 * manager.Focus fires the event after focusEnter, focusLeave or focusMove
 * @event focusChange
 * @param {Object} data
 * @param {Object[]} [data.path] dom element ids upwards
 * @param {Object[]} [data.oldPath] dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path
 * @event focusEnter
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is not included inside the dom id path
 * @event focusLeave
 * @param {Object} data
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path, but the path itself changed
 * @event focusMove
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 * @param {Object[]} data.oldPath dom element ids upwards
 */

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/util/KeyNavigation.mjs":
/*!************************************!*\
  !*** ./src/util/KeyNavigation.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.util.KeyNavigation
 * @extends Neo.core.Base
 */
class KeyNavigation extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.KeyNavigation'
         * @protected
         */
        className: 'Neo.util.KeyNavigation',
        /**
         * @member {String} ntype='keynav'
         * @protected
         */
        ntype: 'keynav',
        /**
         * Internally stores the component id inside _component
         * @member {Neo.component.Base|null} component_=null
         */
        component_: null,
        /**
         * Set this to true in case the keydown event is supposed to bubble upwards inside the component tree
         * @member {Boolean} keyDownEventBubble=false
         */
        keyDownEventBubble: false,
        /**
         * @member {Array|null} keys_=null
         */
        keys_: null
    }

    add(value) {
        this._keys.push(...this.parseKeys(value))
    }

    /**
     * @protected
     * @returns {Neo.component.Base}
     */
    beforeGetComponent() {
        return Neo.getComponent(this._component)
    }

    /**
     * @param {Neo.component.Base} value
     * @protected
     * @returns {String} the component id
     */
    beforeSetComponent(value) {
        return value?.id
    }

    /**
     *
     */
    destroy() {
        this.unregister();
        super.destroy()
    }

    /**
     * @param {Object} data
     */
    onKeyDown(data) {
        // Using the chrome auto-fill feature does trigger a keydown event, not containing a key. See: #64
        if (data.key) {
            let me           = this,
                upperCaseKey = data.key.toUpperCase(),
                scope;

            upperCaseKey = me.parseUpperCaseKey(upperCaseKey);

            me.keys.forEach(key => {
                scope = Neo.get(key.scope);

                if (key.key.toUpperCase() === upperCaseKey) {
                    scope[key.fn]?.apply(scope, [data])
                }
            })
        }
    }

    /**
     * @param {Object} value
     * @returns {Object}
     */
    parseKeys(value) {
        if (!Array.isArray(value)) {
            let componentId = this._component,
                keyArray    = [];

            if (componentId) {
                Object.entries(value).forEach(([key, value]) => {
                    keyArray.push({
                        fn   : value,
                        key,
                        scope: componentId // todo: support VCs later on
                    })
                });

                value = keyArray
            }
        }

        return value
    }

    /**
     * Replaces specific key names, e.g. " " => SPACE
     * @param {String} key
     * @protected
     * @returns {String}
     */
    parseUpperCaseKey(key) {
        switch (key) {
            case ' ':
                key = 'SPACE';
                break
            case 'ARROWDOWN':
                key = 'DOWN';
                break
            case 'ARROWLEFT':
                key = 'LEFT';
                break
            case 'ARROWRIGHT':
                key = 'RIGHT';
                break
            case 'ARROWUP':
                key = 'UP';
                break
        }

        return key
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me = this;

        me.component = component;
        me.keys      = me.parseKeys(me.keys);

        component.addDomListeners({
            keydown: {
                bubble: me.keyDownEventBubble,
                fn    : me.onKeyDown,
                scope : me
            }
        })
    }

    /**
     * Remove a key listener using the same config used when creating it
     * @param {Object} config
     */
    removeKey(config) {
        let me   = this,
            keys = me._keys,
            i    = 0,
            len  = keys.length,
            key;

        for (; i < len; i++) {
            key = keys[i];

            if (Neo.isEqual(key, config)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(keys, key);
                break
            }
        }
    }

    /**
     * Remove multiple key listeners passing an array of config items
     * @param {Array} items
     */
    removeKeys(items) {
        Array.isArray(items) && items.forEach(item => this.removeKey(item))
    }

    /**
     *
     */
    unregister() {
        // todo: remove the dom listener from the owner component
    }
}

Neo.setupClass(KeyNavigation);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyNavigation);


/***/ }),

/***/ "./src/util/Rectangle.mjs":
/*!********************************!*\
  !*** ./src/util/Rectangle.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Rectangle)
/* harmony export */ });
/**
 * The class contains utility methods for working with DOMRect Objects
 * @class Neo.util.Rectangle
 * @extends DOMRect
 */

const
    emptyArray = Object.freeze([]),
    // Convert edge array values into the [T,R,B,L] form.
    parseEdgeValue = (e = 0) => {
        if (!Array.isArray(e)) {
            e = [e];
        }
        switch (e.length) {
            case 1:
                e.length = 4;
                return e.fill(e[0], 1, 4);
            case 2:// top&bottom, left&right
                return [e[0], e[1], e[0], e[1]];
            case 3:// top, left&right, bottom
                return [e[0], e[1], e[2], e[1]];
        }
        return e;
    },
    parseEdgeAlign = edgeAlign => {
        const
            edgeParts     = edgeAlignRE.exec(edgeAlign),
            ourEdgeZone   = edgeZone[edgeParts[1]],
            theirEdgeZone = edgeZone[edgeParts[4]];

        return {
            ourEdge         : edgeParts[1],
            ourEdgeOffset   : parseInt(edgeParts[2] || 50),
            ourEdgeUnit     : edgeParts[3] || '%',
            ourEdgeZone,
            theirEdge       : edgeParts[4],
            theirEdgeOffset : parseInt(edgeParts[5] || 50),
            theirEdgeUnit   : edgeParts[6] || '%',
            theirEdgeZone,

            // Aligned to an edge, *outside* of the target.
            // A normal align as a combo dropdown might request
            edgeAligned     : (ourEdgeZone & 1) === (theirEdgeZone & 1) && ourEdgeZone !== theirEdgeZone
        }
    },
    // The opposite of parseEdgeAlign, and it has to flip the edges
    createReversedEdgeAlign = edges => {
        const
            ourEdge   = oppositeEdge[edges.ourEdge],
            theirEdge = oppositeEdge[edges.theirEdge];

        // reconstitute a rule string with the edges flipped to the opposite sides
        return `${ourEdge}${edges.ourEdgeOffset}${edges.ourEdgeUnit}-${theirEdge}${edges.theirEdgeOffset}${edges.theirEdgeUnit}`

    },
    getElRect = el => {
        const r = el instanceof DOMRect ? el : (el?.nodeType === 1 ? el : typeof el === 'string' ? document.getElementById(el) : null)?.getBoundingClientRect();

        // Convert DOMRect into Rectangle
        return r && new Rectangle(r.x, r.y, r.width, r.height);
    },
    oppositeEdge = {
        t : 'b',
        r : 'l',
        b : 't',
        l : 'r'
    },
    edgeZone = {
        t : 0,
        r : 1,
        b : 2,
        l : 3
    },
    zoneNames = ['top', 'right', 'bottom', 'left'],
    zoneEdges = ['t', 'r', 'b', 'l'],
    zoneDimension = ['width', 'height'],
    zoneCoord = [0, 1, 0, 1],
    zeroMargins = [0, 0, 0, 0],
    edgeAlignRE = /^([trblc])(\d*)(%|px)?-([trblc])(\d*)(%|px)?$/;

class Rectangle extends DOMRect {
    static config = {
        /**
         * @member {String} className='Neo.util.Rectangle'
         * @protected
         */
        className: 'Neo.util.Rectangle'
    }

    /**
     * @member {Number|null} minHeight=null
     */
    minHeight = null
    /**
     * @member {Number|null} minWidth=null
     */
    minWidth = null

    /**
     * Checks if rect1 does not have an intersection with rect2
     * !includes() is true for intersections as well
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static excludes(rect1, rect2) {
        return rect1.bottom < rect2.top     // rect2 is below rect1
            || rect1.left   > rect2.right   // rect2 is left of rect1
            || rect1.right  < rect2.left    // rect2 is right of rect1
            || rect1.top    > rect2.bottom; // rect2 is above rect1
    }

    /**
     * Returns the overlapping area of rect1 & rect2
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Number} The area (x * y)
     */
    static getIntersection(rect1, rect2) {
        return Rectangle.getIntersectionDetails(rect1, rect2).area;
    }

    /**
     * Returns the overlapping area of rect1 & rect2
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Object} x, y & area
     */
    static getIntersectionDetails(rect1, rect2) {
        let width  = Math.max(0, Math.min(rect1.right,  rect2.right)  - Math.max(rect1.left, rect2.left)),
            height = Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top,  rect2.top));

        return {
            area: height * width,
            height,
            width
        };
    }

    /**
     * Checks if rect2 is fully contained inside rect1
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static includes(rect1, rect2) {
        return rect1.bottom >= rect2.bottom
            && rect1.left   <= rect2.left
            && rect1.right  >= rect2.right
            && rect1.top    <= rect2.top;
    }

    /**
     * Checks if rect2 is not contained inside rect1.
     * This could be an intersection or being fully excluded.
     * @param {Object} rect1
     * @param {Object} rect2
     * @param {String} side bottom, left, right or top
     * @returns {Boolean}
     */
    static leavesSide(rect1, rect2, side) {
        if (Rectangle.includes(rect1, rect2)) {
            return false;
        }

        if (side === 'bottom') {
            return rect1.bottom < rect2.bottom;
        }

        if (side === 'left') {
            return rect1.left > rect2.left;
        }

        if (side === 'right') {
            return rect1.right < rect2.right;
        }

        if (side === 'top') {
            return rect1.top > rect2.top;
        }
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveBy(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  += x;
            movedRect.right += x;
            movedRect.x     += x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom += y;
            movedRect.top    += y;
            movedRect.y      += y;
        }

        return movedRect;
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveTo(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  = x;
            movedRect.right = x + movedRect.width;
            movedRect.x     = x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom = y + movedRect.height;
            movedRect.top    = y;
            movedRect.y      = y;
        }

        return movedRect;
    }

    set bottom(b) {
        this.height += b - this.bottom;
    }
    get bottom() {
        return super.bottom;
    }

    set right(r) {
        this.width += r - this.right;
    }
    get right() {
        return super.right;
    }

    // Change the x without moving the Rectangle. The left side moves and the right side doesn't
    changeX(x) {
        const widthDelta = this.x - x;

        this.x = x;
        this.width += widthDelta;
    }

    // Change the y without moving the Rectangle. The top side moves and the bottom side doesn't
    changeY(y) {
        const heightDelta = this.y - y;

        this.y = y;
        this.height += heightDelta;
    }

    clone() {
        return Rectangle.clone(this);
    }

    static clone(r) {
        const result = new Rectangle(r.x, r.y, r.width, r.height);

        result.minWidth = r.minWidth;
        result.minHeight = r.minHeight;

        return result;
    }

    intersects(other) {
        const me = this;

        if (other.height && other.width) {
            const
                left   = Math.max(me.x, other.x),
                top    = Math.max(me.y, other.y),
                right  = Math.min(me.x + me.width, other.x + other.width),
                bottom = Math.min(me.y + me.height, other.y + other.height);

            if (left >= right || top >= bottom) {
                return false;
            }

            return new Rectangle(left, top, right - left, bottom - top);
        }
        // We're dealing with a point here - zero dimensions
        else {
            return (other.x >= me.x && other.y >= me.y && other.right <= me.right && other.bottom <= me.bottom);
        }
    }

    /**
     * Checks if the other Rectangle is fully contained inside this Rectangle
     * @param {Object} other
     * @returns {Boolean}
     */
    contains(other) {
        return this.bottom >= other.bottom
            && this.left   <= other.left
            && this.right  >= other.right
            && this.top    <= other.top;
    }

    /**
     * Returns a clone of this Rectangle expanded according to the edges array.
     * @param {Number}Number[]} edges
     * @returns {Rectangle}
     */
    expand(edges) {
        edges = parseEdgeValue(edges);

        return new this.constructor(this.x - edges[3], this.y - edges[0], this.width + edges[1] + edges[3], this.height + edges[0] + edges[2]);
    }

    moveBy(x = 0, y = 0) {
        const result = this.clone();

        if (Array.isArray(x)) {
            y = x[1];
            x = x[0];
        }
        result.x += x;
        result.y += y;
        return result;
    }

    /**
     * Returns `true` if this Rectangle completely contains the other Rectangle
     * @param {Rectangle} other
     */
    contains(other) {
        return this.constructor.includes(this, other);
    }

    /**
     * Returns a copy of this Rectangle constrained to fit within the passed Rectangle
     * @param {Rectangle} constrainTo
     * @returns {Rectangle|Boolean} A new Rectangle constrained to te passed Rectangle, or false if it could not be constrained.
     */
    constrainTo(constrainTo) {
        const
            me        = this,
            minWidth  = me.minWidth  || me.width,
            minHeight = me.minHeight || me.height;

        // Not possible, even when shrunk to minima
        if (minHeight > constrainTo.height || minWidth > constrainTo.width) {
            return false;
        }

        // We do not mutate this Rectangle, but return a constrained version
        const result = me.clone();

        // Translate result so that the top and left are visible
        result.x = Math.max(me.x + Math.min(constrainTo.right  - result.right,  0), constrainTo.x);
        result.y = Math.max(me.y + Math.min(constrainTo.bottom - result.bottom, 0), constrainTo.y);

        // Pull in any resulting overflow
        result.bottom = Math.min(result.bottom, constrainTo.bottom);
        result.right = Math.min(result.right, constrainTo.right);

        return result;
    }

    alignTo(align) {
        const
            me             = this,
            {
                constrainTo,    // Element or Rectangle result must fit into
                target,         // Element or Rectangle to align to
                edgeAlign,      // t50-b50 type string
                axisLock,       // true for flip, 'flexible' for flip, then try the other edges
                offset,         // Final [x, y] vector to move the result by.
                matchSize
            }              = align,
            targetMargin   = align.targetMargin ? parseEdgeValue(align.targetMargin) : zeroMargins,
            targetRect     = getElRect(target),
            constrainRect  = getElRect(constrainTo),
            edges          = parseEdgeAlign(edgeAlign),
            matchDimension = zoneDimension[edges.theirEdgeZone & 1];

        let result = me.clone();

        if (matchSize) {
            result[matchDimension] = targetRect[matchDimension];
        }

        // Must do the calculations after the aligned side has been matched in size if requested.
        const
            myPoint     = result.getAnchorPoint(edges.ourEdgeZone, edges.ourEdgeOffset, edges.ourEdgeUnit),
            targetPoint = targetRect.getAnchorPoint(edges.theirEdgeZone, edges.theirEdgeOffset, edges.theirEdgeUnit, targetMargin),
            vector      = [targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]];

        result = result.moveBy(vector);

        // A useful property in the resulting rectangle which specifies which zone of the target
        // It is being places in, T,R,B or L - 0, 1, 2, 3
        // Some code may want to treat DOM elements differently depending on the zone
        result.zone = edges.theirEdgeZone;
        result.position = zoneNames[result.zone];

        // Now we create the four Rectangles around the target, into which we may be constrained
        // Zones T,R,B,L 0 9, 1, 2, 3:
        // +-----------------------------------------------------------------------------------+
        // | +-------------------------+------------------------+----------------------------+ |
        // | |          ^              |                        |             ^              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+---------Zone 0---------+-------------+---------->   | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | +----------+--------------+------------------------+-------------+--------------+ |
        // | |          |              | +--------------------+ |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |       Zone 3            | |                    | |          Zone 1            | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | +--------------------+ |             |              | |
        // | ++---------+--------------+------------------------+-------------+--------------+ |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+--------Zone 2----------+-------------+------------> | |
        // | |          |              |                        |             |              | |
        // | |          v              |                        |             v              | |
        // | ++------------------------+------------------------+----------------------------+ |
        // +-----------------------------------------------------------------------------------+
        if (constrainRect && !constrainRect.contains(result)) {
            // They asked to overlap the target, for example t0-t0
            // In these cases, we just return the result
            if (targetRect.intersects(result)) {
                return result;
            }

            // This is the zone we try to fit into first, the one that was asked for
            let zone = edges.theirEdgeZone;

            // We create an array of four rectangles into which we try to fit with appropriate align specs.
            // We must start with the requested zone, whatever that is.
            const zonesToTry = [{
                zone,
                edgeAlign
            }];

            if (axisLock) {
                // Flip to the opposite side for the second try.
                // The alignment string has to be reversed
                // so r20-l30 has to become l20-r30.
                // The other two zones revert to centered so are easier
                zonesToTry[1] = {
                    zone      : zone = (zone + 2) % 4,
                    edgeAlign : createReversedEdgeAlign(edges)
                }

                // Fall back to the other two zones.
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 1) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 3) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
            }
            else {
                // go through the other zones in order
                for (let i = 1; i < 4; i++) {
                    zonesToTry.push({
                        zone      : zone = (zone + 1) % 4,
                        edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                    });
                }
            }

            // Calculate the constraint Rectangle for each zone
            for (let i = 0; i < zonesToTry.length; i++) {
                // We clone the outer constraining rectangle
                // and move it into position
                const c = constrainRect.clone();

                switch (zonesToTry[i].zone) {
                    case 0:
                        // The zone i2 above the target - zone 0/T
                        c.bottom = targetRect.y - targetMargin[0];
                        break;
                    case 1:
                        // The zone is to the right of the target - zone 1/R
                        c.changeX(targetRect.right + targetMargin[1]);
                        break;
                    case 2:
                        // The zone is below the target - zone 2/B
                        c.changeY(targetRect.bottom + targetMargin[2]);
                        break;
                    case 3:
                        // The zone is to the left of the target - zone 3/L
                        c.right = targetRect.x - targetMargin[3];
                        break;
                }
                zonesToTry[i].constrainRect = c;
            }

            // Now try to constrain our result into each zone's constraintZone
            for (let i = 0; i < zonesToTry.length; i++) {
                const
                    {
                        zone,
                        edgeAlign,
                        constrainRect
                    }    = zonesToTry[i],
                    edge = zoneEdges[zone];

                if (matchSize) {
                    // If we are aligning to the requested edge, or it's opposite edge then
                    // match that edge size, else revert it to our own size
                    result[matchDimension] = edge === edges.theirEdge || edge == oppositeEdge[edges.theirEdge] ? targetRect[matchDimension] : me[matchDimension];
                }

                // Do a simple align to the current edge
                result = result.alignTo({
                    target : targetRect,
                    edgeAlign,
                    targetMargin
                });

                let solution = result.constrainTo(constrainRect);

                // As soon as we find a zone into which the result is willing to be constrained. return it
                if (solution) {
                    solution.zone = zone;
                    solution.position = zoneNames[zone];
                    return solution;
                }
            }
        }

        // Add the configurable finishing touch.
        if (offset) {
            result.moveBy(offset);
        }

        return result;
    }

    getAnchorPoint(edgeZone, edgeOffset, edgeUnit, margin = emptyArray) {
        const me = this;

        let result;

        // Edge zones go top, right, bottom, left
        // Each one calculates the start point of that edge then moves along it by
        // the edgeOffset, then moves *away* from it by the margin for that edge if there's a margin.
        switch (edgeZone) {
            case 0:
                result = [me.x, me.y - (margin[0] || 0), me.width, 0];
                break;
            case 1:
                result = [me.x + me.width + (margin[1] || 0), me.y, me.height, 1];
                break;
            case 2:
                result = [me.x, me.y + me.height + (margin[2] || 0), me.width, 0];
                break;
            case 3:
                result = [me.x - (margin[3] || 0), me.y, me.height, 1];
        }
        result[result[3]] += edgeUnit === '%' ? result[2] / 100 * edgeOffset : edgeOffset;
        result.length = 2;
        return result;
    }

    equals(other) {
        return other instanceof DOMRect &&
            other.x === this.x &&
            other.y === this.y &&
            other.height === this.height &&
            other.width === this.width;
    }

    // For debugging purposes only
    show(color = 'red') {
        const div = document.createElement('div');

        div.style = `
            position:absolute;
            transform:translate3d(${this.x}px, ${this.y}px, 0);
            height:${this.height}px;
            width:${this.width}px;
            background-color:${color}
        `;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 30000);
        return div;
    }

    /**
     * When using JSON.stringify(this), we want to add minHeight & minWidth to the output.
     * @returns {Object}
     */
    toJSON() {
        const {bottom, height, left, minHeight, minWidth, right, top, width, x, y} = this;
        return {bottom, height, left, minHeight, minWidth, right, top, width, x, y}
    }
}


/***/ }),

/***/ "./src/util/Style.mjs":
/*!****************************!*\
  !*** ./src/util/Style.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Style
 * @extends Neo.core.Base
 */
class Style extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Style'
         * @protected
         */
        className: 'Neo.util.Style'
    }

    /**
     * Creates an delta object, containing the styles of newStyle which are not included or different than in oldStyle
     * Styles included in oldStyle but missing in newStyle will get a value of null
     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
     * @param {Object|String} newStyle
     * @param {Object|String} oldStyle
     * @returns {Object} style delta
     */
    static compareStyles(newStyle, oldStyle) {
        let styles = {};

        if (Neo.isString(newStyle)) {
            newStyle = Neo.createStyleObject(newStyle)
        }

        if (Neo.isString(oldStyle)) {
            oldStyle = Neo.createStyleObject(oldStyle)
        }

        if (!newStyle && !oldStyle) {
            return null
        } else if (!oldStyle) {
            return Neo.clone(newStyle)
        } else if (!newStyle) {
            Object.keys(oldStyle).forEach(function(style) {
                styles[style] = null
            });
        } else {
            Object.keys(newStyle).forEach(style => {
                if (!oldStyle.hasOwnProperty(style) || oldStyle[style] !== newStyle[style]) {
                    styles[style] = newStyle[style]
                }
            });

            Object.keys(oldStyle).forEach(style => {
                if (!newStyle.hasOwnProperty(style)) {
                    styles[style] = null
                }
            });

            if (Object.keys(styles).length > 0) {
                return styles
            }

            return null
        }
    }
}

Neo.setupClass(Style);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Style);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDQztBQUNSO0FBQ087QUFDRTtBQUNQO0FBQ0Q7QUFDSztBQUNEO0FBQ0o7QUFDRDtBQUNBO0FBQ0M7O0FBRWpEO0FBQ0EsbUZBQW1GLE1BQU07QUFDekY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFRO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWUsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtB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QUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvS2V5TmF2aWdhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1JlY3RhbmdsZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1N0eWxlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IENvcmVCYXNlICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgRG9tRXZlbnRNYW5hZ2VyICBmcm9tICcuLi9tYW5hZ2VyL0RvbUV2ZW50Lm1qcyc7XG5pbXBvcnQgS2V5TmF2aWdhdGlvbiAgICBmcm9tICcuLi91dGlsL0tleU5hdmlnYXRpb24ubWpzJztcbmltcG9ydCBMb2dnZXIgICAgICAgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgICAgICAgIGZyb20gJy4uL3V0aWwvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgU3R5bGUgICAgICAgICAgICBmcm9tICcuLi91dGlsL1N0eWxlLm1qcyc7XG5pbXBvcnQgVXRpbCAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL1V0aWwubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuaW1wb3J0IFZOb2RlVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WTm9kZS5tanMnO1xuXG5jb25zdFxuICAgIGFkZFVuaXRzICAgICAgICAgID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogaXNOYU4odmFsdWUpID8gdmFsdWUgOiBgJHt2YWx1ZX1weGAsXG4gICAgY2xvc2VzdENvbnRyb2xsZXIgPSBTeW1ib2wuZm9yKCdjbG9zZXN0Q29udHJvbGxlcicpLFxuICAgIGNsb3Nlc3RNb2RlbCAgICAgID0gU3ltYm9sLmZvcignY2xvc2VzdE1vZGVsJyksXG4gICAgbGVuZ3RoUkUgICAgICAgICAgPSAvXlxcZCtcXHcrJC87XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaGlkZU1vZGVcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaGlkZU1vZGVzPVsncmVtb3ZlRG9tJywndmlzaWJpbGl0eSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaGlkZU1vZGVzID0gWydyZW1vdmVEb20nLCAndmlzaWJpbGl0eSddXG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBhbGlnbm1lbnQgc3BlY2lmaWNhdGlvbiB0byBwb3NpdGlvbiB0aGlzIENvbXBvbmVudCByZWxhdGl2ZSB0byBzb21lIG90aGVyXG4gICAgICAgICAqIENvbXBvbmVudCwgb3IgRWxlbWVudCBvciBSZWN0YW5nbGUuIE9ubHkgYXBwbGllcyBpbiBjYXNlIGZsb2F0aW5nID0gdHJ1ZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ30gYWxpZ25fPXtlZGdlQWxpZ246J3QtYicsY29uc3RyYWluVG86J2RvY3VtZW50LmJvZHknfVxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ25fOiB7XG4gICAgICAgICAgICBlZGdlQWxpZ24gIDogJ3QtYicsXG4gICAgICAgICAgICBjb25zdHJhaW5UbzogJ2RvY3VtZW50LmJvZHknXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgQXBwIHRoaXMgY29tcG9uZW50IGJlbG9uZ3MgdG9cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFwcE5hbWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IG1vdW50cyBhIGNvbXBvbmVudCBhZnRlciBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgICogVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWwgY29tcG9uZW50IG9mIHlvdXIgYXBwLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9ZmFsc2VcbiAgICAgICAgICogQHR1dG9yaWFsIDAyX0NsYXNzU3lzdGVtXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IHJlbmRlcnMgYSBjb21wb25lbnQgYWZ0ZXIgYmVpbmcgY3JlYXRlZCBpbnNpZGUgdGhlIGluaXQgY2FsbC5cbiAgICAgICAgICogVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWwgY29tcG9uZW50IG9mIHlvdXIgYXBwLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvUmVuZGVyPWZhbHNlXG4gICAgICAgICAqIEBzZWUge0BsaW5rIE5lby5jb21wb25lbnQuQmFzZSNpbml0IGluaXR9XG4gICAgICAgICAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1JlbmRlcjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDU1Mgc2VsZWN0b3JzIHRvIGFwcGx5IHRvIHRoZSByb290IGxldmVsIG5vZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9W11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBjb25maWdzIHRvIG1vZGVsLkNvbXBvbmVudCBkYXRhIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEV4YW1wbGUgZm9yIGEgYnV0dG9uLkJhc2U6XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGJpbmQ6IHtcbiAgICAgICAgICogICAgIGljb25DbHM6IGRhdGEgPT4gYGZhIGZhLXskZGF0YS5pY29ufWAsXG4gICAgICAgICAqICAgICB0ZXh0ICAgOiBkYXRhID0+IGRhdGEuZm9vLmJhclxuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vYmxvYi9kZXYvZXhhbXBsZXMvbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGJpbmQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBDU1Mgc2VsZWN0b3JzIHRvIGFwcGx5IHRvIHRoZSByb290IGxldmVsIG5vZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICogWW91IGNhbiBvdmVycmlkZSBiYXNlQ2xzIHRvIHJlbW92ZSBkZWZhdWx0IHNlbGVjdG9ycy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNsc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hbmFnZXIuRm9jdXMgd2lsbCBjaGFuZ2UgdGhpcyBmbGFnIG9uIGZvY3VzaW4gJiBvdXQgZG9tIGV2ZW50c1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjb250YWluc0ZvY3VzXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluc0ZvY3VzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NpZ24gYSBjb21wb25lbnQgY29udHJvbGxlciB0byB0aGlzIGNvbXBvbmVudCAocGFzcyBhbiBpbXBvcnRlZCBtb2R1bGUgb3IgdGhlIHN0cmluZyBiYXNlZCBjbGFzcyBuYW1lKVxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8U3RyaW5nfSBjb250cm9sbGVyXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sbGVyXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHRvIGFjY2VzcyB0aGUgZGF0YSBjb25maWcgb2YgdGhlIGNsb3Nlc3QgbW9kZWwuQ29tcG9uZW50LlxuICAgICAgICAgKiBSZWFkIG9ubHkuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVkIGNvbXBvbmVudHMgd2lsbCBnZXQgdGhlIG5lby1kaXNhYmxlZCBjbHMgYXBwbGllZCBhbmQgd29uJ3QgcmVjZWl2ZSBET00gZXZlbnRzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVkXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGRvbUxpc3RlbmVyIGNvbmZpZ3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W118bnVsbH0gZG9tTGlzdGVuZXJzXz1udWxsXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFmdGVyU2V0U3RheU9uSG92ZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAqICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICogICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhcbiAgICAgICAgICogICAgICAgICAgICAge21vdXNlZW50ZXI6IG1lLm9uTW91c2VFbnRlciwgc2NvcGU6IG1lfSxcbiAgICAgICAgICogICAgICAgICAgICAge21vdXNlbGVhdmU6IG1lLm9uTW91c2VMZWF2ZSwgc2NvcGU6IG1lfVxuICAgICAgICAgKiAgICAgICAgIClcbiAgICAgICAgICogICAgfVxuICAgICAgICAgKn1cbiAgICAgICAgICovXG4gICAgICAgIGRvbUxpc3RlbmVyc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gdHJ1ZSB0byBkeW5hbWljYWxseSBpbXBvcnQgYSBEcm9wWm9uZSBtb2R1bGUgJiBjcmVhdGUgYW4gaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJvcHBhYmxlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHBhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLkRyb3Bab25lfG51bGx9IGRyb3Bab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcm9wWm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wWm9uZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gcmVuZGVyIHRoaXMgY29tcG9uZW50IGludG8gdGhlIHZpZXdwb3J0IG91dHNpZGUgb2YgdGhlIGRvY3VtZW50IGZsb3dcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZmxvYXRpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgb24gbW91bnRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGFzQmVlbk1vdW50ZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzQmVlbk1vdW50ZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNSZW5kZXJpbmdMaXN0ZW5lcj1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoYXNSZW5kZXJpbmdMaXN0ZW5lcjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIGZvciB2ZG9tIGNoYW5nZXMgYWZ0ZXIgYSBjb21wb25lbnQgZ290IHVubW91bnRlZFxuICAgICAgICAgKiAoZGVsdGEgdXBkYXRlcyBjYW4gbm8gbG9uZ2VyIGdldCBhcHBsaWVkICYgYSBuZXcgcmVuZGVyIGNhbGwgaXMgcmVxdWlyZWQgYmVmb3JlIHJlLW1vdW50aW5nKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNVbm1vdW50ZWRWZG9tQ2hhbmdlc189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzVW5tb3VudGVkVmRvbUNoYW5nZXNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5oZWlnaHQsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gaGVpZ2h0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWlnaHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbCBzZXR0aW5nIHRvIGhpZGUgb3Igc2hvdyB0aGUgY29tcG9uZW50IGFuZFxuICAgICAgICAgKiB5b3UgY2FuIHVzZSBlaXRoZXIgaGlkZSgpL3Nob3coKSBvciBjaGFuZ2UgdGhpcyBjb25maWcgZGlyZWN0bHkgdG8gY2hhbmdlIHRoZSBoaWRkZW4gc3RhdGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGlkZGVuXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZGVuXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciBoaWRlIGFuZCBzaG93IGFuZCBkZWZpbmVzIGlmIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogc2hvdWxkIHVzZSBjc3MgdmlzaWJpbGl0eTonaGlkZGVuJyBvciB2ZG9tOnJlbW92ZURvbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGhpZGVNb2RlXz0ncmVtb3ZlRG9tJ1xuICAgICAgICAgKi9cbiAgICAgICAgaGlkZU1vZGVfOiAncmVtb3ZlRG9tJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3AgbGV2ZWwgaW5uZXJIVE1MIG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGh0bWxfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGh0bWxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGB0cnVlYCB0byBzaG93IGEgc3Bpbm5lciBjZW50ZXJlZCBpbiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBTZXQgdG8gYSBzdHJpbmcgdG8gc2hvdyBhIG1lc3NhZ2UgbmV4dCB0byBhIHNwaW5uZXIgY2VudGVyZWQgaW4gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxTdHJpbmd9IGlzTG9hZGluZz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNMb2FkaW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIHdoaWxlIGFuIHVwZGF0ZSByZXF1ZXN0ICh3b3JrZXIgbWVzc2FnZXMpIGlzIGluIHByb2dyZXNzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVmRvbVVwZGF0aW5nPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzVmRvbVVwZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzaW5nIHRoZSBrZXlzIGNvbmZpZyB3aWxsIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBOZW8udXRpbC5LZXlOYXZpZ2F0aW9uLlxuICAgICAgICAgKiBAc2VlIHtAbGluayBOZW8udXRpbC5LZXlOYXZpZ2F0aW9uIEtleU5hdmlnYXRpb259XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0ga2V5c189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAga2V5c186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHVzZWQgaW5zaWRlIGFmdGVyU2V0SXNMb2FkaW5nKCkgdG8gZGVmaW5lIHRoZSBDU1MgZm9yIHRoZSBsb2FkaW5nIHNwaW5uZXIgaWNvblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbG9hZGluZ1NwaW5uZXJDbHNfPVsnZmEnLCdmYS1zcGlubmVyJywnZmEtc3BpbiddXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkaW5nU3Bpbm5lckNsc186IFsnZmEnLCAnZmEtc3Bpbm5lcicsICdmYS1zcGluJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCBmb3Igc3R5bGUubWF4SGVpZ2h0LCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG1heEhlaWdodF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4SGVpZ2h0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5tYXhXaWR0aCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtYXhXaWR0aF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4V2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1pbkhlaWdodCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtaW5IZWlnaHRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1pbkhlaWdodF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCBmb3Igc3R5bGUubWluV2lkdGgsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gbWluV2lkdGhfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1pbldpZHRoXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsbHkgYWRkIGEgbW9kZWwuQ29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBtb2RlbF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgc3BlY2lmaWMgbW9kZWwgZGF0YSBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBUaGlzIHdpbGwgbWVyZ2UgdGhlIGNvbnRlbnQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBtb2RlbF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWxEYXRhOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCB0byB0aGUgRE9NXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdW50ZWRfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vdW50ZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgaW4gY2FzZSBhbiB1cGRhdGUgY2FsbCBhcnJpdmVzIHdoaWxlIGFub3RoZXIgdXBkYXRlIGlzIHJ1bm5pbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbmVlZHNWZG9tVXBkYXRlXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBuZWVkc1Zkb21VcGRhdGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBwYXJlbnRJZCBkb2VzIG5vdCBtYXRjaCBhIG5lbyBjb21wb25lbnQgaWQsIHlvdSBjYW4gbWFudWFsbHkgc2V0IHRoaXMgdmFsdWUgZm9yIGZpbmRpbmdcbiAgICAgICAgICogdmlldyBjb250cm9sbGVycyBvciBtb2RlbHMuXG4gICAgICAgICAqIFVzZSBjYXNlOiBtYW51YWxseSBkcm9wcGluZyBjb21wb25lbnRzIGludG8gYSB2ZG9tIHN0cnVjdHVyZVxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gcGFyZW50Q29tcG9uZW50Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudENvbXBvbmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyZW50IGNvbXBvbmVudCBpZCBvciBkb2N1bWVudC5ib2R5XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcGFyZW50SWQ9J2RvY3VtZW50LmJvZHknXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRJZDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXkgb2YgUGx1Z2luIE1vZHVsZXMgYW5kIC8gb3IgY29uZmlnIG9iamVjdHNcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gcGx1Z2luc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwbHVnaW5zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBhIHJlZmVyZW5jZSBmb3IgYWNjZXNzaW5nIHRoZSBjb21wb25lbnQgaW5zaWRlIHZpZXcgY29udHJvbGxlcnMuXG4gICAgICAgICAqIFJlZmVyZW5jZXMgd2lsbCBhbHNvIGdldCBtYXBwZWQgaW50byB0aGUgdmRvbSByb290IChkYXRhLXJlZjogdmFsdWUpLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcmVmZXJlbmNlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlZmVyZW5jZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIHRoZSB2aWV3IFJlc3BvbnNpdmUgYnkgYWRkaW5nIGFsdGVybmF0aXZlIGNvbmZpZ3MuXG4gICAgICAgICAqIFRoZSBkZWZpbml0aW9uIGhhcHBlbnMgdmlhIHJlc3BvbnNpdmVDZmdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZXNwb25zaXZlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzcG9uc2l2ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJpbmcgdGhlIHZub2RlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlcmluZ189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyaW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgcm9sZSB0YWcgYXR0cmlidXRlIGZvciB0aGUgdmRvbSByb290LlxuICAgICAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FjY2Vzc2liaWxpdHkvQVJJQS9Sb2xlc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcm9sZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGZvciBzdHlsZSAnb3ZlcmZsb3c6YXV0bycuXG4gICAgICAgICAqIFNldCB0aGlzIHRvICd4JyBvciAneScgdG8gYWRkIHN0eWxlICdvdmVyZmxvdy14JyBvciAnb3ZlcmZsb3cteScgdG8gJ2F1dG8nXG4gICAgICAgICAqIE90aGVyIHRoYW4gZmFsc2UgdGhpcyB3aWxsIGFkZCBjbHMgJ25lby1zY3JvbGxhYmxlJy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxcInhcInxcInlcIn0gc2Nyb2xsYWJsZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgZm9yIGJ1bGsgdXBkYXRlcy4gRW5zdXJlIHRvIHNldCBpdCBiYWNrIHRvIGZhbHNlIGFmdGVyd2FyZHMuXG4gICAgICAgICAqIEludGVybmFsbHkgdGhlIHZhbHVlIHdpbGwgZ2V0IHNhdmVkIGFzIGEgbnVtYmVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkIG1ldGhvZHMgd29uJ3Qgc3RvcCB0aGUgc2lsZW50IG1vZGUgdG9vIGVhcmx5LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWxlbnRWZG9tVXBkYXRlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50VmRvbVVwZGF0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3R5bGUgYXR0cmlidXRlcyBhZGRlZCB0byB0aGlzIHZkb20gcm9vdC4gc2VlOiBnZXRWZG9tUm9vdCgpXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3R5bGVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gcGFzcyBhbiB1c2VkIHRoZW1lIGRpcmVjdGx5IHRvIGFueSBjb21wb25lbnQsXG4gICAgICAgICAqIHRvIHN0eWxlIHNwZWNpZmljIGNvbXBvbmVudCB0cmVlcyBkaWZmZXJlbnRseSBmcm9tIHlvdXIgbWFpbiB2aWV3LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdGhlbWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoZW1lXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCB0b29sdGlwIGNvbmZpZyBvYmplY3Qgb3IgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZGlzcGxheSB0ZXh0XG4gICAgICAgICAqIFNlZSB0b29sdGlwL0Jhc2UubWpzXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGEgc2luZ2xlLCBzaGFyZWQgVG9vbHRpcCBpbnN0YW5jZSBpcyB1c2VkIGZvciBhbGwgd2lkZ2V0cyB3aGljaCByZXF1ZXN0XG4gICAgICAgICAqIGEgdG9vbHRpcC4gSXQgcmVjb25maWd1cmVzIGl0c2VsZiBmcm9tIHRoZSB3aWRnZXQncyBkZWZpbml0aW9uIGp1c3QgYmVmb3JlIHNob3dpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgd2lkZ2V0IG5lZWRzIGl0cyBvd24gaW5zdGFuY2UgZm9yIGFueSByZWFzb24sIGluc2x1ZGUgdGhlIHByb3BlcnR5IGBvd25JbnN0YW5jZSA6IHRydWVgXG4gICAgICAgICAqIGluIHRoZSB0b29sdGlwIGNvbmZpZyBvYmplY3QuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd9IHRvb2x0aXBfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRvb2x0aXBfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkICdwcmltYXJ5JyBhbmQgb3RoZXIgYXR0cmlidXRlcyB0byBtYWtlIGl0IGFuIG91dHN0YW5kaW5nIGRlc2lnblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdWlfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHVpXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wb25lbnQgdm5vZGUgdHJlZS4gQXZhaWxhYmxlIGFmdGVyIHRoZSBjb21wb25lbnQgZ290IHJlbmRlcmVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZub2RlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZub2RlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS53aWR0aCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSB3aWR0aF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1c3RvbSB3aW5kb3dJcyAodGltZXN0YW1wKSB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118bnVsbH0gd3JhcHBlckNsc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlckNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcy4gVXNlZnVsIGluIGNhc2UgZ2V0VmRvbVJvb3QoKSBkb2VzIG5vdCBwb2ludCB0byB0aGUgdG9wIGxldmVsIERPTSBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gd3JhcHBlclN0eWxlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwcGVyU3R5bGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZkb20gbWFya3VwIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17fVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGNoaWxkVXBkYXRlQ2FjaGU9W11cbiAgICAgKi9cbiAgICBjaGlsZFVwZGF0ZUNhY2hlID0gW11cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbltdfSByZXNvbHZlVXBkYXRlQ2FjaGU9W11cbiAgICAgKi9cbiAgICByZXNvbHZlVXBkYXRlQ2FjaGUgPSBbXVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWNjZXNzIHRoZSBBcHAgdGhpcyBjb21wb25lbnQgYmVsb25ncyB0b1xuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5BcHBsaWNhdGlvbnxudWxsfVxuICAgICAqL1xuICAgIGdldCBhcHAoKSB7XG4gICAgICAgIHJldHVybiBOZW8uYXBwc1t0aGlzLmFwcE5hbWVdIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBDb21wb25lbnQgaXMgZnVsbHkgdmlzaWJsZSwgdGhhdCBpcyBpdCBpcyBub3QgaGlkZGVuIGFuZCBoYXMgbm8gaGlkZGVuIGFuY2VzdG9yc1xuICAgICAqL1xuICAgIGdldCBpc1Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdW50ZWQgJiYgIXRoaXMuaGlkZGVuICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNWaXNpYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBjb21wb25lbnQgYmFzZWQgbGlzdGVuZXJzXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBsaXN0ZW5lcnM9e31cbiAgICAgKi9cbiAgICBnZXQgbGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzIHx8IHt9XG4gICAgfVxuICAgIHNldCBsaXN0ZW5lcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWNjZXNzIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLnBhcmVudENvbXBvbmVudCB8fCBtZS5wYXJlbnRJZCA9PT0gJ2RvY3VtZW50LmJvZHknID8gbnVsbCA6IE5lby5nZXRDb21wb25lbnQobWUucGFyZW50SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBhZnRlciB0aGUgY29tcG9uZW50IHJlbmRlcigpIG1ldGhvZCB3YXMgY2FsbGVkLiBBbHNvIGZpcmVzIHRoZSByZW5kZXJlZCBldmVudC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJlZD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZCB8fCBmYWxzZVxuICAgIH1cbiAgICBzZXQgcmVuZGVyZWQodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fcmVuZGVyZWQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3JlbmRlcmVkJywgbWUuaWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0dGVyIHdpbGwgaGFuZGxlIHZkb20gdXBkYXRlcyBhdXRvbWF0aWNhbGx5XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tPXRoaXMuX3Zkb21cbiAgICAgKi9cbiAgICBnZXQgdmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zkb21cbiAgICB9XG4gICAgc2V0IHZkb20odmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZnRlclNldFZkb20odmFsdWUsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBjbHMgdG8gdGhlIHZkb21Sb290XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgYWRkQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWRkIGFkZGl0aW9uYWwgZG9tIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVycyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkb21MaXN0ZW5lcnMgPSB0aGlzLmRvbUxpc3RlbmVycztcblxuICAgICAgICBkb21MaXN0ZW5lcnMucHVzaCguLi52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFaXRoZXIgYSBzdHJpbmcgbGlrZSAnY29sb3I6IHJlZDsgYmFja2dyb3VuZC1jb2xvcjogYmx1ZTsnXG4gICAgICogb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgc3R5bGUgYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhbGwgc3R5bGVzIG9mIHRoaXMuZWxcbiAgICAgKi9cbiAgICBhZGRTdHlsZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBVdGlsLmNyZWF0ZVN0eWxlT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZG86IGFkZCBhIGNoZWNrIGlmIHNvbWV0aGluZyBoYXMgY2hhbmdlZFxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlID0gT2JqZWN0LmFzc2lnbih0aGlzLnN0eWxlLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMud2luZG93SWQsIHRoaXMuX19wcm90b19fKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSA9IG9sZFZhbHVlIHx8IFtdO1xuXG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2ZG9tICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICB2ZG9tUm9vdCA9IG1lLmdldFZkb21Sb290KCksXG4gICAgICAgICAgICBjbHM7XG5cbiAgICAgICAgaWYgKHZkb20gIT09IHZkb21Sb290KSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgdXNpbmcgYSB3cmFwcGVyIG5vZGVcbiAgICAgICAgICAgIHZkb21Sb290LmNscyA9IFsuLi52YWx1ZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWVyZ2UgY2hhbmdlc1xuICAgICAgICAgICAgY2xzID0gTmVvQXJyYXkudW5pb24obWUud3JhcHBlckNscywgdmFsdWUpO1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgTmVvQXJyYXkuZGlmZmVyZW5jZShvbGRWYWx1ZSwgdmFsdWUpKTtcbiAgICAgICAgICAgIHZkb20uY2xzID0gY2xzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaXNWZG9tVXBkYXRpbmcgfHwgbWUuc2lsZW50VmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKG1lLm1vdW50ZWQgJiYgbWUudm5vZGUpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUNscyh2YWx1ZSwgb2xkVmFsdWUsIHZkb21Sb290LmlkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIGFueSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDb25maWcoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5jdXJyZW50V29ya2VyLmlzVXNpbmdWaWV3TW9kZWxzICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBiaW5kaW5nID0gdGhpcy5iaW5kPy5ba2V5XTtcblxuICAgICAgICAgICAgaWYgKGJpbmRpbmc/LnR3b1dheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TW9kZWwoKT8uc2V0RGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkaXNhYmxlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERpc2FibGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGRvbUxpc3RlbmVycyBpbnNpZGUgdGhlIE5lby5tYW5hZ2VyLkRvbUV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERvbUxpc3RlbmVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWU/LlswXSB8fCBvbGRWYWx1ZT8uWzBdKSB7XG4gICAgICAgICAgICBtZS5nZXRDb250cm9sbGVyKCk/LnBhcnNlRG9tTGlzdGVuZXJzKG1lKTtcblxuICAgICAgICAgICAgRG9tRXZlbnRNYW5hZ2VyLnVwZGF0ZURvbUxpc3RlbmVycyhtZSwgdmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcm9wcGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcm9wcGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFtZS5kcm9wWm9uZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvRHJvcFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmRyb3Bab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBvd25lciAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZHJvcFpvbmVDb25maWdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZmxleCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGbGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBgJHt2YWx1ZX0gJHt2YWx1ZX0gMCVgXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRGbGV4ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2ZsZXgnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGhhc1VubW91bnRlZFZkb21DaGFuZ2VzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGFzVW5tb3VudGVkVmRvbUNoYW5nZXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSB8fCAoIXZhbHVlICYmIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudElkcyA9IENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50SWRzKHRoaXMpLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICAgICAgID0gcGFyZW50SWRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5faGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgPSB2YWx1ZSAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRIZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2hlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZGVuIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGlkZGVuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RhdGUgPSB2YWx1ZSA/ICdoaWRlJyA6ICdzaG93JztcblxuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBtZS5oaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScpIHtcbiAgICAgICAgICAgIG1lLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIHx8IG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lW3N0YXRlXSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBtZS5yZXZlcnRGb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZShzdGF0ZSwge2lkOiBtZS5pZH0pO1xuICAgICAgICBtZS5maXJlKCdoaWRkZW5DaGFuZ2UnLCB7aWQ6IG1lLmlkLCBvbGRWYWx1ZSwgdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaHRtbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SHRtbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnaHRtbCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2lkJywgdmFsdWUpO1xuXG4gICAgICAgIG9sZFZhbHVlICYmIENvbXBvbmVudE1hbmFnZXIudW5yZWdpc3RlcihvbGRWYWx1ZSk7XG4gICAgICAgIENvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlzTG9hZGluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNMb2FkaW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSA9PT0gZmFsc2UgJiYgb2xkVmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2NscywgdmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBtYXNrSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZkb20uY24pIHtcbiAgICAgICAgICAgICAgICBtYXNrSW5kZXggPSB2ZG9tLmNuLmZpbmRJbmRleChjID0+IGMuY2xzLmluY2x1ZGVzKCduZW8tbG9hZC1tYXNrJykpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsb2FkIG1hc2tcbiAgICAgICAgICAgICAgICBpZiAobWFza0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuLnNwbGljZShtYXNrSW5kZXgsIDEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2ZG9tLmNuLnB1c2gobWUubG9hZE1hc2sgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogWyduZW8tbG9hZC1tYXNrJ10sXG4gICAgICAgICAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogWyduZW8tbG9hZC1tYXNrLWJvZHknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6IG1lLmxvYWRpbmdTcGlubmVyQ2xzXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1sb2FkaW5nLW1lc3NhZ2UnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICAgICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogIU5lby5pc1N0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1tYXNrZWQnLCB2YWx1ZSk7XG4gICAgICAgICAgICBtZS5zZXQoe2NscywgdmRvbX0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heEhlaWdodCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhIZWlnaHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1heEhlaWdodCA9IGFkZFVuaXRzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnbWF4SGVpZ2h0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXhXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkTWF4V2lkdGggPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21heFdpZHRoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtaW5IZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluSGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRNaW5IZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21pbkhlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluV2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluV2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1pbldpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdtaW5XaWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtpZCwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmhhc0JlZW5Nb3VudGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5kb21MaXN0ZW5lcnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogdGhlIG1haW4gdGhyZWFkIHJlcGx5IG9mIG1vdW50IGFycml2ZXMgYWZ0ZXIgcHVzaGluZyB0aGUgdGFzayBpbnRvIHRoZSBxdWV1ZSB3aGljaCBkb2VzIG5vdCBlbnN1cmUgdGhlIGRvbSBpcyBtb3VudGVkXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgRG9tRXZlbnRNYW5hZ2VyLm1vdW50RG9tTGlzdGVuZXJzKG1lKVxuICAgICAgICAgICAgICAgICAgICB9LCAxNTApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuZG9SZXNvbHZlVXBkYXRlQ2FjaGUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5mbG9hdGluZykge1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGlnblRvKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9jdXMgd2lsbCBiZSBwdXNoZWQgaW50byB0aGUgZmlyc3QgaW5wdXQgZmllbGQgb3Igb3RoZXIgZm9jdXNhYmxlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLmZvY3VzKHtpZCwgY2hpbGRyZW46IHRydWUsIHdpbmRvd0lkfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdtb3VudGVkJywgbWUuaWQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnJldmVydEZvY3VzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVmZXJlbmNlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWZlcmVuY2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2RhdGEtcmVmJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZXNwb25zaXZlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldFJlc3BvbnNpdmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5nZXRQbHVnaW4oJ3Jlc3BvbnNpdmUnKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG1vZHVsZSAgPSBhd2FpdCBpbXBvcnQoYC4uLy4uL3NyYy9wbHVnaW4vUmVzcG9uc2l2ZS5tanNgKSxcbiAgICAgICAgICAgICAgICBwbHVnaW5zID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm9sZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um9sZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgncm9sZScsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2Nyb2xsYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW58bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTY3JvbGxhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBvbGRPdmVyZmxvd0tleSA9ICdvdmVyZmxvdyc7XG5cbiAgICAgICAgICAgIGlmICghTmVvLmlzQm9vbGVhbihvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRPdmVyZmxvd0tleSArPSBOZW8uY2FwaXRhbGl6ZShvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUucmVtb3ZlU3R5bGUoW29sZE92ZXJmbG93S2V5XSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmZsb3dLZXkgPSAnb3ZlcmZsb3cnO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgIU5lby5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dLZXkgKz0gTmVvLmNhcGl0YWxpemUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmFkZFN0eWxlKG92ZXJmbG93S2V5ICsgJzphdXRvJyk7XG4gICAgICAgICAgICAgICAgbWUuYWRkQ2xzKCduZW8tc2Nyb2xsYWJsZScpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnJlbW92ZUNscygnbmVvLXNjcm9sbGFibGUnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdHlsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdHlsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoIXZhbHVlICYmIG9sZFZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGhlbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgfHwgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSAmJiBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRvb2x0aXAgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUb29sdGlwKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKE5lby5ucygnTmVvLnRvb2x0aXAuQmFzZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0KCcuLi90b29sdGlwL0Jhc2UubWpzJykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3Igc3R5bGluZyBwdXJwb3NlcyBvbmx5LlxuICAgICAqIFRvIGRlZmluZSBidXR0b24gc3R5bGVzIG9yIGNvbXBvbmVudCBzdHlsZXMsXG4gICAgICogdGhpcyB3aWxsIGFkZCBhIGNzcyBjbGFzczogbmVvLW50eXBlLXZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VWkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIGBuZW8tJHttZS5udHlwZX0tJHtvbGRWYWx1ZX1gKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCBgbmVvLSR7bWUubnR5cGV9LSR7dmFsdWV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmRvbSBwc2V1ZG8tY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWZG9tKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZkb20odmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2bm9kZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZub2RlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc3luY1Zub2RlVHJlZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkV2lkdGggPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ3dpZHRoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBjb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyO1xuXG4gICAgICAgIGlmIChjb250cm9sbGVyICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgY29tcG9uZW50IGdldHMgbW92ZWQgaW50byBhIGRpZmZlcmVudCB3aW5kb3csIGFuIHVwZGF0ZSBjeWNsZSBtaWdodCBzdGlsbCBiZSBydW5uaW5nLlxuICAgICAgICAvLyBTaW5jZSB0aGUgdXBkYXRlIG1pZ2h0IG5vIGxvbmdlciBnZXQgbWFwcGVkLCB3ZSB3YW50IHRvIHJlLWVuYWJsZSB0aGlzIGluc3RhbmNlIGZvciBmdXR1cmUgdXBkYXRlcy5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmlzVmRvbVVwZGF0aW5nID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd3JhcHBlckNscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdyYXBwZXJDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlID0gb2xkVmFsdWUgfHwgW107XG4gICAgICAgIHZhbHVlICAgID0gdmFsdWUgICAgfHwgW107XG5cbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIHZkb21Sb290ID0gbWUuZ2V0VmRvbVJvb3QoKSxcbiAgICAgICAgICAgIGNscyAgICAgID0gbWUudmRvbT8uY2xzIHx8IFtdO1xuXG4gICAgICAgIGlmICh2ZG9tID09PSB2ZG9tUm9vdCkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtZXJnZSBjaGFuZ2VzXG4gICAgICAgICAgICBjbHMgPSBOZW9BcnJheS51bmlvbihjbHMsIHZhbHVlKTtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkVmFsdWUsIHZhbHVlKSk7XG4gICAgICAgICAgICB2ZG9tLmNscyA9IGNsc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCB1c2luZyBhIHdyYXBwZXIgPT4gY2xzICYgd3JhcHBlckNscyBzaGFyZSB0aGUgc2FtZSBub2RlXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBbXTtcblxuICAgICAgICAgICAgb2xkVmFsdWUgJiYgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAodmRvbSkge1xuICAgICAgICAgICAgICAgIHZkb20uY2xzID0gY2xzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaXNWZG9tVXBkYXRpbmcgfHwgbWUuc2lsZW50VmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUNscyh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdyYXBwZXJTdHlsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXcmFwcGVyU3R5bGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghKCF2YWx1ZSAmJiBvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHZkb20gPSBtZS52ZG9tO1xuXG4gICAgICAgICAgICBpZiAoIXZkb20uaWQpIHtcbiAgICAgICAgICAgICAgICB2ZG9tLnN0eWxlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlU3R5bGUodmFsdWUsIG9sZFZhbHVlLCB2ZG9tLmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpZ25zIHRoZSB0b3AgbGV2ZWwgbm9kZSBpbnNpZGUgdGhlIG1haW4gdGhyZWFkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWM9e31cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBhbGlnblRvKHNwZWM9e30pIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFsaWduID0ge1xuICAgICAgICAgICAgICAgIC4uLm1lLmFsaWduLFxuICAgICAgICAgICAgICAgIC4uLnNwZWMsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgICAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZEZsZXggICAgIDogbWUuY29uZmlndXJlZEZsZXgsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZFdpZHRoICAgIDogbWUuY29uZmlndXJlZFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRIZWlnaHQgICA6IG1lLmNvbmZpZ3VyZWRIZWlnaHQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZE1pbldpZHRoIDogbWUuY29uZmlndXJlZE1pbldpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNaW5IZWlnaHQ6IG1lLmNvbmZpZ3VyZWRNaW5IZWlnaHQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZE1heFdpZHRoIDogbWUuY29uZmlndXJlZE1heFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNYXhIZWlnaHQ6IG1lLmNvbmZpZ3VyZWRNYXhIZWlnaHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFsaWduLnRhcmdldCkge1xuICAgICAgICAgICAgYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLmFsaWduKGFsaWduKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBjbHMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRDbHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gWy4uLnZhbHVlXSA6IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBkYXRhIGNvbmZpZ1xuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHdoaWNoIGlzIGV4cGVuc2l2ZSB0byB1c2UsXG4gICAgICogc2luY2UgaXQgd2lsbCBnZW5lcmF0ZSBhIG1lcmdlZCBwYXJlbnQgbW9kZWwgZGF0YSBtYXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldERhdGEodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwoKS5nZXRIaWVyYXJjaHlEYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIHN0eWxlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRTdHlsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gey4uLnZhbHVlfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgd3JhcHBlckNscyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldFdyYXBwZXJDbHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gWy4uLnZhbHVlXSA6IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSB3cmFwcGVyU3R5bGUgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldFdyYXBwZXJTdHlsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gey4uLk9iamVjdC5hc3NpZ24odGhpcy52ZG9tLnN0eWxlIHx8IHt9LCB2YWx1ZSl9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgYWxpZ24gY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0QWxpZ24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gSnVzdCBhIHNpbXBsZSAndC1iJ1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgZWRnZUFsaWduOiB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVyZ2UgdGhlIGluY29taW5nIGFsaWdubWVudCBzcGVjaWZpY2F0aW9uIGludG8gdGhlIGNvbmZpZ3VyZWQgZGVmYXVsdFxuICAgICAgICByZXR1cm4gTmVvLm1lcmdlKHt9LCB2YWx1ZSwgbWUuY29uc3RydWN0b3IuY29uZmlnLmFsaWduKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGNscyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lb0FycmF5LnVuaW9uKHZhbHVlIHx8IFtdLCB0aGlzLmJhc2VDbHMsIHRoaXMuZ2V0QmFzZUNsYXNzKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGNvbnRyb2xsZXIgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBDcmVhdGVzIGEgY29udHJvbGxlci5Db21wb25lbnQgaW5zdGFuY2UgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fE9iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldENvbnRyb2xsZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkIDogdGhpcy53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRvbUxpc3RlbmVycyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREb21MaXN0ZW5lcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGhpZGVNb2RlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRIaWRlTW9kZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2hpZGVNb2RlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBrZXlzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQ3JlYXRlcyBhIEtleU5hdmlnYXRpb24gaW5zdGFuY2UgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8udXRpbC5LZXlOYXZpZ2F0aW9ufG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEtleXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgS2V5TmF2aWdhdGlvbiwge1xuICAgICAgICAgICAgICAgIGtleURvd25FdmVudEJ1YmJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXlzICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBDcmVhdGVzIGEgbW9kZWwuQ29tcG9uZW50IGluc3RhbmNlIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLm1vZGVsLkNvbXBvbmVudH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlcyA9IHtjb21wb25lbnQ6IG1lfTtcblxuICAgICAgICAgICAgaWYgKG1lLm1vZGVsRGF0YSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXMuZGF0YSA9IG1lLm1vZGVsRGF0YVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCAnTmVvLm1vZGVsLkNvbXBvbmVudCcsIGRlZmF1bHRWYWx1ZXMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHBsdWdpbnMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5wbHVnaW4uQmFzZVtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQbHVnaW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKGl0ZW0sIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNpbGVudFZkb21VcGRhdGUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNpbGVudFZkb21VcGRhdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE5lby5pc051bWJlcihvbGRWYWx1ZSkgPyAob2xkVmFsdWUgKyAxKSA6IDFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSAmJiBvbGRWYWx1ZSA+IDApID8gKG9sZFZhbHVlIC0gMSkgOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWUgb2YgYSB2ZG9tIG9iamVjdCBhdHRyaWJ1dGUgb3IgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IGhhcyBubyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcnxPYmplY3R8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICovXG4gICAgY2hhbmdlVmRvbVJvb3RLZXkoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICByb290ID0gbWUuZ2V0VmRvbVJvb3QoKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJvb3Rba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgcm9vdFtrZXldXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHRvb2x0aXAgaW5zdGFuY2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVUb29sdGlwKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlLm93bkluc3RhbmNlKSB7XG4gICAgICAgICAgICBtZS5fdG9vbHRpcCA9IE5lby5jcmVhdGUoJ05lby50b29sdGlwLkJhc2UnLCB7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50SWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLl90b29sdGlwID0gdmFsdWU7XG4gICAgICAgICAgICBOZW8udG9vbHRpcC5CYXNlLmNyZWF0ZVNpbmdsZXRvbihtZS5hcHApO1xuICAgICAgICAgICAgbWUuYWRkQ2xzKCduZW8tdXNlcy1zaGFyZWQtdG9vbHRpcCcpO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgdGhpcyBpbnN0YW5jZSBmcm9tIHRoZSBDb21wb25lbnRNYW5hZ2VyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1cGRhdGVQYXJlbnRWZG9tPWZhbHNlIHRydWUgdG8gcmVtb3ZlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgcGFyZW50IHZkb20gPT4gcmVhbCBkb21cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZSB0cnVlIHRvIHVwZGF0ZSB0aGUgdmRvbSBzaWxlbnRseSAodXNlZnVsIGZvciBkZXN0cm95aW5nIG11bHRpcGxlIGNoaWxkIGl0ZW1zIGluIGEgcm93KVxuICAgICAqIHRvZG86IHVucmVnaXN0ZXIgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tPWZhbHNlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50LCBwYXJlbnRJZH0gPSBtZSxcbiAgICAgICAgICAgIHBhcmVudE1vZGVsICAgICAgICA9IHBhcmVudD8uZ2V0TW9kZWwoKSxcbiAgICAgICAgICAgIHBhcmVudFZkb207XG5cbiAgICAgICAgbWUucmV2ZXJ0Rm9jdXMoKTtcblxuICAgICAgICBtZS5kb21MaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICBtZS5jb250cm9sbGVyID0gbnVsbDsgLy8gdHJpZ2dlcnMgZGVzdHJveSgpXG5cbiAgICAgICAgbWUucmVmZXJlbmNlICYmIG1lLmdldENvbnRyb2xsZXIoKT8ucmVtb3ZlUmVmZXJlbmNlKG1lKTsgLy8gcmVtb3ZlIG93biByZWZlcmVuY2UgZnJvbSBwYXJlbnQgY29udHJvbGxlcnNcblxuICAgICAgICBtZS5tb2RlbCA9IG51bGw7IC8vIHRyaWdnZXJzIGRlc3Ryb3koKVxuXG4gICAgICAgIG1lLmJpbmQgJiYgcGFyZW50TW9kZWw/LnJlbW92ZUJpbmRpbmdzKG1lLmlkKTtcblxuICAgICAgICBtZS5wbHVnaW5zPy5mb3JFYWNoKHBsdWdpbiA9PiB7XG4gICAgICAgICAgICBwbHVnaW4uZGVzdHJveSgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh1cGRhdGVQYXJlbnRWZG9tICYmIHBhcmVudElkKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50SWQgPT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCB7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkOiBtZS52ZG9tLmlkfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50VmRvbSA9IHBhcmVudC52ZG9tO1xuXG4gICAgICAgICAgICAgICAgVkRvbVV0aWwucmVtb3ZlVmRvbUNoaWxkKHBhcmVudFZkb20sIG1lLnZkb20uaWQpO1xuICAgICAgICAgICAgICAgIHBhcmVudFtzaWxlbnQgPyAnX3Zkb20nIDogJ3Zkb20nXSA9IHBhcmVudFZkb21cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIENvbXBvbmVudE1hbmFnZXIudW5yZWdpc3RlcihtZSk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIFdlIGRvIHdhbnQgdG8gcHJldmVudCBkZWxheWVkIGNhbGxzIGFmdGVyIGEgY29tcG9uZW50IGluc3RhbmNlIGdvdCBkZXN0cm95ZWQuXG4gICAgICAgIG1lLm9uRm9jdXNMZWF2ZSA9IE5lby5lbXB0eUZuO1xuICAgICAgICBtZS51bm1vdW50ICAgICAgPSBOZW8uZW1wdHlGblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFsbCBzdG9yZWQgcmVzb2x2ZSgpIGNhbGxiYWNrc1xuICAgICAqL1xuICAgIGRvUmVzb2x2ZVVwZGF0ZUNhY2hlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5yZXNvbHZlVXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgIG1lLnJlc29sdmVVcGRhdGVDYWNoZS5mb3JFYWNoKGl0ZW0gPT4gaXRlbSgpKTtcbiAgICAgICAgICAgIG1lLnJlc29sdmVVcGRhdGVDYWNoZSA9IFtdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgTmVvLm1hbmFnZXIuQ29tcG9uZW50LmRvd25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD10cnVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBUaGUgbWF0Y2hpbmcgaW5zdGFuY2Ugb3IgbnVsbFxuICAgICAqL1xuICAgIGRvd24oY29uZmlnLCByZXR1cm5GaXJzdE1hdGNoPXRydWUpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1hbmFnZXIuZG93bih0aGlzLCBjb25maWcsIHJldHVybkZpcnN0TWF0Y2gpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIHNlbmQgdXBkYXRlIHJlcXVlc3RzIHRvIHRoZSB2ZG9tIHdvcmtlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVzb2x2ZV0gdXNlZCBieSBwcm9taXNlVXBkYXRlKClcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVqZWN0XSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2V4ZWN1dGVWZG9tVXBkYXRlKHZkb20sIHZub2RlLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgb3B0cyA9IHt2ZG9tLCB2bm9kZX0sXG4gICAgICAgICAgICBkZWx0YXM7XG5cbiAgICAgICAgaWYgKE5lby5jdXJyZW50V29ya2VyLmlzU2hhcmVkV29ya2VyKSB7XG4gICAgICAgICAgICBvcHRzLmFwcE5hbWUgID0gbWUuYXBwTmFtZTtcbiAgICAgICAgICAgIG9wdHMud2luZG93SWQgPSBtZS53aW5kb3dJZFxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNWZG9tVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIHdlIGNhbiBub3Qgc2V0IHRoZSBjb25maWcgZGlyZWN0bHkgPT4gaXQgY291bGQgYWxyZWFkeSBiZSBmYWxzZSxcbiAgICAgICAgLy8gYW5kIHdlIHN0aWxsIHdhbnQgdG8gcGFzcyBpdCBmdXJ0aGVyIGludG8gc3VidHJlZXNcbiAgICAgICAgbWUuX25lZWRzVmRvbVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBtZS5hZnRlclNldE5lZWRzVmRvbVVwZGF0ZT8uKGZhbHNlLCB0cnVlKVxuXG4gICAgICAgIE5lby52ZG9tLkhlbHBlci51cGRhdGUob3B0cykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgYXR0ZW1wdGluZyB0byB1cGRhdGUgY29tcG9uZW50IGRvbScsIGVyciwgbWUpO1xuXG4gICAgICAgICAgICByZWplY3Q/LigpXG4gICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gY2hlY2tpbmcgaWYgdGhlIGNvbXBvbmVudCBnb3QgZGVzdHJveWVkIGJlZm9yZSB0aGUgdXBkYXRlIGN5Y2xlIGlzIGRvbmVcbiAgICAgICAgICAgIGlmIChtZS5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDb21wb25lbnQgdm5vZGUgdXBkYXRlZCcsIGRhdGEpO1xuICAgICAgICAgICAgICAgIG1lLnZub2RlID0gZGF0YS52bm9kZTtcblxuICAgICAgICAgICAgICAgIGRlbHRhcyA9IGRhdGEuZGVsdGFzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uY29uZmlnLnVzZVZkb21Xb3JrZXIgJiYgZGVsdGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIGRlbHRhcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5yZXNvbHZlVmRvbVVwZGF0ZShyZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlc29sdmVWZG9tVXBkYXRlKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGZvY3VzKCkgb24gdGhlIHRvcCBsZXZlbCBET00gbm9kZSBvZiB0aGlzIGNvbXBvbmVudCBvciBvbiBhIGdpdmVuIG5vZGUgdmlhIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkPXRoaXMuaWRcbiAgICAgKi9cbiAgICBmb2N1cyhpZD10aGlzLmlkKSB7XG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5mb2N1cyh7aWQsIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgZHluYW1pYyB2YWx1ZXMgaW50byB0aGlzLmNsc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRCYXNlQ2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLmZsb2F0aW5nKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnbmVvLWZsb2F0aW5nJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuIGluc3RhbmNlIHN0b3JlZCBpbnNpZGUgYSBjb25maWcgdmlhIG9wdGlvbmFsbHkgcGFzc2luZyBhIG50eXBlLlxuICAgICAqIFJldHVybnMgdGhpc1tjb25maWdOYW1lXSBvciB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggYSBtYXRjaC5cbiAgICAgKiBVc2VkIGJ5IGdldENvbnRyb2xsZXIoKSAmIGdldE1vZGVsKClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoY29uZmlnTmFtZSwgbnR5cGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgICAgICAgICAgID0gbWVbY29uZmlnTmFtZV0sXG4gICAgICAgICAgICB7cGFyZW50Q29tcG9uZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChjb25maWcgJiYgKCFudHlwZSB8fCBudHlwZSA9PT0gY29uZmlnLm50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJlbnRDb21wb25lbnQgJiYgbWUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCA9IG1lLnBhcmVudCB8fCBOZW8uZ2V0KG1lLnBhcmVudElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQuZ2V0Q29uZmlnSW5zdGFuY2VCeU50eXBlKGNvbmZpZ05hbWUsIG50eXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMuY29udHJvbGxlciBvciB0aGUgY2xvc2VzdCBwYXJlbnQgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldENvbnRyb2xsZXIobnR5cGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI7XG5cbiAgICAgICAgaWYgKCFudHlwZSkge1xuICAgICAgICAgICAgY29udHJvbGxlciA9IG1lW2Nsb3Nlc3RDb250cm9sbGVyXTtcblxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udHJvbGxlciA9IG1lLmdldENvbmZpZ0luc3RhbmNlQnlOdHlwZSgnY29udHJvbGxlcicsIG50eXBlKTtcblxuICAgICAgICBpZiAoIW50eXBlKSB7XG4gICAgICAgICAgICBtZVtjbG9zZXN0Q29udHJvbGxlcl0gPSBjb250cm9sbGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBpZD10aGlzLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFwcE5hbWU9dGhpcy5hcHBOYW1lXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLnV0aWwuUmVjdGFuZ2xlPn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXREb21SZWN0KGlkPXRoaXMuaWQsIGFwcE5hbWU9dGhpcy5hcHBOYW1lKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBOZW8ubWFpbi5Eb21BY2Nlc3MuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHthcHBOYW1lLCBpZCwgd2luZG93SWQ6IHRoaXMud2luZG93SWR9KTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChyZWN0ID0+IFJlY3RhbmdsZS5jbG9uZShyZWN0KSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWN0YW5nbGUuY2xvbmUocmVzdWx0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcy5tb2RlbCBvciB0aGUgY2xvc2VzdCBwYXJlbnQgbW9kZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8ubW9kZWwuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0TW9kZWwobnR5cGUpIHtcbiAgICAgICAgaWYgKCFOZW8uY3VycmVudFdvcmtlci5pc1VzaW5nVmlld01vZGVscykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBtb2RlbDtcblxuICAgICAgICBpZiAoIW50eXBlKSB7XG4gICAgICAgICAgICBtb2RlbCA9IG1lW2Nsb3Nlc3RNb2RlbF07XG5cbiAgICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbW9kZWwgPSBtZS5nZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoJ21vZGVsJywgbnR5cGUpO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIG1lW2Nsb3Nlc3RNb2RlbF0gPSBtb2RlbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9ub3JzIGRpZmZlcmVudCBpdGVtIHJvb3RzIGZvciBtb3VudCAvIHJlbmRlciBPUHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1vdW50ZWRQYXJlbnRJZCgpIHtcbiAgICAgICAgbGV0IHBhcmVudElkICA9IHRoaXMucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnQgICAgPSBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkKSxcbiAgICAgICAgICAgIGl0ZW1zUm9vdCA9IHBhcmVudD8uZ2V0VmRvbUl0ZW1zUm9vdD8uKCk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zUm9vdCA/IGl0ZW1zUm9vdC5pZCA6IHBhcmVudElkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSByZWFsIHBhcmVudEluZGV4IGluc2lkZSB0aGUgRE9NXG4gICAgICogQHJldHVybnMge051bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0TW91bnRlZFBhcmVudEluZGV4KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICAgICAgICBpdGVtcyAgPSBwYXJlbnQ/Lml0ZW1zIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgID0gMCxcbiAgICAgICAgICAgIGluZGV4ICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpdGVtLmhpZGRlbiAmJiBpdGVtLmhpZGVNb2RlID09PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyZW50IGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICovXG4gICAgZ2V0UGFyZW50cygpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyh0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0c1xuICAgICAqIEByZXR1cm5zIHtOZW8ucGx1Z2luLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4ob3B0cykge1xuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKG9wdHMpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdHMuc3RhcnRzV2l0aCgncGx1Z2luLScpKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9ICdwbHVnaW4tJyArIG9wdHNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0cyA9IHtudHlwZTogb3B0c31cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBoYXNNYXRjaDtcblxuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBtZS5wbHVnaW5zIHx8IFtdKSB7XG4gICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luW2tleV0gIT09IG9wdHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSZWZlcmVuY2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bih7cmVmZXJlbmNlOiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Fsa3MgdXAgdGhlIHZkb20gdHJlZSBhbmQgcmV0dXJucyB0aGUgY2xvc2VzdCB0aGVtZSBmb3VuZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VGhlbWUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRoZW1lTWF0Y2ggPSAnbmVvLXRoZW1lLScsXG4gICAgICAgICAgICBtYWluVmlldywgcGFyZW50Tm9kZXM7XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG1lLmNscyB8fCBbXSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnRzV2l0aCh0aGVtZU1hdGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYWluVmlldyA9IG1lLmFwcD8ubWFpblZpZXc7XG5cbiAgICAgICAgaWYgKG1haW5WaWV3KSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlcyA9IFZEb21VdGlsLmdldFBhcmVudE5vZGVzKG1haW5WaWV3LnZkb20sIG1lLmlkKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHBhcmVudE5vZGVzIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuY2xzIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0YXJ0c1dpdGgodGhlbWVNYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmVvLmNvbmZpZy50aGVtZXM/LlswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBhIHZkb20gY2hpbGQgbm9kZSBieSBpZCBmb3IgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbT10aGlzLnZkb21cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZkb21DaGlsZChpZCwgdmRvbT10aGlzLnZkb20pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKHZkb20sIGlkKTtcbiAgICAgICAgcmV0dXJuIG5vZGU/LnZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZkb20gcm9vdCBpZiBuZWVkZWQgdG8gYXBwbHkgdGhlIHRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzIG9uIGEgZGlmZmVyZW50IGxldmVsLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgZ2V0Vm5vZGVSb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2ZG9tIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWZG9tUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdm5vZGUgcm9vdCBpZiBuZWVkZWQgdG8gYXBwbHkgdGhlIHRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzIG9uIGEgZGlmZmVyZW50IGxldmVsLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgZ2V0VmRvbVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZub2RlIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgY29tcG9uZW50LlxuICAgICAqIGhpZGVNb2RlOiAncmVtb3ZlRG9tJyAgdXNlcyB2ZG9tIHJlbW92ZURvbS5cbiAgICAgKiBoaWRlTW9kZTogJ3Zpc2liaWxpdHknIHVzZXMgY3NzIHZpc2liaWxpdHkuXG4gICAgICogSWYgaGlkZU1vZGUgPT09ICdyZW1vdmVEb20nIHlvdSBjYW4gcGFzcyBhIHRpbWVvdXQgZm9yIGN1c3RvbSBjc3MgY2xhc3MgaGlkaW5nLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gICAgICovXG4gICAgaGlkZSh0aW1lb3V0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmhpZGVNb2RlICE9PSAndmlzaWJpbGl0eScpIHtcbiAgICAgICAgICAgIGxldCByZW1vdmVGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobWUucGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgICAgICAgICBtZS52ZG9tLnJlbW92ZURvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1lLnBhcmVudC51cGRhdGUoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVubW91bnQoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlbW92ZUZuLCB0aW1lb3V0KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVGbigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBtZS5zdHlsZTtcbiAgICAgICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIG1lLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5faGlkZGVuID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5hdXRvUmVuZGVyICYmIHRoaXMucmVuZGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBhcmUgdXNpbmcgdGhpcyBtZXRob2QgYXMgYSBjdG9yIGhvb2sgaGVyZSB0byBhZGQgdGhlIGluaXRpYWwgbW9kZWwuQ29tcG9uZW50ICYgY29udHJvbGxlci5Db21wb25lbnQgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGluaXRDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgc3VwZXIuaW5pdENvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5nZXRDb250cm9sbGVyKCk/LnBhcnNlQ29uZmlnKG1lKTtcbiAgICAgICAgbWUuZ2V0TW9kZWwoKSAgICAgPy5wYXJzZUNvbmZpZyhtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIHZkb20gdXBkYXRlcyBpbnNpZGUgdGhlIHBhcmVudCBjaGFpbiBhbmQgaWYgZm91bmQuXG4gICAgICogUmVnaXN0ZXJzIHRoZSBjb21wb25lbnQgZm9yIGEgdmRvbSB1cGRhdGUgb25jZSBkb25lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRJZD10aGlzLnBhcmVudElkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdIGdldHMgcGFzc2VkIGJ5IHVwZGF0ZVZkb20oKVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUGFyZW50VmRvbVVwZGF0aW5nKHBhcmVudElkPXRoaXMucGFyZW50SWQsIHJlc29sdmUpIHtcbiAgICAgICAgaWYgKHBhcmVudElkICE9PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5pc1Zkb21VcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmNvbmZpZy5sb2dWZG9tVXBkYXRlQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCd2ZG9tIHBhcmVudCB1cGRhdGUgY29uZmxpY3Qgd2l0aDonLCBwYXJlbnQsICdmb3I6JywgbWUpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQocGFyZW50LmNoaWxkVXBkYXRlQ2FjaGUsIG1lLmlkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdGhlIHJlc29sdmUgZm4gdG8gaXRzIG93biBjYWNoZSwgc2luY2UgdGhlIHBhcmVudCB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBuZXcgdXBkYXRlKCkgZGlyZWN0bHkgb24gdGhpcyBjbXBcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSAmJiBtZS5yZXNvbHZlVXBkYXRlQ2FjaGUucHVzaChyZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5pc1BhcmVudFZkb21VcGRhdGluZyhwYXJlbnQucGFyZW50SWQsIHJlc29sdmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAgICovXG4gICAgYXN5bmMgbWVhc3VyZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZW5ndGhSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxldCB7aWQsIHdpbmRvd0lkfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhd2FpdCBOZW8ubWFpbi5Eb21BY2Nlc3MubWVhc3VyZSh7aWQsIHZhbHVlLCB3aW5kb3dJZH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIG9yZGVyIGNvbmZpZ3MgYXJlIGFwcGxpZWQgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gc3VwZXIubWVyZ2VDb25maWcoLi4uYXJncyksXG5cbiAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byBzZXQgY3VzdG9tIGNvbmZpZ3MgZm9yIHRoZSB2ZG9tIG9uIGluc3RhbmNlIGxldmVsLFxuICAgICAgICAgICAgLy8gaG93ZXZlciB0aGVyZSB3aWxsIGJlIGFscmVhZHkgYWRkZWQgYXR0cmlidXRlcyAoZS5nLiBpZCksIHNvIGEgbWVyZ2Ugc2VlbXMgdG8gYmUgdGhlIGJlc3Qgc3RyYXRlZ3kuXG4gICAgICAgICAgICB2ZG9tID0gey4uLm1lLl92ZG9tIHx8IHt9LCAuLi5jb25maWcudmRvbSB8fCB7fX07XG5cbiAgICAgICAgLy8gYXZvaWQgYW55IGludGVyZmVyZW5jZSBvbiBwcm90b3R5cGUgbGV2ZWxcbiAgICAgICAgLy8gZG9lcyBub3QgY2xvbmUgZXhpc3RpbmcgTmVvIGluc3RhbmNlc1xuICAgICAgICBtZS5fdmRvbSA9IE5lby5jbG9uZSh2ZG9tLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICBpZiAoY29uZmlnLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgcGFzc2VkIGFuIG9iamVjdCwgbWVyZ2UgaXQgd2l0aCB0aGUgY2xhc3MncyBvd24gc3R5bGVcbiAgICAgICAgICAgIG1lLnN0eWxlID0gTmVvLnR5cGVPZihjb25maWcuc3R5bGUpID09PSAnT2JqZWN0JyA/IHsuLi5jb25maWcuc3R5bGUsIC4uLm1lLmNvbnN0cnVjdG9yLmNvbmZpZy5zdHlsZX0gOiBjb25maWcuc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLndyYXBwZXJTdHlsZSA9IE5lby5jbG9uZShjb25maWcud3JhcHBlclN0eWxlLCBmYWxzZSk7XG5cbiAgICAgICAgZGVsZXRlIGNvbmZpZy5zdHlsZTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5fdmRvbTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy52ZG9tO1xuICAgICAgICBkZWxldGUgY29uZmlnLndyYXBwZXJTdHlsZTtcblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuIGdldCBjYWxsZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBnb3QgcmVuZGVyZWQuIFNlZSB0aGUgYXV0b01vdW50IGNvbmZpZyBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGFzeW5jIG1vdW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY2hpbGQsIGNoaWxkSWRzO1xuXG4gICAgICAgIGlmICghbWUudm5vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHZub2RlIG11c3QgYmUgZ2VuZXJhdGVkIGJlZm9yZSBtb3VudGluZywgdXNlIENvbXBvbmVudC5yZW5kZXIoKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gY2FzZSB0aGUgY29tcG9uZW50IHdhcyBhbHJlYWR5IG1vdW50ZWQsIGdvdCB1bm1vdW50ZWQgYW5kIHJlY2VpdmVkIHZkb20gY2hhbmdlcyBhZnRlcndhcmRzLFxuICAgICAgICAvLyBhIG5ldyByZW5kZXIoKSBjYWxsIGlzIG1hbmRhdG9yeSBzaW5jZSBkZWx0YSB1cGRhdGVzIGNvdWxkIG5vdCBnZXQgYXBwbGllZC5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjbGVhciB0aGUgaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgc3RhdGUgZm9yIGFsbCBjaGlsZCBjb21wb25lbnRzXG4gICAgICAgIGlmIChtZS5oYXNVbm1vdW50ZWRWZG9tQ2hhbmdlcykge1xuICAgICAgICAgICAgLy8gdG9kbzogdGhlIGhhc1VubW91bnRlZFZkb21DaGFuZ2VzIGZsYWcgY2hhbmdlcyBzaG91bGQgaGFwcGVuIG9uIHJlbmRlclxuICAgICAgICAgICAgbWUuaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgY2hpbGRJZHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkSWRzKG1lLnZub2RlKTtcblxuICAgICAgICAgICAgY2hpbGRJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5faGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgPSBmYWxzZTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZW5kIHRvZG9cblxuICAgICAgICAgICAgbWUucmVuZGVyKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBOZW8uY3VycmVudFdvcmtlci5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gICAgIDogJ21vdW50RG9tJyxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgaHRtbCAgICAgICA6IG1lLnZub2RlLm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCAgIDogbWUuZ2V0TW91bnRlZFBhcmVudElkKCksXG4gICAgICAgICAgICAgICAgcGFyZW50SW5kZXg6IG1lLmdldE1vdW50ZWRQYXJlbnRJbmRleCgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVsZXRlIG1lLnZkb20ucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTtcblxuICAgICAgICAgICAgbWUubW91bnRlZCA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgbmVlZHNWZG9tVXBkYXRlIGNvbmZpZyBpbnNpZGUgdGhlIHBhcmVudCB0cmVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudElkPXRoaXMucGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV0gZ2V0cyBwYXNzZWQgYnkgdXBkYXRlVmRvbSgpXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgbmVlZHNQYXJlbnRVcGRhdGUocGFyZW50SWQ9dGhpcy5wYXJlbnRJZCwgcmVzb2x2ZSkge1xuICAgICAgICBpZiAocGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5lZWRzVmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVzb2x2ZVVwZGF0ZUNhY2hlLnB1c2goLi4ubWUucmVzb2x2ZVVwZGF0ZUNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSAmJiBwYXJlbnQucmVzb2x2ZVVwZGF0ZUNhY2hlLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlc29sdmVVcGRhdGVDYWNoZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5uZWVkc1BhcmVudFVwZGF0ZShwYXJlbnQucGFyZW50SWQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG4gICAgICAgIHRoaXMua2V5cz8ucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXNFbnRlcihkYXRhKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBoaWRkZW4sIG9yIHVubW91bnRlZCB3aGlsZSB3ZSBzdGlsbCBjb250YWluIGZvY3VzLCB3ZSBoYXZlIHRvIHJldmVydFxuICAgICAgICAvLyBmb2N1cyB0byB3aGVyZSBpdCBjYW1lIGZyb20gaWYgcG9zc2libGVcbiAgICAgICAgdGhpcy5mb2N1c0VudGVyRGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICB0aGlzLmZvY3VzRW50ZXJEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgbWFuYWdlci5Gb2N1c1xuICAgICAqIEBuYW1lIG9uRm9jdXNFbnRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBtYW5hZ2VyLkZvY3VzXG4gICAgICogQG5hbWUgb25Gb2N1c0xlYXZlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJ5IG1hbmFnZXIuRm9jdXNcbiAgICAgKiBAbmFtZSBvbkZvY3VzTW92ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMubmV3UGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLm9sZFBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIGZyb20gdGhlIHJlbmRlcigpIHByb21pc2Ugc3VjY2VzcyBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGF1dG9Nb3VudCBNb3VudCB0aGUgRE9NIGFmdGVyIHRoZSB2bm9kZSBnb3QgY3JlYXRlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblJlbmRlcihkYXRhLCBhdXRvTW91bnQpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHB9ID0gbWU7XG5cbiAgICAgICAgbWUucmVuZGVyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgYXBwIGlzIGEgY2hlY2sgdG8gc2VlIGlmIHRoZSBDb21wb25lbnQgZ290IGRlc3Ryb3llZCB3aGlsZSByZW5kZXJpbmcgPT4gYmVmb3JlIG9uUmVuZGVyIGdvdCB0cmlnZ2VyZWRcbiAgICAgICAgaWYgKGFwcCkge1xuICAgICAgICAgICAgaWYgKCFhcHAucmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBhcHAucmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYXBwLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhcHAuZmlyZSgncmVuZGVyJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUudm5vZGUgPSBkYXRhO1xuXG4gICAgICAgICAgICBsZXQgY2hpbGRJZHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkSWRzKGRhdGEpLFxuICAgICAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gICAgICA9IGNoaWxkSWRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjaGlsZDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gTmVvLmdldENvbXBvbmVudChjaGlsZElkc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucmVuZGVyZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5fcmVuZGVyZWQgPSB0cnVlOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICBtZS5maXJlKCdyZW5kZXJlZCcsIG1lLmlkKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbmRlcmVkOiAnICsgbWUuYXBwTmFtZSArICcgJyArIG1lLmlkLCBtZSk7XG5cbiAgICAgICAgICAgIGlmIChhdXRvTW91bnQpIHtcbiAgICAgICAgICAgICAgICBtZS5tb3VudGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICghYXBwLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhcHAuZmlyZSgnbW91bnRlZCcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvbWlzZSBiYXNlZCB2ZG9tIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tPXRoaXMudmRvbVxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IHZub2RlPSB0aGlzLnZub2RlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9taXNlVXBkYXRlKHZkb20gPSB0aGlzLnZkb20sIHZub2RlID0gdGhpcy52bm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWZG9tKHZkb20sIHZub2RlLCByZXNvbHZlLCByZWplY3QpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY2xzIGZyb20gdGhlIHZkb21Sb290XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgcmVtb3ZlQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHZhbHVlXG4gICAgICovXG4gICAgcmVtb3ZlRG9tTGlzdGVuZXJzKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZG9tTGlzdGVuZXJzfSA9IG1lLFxuICAgICAgICAgICAgaSwgbGVuO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIGxlbiA9IGRvbUxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzRXF1YWwoaXRlbSwgZG9tTGlzdGVuZXJzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21MaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZG9tTGlzdGVuZXJzID0gZG9tTGlzdGVuZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgc3RyaW5nIGxpa2UgJ2NvbG9yJyBvciBhbiBhcnJheSBjb250YWluaW5nIHN0eWxlIGF0dHJpYnV0ZXMgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHZhbHVlIGNhbWVsQ2FzZSBvbmx5XG4gICAgICogQHJldHVybnMge09iamVjdH0gYWxsIHN0eWxlcyBvZiB0aGlzLmVsXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQge3N0eWxlfSAgPSB0aGlzLFxuICAgICAgICAgICAgZG9VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlW2tleV07XG4gICAgICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkb1VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB2bm9kZSB0cmVlIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgbW91bnRzIHRoZSBjb21wb25lbnQgaW4gY2FzZVxuICAgICAqIC0geW91IHBhc3MgdHJ1ZSBmb3IgdGhlIG1vdW50IHBhcmFtXG4gICAgICogLSBvciB0aGUgYXV0b01vdW50IGNvbmZpZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21vdW50XSBNb3VudCB0aGUgRE9NIGFmdGVyIHRoZSB2bm9kZSBnb3QgY3JlYXRlZFxuICAgICAqL1xuICAgIGFzeW5jIHJlbmRlcihtb3VudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhdXRvTW91bnQgICAgID0gbW91bnQgfHwgbWUuYXV0b01vdW50LFxuICAgICAgICAgICAgYXBwICAgICAgICAgICA9IG1lLmFwcCxcbiAgICAgICAgICAgIHVzZVZkb21Xb3JrZXIgPSBOZW8uY29uZmlnLnVzZVZkb21Xb3JrZXI7XG5cbiAgICAgICAgbWUucmVuZGVyaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWFwcC5yZW5kZXJlZCkge1xuICAgICAgICAgICAgYXBwLnJlbmRlcmluZyA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS52ZG9tKSB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZS52ZG9tLnJlbW92ZURvbTtcblxuICAgICAgICAgICAgbWUuX25lZWRzVmRvbVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbWUuYWZ0ZXJTZXROZWVkc1Zkb21VcGRhdGU/LihmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBOZW8udmRvbS5IZWxwZXIuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBhdXRvTW91bnQsXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgICA6IGF1dG9Nb3VudCA/IG1lLmdldE1vdW50ZWRQYXJlbnRJZCgpICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhcmVudEluZGV4OiBhdXRvTW91bnQgPyBtZS5nZXRNb3VudGVkUGFyZW50SW5kZXgoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCAgIDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgLi4ubWUudmRvbVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLm9uUmVuZGVyKGRhdGEsIHVzZVZkb21Xb3JrZXIgPyBhdXRvTW91bnQgOiBmYWxzZSk7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBhdXRvTW91bnQgJiYgIXVzZVZkb21Xb3JrZXIgJiYgbWUubW91bnQoKTtcblxuICAgICAgICAgICAgbWUucmVzb2x2ZVZkb21VcGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZuIHRvIHJlc29sdmUgdGhlIFByb21pc2UgZm9yIHVwZGF0ZVZkb20oKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258dW5kZWZpbmVkfSByZXNvbHZlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlc29sdmVWZG9tVXBkYXRlKHJlc29sdmUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kb1Jlc29sdmVVcGRhdGVDYWNoZSgpO1xuXG4gICAgICAgIHJlc29sdmU/LigpO1xuXG4gICAgICAgIGlmIChtZS5uZWVkc1Zkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIGlmIGEgbmV3IHVwZGF0ZSBpcyBzY2hlZHVsZWQsIHdlIGNhbiBjbGVhciB0aGUgY2FjaGUgPT4gdGhlc2UgdXBkYXRlcyBhcmUgaW5jbHVkZWRcbiAgICAgICAgICAgIG1lLmNoaWxkVXBkYXRlQ2FjaGUgPSBbXTtcblxuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfSBlbHNlIGlmIChtZS5jaGlsZFVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICBbLi4ubWUuY2hpbGRVcGRhdGVDYWNoZV0uZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgTmVvLmdldENvbXBvbmVudChpZCk/LnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShtZS5jaGlsZFVwZGF0ZUNhY2hlLCBpZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJldmVydEZvY3VzKCkge1xuICAgICAgICBsZXQgcmVsYXRlZFRhcmdldCA9IHRoaXMuZm9jdXNFbnRlckRhdGE/LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNGb2N1cyAmJiByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KHJlbGF0ZWRUYXJnZXQuaWQpPy5mb2N1cygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgbXVsdGlwbGUgY29uZmlncyBhdCBvbmNlLCBlbnN1cmluZyB0aGF0IGFsbCBhZnRlclNldCBtZXRob2RzIGdldCBhbGwgbmV3IGFzc2lnbmVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgc2V0KHZhbHVlcz17fSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuZWVkc1JlbmRlcmluZyA9IHZhbHVlcy5oaWRkZW4gPT09IGZhbHNlICYmIHZhbHVlcy5oaWRkZW4gIT09IG1lLmhpZGRlbjtcblxuICAgICAgICBtZS5zaWxlbnRWZG9tVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICBzdXBlci5zZXQodmFsdWVzKTtcblxuICAgICAgICBtZS5zaWxlbnRWZG9tVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNpbGVudCB8fCAhbWUubmVlZHNWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZWVkc1JlbmRlcmluZykge1xuICAgICAgICAgICAgICAgIG1lLnNob3coKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1lLnByb21pc2VVcGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgY2FsbGluZyBzZXQoKSB3aXRoIHRoZSBzaWxlbnQgZmxhZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKi9cbiAgICBzZXRTaWxlbnQodmFsdWVzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHZhbHVlcywgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBjb21wb25lbnQuXG4gICAgICogaGlkZU1vZGU6ICdyZW1vdmVEb20nICB1c2VzIHZkb20gcmVtb3ZlRG9tLlxuICAgICAqIGhpZGVNb2RlOiAndmlzaWJpbGl0eScgdXNlcyBjc3MgdmlzaWJpbGl0eS5cbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmhpZGVNb2RlICE9PSAndmlzaWJpbGl0eScpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS52ZG9tLnJlbW92ZURvbTtcblxuICAgICAgICAgICAgaWYgKG1lLnNpbGVudFZkb21VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS5uZWVkc1Zkb21VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lLnBhcmVudElkICE9PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgICAgICBtZS5wYXJlbnQudXBkYXRlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIW1lLm1vdW50ZWQgJiYgbWUucmVuZGVyKHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBtZS5zdHlsZTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZS52aXNpYmlsaXR5O1xuICAgICAgICAgICAgbWUuc3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuX2hpZGRlbiA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIGZvciB1dGlsLlZEb20uc3luY1Zkb21JZHMgdG8gYWxsb3cgb3ZlcnJpZGluZyAoZGlzYWJsaW5nKSBpdFxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IFt2bm9kZT10aGlzLnZub2RlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbT10aGlzLnZkb21dXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZT1mYWxzZVxuICAgICAqL1xuICAgIHN5bmNWZG9tSWRzKHZub2RlID0gdGhpcy52bm9kZSwgdmRvbSA9IHRoaXMudmRvbSwgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBWRG9tVXRpbC5zeW5jVmRvbUlkcyh2bm9kZSwgdmRvbSwgZm9yY2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBhIGNvbXBvbmVudCByZWNlaXZlcyBhIG5ldyB2bm9kZSwgd2Ugd2FudCB0byBkbzpcbiAgICAgKiAtIHN5bmMgdGhlIHZkb20gaWRzXG4gICAgICogLSBzZXR0aW5nIHJlbmRlcmVkIHRvIHRydWUgZm9yIGNoaWxkIGNvbXBvbmVudHNcbiAgICAgKiAtIHVwZGF0aW5nIHRoZSBwYXJlbnQgY29tcG9uZW50IHRvIGVuc3VyZSB0aGF0IHRoZSB2bm9kZSB0cmVlIHN0YXlzIHBlcnNpc3RlbnRcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBbdm5vZGU9dGhpcy52bm9kZV1cbiAgICAgKi9cbiAgICBzeW5jVm5vZGVUcmVlKHZub2RlPXRoaXMudm5vZGUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRlYnVnID0gZmFsc2UsXG4gICAgICAgICAgICBjaGlsZFZub2RlLCBzdGFydDtcblxuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnN5bmNWZG9tSWRzKCk7XG5cbiAgICAgICAgLy8gZGVsZWdhdGUgdGhlIGxhdGVzdCBub2RlIHVwZGF0ZXMgdG8gYWxsIHBvc3NpYmxlIGNoaWxkIGNvbXBvbmVudHMgZm91bmQgaW5zaWRlIHRoZSB2bm9kZSB0cmVlXG4gICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0Q2hpbGRyZW4obWUpLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgIGNoaWxkVm5vZGUgPSBWTm9kZVV0aWwuZmluZENoaWxkVm5vZGUobWUudm5vZGUsIGNvbXBvbmVudC52ZG9tLmlkKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkVm5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuX3Zub2RlID0gY2hpbGRWbm9kZS52bm9kZTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQucmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Ll9yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKCdyZW5kZXJlZCcsIGNvbXBvbmVudC5pZClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQubW91bnRlZCA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzeW5jVm5vZGVUcmVlOiBDb3VsZCBub3QgcmVwbGFjZSB0aGUgY2hpbGQgdm5vZGUgZm9yJywgY29tcG9uZW50LmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhtZS52bm9kZSwgbWUubW91bnRlZCk7XG5cbiAgICAgICAgLy8ga2VlcCB0aGUgdm5vZGUgcGFyZW50IHRyZWUgaW4gc3luY1xuICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2goKGNvbXBvbmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQudm5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLnZub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiAhVk5vZGVVdGlsLnJlbW92ZUNoaWxkVm5vZGUoY29tcG9uZW50LnZub2RlLCBtZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGZhaWwsIGluIGNhc2UgdGhlIHZub2RlIGlzIGFscmVhZHkgcmVtb3ZlZCAobm90IGFuIGlzc3VlLCBiZXR0ZXIgc2FmZSB0aGFuIHNvcnJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCdzeW5jVm5vZGVUcmVlOiBDb3VsZCBub3QgcmVtb3ZlIHRoZSBwYXJlbnQgdm5vZGUgZm9yJywgbWUuaWQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHluYW1pY2FsbHkgcmVuZGVyZWQgY29tcG9uZW50cyB3aGljaCBnZXQgaW5zZXJ0ZWQgaW50byB0aGUgY29tcG9uZW50IHRyZWVcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gMCAmJiBtZS52bm9kZS5vdXRlckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2R5biBpdGVtJywgbWUudm5vZGUsIG1lLnBhcmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnZub2RlLmNoaWxkTm9kZXMuc3BsaWNlKG1lLnBhcmVudEluZGV4IHx8IDAsIDAsIG1lLnZub2RlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIVZOb2RlVXRpbC5yZXBsYWNlQ2hpbGRWbm9kZShjb21wb25lbnQudm5vZGUsIG1lLnZub2RlLmlkLCBtZS52bm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogY2FuIGhhcHBlbiBmb3IgZHluYW1pY2FsbHkgaW5zZXJ0ZWQgY29udGFpbmVyIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2Fybignc3luY1Zub2RlVHJlZTogQ291bGQgbm90IHJlcGxhY2UgdGhlIHBhcmVudCB2bm9kZSBmb3InLCBtZS52bm9kZS5pZCwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlYnVnICYmIGNvbnNvbGUubG9nKCdzeW5jVm5vZGVUcmVlJywgbWUuaWQsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIGEgY2xzIGluc2lkZSB0aGUgdmRvbVJvb3Qgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FkZF0gVXNlIHRoaXMgcGFyYW0gdG8gZW5mb3JjZSBhbiBhZGQoKSBvciByZW1vdmUoKSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgdG9nZ2xlQ2xzKHZhbHVlLCBhZGQpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsIHZhbHVlLCBhZGQpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbXBvbmVudCBET01cbiAgICAgKi9cbiAgICB1bm1vdW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZTtcblxuICAgICAgICBtZS5faGlkZGVuID0gdHJ1ZTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICBtZS5tb3VudGVkID0gZmFsc2U7XG5cbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHthY3Rpb246ICdyZW1vdmVOb2RlJywgaWQ6IG1lLnZkb20uaWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBOZW8ubWFuYWdlci5Db21wb25lbnQudXBcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gVGhlIG1hdGNoaW5nIGluc3RhbmNlIG9yIG51bGxcbiAgICAgKi9cbiAgICB1cChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1hbmFnZXIudXAodGhpcy5pZCwgY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFmdGVyU2V0VmRvbSh0aGlzLnZkb20sIG51bGwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsdGEgdXBkYXRlcyBmb3IgdGhlIGNscyBjb25maWcuIEdldHMgY2FsbGVkIGFmdGVyIHRoZSBjbHMgY29uZmlnIGdldHMgY2hhbmdlZCBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBjbHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRDbHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQ9dGhpcy5pZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVDbHMoY2xzLCBvbGRDbHMsIGlkPXRoaXMuaWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2bm9kZX0gICAgID0gbWUsXG4gICAgICAgICAgICB2bm9kZVRhcmdldCA9IHZub2RlICYmIFZOb2RlVXRpbC5maW5kQ2hpbGRWbm9kZShtZS52bm9kZSwge2lkfSk/LnZub2RlO1xuXG4gICAgICAgIGlmICh2bm9kZSAmJiAhTmVvLmlzRXF1YWwoY2xzLCBvbGRDbHMpKSB7XG4gICAgICAgICAgICBpZiAodm5vZGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2bm9kZVRhcmdldC5jbGFzc05hbWUgPSBjbHM7IC8vIGtlZXAgdGhlIHZub2RlIGluIHN5bmNcbiAgICAgICAgICAgICAgICBtZS52bm9kZSA9IHZub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGNsczoge1xuICAgICAgICAgICAgICAgICAgICBhZGQgICA6IE5lb0FycmF5LmRpZmZlcmVuY2UoY2xzLCBvbGRDbHMpLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkQ2xzLCBjbHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHN0eWxlIGRlbHRhcyBmb3IgbmV3VmFsdWUgJiBvbGRWYWx1ZSBhbmQgYXBwbGllcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSBET00uXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2lkPXRoaXMuaWRdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVN0eWxlKHZhbHVlLCBvbGRWYWx1ZSwgaWQ9dGhpcy5pZCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGVsdGEgPSBTdHlsZS5jb21wYXJlU3R5bGVzKHZhbHVlLCBvbGRWYWx1ZSksXG4gICAgICAgICAgICBvcHRzLCB2ZG9tLCB2bm9kZSwgdm5vZGVTdHlsZTtcblxuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHZkb20gID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCBpZCk7XG4gICAgICAgICAgICB2bm9kZSA9IG1lLnZub2RlICYmIFZOb2RlVXRpbC5maW5kQ2hpbGRWbm9kZShtZS52bm9kZSwgaWQpO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmhhc1VubW91bnRlZFZkb21DaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgPSAhbWUubW91bnRlZCAmJiBtZS5oYXNCZWVuTW91bnRlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZG9tLnZkb20uc3R5bGUgPSB2YWx1ZTsgLy8ga2VlcCB0aGUgdmRvbSBpbiBzeW5jXG5cbiAgICAgICAgICAgIGlmIChtZS5zaWxlbnRWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVTdHlsZSA9IHZub2RlLnZub2RlLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgLy8ga2VlcCB0aGUgdm5vZGUgaW4gc3luY1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhlIGl0ZXJhdGlvbiBzaW5jZSB2ZG9tIHNob3J0Y3V0cyAoaGVpZ2h0LCB3aWR0aCwuLi4pIGxpdmUgd2l0aGluIHRoZSB2bm9kZSBzdHlsZVxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHZub2RlLnZub2RlLnN0eWxlID0gc3R5bGUgd291bGQgbG9zZSB0aGVtLlxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRlbHRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdm5vZGUudm5vZGUuc3R5bGVba2V5XVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGVTdHlsZVtrZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAndXBkYXRlRG9tJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFzOiBbe2lkLCBzdHlsZTogZGVsdGF9XVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLmN1cnJlbnRXb3JrZXIuaXNTaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5hcHBOYW1lID0gbWUuYXBwTmFtZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLnNlbmRNZXNzYWdlKCdtYWluJywgb3B0cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSB2ZG9tIGNvbmZpZyBnZXRzIGNoYW5nZWQgaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIGFscmVhZHkgbW91bnRlZCAoZGVsdGEgdXBkYXRlcykuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb209dGhpcy52ZG9tXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gdm5vZGU9dGhpcy52bm9kZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXNvbHZlXSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZWplY3RdIHVzZWQgYnkgcHJvbWlzZVVwZGF0ZSgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVZkb20odmRvbT10aGlzLnZkb20sIHZub2RlPXRoaXMudm5vZGUsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHAsIG1vdW50ZWQsIHBhcmVudElkfSA9IG1lLFxuICAgICAgICAgICAgbGlzdGVuZXJJZDtcblxuICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8ga2VlcCB0aGUgdmRvbSB0cmVlIHN0YWJsZSB0byBlbnN1cmUgdGhhdCBjb250YWluZXJzIGRvIG5vdCBsb3NlIHRoZSByZWZlcmVuY2VzIHRvIHRoZWlyXG4gICAgICAgIC8vIGNoaWxkIHZkb20gdHJlZXMuIFRoZSBpZiBjYXNlIHNob3VsZCBub3QgaGFwcGVuLCBidXQgaW4gY2FzZSBpdCBkb2VzLCBrZWVwaW5nIHRoZSByZWZlcmVuY2UgYW5kIG1lcmdpbmdcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgb3ZlciBzZWVtcyB0byBiZSB0aGUgYmVzdCBzdHJhdGVneVxuICAgICAgICBpZiAobWUuX3Zkb20gIT09IHZkb20pIHtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKCd2ZG9tIGdvdCByZXBsYWNlZCBmb3I6ICcgKyBtZS5pZCArICcuIENvcHlpbmcgdGhlIGNvbnRlbnQgaW50byB0aGUgcmVmZXJlbmNlIGhvbGRlciBvYmplY3QnKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMobWUuX3Zkb20pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWUuX3Zkb21ba2V5XVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZkb20gPSBPYmplY3QuYXNzaWduKG1lLl92ZG9tLCB2ZG9tKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc29sdmUgJiYgbWUuaXNWZG9tVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIG1lLnJlc29sdmVVcGRhdGVDYWNoZS5wdXNoKHJlc29sdmUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaXNWZG9tVXBkYXRpbmcgfHwgbWUuc2lsZW50VmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtb3VudGVkICYmIG1lLmlzQ29uc3RydWN0ZWQgJiYgIW1lLmhhc1JlbmRlcmluZ0xpc3RlbmVyICYmIGFwcD8ucmVuZGVyaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFzUmVuZGVyaW5nTGlzdGVuZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJJZCA9IGFwcC5vbignbW91bnRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXBwLnVuKCdtb3VudGVkJywgbGlzdGVuZXJJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS52bm9kZSAmJiBtZS51cGRhdGVWZG9tKG1lLnZkb20sIG1lLnZub2RlLCByZXNvbHZlLCByZWplY3QpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmUgJiYgKCFtb3VudGVkIHx8ICF2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVzb2x2ZVVwZGF0ZUNhY2hlLnB1c2gocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFtZS5uZWVkc1BhcmVudFVwZGF0ZShwYXJlbnRJZCwgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgJiYgIW1lLmlzUGFyZW50VmRvbVVwZGF0aW5nKHBhcmVudElkLCByZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAmJiBtb3VudGVkXG4gICAgICAgICAgICAgICAgICAgICYmIHZub2RlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLiNleGVjdXRlVmRvbVVwZGF0ZSh2ZG9tLCB2bm9kZSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmhhc1VubW91bnRlZFZkb21DaGFuZ2VzID0gIW1vdW50ZWQgJiYgbWUuaGFzQmVlbk1vdW50ZWRcbiAgICB9XG59XG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgYWZ0ZXIgZm9jdXNFbnRlciwgZm9jdXNMZWF2ZSBvciBmb2N1c01vdmVcbiAqIEBldmVudCBmb2N1c0NoYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0W119IFtkYXRhLnBhdGhdIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBbZGF0YS5vbGRQYXRoXSBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICovXG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlkIGlzIGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGhcbiAqIEBldmVudCBmb2N1c0VudGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgbm90IGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGhcbiAqIEBldmVudCBmb2N1c0xlYXZlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgaW5jbHVkZWQgaW5zaWRlIHRoZSBkb20gaWQgcGF0aCwgYnV0IHRoZSBwYXRoIGl0c2VsZiBjaGFuZ2VkXG4gKiBAZXZlbnQgZm9jdXNNb3ZlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqL1xuXG5OZW8uc2V0dXBDbGFzcyhCYXNlKTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZTtcbiIsImltcG9ydCBCYXNlICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLktleU5hdmlnYXRpb25cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgS2V5TmF2aWdhdGlvbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuS2V5TmF2aWdhdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuS2V5TmF2aWdhdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdrZXluYXYnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAna2V5bmF2JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsbHkgc3RvcmVzIHRoZSBjb21wb25lbnQgaWQgaW5zaWRlIF9jb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSB0aGUga2V5ZG93biBldmVudCBpcyBzdXBwb3NlZCB0byBidWJibGUgdXB3YXJkcyBpbnNpZGUgdGhlIGNvbXBvbmVudCB0cmVlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGtleURvd25FdmVudEJ1YmJsZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5RG93bkV2ZW50QnViYmxlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGtleXNfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGtleXNfOiBudWxsXG4gICAgfVxuXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2tleXMucHVzaCguLi50aGlzLnBhcnNlS2V5cyh2YWx1ZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V9XG4gICAgICovXG4gICAgYmVmb3JlR2V0Q29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLl9jb21wb25lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBjb21wb25lbnQgaWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb21wb25lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlPy5pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duKGRhdGEpIHtcbiAgICAgICAgLy8gVXNpbmcgdGhlIGNocm9tZSBhdXRvLWZpbGwgZmVhdHVyZSBkb2VzIHRyaWdnZXIgYSBrZXlkb3duIGV2ZW50LCBub3QgY29udGFpbmluZyBhIGtleS4gU2VlOiAjNjRcbiAgICAgICAgaWYgKGRhdGEua2V5KSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB1cHBlckNhc2VLZXkgPSBkYXRhLmtleS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIHNjb3BlO1xuXG4gICAgICAgICAgICB1cHBlckNhc2VLZXkgPSBtZS5wYXJzZVVwcGVyQ2FzZUtleSh1cHBlckNhc2VLZXkpO1xuXG4gICAgICAgICAgICBtZS5rZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBzY29wZSA9IE5lby5nZXQoa2V5LnNjb3BlKTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkua2V5LnRvVXBwZXJDYXNlKCkgPT09IHVwcGVyQ2FzZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZVtrZXkuZm5dPy5hcHBseShzY29wZSwgW2RhdGFdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHBhcnNlS2V5cyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50SWQgPSB0aGlzLl9jb21wb25lbnQsXG4gICAgICAgICAgICAgICAga2V5QXJyYXkgICAgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBrZXlBcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuICAgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiBjb21wb25lbnRJZCAvLyB0b2RvOiBzdXBwb3J0IFZDcyBsYXRlciBvblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBrZXlBcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgc3BlY2lmaWMga2V5IG5hbWVzLCBlLmcuIFwiIFwiID0+IFNQQUNFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHBhcnNlVXBwZXJDYXNlS2V5KGtleSkge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ1NQQUNFJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVJST1dET1dOJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnRE9XTic7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FSUk9XTEVGVCc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ0xFRlQnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV1JJR0hUJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnUklHSFQnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV1VQJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnVVAnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgbWUua2V5cyAgICAgID0gbWUucGFyc2VLZXlzKG1lLmtleXMpO1xuXG4gICAgICAgIGNvbXBvbmVudC5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAga2V5ZG93bjoge1xuICAgICAgICAgICAgICAgIGJ1YmJsZTogbWUua2V5RG93bkV2ZW50QnViYmxlLFxuICAgICAgICAgICAgICAgIGZuICAgIDogbWUub25LZXlEb3duLFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBrZXkgbGlzdGVuZXIgdXNpbmcgdGhlIHNhbWUgY29uZmlnIHVzZWQgd2hlbiBjcmVhdGluZyBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICByZW1vdmVLZXkoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleXMgPSBtZS5fa2V5cyxcbiAgICAgICAgICAgIGkgICAgPSAwLFxuICAgICAgICAgICAgbGVuICA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNFcXVhbChrZXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG11bHRpcGxlIGtleSBsaXN0ZW5lcnMgcGFzc2luZyBhbiBhcnJheSBvZiBjb25maWcgaXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICAgICAqL1xuICAgIHJlbW92ZUtleXMoaXRlbXMpIHtcbiAgICAgICAgQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMuZm9yRWFjaChpdGVtID0+IHRoaXMucmVtb3ZlS2V5KGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoZSBkb20gbGlzdGVuZXIgZnJvbSB0aGUgb3duZXIgY29tcG9uZW50XG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhLZXlOYXZpZ2F0aW9uKTtcblxuZXhwb3J0IGRlZmF1bHQgS2V5TmF2aWdhdGlvbjtcbiIsIi8qKlxuICogVGhlIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIERPTVJlY3QgT2JqZWN0c1xuICogQGNsYXNzIE5lby51dGlsLlJlY3RhbmdsZVxuICogQGV4dGVuZHMgRE9NUmVjdFxuICovXG5cbmNvbnN0XG4gICAgZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUoW10pLFxuICAgIC8vIENvbnZlcnQgZWRnZSBhcnJheSB2YWx1ZXMgaW50byB0aGUgW1QsUixCLExdIGZvcm0uXG4gICAgcGFyc2VFZGdlVmFsdWUgPSAoZSA9IDApID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICBlID0gW2VdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBlLmxlbmd0aCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZmlsbChlWzBdLCAxLCA0KTtcbiAgICAgICAgICAgIGNhc2UgMjovLyB0b3AmYm90dG9tLCBsZWZ0JnJpZ2h0XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlWzBdLCBlWzFdLCBlWzBdLCBlWzFdXTtcbiAgICAgICAgICAgIGNhc2UgMzovLyB0b3AsIGxlZnQmcmlnaHQsIGJvdHRvbVxuICAgICAgICAgICAgICAgIHJldHVybiBbZVswXSwgZVsxXSwgZVsyXSwgZVsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfSxcbiAgICBwYXJzZUVkZ2VBbGlnbiA9IGVkZ2VBbGlnbiA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBlZGdlUGFydHMgICAgID0gZWRnZUFsaWduUkUuZXhlYyhlZGdlQWxpZ24pLFxuICAgICAgICAgICAgb3VyRWRnZVpvbmUgICA9IGVkZ2Vab25lW2VkZ2VQYXJ0c1sxXV0sXG4gICAgICAgICAgICB0aGVpckVkZ2Vab25lID0gZWRnZVpvbmVbZWRnZVBhcnRzWzRdXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3VyRWRnZSAgICAgICAgIDogZWRnZVBhcnRzWzFdLFxuICAgICAgICAgICAgb3VyRWRnZU9mZnNldCAgIDogcGFyc2VJbnQoZWRnZVBhcnRzWzJdIHx8IDUwKSxcbiAgICAgICAgICAgIG91ckVkZ2VVbml0ICAgICA6IGVkZ2VQYXJ0c1szXSB8fCAnJScsXG4gICAgICAgICAgICBvdXJFZGdlWm9uZSxcbiAgICAgICAgICAgIHRoZWlyRWRnZSAgICAgICA6IGVkZ2VQYXJ0c1s0XSxcbiAgICAgICAgICAgIHRoZWlyRWRnZU9mZnNldCA6IHBhcnNlSW50KGVkZ2VQYXJ0c1s1XSB8fCA1MCksXG4gICAgICAgICAgICB0aGVpckVkZ2VVbml0ICAgOiBlZGdlUGFydHNbNl0gfHwgJyUnLFxuICAgICAgICAgICAgdGhlaXJFZGdlWm9uZSxcblxuICAgICAgICAgICAgLy8gQWxpZ25lZCB0byBhbiBlZGdlLCAqb3V0c2lkZSogb2YgdGhlIHRhcmdldC5cbiAgICAgICAgICAgIC8vIEEgbm9ybWFsIGFsaWduIGFzIGEgY29tYm8gZHJvcGRvd24gbWlnaHQgcmVxdWVzdFxuICAgICAgICAgICAgZWRnZUFsaWduZWQgICAgIDogKG91ckVkZ2Vab25lICYgMSkgPT09ICh0aGVpckVkZ2Vab25lICYgMSkgJiYgb3VyRWRnZVpvbmUgIT09IHRoZWlyRWRnZVpvbmVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gVGhlIG9wcG9zaXRlIG9mIHBhcnNlRWRnZUFsaWduLCBhbmQgaXQgaGFzIHRvIGZsaXAgdGhlIGVkZ2VzXG4gICAgY3JlYXRlUmV2ZXJzZWRFZGdlQWxpZ24gPSBlZGdlcyA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBvdXJFZGdlICAgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMub3VyRWRnZV0sXG4gICAgICAgICAgICB0aGVpckVkZ2UgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMudGhlaXJFZGdlXTtcblxuICAgICAgICAvLyByZWNvbnN0aXR1dGUgYSBydWxlIHN0cmluZyB3aXRoIHRoZSBlZGdlcyBmbGlwcGVkIHRvIHRoZSBvcHBvc2l0ZSBzaWRlc1xuICAgICAgICByZXR1cm4gYCR7b3VyRWRnZX0ke2VkZ2VzLm91ckVkZ2VPZmZzZXR9JHtlZGdlcy5vdXJFZGdlVW5pdH0tJHt0aGVpckVkZ2V9JHtlZGdlcy50aGVpckVkZ2VPZmZzZXR9JHtlZGdlcy50aGVpckVkZ2VVbml0fWBcblxuICAgIH0sXG4gICAgZ2V0RWxSZWN0ID0gZWwgPT4ge1xuICAgICAgICBjb25zdCByID0gZWwgaW5zdGFuY2VvZiBET01SZWN0ID8gZWwgOiAoZWw/Lm5vZGVUeXBlID09PSAxID8gZWwgOiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpIDogbnVsbCk/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgRE9NUmVjdCBpbnRvIFJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gciAmJiBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG4gICAgfSxcbiAgICBvcHBvc2l0ZUVkZ2UgPSB7XG4gICAgICAgIHQgOiAnYicsXG4gICAgICAgIHIgOiAnbCcsXG4gICAgICAgIGIgOiAndCcsXG4gICAgICAgIGwgOiAncidcbiAgICB9LFxuICAgIGVkZ2Vab25lID0ge1xuICAgICAgICB0IDogMCxcbiAgICAgICAgciA6IDEsXG4gICAgICAgIGIgOiAyLFxuICAgICAgICBsIDogM1xuICAgIH0sXG4gICAgem9uZU5hbWVzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgICB6b25lRWRnZXMgPSBbJ3QnLCAncicsICdiJywgJ2wnXSxcbiAgICB6b25lRGltZW5zaW9uID0gWyd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICB6b25lQ29vcmQgPSBbMCwgMSwgMCwgMV0sXG4gICAgemVyb01hcmdpbnMgPSBbMCwgMCwgMCwgMF0sXG4gICAgZWRnZUFsaWduUkUgPSAvXihbdHJibGNdKShcXGQqKSglfHB4KT8tKFt0cmJsY10pKFxcZCopKCV8cHgpPyQvO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBET01SZWN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLlJlY3RhbmdsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuUmVjdGFuZ2xlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtaW5IZWlnaHQ9bnVsbFxuICAgICAqL1xuICAgIG1pbkhlaWdodCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbWluV2lkdGg9bnVsbFxuICAgICAqL1xuICAgIG1pbldpZHRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QxIGRvZXMgbm90IGhhdmUgYW4gaW50ZXJzZWN0aW9uIHdpdGggcmVjdDJcbiAgICAgKiAhaW5jbHVkZXMoKSBpcyB0cnVlIGZvciBpbnRlcnNlY3Rpb25zIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhjbHVkZXMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIHJldHVybiByZWN0MS5ib3R0b20gPCByZWN0Mi50b3AgICAgIC8vIHJlY3QyIGlzIGJlbG93IHJlY3QxXG4gICAgICAgICAgICB8fCByZWN0MS5sZWZ0ICAgPiByZWN0Mi5yaWdodCAgIC8vIHJlY3QyIGlzIGxlZnQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnJpZ2h0ICA8IHJlY3QyLmxlZnQgICAgLy8gcmVjdDIgaXMgcmlnaHQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnRvcCAgICA+IHJlY3QyLmJvdHRvbTsgLy8gcmVjdDIgaXMgYWJvdmUgcmVjdDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGFwcGluZyBhcmVhIG9mIHJlY3QxICYgcmVjdDJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYXJlYSAoeCAqIHkpXG4gICAgICovXG4gICAgc3RhdGljIGdldEludGVyc2VjdGlvbihyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5nZXRJbnRlcnNlY3Rpb25EZXRhaWxzKHJlY3QxLCByZWN0MikuYXJlYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGFwcGluZyBhcmVhIG9mIHJlY3QxICYgcmVjdDJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB4LCB5ICYgYXJlYVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJbnRlcnNlY3Rpb25EZXRhaWxzKHJlY3QxLCByZWN0Mikge1xuICAgICAgICBsZXQgd2lkdGggID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdDEucmlnaHQsICByZWN0Mi5yaWdodCkgIC0gTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCkpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pIC0gTWF0aC5tYXgocmVjdDEudG9wLCAgcmVjdDIudG9wKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyZWE6IGhlaWdodCAqIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcmVjdDIgaXMgZnVsbHkgY29udGFpbmVkIGluc2lkZSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbmNsdWRlcyhyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QxLmJvdHRvbSA+PSByZWN0Mi5ib3R0b21cbiAgICAgICAgICAgICYmIHJlY3QxLmxlZnQgICA8PSByZWN0Mi5sZWZ0XG4gICAgICAgICAgICAmJiByZWN0MS5yaWdodCAgPj0gcmVjdDIucmlnaHRcbiAgICAgICAgICAgICYmIHJlY3QxLnRvcCAgICA8PSByZWN0Mi50b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QyIGlzIG5vdCBjb250YWluZWQgaW5zaWRlIHJlY3QxLlxuICAgICAqIFRoaXMgY291bGQgYmUgYW4gaW50ZXJzZWN0aW9uIG9yIGJlaW5nIGZ1bGx5IGV4Y2x1ZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlIGJvdHRvbSwgbGVmdCwgcmlnaHQgb3IgdG9wXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGxlYXZlc1NpZGUocmVjdDEsIHJlY3QyLCBzaWRlKSB7XG4gICAgICAgIGlmIChSZWN0YW5nbGUuaW5jbHVkZXMocmVjdDEsIHJlY3QyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEuYm90dG9tIDwgcmVjdDIuYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLmxlZnQgPiByZWN0Mi5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0MS5yaWdodCA8IHJlY3QyLnJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEudG9wID4gcmVjdDIudG9wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIERPTVJlY3Qgb2JqZWN0IHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeD1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5PW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH0gbW92ZWRSZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1vdmVCeShyZWN0LCB4PW51bGwsIHk9bnVsbCkge1xuICAgICAgICBsZXQgbW92ZWRSZWN0ID0gey4uLnJlY3R9O1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5sZWZ0ICArPSB4O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnJpZ2h0ICs9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QueCAgICAgKz0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5ib3R0b20gKz0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC50b3AgICAgKz0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC55ICAgICAgKz0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3ZlZFJlY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIERPTVJlY3Qgb2JqZWN0IHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeD1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5PW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH0gbW92ZWRSZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1vdmVUbyhyZWN0LCB4PW51bGwsIHk9bnVsbCkge1xuICAgICAgICBsZXQgbW92ZWRSZWN0ID0gey4uLnJlY3R9O1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5sZWZ0ICA9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QucmlnaHQgPSB4ICsgbW92ZWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgbW92ZWRSZWN0LnggICAgID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5ib3R0b20gPSB5ICsgbW92ZWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC50b3AgICAgPSB5O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnkgICAgICA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWRSZWN0O1xuICAgIH1cblxuICAgIHNldCBib3R0b20oYikge1xuICAgICAgICB0aGlzLmhlaWdodCArPSBiIC0gdGhpcy5ib3R0b207XG4gICAgfVxuICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5ib3R0b207XG4gICAgfVxuXG4gICAgc2V0IHJpZ2h0KHIpIHtcbiAgICAgICAgdGhpcy53aWR0aCArPSByIC0gdGhpcy5yaWdodDtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gc3VwZXIucmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSB4IHdpdGhvdXQgbW92aW5nIHRoZSBSZWN0YW5nbGUuIFRoZSBsZWZ0IHNpZGUgbW92ZXMgYW5kIHRoZSByaWdodCBzaWRlIGRvZXNuJ3RcbiAgICBjaGFuZ2VYKHgpIHtcbiAgICAgICAgY29uc3Qgd2lkdGhEZWx0YSA9IHRoaXMueCAtIHg7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy53aWR0aCArPSB3aWR0aERlbHRhO1xuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgeSB3aXRob3V0IG1vdmluZyB0aGUgUmVjdGFuZ2xlLiBUaGUgdG9wIHNpZGUgbW92ZXMgYW5kIHRoZSBib3R0b20gc2lkZSBkb2Vzbid0XG4gICAgY2hhbmdlWSh5KSB7XG4gICAgICAgIGNvbnN0IGhlaWdodERlbHRhID0gdGhpcy55IC0geTtcblxuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHREZWx0YTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5jbG9uZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xvbmUocikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG5cbiAgICAgICAgcmVzdWx0Lm1pbldpZHRoID0gci5taW5XaWR0aDtcbiAgICAgICAgcmVzdWx0Lm1pbkhlaWdodCA9IHIubWluSGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0cyhvdGhlcikge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG90aGVyLmhlaWdodCAmJiBvdGhlci53aWR0aCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBsZWZ0ICAgPSBNYXRoLm1heChtZS54LCBvdGhlci54KSxcbiAgICAgICAgICAgICAgICB0b3AgICAgPSBNYXRoLm1heChtZS55LCBvdGhlci55KSxcbiAgICAgICAgICAgICAgICByaWdodCAgPSBNYXRoLm1pbihtZS54ICsgbWUud2lkdGgsIG90aGVyLnggKyBvdGhlci53aWR0aCksXG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4obWUueSArIG1lLmhlaWdodCwgb3RoZXIueSArIG90aGVyLmhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0ID49IHJpZ2h0IHx8IHRvcCA+PSBib3R0b20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBhIHBvaW50IGhlcmUgLSB6ZXJvIGRpbWVuc2lvbnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKG90aGVyLnggPj0gbWUueCAmJiBvdGhlci55ID49IG1lLnkgJiYgb3RoZXIucmlnaHQgPD0gbWUucmlnaHQgJiYgb3RoZXIuYm90dG9tIDw9IG1lLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG90aGVyIFJlY3RhbmdsZSBpcyBmdWxseSBjb250YWluZWQgaW5zaWRlIHRoaXMgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY29udGFpbnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tID49IG90aGVyLmJvdHRvbVxuICAgICAgICAgICAgJiYgdGhpcy5sZWZ0ICAgPD0gb3RoZXIubGVmdFxuICAgICAgICAgICAgJiYgdGhpcy5yaWdodCAgPj0gb3RoZXIucmlnaHRcbiAgICAgICAgICAgICYmIHRoaXMudG9wICAgIDw9IG90aGVyLnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGUgZXhwYW5kZWQgYWNjb3JkaW5nIHRvIHRoZSBlZGdlcyBhcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn1OdW1iZXJbXX0gZWRnZXNcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIGV4cGFuZChlZGdlcykge1xuICAgICAgICBlZGdlcyA9IHBhcnNlRWRnZVZhbHVlKGVkZ2VzKTtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54IC0gZWRnZXNbM10sIHRoaXMueSAtIGVkZ2VzWzBdLCB0aGlzLndpZHRoICsgZWRnZXNbMV0gKyBlZGdlc1szXSwgdGhpcy5oZWlnaHQgKyBlZGdlc1swXSArIGVkZ2VzWzJdKTtcbiAgICB9XG5cbiAgICBtb3ZlQnkoeCA9IDAsIHkgPSAwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICAgICAgeSA9IHhbMV07XG4gICAgICAgICAgICB4ID0geFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQueCArPSB4O1xuICAgICAgICByZXN1bHQueSArPSB5O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgUmVjdGFuZ2xlIGNvbXBsZXRlbHkgY29udGFpbnMgdGhlIG90aGVyIFJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBvdGhlclxuICAgICAqL1xuICAgIGNvbnRhaW5zKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmluY2x1ZGVzKHRoaXMsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIFJlY3RhbmdsZSBjb25zdHJhaW5lZCB0byBmaXQgd2l0aGluIHRoZSBwYXNzZWQgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbnN0cmFpblRvXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZXxCb29sZWFufSBBIG5ldyBSZWN0YW5nbGUgY29uc3RyYWluZWQgdG8gdGUgcGFzc2VkIFJlY3RhbmdsZSwgb3IgZmFsc2UgaWYgaXQgY291bGQgbm90IGJlIGNvbnN0cmFpbmVkLlxuICAgICAqL1xuICAgIGNvbnN0cmFpblRvKGNvbnN0cmFpblRvKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbWluV2lkdGggID0gbWUubWluV2lkdGggIHx8IG1lLndpZHRoLFxuICAgICAgICAgICAgbWluSGVpZ2h0ID0gbWUubWluSGVpZ2h0IHx8IG1lLmhlaWdodDtcblxuICAgICAgICAvLyBOb3QgcG9zc2libGUsIGV2ZW4gd2hlbiBzaHJ1bmsgdG8gbWluaW1hXG4gICAgICAgIGlmIChtaW5IZWlnaHQgPiBjb25zdHJhaW5Uby5oZWlnaHQgfHwgbWluV2lkdGggPiBjb25zdHJhaW5Uby53aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZG8gbm90IG11dGF0ZSB0aGlzIFJlY3RhbmdsZSwgYnV0IHJldHVybiBhIGNvbnN0cmFpbmVkIHZlcnNpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbWUuY2xvbmUoKTtcblxuICAgICAgICAvLyBUcmFuc2xhdGUgcmVzdWx0IHNvIHRoYXQgdGhlIHRvcCBhbmQgbGVmdCBhcmUgdmlzaWJsZVxuICAgICAgICByZXN1bHQueCA9IE1hdGgubWF4KG1lLnggKyBNYXRoLm1pbihjb25zdHJhaW5Uby5yaWdodCAgLSByZXN1bHQucmlnaHQsICAwKSwgY29uc3RyYWluVG8ueCk7XG4gICAgICAgIHJlc3VsdC55ID0gTWF0aC5tYXgobWUueSArIE1hdGgubWluKGNvbnN0cmFpblRvLmJvdHRvbSAtIHJlc3VsdC5ib3R0b20sIDApLCBjb25zdHJhaW5Uby55KTtcblxuICAgICAgICAvLyBQdWxsIGluIGFueSByZXN1bHRpbmcgb3ZlcmZsb3dcbiAgICAgICAgcmVzdWx0LmJvdHRvbSA9IE1hdGgubWluKHJlc3VsdC5ib3R0b20sIGNvbnN0cmFpblRvLmJvdHRvbSk7XG4gICAgICAgIHJlc3VsdC5yaWdodCA9IE1hdGgubWluKHJlc3VsdC5yaWdodCwgY29uc3RyYWluVG8ucmlnaHQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYWxpZ25UbyhhbGlnbikge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpblRvLCAgICAvLyBFbGVtZW50IG9yIFJlY3RhbmdsZSByZXN1bHQgbXVzdCBmaXQgaW50b1xuICAgICAgICAgICAgICAgIHRhcmdldCwgICAgICAgICAvLyBFbGVtZW50IG9yIFJlY3RhbmdsZSB0byBhbGlnbiB0b1xuICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiwgICAgICAvLyB0NTAtYjUwIHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgYXhpc0xvY2ssICAgICAgIC8vIHRydWUgZm9yIGZsaXAsICdmbGV4aWJsZScgZm9yIGZsaXAsIHRoZW4gdHJ5IHRoZSBvdGhlciBlZGdlc1xuICAgICAgICAgICAgICAgIG9mZnNldCwgICAgICAgICAvLyBGaW5hbCBbeCwgeV0gdmVjdG9yIHRvIG1vdmUgdGhlIHJlc3VsdCBieS5cbiAgICAgICAgICAgICAgICBtYXRjaFNpemVcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgID0gYWxpZ24sXG4gICAgICAgICAgICB0YXJnZXRNYXJnaW4gICA9IGFsaWduLnRhcmdldE1hcmdpbiA/IHBhcnNlRWRnZVZhbHVlKGFsaWduLnRhcmdldE1hcmdpbikgOiB6ZXJvTWFyZ2lucyxcbiAgICAgICAgICAgIHRhcmdldFJlY3QgICAgID0gZ2V0RWxSZWN0KHRhcmdldCksXG4gICAgICAgICAgICBjb25zdHJhaW5SZWN0ICA9IGdldEVsUmVjdChjb25zdHJhaW5UbyksXG4gICAgICAgICAgICBlZGdlcyAgICAgICAgICA9IHBhcnNlRWRnZUFsaWduKGVkZ2VBbGlnbiksXG4gICAgICAgICAgICBtYXRjaERpbWVuc2lvbiA9IHpvbmVEaW1lbnNpb25bZWRnZXMudGhlaXJFZGdlWm9uZSAmIDFdO1xuXG4gICAgICAgIGxldCByZXN1bHQgPSBtZS5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdFttYXRjaERpbWVuc2lvbl0gPSB0YXJnZXRSZWN0W21hdGNoRGltZW5zaW9uXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE11c3QgZG8gdGhlIGNhbGN1bGF0aW9ucyBhZnRlciB0aGUgYWxpZ25lZCBzaWRlIGhhcyBiZWVuIG1hdGNoZWQgaW4gc2l6ZSBpZiByZXF1ZXN0ZWQuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBteVBvaW50ICAgICA9IHJlc3VsdC5nZXRBbmNob3JQb2ludChlZGdlcy5vdXJFZGdlWm9uZSwgZWRnZXMub3VyRWRnZU9mZnNldCwgZWRnZXMub3VyRWRnZVVuaXQpLFxuICAgICAgICAgICAgdGFyZ2V0UG9pbnQgPSB0YXJnZXRSZWN0LmdldEFuY2hvclBvaW50KGVkZ2VzLnRoZWlyRWRnZVpvbmUsIGVkZ2VzLnRoZWlyRWRnZU9mZnNldCwgZWRnZXMudGhlaXJFZGdlVW5pdCwgdGFyZ2V0TWFyZ2luKSxcbiAgICAgICAgICAgIHZlY3RvciAgICAgID0gW3RhcmdldFBvaW50WzBdIC0gbXlQb2ludFswXSwgdGFyZ2V0UG9pbnRbMV0gLSBteVBvaW50WzFdXTtcblxuICAgICAgICByZXN1bHQgPSByZXN1bHQubW92ZUJ5KHZlY3Rvcik7XG5cbiAgICAgICAgLy8gQSB1c2VmdWwgcHJvcGVydHkgaW4gdGhlIHJlc3VsdGluZyByZWN0YW5nbGUgd2hpY2ggc3BlY2lmaWVzIHdoaWNoIHpvbmUgb2YgdGhlIHRhcmdldFxuICAgICAgICAvLyBJdCBpcyBiZWluZyBwbGFjZXMgaW4sIFQsUixCIG9yIEwgLSAwLCAxLCAyLCAzXG4gICAgICAgIC8vIFNvbWUgY29kZSBtYXkgd2FudCB0byB0cmVhdCBET00gZWxlbWVudHMgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHRoZSB6b25lXG4gICAgICAgIHJlc3VsdC56b25lID0gZWRnZXMudGhlaXJFZGdlWm9uZTtcbiAgICAgICAgcmVzdWx0LnBvc2l0aW9uID0gem9uZU5hbWVzW3Jlc3VsdC56b25lXTtcblxuICAgICAgICAvLyBOb3cgd2UgY3JlYXRlIHRoZSBmb3VyIFJlY3RhbmdsZXMgYXJvdW5kIHRoZSB0YXJnZXQsIGludG8gd2hpY2ggd2UgbWF5IGJlIGNvbnN0cmFpbmVkXG4gICAgICAgIC8vIFpvbmVzIFQsUixCLEwgMCA5LCAxLCAyLCAzOlxuICAgICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgIC8vIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIF4gICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIF4gICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgPC0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tWm9uZSAwLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLT4gICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKy0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgIFpvbmUgMyAgICAgICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgIFpvbmUgMSAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8ICsrLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgPC0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS1ab25lIDItLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tPiB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgdiAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgdiAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKystLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICBpZiAoY29uc3RyYWluUmVjdCAmJiAhY29uc3RyYWluUmVjdC5jb250YWlucyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAvLyBUaGV5IGFza2VkIHRvIG92ZXJsYXAgdGhlIHRhcmdldCwgZm9yIGV4YW1wbGUgdDAtdDBcbiAgICAgICAgICAgIC8vIEluIHRoZXNlIGNhc2VzLCB3ZSBqdXN0IHJldHVybiB0aGUgcmVzdWx0XG4gICAgICAgICAgICBpZiAodGFyZ2V0UmVjdC5pbnRlcnNlY3RzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSB6b25lIHdlIHRyeSB0byBmaXQgaW50byBmaXJzdCwgdGhlIG9uZSB0aGF0IHdhcyBhc2tlZCBmb3JcbiAgICAgICAgICAgIGxldCB6b25lID0gZWRnZXMudGhlaXJFZGdlWm9uZTtcblxuICAgICAgICAgICAgLy8gV2UgY3JlYXRlIGFuIGFycmF5IG9mIGZvdXIgcmVjdGFuZ2xlcyBpbnRvIHdoaWNoIHdlIHRyeSB0byBmaXQgd2l0aCBhcHByb3ByaWF0ZSBhbGlnbiBzcGVjcy5cbiAgICAgICAgICAgIC8vIFdlIG11c3Qgc3RhcnQgd2l0aCB0aGUgcmVxdWVzdGVkIHpvbmUsIHdoYXRldmVyIHRoYXQgaXMuXG4gICAgICAgICAgICBjb25zdCB6b25lc1RvVHJ5ID0gW3tcbiAgICAgICAgICAgICAgICB6b25lLFxuICAgICAgICAgICAgICAgIGVkZ2VBbGlnblxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGlmIChheGlzTG9jaykge1xuICAgICAgICAgICAgICAgIC8vIEZsaXAgdG8gdGhlIG9wcG9zaXRlIHNpZGUgZm9yIHRoZSBzZWNvbmQgdHJ5LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBhbGlnbm1lbnQgc3RyaW5nIGhhcyB0byBiZSByZXZlcnNlZFxuICAgICAgICAgICAgICAgIC8vIHNvIHIyMC1sMzAgaGFzIHRvIGJlY29tZSBsMjAtcjMwLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBvdGhlciB0d28gem9uZXMgcmV2ZXJ0IHRvIGNlbnRlcmVkIHNvIGFyZSBlYXNpZXJcbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5WzFdID0ge1xuICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKHpvbmUgKyAyKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGNyZWF0ZVJldmVyc2VkRWRnZUFsaWduKGVkZ2VzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgb3RoZXIgdHdvIHpvbmVzLlxuICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoZWRnZXMudGhlaXJFZGdlWm9uZSArIDEpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduIDogYCR7b3Bwb3NpdGVFZGdlW3pvbmVFZGdlc1t6b25lXV19LSR7em9uZUVkZ2VzW3pvbmVdfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKGVkZ2VzLnRoZWlyRWRnZVpvbmUgKyAzKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGAke29wcG9zaXRlRWRnZVt6b25lRWRnZXNbem9uZV1dfS0ke3pvbmVFZGdlc1t6b25lXX1gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBvdGhlciB6b25lcyBpbiBvcmRlclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKHpvbmUgKyAxKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24gOiBgJHtvcHBvc2l0ZUVkZ2Vbem9uZUVkZ2VzW3pvbmVdXX0tJHt6b25lRWRnZXNbem9uZV19YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29uc3RyYWludCBSZWN0YW5nbGUgZm9yIGVhY2ggem9uZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6b25lc1RvVHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2xvbmUgdGhlIG91dGVyIGNvbnN0cmFpbmluZyByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAvLyBhbmQgbW92ZSBpdCBpbnRvIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNvbnN0cmFpblJlY3QuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoem9uZXNUb1RyeVtpXS56b25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGkyIGFib3ZlIHRoZSB0YXJnZXQgLSB6b25lIDAvVFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5ib3R0b20gPSB0YXJnZXRSZWN0LnkgLSB0YXJnZXRNYXJnaW5bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHpvbmUgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSB0YXJnZXQgLSB6b25lIDEvUlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFuZ2VYKHRhcmdldFJlY3QucmlnaHQgKyB0YXJnZXRNYXJnaW5bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGlzIGJlbG93IHRoZSB0YXJnZXQgLSB6b25lIDIvQlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFuZ2VZKHRhcmdldFJlY3QuYm90dG9tICsgdGFyZ2V0TWFyZ2luWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgem9uZSBpcyB0byB0aGUgbGVmdCBvZiB0aGUgdGFyZ2V0IC0gem9uZSAzL0xcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSB0YXJnZXRSZWN0LnggLSB0YXJnZXRNYXJnaW5bM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgem9uZXNUb1RyeVtpXS5jb25zdHJhaW5SZWN0ID0gYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHRyeSB0byBjb25zdHJhaW4gb3VyIHJlc3VsdCBpbnRvIGVhY2ggem9uZSdzIGNvbnN0cmFpbnRab25lXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHpvbmVzVG9UcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWluUmVjdFxuICAgICAgICAgICAgICAgICAgICB9ICAgID0gem9uZXNUb1RyeVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZSA9IHpvbmVFZGdlc1t6b25lXTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGFsaWduaW5nIHRvIHRoZSByZXF1ZXN0ZWQgZWRnZSwgb3IgaXQncyBvcHBvc2l0ZSBlZGdlIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhhdCBlZGdlIHNpemUsIGVsc2UgcmV2ZXJ0IGl0IHRvIG91ciBvd24gc2l6ZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbWF0Y2hEaW1lbnNpb25dID0gZWRnZSA9PT0gZWRnZXMudGhlaXJFZGdlIHx8IGVkZ2UgPT0gb3Bwb3NpdGVFZGdlW2VkZ2VzLnRoZWlyRWRnZV0gPyB0YXJnZXRSZWN0W21hdGNoRGltZW5zaW9uXSA6IG1lW21hdGNoRGltZW5zaW9uXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBhIHNpbXBsZSBhbGlnbiB0byB0aGUgY3VycmVudCBlZGdlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFsaWduVG8oe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgOiB0YXJnZXRSZWN0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNvbHV0aW9uID0gcmVzdWx0LmNvbnN0cmFpblRvKGNvbnN0cmFpblJlY3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXMgc29vbiBhcyB3ZSBmaW5kIGEgem9uZSBpbnRvIHdoaWNoIHRoZSByZXN1bHQgaXMgd2lsbGluZyB0byBiZSBjb25zdHJhaW5lZC4gcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLnpvbmUgPSB6b25lO1xuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbi5wb3NpdGlvbiA9IHpvbmVOYW1lc1t6b25lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgY29uZmlndXJhYmxlIGZpbmlzaGluZyB0b3VjaC5cbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1vdmVCeShvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXRBbmNob3JQb2ludChlZGdlWm9uZSwgZWRnZU9mZnNldCwgZWRnZVVuaXQsIG1hcmdpbiA9IGVtcHR5QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgLy8gRWRnZSB6b25lcyBnbyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgICAgLy8gRWFjaCBvbmUgY2FsY3VsYXRlcyB0aGUgc3RhcnQgcG9pbnQgb2YgdGhhdCBlZGdlIHRoZW4gbW92ZXMgYWxvbmcgaXQgYnlcbiAgICAgICAgLy8gdGhlIGVkZ2VPZmZzZXQsIHRoZW4gbW92ZXMgKmF3YXkqIGZyb20gaXQgYnkgdGhlIG1hcmdpbiBmb3IgdGhhdCBlZGdlIGlmIHRoZXJlJ3MgYSBtYXJnaW4uXG4gICAgICAgIHN3aXRjaCAoZWRnZVpvbmUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCwgbWUueSAtIChtYXJnaW5bMF0gfHwgMCksIG1lLndpZHRoLCAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCArIG1lLndpZHRoICsgKG1hcmdpblsxXSB8fCAwKSwgbWUueSwgbWUuaGVpZ2h0LCAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCwgbWUueSArIG1lLmhlaWdodCArIChtYXJnaW5bMl0gfHwgMCksIG1lLndpZHRoLCAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCAtIChtYXJnaW5bM10gfHwgMCksIG1lLnksIG1lLmhlaWdodCwgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc3VsdFszXV0gKz0gZWRnZVVuaXQgPT09ICclJyA/IHJlc3VsdFsyXSAvIDEwMCAqIGVkZ2VPZmZzZXQgOiBlZGdlT2Zmc2V0O1xuICAgICAgICByZXN1bHQubGVuZ3RoID0gMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgRE9NUmVjdCAmJlxuICAgICAgICAgICAgb3RoZXIueCA9PT0gdGhpcy54ICYmXG4gICAgICAgICAgICBvdGhlci55ID09PSB0aGlzLnkgJiZcbiAgICAgICAgICAgIG90aGVyLmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgICAgICAgIG90aGVyLndpZHRoID09PSB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgb25seVxuICAgIHNob3coY29sb3IgPSAncmVkJykge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBkaXYuc3R5bGUgPSBgXG4gICAgICAgICAgICBwb3NpdGlvbjphYnNvbHV0ZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTp0cmFuc2xhdGUzZCgke3RoaXMueH1weCwgJHt0aGlzLnl9cHgsIDApO1xuICAgICAgICAgICAgaGVpZ2h0OiR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICB3aWR0aDoke3RoaXMud2lkdGh9cHg7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiR7Y29sb3J9XG4gICAgICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBkaXYucmVtb3ZlKCksIDMwMDAwKTtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIEpTT04uc3RyaW5naWZ5KHRoaXMpLCB3ZSB3YW50IHRvIGFkZCBtaW5IZWlnaHQgJiBtaW5XaWR0aCB0byB0aGUgb3V0cHV0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIG1pbkhlaWdodCwgbWluV2lkdGgsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIG1pbkhlaWdodCwgbWluV2lkdGgsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fVxuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5TdHlsZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTdHlsZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuU3R5bGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlN0eWxlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZGVsdGEgb2JqZWN0LCBjb250YWluaW5nIHRoZSBzdHlsZXMgb2YgbmV3U3R5bGUgd2hpY2ggYXJlIG5vdCBpbmNsdWRlZCBvciBkaWZmZXJlbnQgdGhhbiBpbiBvbGRTdHlsZVxuICAgICAqIFN0eWxlcyBpbmNsdWRlZCBpbiBvbGRTdHlsZSBidXQgbWlzc2luZyBpbiBuZXdTdHlsZSB3aWxsIGdldCBhIHZhbHVlIG9mIG51bGxcbiAgICAgKiBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9zdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmV3U3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9sZFN0eWxlXG4gICAgICogQHJldHVybnMge09iamVjdH0gc3R5bGUgZGVsdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVN0eWxlcyhuZXdTdHlsZSwgb2xkU3R5bGUpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IHt9O1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcobmV3U3R5bGUpKSB7XG4gICAgICAgICAgICBuZXdTdHlsZSA9IE5lby5jcmVhdGVTdHlsZU9iamVjdChuZXdTdHlsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcob2xkU3R5bGUpKSB7XG4gICAgICAgICAgICBvbGRTdHlsZSA9IE5lby5jcmVhdGVTdHlsZU9iamVjdChvbGRTdHlsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3U3R5bGUgJiYgIW9sZFN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKCFvbGRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIE5lby5jbG9uZShuZXdTdHlsZSlcbiAgICAgICAgfSBlbHNlIGlmICghbmV3U3R5bGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3U3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb2xkU3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpIHx8IG9sZFN0eWxlW3N0eWxlXSAhPT0gbmV3U3R5bGVbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBuZXdTdHlsZVtzdHlsZV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMob2xkU3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbmV3U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKFN0eWxlKTtcblxuZXhwb3J0IGRlZmF1bHQgU3R5bGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=