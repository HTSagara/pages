"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_week_plugin_DragDrop_mjs"],{

/***/ "./src/calendar/view/week/EventDragZone.mjs":
/*!**************************************************!*\
  !*** ./src/calendar/view/week/EventDragZone.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../draggable/DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.calendar.view.week.EventDragZone
 * @extends Neo.draggable.DragZone
 */
class EventDragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.EventDragZone'
         * @protected
         */
        className: 'Neo.calendar.view.week.EventDragZone',
        /**
         * @member {Boolean} addDragProxyCls=false
         */
        addDragProxyCls: false,
        /**
         * @member {Boolean} enableResizingAcrossOppositeEdge=true
         */
        enableResizingAcrossOppositeEdge: true,
        /**
         * @member {Number} axisEndTime=0
         */
        axisEndTime: 0,
        /**
         * @member {Number} axisStartTime=0
         */
        axisStartTime: 0,
        /**
         * @member {Number} columnHeight=0
         */
        columnHeight: 0,
        /**
         * @member {Number} columnTop=0
         */
        columnTop: 0,
        /**
         * @member {Number} currentInterval=0
         */
        currentInterval: 0,
        /**
         * time in minutes
         * @member {Number} eventDuration=0
         */
        eventDuration: 0,
        /**
         * @member {Object} eventRecord=null
         */
        eventRecord: null,
        /**
         * Internal flag.
         * If we resize across the opposite edge and then back, we need to update the related edge position once.
         * @member {Boolean} forceUpdate=false
         * @protected
         */
        forceUpdate: false,
        /**
         * Internal flag
         * @member {Boolean} hasOverflow=false
         * @protected
         */
        hasOverflow: false,
        /**
         * time in minutes
         * @member {Number} intervalSize=15
         */
        intervalSize: 15,
        /**
         * @member {Boolean} keepEndDate=false
         */
        keepEndDate: false,
        /**
         * @member {Boolean} keepStartDate=false
         */
        keepStartDate: false,
        /**
         * @member {Boolean} moveHorizontal=false
         */
        moveHorizontal: false,
        /**
         * @member {Boolean} moveInMainThread=false
         */
        moveInMainThread: false,
        /**
         * Internal flag.
         * @member {Date} newEndDate=null
         * @protected
         */
        newEndDate: null,
        /**
         * Internal flag.
         * @member {Date} newStartDate=null
         * @protected
         */
        newStartDate: null,
        /**
         * @member {Number} scrollFactorLeft=3
         */
        scrollFactorLeft: 3,
        /**
         * @member {Boolean} useProxyWrapper=false
         */
        useProxyWrapper: false
    }

    /**
     *
     */
    addBodyCursorCls() {
        Neo.applyDeltas(this.appName, {id: 'document.body', cls: {add: ['neo-cursor-move']}})
    }

    /**
     * Resolves the 24:00 issue, where an event would end on the next day
     * @param {Date} date
     * @returns {Date}
     */
    adjustEndDate(date) {
        if (date.getHours() === 0 && date.getMinutes() === 0) {
            // if an event ends at 24:00, change it to 23:59 => otherwise the day increases by 1
            date.setMinutes(date.getMinutes() - 1)
        } else if (!(date.getHours() === 23 && date.getMinutes() === 59) && date.getMinutes() % this.intervalSize !== 0) {
            // otherwise switch non interval based values back
            date.setMinutes(date.getMinutes() + 1)
        }

        return date
    }

    /**
     * Triggered after the proxyParentId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetProxyParentId(value, oldValue) {
        if (value && oldValue !== undefined) {
            let me = this;

            // check if the node did not get removed yet
            if (me.dragProxy?.vdom.cn[0].id) {
                Neo.applyDeltas(me.appName, {
                    action  : 'moveNode',
                    id      : me.dragProxy.id,
                    index   : 0,
                    parentId: value
                })
            }
        }
    }

    /**
     * @param {Object} data
     */
    createDragProxy(data) {
        let me        = this,
            component = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            vdom      = me.dragProxyConfig?.vdom,
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].clone(vdom ? vdom : me.dragElement);

            clone.cn[2].removeDom = false;

        const config = {
            module          : _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,

            ...me.dragProxyConfig,

            vdom: me.useProxyWrapper ? {cn: [clone]} : clone // we want to override dragProxyConfig.vdom if needed
        };

        config.cls = config.cls || [];

        config.cls.push('neo-focus');

        if (component) {
            config.cls.push(component.getTheme())
        }

        if (clone.cls && !me.useProxyWrapper) {
            config.cls.push(...clone.cls)
        }

        if (me.addDragProxyCls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(config.cls, me.dragProxyCls)
        }

        Object.assign(config.style, {
            height: `${data.height}px`,
            top   : `${data.y - me.columnTop}px`,
            width : `${data.width}px`
        });

        me.dragProxy = Neo.create(config)
    }

    /**
     * DragEnd equals drop, since we can only drag to valid positions
     * todo: ESC key
     * @param {Object} data
     */
    dragEnd(data) {
        super.dragEnd(data);

        let me      = this,
            {owner} = me,
            record  = me.eventRecord,
            endDate, startDate;

        if (me.keepStartDate) {
            endDate   = me.newEndDate;
            startDate = me.newStartDate || record.startDate
        } else {
            startDate = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].findVdomChild(owner.vdom, me.proxyParentId).vdom.flag + 'T00:00:00.000Z');
            startDate.setHours(me.axisStartTime);
            startDate.setMinutes(me.currentInterval * me.intervalSize);

            if (me.keepEndDate) {
                endDate   = me.newEndDate   || record.endDate;
                startDate = me.newStartDate || startDate
            } else {
                endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(startDate);
                endDate.setMinutes(endDate.getMinutes() + me.eventDuration)
            }
        }

        endDate = me.adjustEndDate(endDate);

        record.setSilent({
            endDate,
            startDate
        });

        Object.assign(me, {
            currentInterval: 0,
            hasOverflow    : false,
            keepEndDate    : false,
            keepStartDate  : false,
            newEndDate     : null,
            newStartDate   : null,
            proxyParentId  : null
        });

        // todo: updating a record field which is included inside a sorter should trigger collection.doSort()
        // see: https://github.com/neomjs/neo/issues/2392

        owner.getModel().getStore('events').doSort();
        owner.updateEvents()
    }

    /**
     * @param {Object} data
     */
    dragMove(data) {
        let me              = this,
            {axisEndTime, axisStartTime, columnHeight, eventDuration, intervalSize, keepEndDate, keepStartDate, owner} = me,
            i               = 0,
            path            = data.targetPath,
            len             = path.length,
            record          = me.eventRecord,
            switchDirection = false,
            {timeAxis}      = owner,
            axisStartDate, currentInterval, deltas, duration, endDate, eventIntervals, height, intervalHeight,
            intervals, limitInterval, minimumEventIntervals, position, startDate, startInterval;

        if (me.dragProxy) {
            if (!keepEndDate && !keepStartDate) {
                for (; i < len; i++) {
                    if (path[i].cls.includes('neo-c-w-column')) {
                        me.proxyParentId = path[i].id;
                        break
                    }
                }
            }

            intervals      = (axisEndTime - axisStartTime) * 60 / intervalSize; // 15 minutes each
            intervalHeight = columnHeight / intervals;

            position = Math.min(columnHeight, data.clientY - me.offsetY - me.columnTop);

            currentInterval = Math.floor(position / intervalHeight);

            endDate   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.endDate);
            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.startDate);

            // events can have a smaller start time than the axis min value.
            // resizing via the north handle needs to adjust the duration to honor this.
            if (keepEndDate) {
                if (axisStartTime > startDate.getHours()) {
                    startDate.setHours(axisStartTime);
                    startDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000 // duration in minutes
                }
            }

            // events can have a bigger end time than the axis max value.
            // resizing via the south handle needs to adjust the duration to honor this.
            if (keepStartDate) {
                if (axisEndTime < endDate.getHours()) {
                    endDate.setHours(axisEndTime);
                    endDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000 // duration in minutes
                }
            }

            if (!keepEndDate) {
                // events must not end after the last visible interval
                currentInterval = Math.min(currentInterval, intervals - (eventDuration / intervalSize))
            }

            deltas = [{
                id   : me.dragProxy.id,
                style: {}
            }];

            if (keepEndDate || keepStartDate) {
                axisStartDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.startDate);
                axisStartDate.setHours(axisStartTime);
                axisStartDate.setMinutes(0);

                minimumEventIntervals = owner.minimumEventDuration / intervalSize;
                startInterval         = (record.startDate - axisStartDate) / intervalSize / 60 / 1000;

                if (keepEndDate) {
                    limitInterval = startInterval + (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        if (me.forceUpdate && currentInterval > limitInterval -minimumEventIntervals && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return
                        } else if (currentInterval >= limitInterval + minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(currentInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(limitInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                            deltas[0].style.top = `calc(${limitInterval * intervalHeight / columnHeight * 100}% + 1px)`
                        } else {
                            me.forceUpdate  = false;
                            me.newStartDate = null
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.min(currentInterval, limitInterval - minimumEventIntervals)
                    }

                } else if (keepStartDate) {
                    limitInterval = startInterval - (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        // events must not start before the first visible interval
                        currentInterval = Math.max(-(eventDuration / intervalSize), currentInterval);

                        if (currentInterval <= limitInterval - minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(eventDuration + limitInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(eventDuration + currentInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours

                            position = (eventDuration / intervalSize + currentInterval) * intervalHeight; // snap to valid intervals
                            position = position / columnHeight * 100;

                            deltas[0].style.top = `calc(${position}% + 1px)`
                        } else if (me.forceUpdate && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return
                        } else if (me.forceUpdate && currentInterval >= limitInterval + minimumEventIntervals) {
                            if (me.currentInterval !== currentInterval) {
                                me.forceUpdate  = false;
                                me.newStartDate = null;
                                deltas[0].style.top = `calc(${startInterval * intervalHeight / columnHeight * 100}% + 1px)`
                            }
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.max(currentInterval, limitInterval + minimumEventIntervals)
                    }
                }
            }

            if (!keepStartDate) {
                // events must not start before the first visible interval
                currentInterval = Math.max(0, currentInterval)
            }

            if (me.currentInterval !== currentInterval) {
                if (!switchDirection) {
                    if (!keepEndDate) {
                        endDate.setHours(axisStartTime);
                        endDate.setMinutes(eventDuration + currentInterval * intervalSize)
                    }

                    if (keepStartDate) {
                        me.newEndDate = endDate;
                        duration = (endDate - record.startDate) / 60 / 60 / 1000 // duration in hours
                    } else {
                        startDate.setHours(axisStartTime);
                        startDate.setMinutes(currentInterval * intervalSize);

                        position = currentInterval * intervalHeight; // snap to valid intervals
                        position = position / columnHeight * 100;

                        deltas[0].style.top = `calc(${position}% + 1px)`
                    }

                    if (keepEndDate) {
                        duration = (record.endDate - startDate) / 60 / 60 / 1000 // duration in hours
                    }
                }

                endDate = me.adjustEndDate(endDate);

                deltas.push({
                    id       : me.dragProxy.vdom.cn[2].id,
                    innerHTML: owner.intlFormat_time.format(endDate)
                });

                if (keepEndDate || keepStartDate) {
                    height = Math.round(duration / (axisEndTime - axisStartTime) * 100 * 1000) / 1000;
                    deltas[0].style.height = `calc(${height}% - 2px)`
                }

                deltas.push({
                    id       : me.dragProxy.vdom.cn[0].id,
                    innerHTML: owner.intlFormat_time.format(startDate)
                });

                // check if the node got added yet
                if (me.dragProxy.vdom.cn[0].id) {
                    eventIntervals = (duration && duration * 60 || eventDuration) / timeAxis.interval;

                    if (eventIntervals <= 2) {
                        if (timeAxis.rowHeight / eventIntervals < 25 && !me.hasOverflow) {
                            deltas.push({
                                id : me.dragProxy.id,
                                cls: {add: ['neo-overflow']}
                            });

                            me.hasOverflow = true
                        }
                    } else if (me.hasOverflow) {
                        deltas.push({
                            id : me.dragProxy.id,
                            cls: {remove: ['neo-overflow']}
                        });

                        me.hasOverflow = false
                    }

                    Neo.applyDeltas(me.appName, deltas)
                }
            }

            me.currentInterval = currentInterval
        }
    }

    /**
     * @param {Object} data
     */
    dragStart(data) {
        let me = this,
            eventDuration, offsetX, offsetY;

        me.owner.getDomRect([me.getDragElementRoot().id, data.path[1].id]).then(rects => {
            eventDuration = (me.eventRecord.endDate - me.eventRecord.startDate) / 60 / 1000;
            offsetX       = data.clientX - rects[0].left;
            offsetY       = data.clientY - rects[0].top;

            Object.assign(me, {
                columnHeight   : rects[1].height,
                columnTop      : rects[1].top,
                dragElementRect: rects[0],
                eventDuration  : Math.round(eventDuration / me.intervalSize) * me.intervalSize,
                offsetX,
                offsetY
            });

            me.createDragProxy(rects[0]);

            me.fire('dragStart', {
                dragElementRect: rects[0],
                id             : me.id,
                offsetX,
                offsetY
            });

            me.dragMove(data)
        })
    }

    /**
     *
     */
    removeBodyCursorCls() {
        Neo.applyDeltas(this.appName, {id: 'document.body', cls: {remove: ['neo-cursor-move']}})
    }
}

Neo.setupClass(EventDragZone);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventDragZone);


/***/ }),

/***/ "./src/calendar/view/week/plugin/DragDrop.mjs":
/*!****************************************************!*\
  !*** ./src/calendar/view/week/plugin/DragDrop.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EventDragZone.mjs */ "./src/calendar/view/week/EventDragZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../util/VDom.mjs */ "./src/util/VDom.mjs");





const newRecordSymbol = Symbol.for('newRecordSymbol');

/**
 * @class Neo.calendar.view.week.plugin.DragDrop
 * @extends Neo.plugin.Base
 */
class DragDrop extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.plugin.DragDrop'
         * @protected
         */
        className: 'Neo.calendar.view.week.plugin.DragDrop',
        /**
         * @member {String} ntype='plugin-calendar-week-dragdrop'
         * @protected
         */
        ntype: 'plugin-calendar-week-dragdrop',
        /**
         * @member {Boolean} isDragging=false
         * @protected
         */
        isDragging: false,
        /**
         * @member {String} resizablePluginType='plugin-calendar-week-dragdrop'
         */
        resizablePluginType: 'calendar-week-eventresizable'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me         = this,
            columnOpts = {scope: me, delegate: '.neo-c-w-column'},
            eventOpts  = {scope: me, delegate: '.neo-event'};

        me.owner.addDomListeners([
            {'drag:end'  : me.onColumnDragEnd,   ...columnOpts},
            {'drag:end'  : me.onEventDragEnd,    ...eventOpts},
            {'drag:move' : me.onColumnDragMove,  ...columnOpts},
            {'drag:move' : me.onEventDragMove,   ...eventOpts},
            {'drag:start': me.onColumnDragStart, ...columnOpts},
            {'drag:start': me.onEventDragStart,  ...eventOpts}
        ]);
    }

    /**
     * Adjusts drag events which start on an event resize handle
     * @param {Object} data
     * @returns {Object}
     */
    adjustResizeEvent(data) {
        data.path.shift();
        data.targetPath.shift();
        data.target = data.path[0];

        return data;
    }

    /**
     * @param {Object} opts
     * @param {Object} opts.dragElement
     * @param {Boolean} opts.enableResizingAcrossOppositeEdge
     * @param {Object} opts.eventRecord
     * @param {String} opts.proxyParentId
     * @returns {Neo.calendar.view.week.EventDragZone}
     */
    getEventDragZone(opts) {
        let me                        = this,
            {appName, owner}          = me,
            {eventDragZone, timeAxis} = owner,

            config = {
                axisEndTime                     : timeAxis.getTime(owner.endTime),
                axisStartTime                   : timeAxis.getTime(owner.startTime),
                dragElement                     : opts.dragElement,
                enableResizingAcrossOppositeEdge: opts.enableResizingAcrossOppositeEdge,
                eventRecord                     : opts.eventRecord,
                proxyParentId                   : opts.proxyParentId
            };

        if (!eventDragZone) {
            owner.eventDragZone = eventDragZone = Neo.create({
                module           : _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                appName,
                owner,
                scrollContainerId: owner.getScrollContainer().id,
                ...config,

                dragProxyConfig: {
                    style: {
                        transition: 'none',
                        willChange: 'height'
                    }
                }
            })
        } else {
            eventDragZone.set(config)
        }

        return eventDragZone
    }

    /**
     * Returns the active field value of the active or first calendar record
     * @returns {Boolean}
     */
    isActiveCalendar() {
        let {owner}         = this,
            {calendarStore} = owner,
            calendarId      = owner.data.activeCalendarId || calendarStore.getAt(0)[calendarStore.keyProperty];

        return calendarStore.get(calendarId).active
    }

    /**
     * @param {Object} path
     * @returns {Boolean}
     */
    isTopLevelColumn(path) {
        return path[0].cls.includes('neo-c-w-column')
    }

    /**
     * @param {Object} eventData
     * @returns {Boolean}
     */
    isTopLevelEvent(eventData) {
        return eventData.path[0].cls.includes('neo-event')
    }

    /**
     * @param {Object} data
     */
    onColumnDragEnd(data) {
        let me      = this,
            {owner} = me,
            record  = me[newRecordSymbol];

        if (record && me.isTopLevelColumn(data.path)) {
            me.isDragging = false;

            delete me[newRecordSymbol];

            Neo.applyDeltas(me.appName, {
                id   : owner.getEventId(record.id),
                style: {opacity: 1}
            }).then(() => {
                owner.eventDragZone.dragEnd();
                owner.getPlugin(me.resizablePluginType).onDragEnd(data)
            })
        }
    }

    /**
     * @param {Object} data
     */
    onColumnDragMove(data) {
        let me = this;

        if (me.isActiveCalendar() && me.isTopLevelColumn(data.path)) {
            me.owner.eventDragZone?.dragMove(data)
        }
    }

    /**
     * @param {Object} data
     */
    onColumnDragStart(data) {
        let me = this;

        if (me.isActiveCalendar() && me.isTopLevelColumn(data.targetPath)) {
            let {owner}         = me,
                axisStartTime   = owner.timeAxis.getTime(owner.startTime),
                {calendarStore} = owner,
                columnRect      = data.path[0].rect,
                intervalSize    = 15,
                intervals       = (owner.timeAxis.getTime(owner.endTime) - axisStartTime) * 60 / intervalSize,
                intervalHeight  = columnRect.height / intervals,
                position        = Math.min(columnRect.height, data.clientY - columnRect.top),
                currentInterval = Math.floor(position / intervalHeight),
                startDate       = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].findVdomChild(owner.vdom, data.path[0].id).vdom.flag + 'T00:00:00.000Z'),
                dragElement, endDate, eventDragZone, eventId, record;

            me.isDragging = true;

            startDate.setHours(axisStartTime);
            startDate.setMinutes(Math.min(currentInterval * intervalSize, intervals * intervalSize - owner.minimumEventDuration));

            endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(startDate);

            endDate.setMinutes(endDate.getMinutes() + owner.minimumEventDuration);

            // 24:00 fix
            endDate.getHours() === 0 && endDate.getMinutes() === 0 && endDate.setMinutes(endDate.getMinutes() - 1);

            record = owner.eventStore.add({
                calendarId: owner.data.activeCalendarId || calendarStore.getAt(0)[calendarStore.keyProperty],
                endDate,
                startDate,
                title     : 'New Event'
            })[0];

            // we need to cache a reference to make the record accessible for onColumnDragEnd()
            me[newRecordSymbol] = record;

            // wait until the new event got mounted
            setTimeout(() => {
                eventId     = owner.getEventId(record.id);
                dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].findVdomChild(owner.vdom, eventId).vdom;

                eventDragZone = me.getEventDragZone({
                    dragElement,
                    enableResizingAcrossOppositeEdge: true,
                    eventRecord                     : record,
                    proxyParentId                   : data.path[0].id
                });

                owner.getPlugin(me.resizablePluginType).onDragStart(data);
                eventDragZone.dragStart(data);

                setTimeout(() => {
                    me.isDragging && Neo.applyDeltas(me.appName, {
                        id   : eventId,
                        style: {opacity: 0}
                    })
                }, 50)
            }, 50)
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragEnd(data) {
        let me              = this,
            {owner}         = me,
            {eventDragZone} = owner;

        if (owner.enableDrag) {
            eventDragZone.dragEnd();

            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data);
                owner.getPlugin(me.resizablePluginType).onDragEnd(data)
            } else {
                eventDragZone.removeBodyCursorCls()
            }

            me.isDragging = false
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragMove(data) {
        let me      = this,
            {owner} = me;

        if (owner.enableDrag) {
            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data)
            }

            owner.eventDragZone.dragMove(data)
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragStart(data) {
        let me        = this,
            {owner}   = me,
            modelData = owner.data;

        if (owner.enableDrag) {
            let isTopLevelEvent = me.isTopLevelEvent(data),
                dragElement, eventDragZone;

            if (!isTopLevelEvent) {
                data = me.adjustResizeEvent(data)
            }

            me.isDragging = true;

            dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].findVdomChild(owner.vdom, data.path[0].id).vdom;

            eventDragZone = me.getEventDragZone({
                dragElement,
                enableResizingAcrossOppositeEdge: modelData.events.enableResizingAcrossOppositeEdge,
                eventRecord                     : owner.eventStore.get(dragElement.flag),
                proxyParentId                   : data.path[1].id
            });

            if (isTopLevelEvent) {
                eventDragZone.addBodyCursorCls()
            } else {
                owner.getPlugin(me.resizablePluginType).onDragStart(data)
            }

            eventDragZone.dragStart(data)
        }
    }
}

Neo.setupClass(DragDrop);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragDrop);


/***/ }),

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.owner.mounted) {
            me.onOwnerMounted();
        } else {
            me.owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X3dlZWtfcGx1Z2luX0RyYWdEcm9wX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDbUI7QUFDVjtBQUNSO0FBQ0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUFRO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtB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O0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsUUFBUSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDN1RnQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQVE7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L3dlZWsvRXZlbnREcmFnWm9uZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L3dlZWsvcGx1Z2luL0RyYWdEcm9wLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGF0ZVV0aWwgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3V0aWwvRGF0ZS5tanMnO1xuaW1wb3J0IERyYWdQcm94eUNvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9kcmFnZ2FibGUvRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgRHJhZ1pvbmUgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy53ZWVrLkV2ZW50RHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqL1xuY2xhc3MgRXZlbnREcmFnWm9uZSBleHRlbmRzIERyYWdab25lIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LndlZWsuRXZlbnREcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudERyYWdab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFkZERyYWdQcm94eUNscz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRHJhZ1Byb3h5Q2xzOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBheGlzRW5kVGltZT0wXG4gICAgICAgICAqL1xuICAgICAgICBheGlzRW5kVGltZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXhpc1N0YXJ0VGltZT0wXG4gICAgICAgICAqL1xuICAgICAgICBheGlzU3RhcnRUaW1lOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb2x1bW5IZWlnaHQ9MFxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uSGVpZ2h0OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb2x1bW5Ub3A9MFxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uVG9wOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjdXJyZW50SW50ZXJ2YWw9MFxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudEludGVydmFsOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogdGltZSBpbiBtaW51dGVzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZXZlbnREdXJhdGlvbj0wXG4gICAgICAgICAqL1xuICAgICAgICBldmVudER1cmF0aW9uOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBldmVudFJlY29yZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudFJlY29yZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuXG4gICAgICAgICAqIElmIHdlIHJlc2l6ZSBhY3Jvc3MgdGhlIG9wcG9zaXRlIGVkZ2UgYW5kIHRoZW4gYmFjaywgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJlbGF0ZWQgZWRnZSBwb3NpdGlvbiBvbmNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmb3JjZVVwZGF0ZT1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmb3JjZVVwZGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhhc092ZXJmbG93PWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGhhc092ZXJmbG93OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRpbWUgaW4gbWludXRlc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGludGVydmFsU2l6ZT0xNVxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJ2YWxTaXplOiAxNSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGtlZXBFbmREYXRlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBrZWVwRW5kRGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBrZWVwU3RhcnREYXRlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBrZWVwU3RhcnREYXRlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVIb3Jpem9udGFsPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV9IG5ld0VuZERhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBuZXdFbmREYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy5cbiAgICAgICAgICogQG1lbWJlciB7RGF0ZX0gbmV3U3RhcnREYXRlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbmV3U3RhcnREYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxGYWN0b3JMZWZ0PTNcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbEZhY3RvckxlZnQ6IDMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VQcm94eVdyYXBwZXI9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHVzZVByb3h5V3JhcHBlcjogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEJvZHlDdXJzb3JDbHMoKSB7XG4gICAgICAgIE5lby5hcHBseURlbHRhcyh0aGlzLmFwcE5hbWUsIHtpZDogJ2RvY3VtZW50LmJvZHknLCBjbHM6IHthZGQ6IFsnbmVvLWN1cnNvci1tb3ZlJ119fSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgMjQ6MDAgaXNzdWUsIHdoZXJlIGFuIGV2ZW50IHdvdWxkIGVuZCBvbiB0aGUgbmV4dCBkYXlcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICAgKi9cbiAgICBhZGp1c3RFbmREYXRlKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUuZ2V0SG91cnMoKSA9PT0gMCAmJiBkYXRlLmdldE1pbnV0ZXMoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgYW4gZXZlbnQgZW5kcyBhdCAyNDowMCwgY2hhbmdlIGl0IHRvIDIzOjU5ID0+IG90aGVyd2lzZSB0aGUgZGF5IGluY3JlYXNlcyBieSAxXG4gICAgICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgLSAxKVxuICAgICAgICB9IGVsc2UgaWYgKCEoZGF0ZS5nZXRIb3VycygpID09PSAyMyAmJiBkYXRlLmdldE1pbnV0ZXMoKSA9PT0gNTkpICYmIGRhdGUuZ2V0TWludXRlcygpICUgdGhpcy5pbnRlcnZhbFNpemUgIT09IDApIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzd2l0Y2ggbm9uIGludGVydmFsIGJhc2VkIHZhbHVlcyBiYWNrXG4gICAgICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyAxKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHByb3h5UGFyZW50SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UHJveHlQYXJlbnRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBub2RlIGRpZCBub3QgZ2V0IHJlbW92ZWQgeWV0XG4gICAgICAgICAgICBpZiAobWUuZHJhZ1Byb3h5Py52ZG9tLmNuWzBdLmlkKSB7XG4gICAgICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uICA6ICdtb3ZlTm9kZScsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBtZS5kcmFnUHJveHkuaWQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICAgOiAwLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVEcmFnUHJveHkoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQobWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWQpIHx8IG1lLm93bmVyLFxuICAgICAgICAgICAgdmRvbSAgICAgID0gbWUuZHJhZ1Byb3h5Q29uZmlnPy52ZG9tLFxuICAgICAgICAgICAgY2xvbmUgICAgID0gVkRvbVV0aWwuY2xvbmUodmRvbSA/IHZkb20gOiBtZS5kcmFnRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGNsb25lLmNuWzJdLnJlbW92ZURvbSA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICA6IERyYWdQcm94eUNvbXBvbmVudCxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBtZS5tb3ZlSW5NYWluVGhyZWFkLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgIDogbWUucHJveHlQYXJlbnRJZCxcblxuICAgICAgICAgICAgLi4ubWUuZHJhZ1Byb3h5Q29uZmlnLFxuXG4gICAgICAgICAgICB2ZG9tOiBtZS51c2VQcm94eVdyYXBwZXIgPyB7Y246IFtjbG9uZV19IDogY2xvbmUgLy8gd2Ugd2FudCB0byBvdmVycmlkZSBkcmFnUHJveHlDb25maWcudmRvbSBpZiBuZWVkZWRcbiAgICAgICAgfTtcblxuICAgICAgICBjb25maWcuY2xzID0gY29uZmlnLmNscyB8fCBbXTtcblxuICAgICAgICBjb25maWcuY2xzLnB1c2goJ25lby1mb2N1cycpO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMucHVzaChjb21wb25lbnQuZ2V0VGhlbWUoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9uZS5jbHMgJiYgIW1lLnVzZVByb3h5V3JhcHBlcikge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKC4uLmNsb25lLmNscylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5hZGREcmFnUHJveHlDbHMpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjb25maWcuY2xzLCBtZS5kcmFnUHJveHlDbHMpXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZy5zdHlsZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBgJHtkYXRhLmhlaWdodH1weGAsXG4gICAgICAgICAgICB0b3AgICA6IGAke2RhdGEueSAtIG1lLmNvbHVtblRvcH1weGAsXG4gICAgICAgICAgICB3aWR0aCA6IGAke2RhdGEud2lkdGh9cHhgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdQcm94eSA9IE5lby5jcmVhdGUoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYWdFbmQgZXF1YWxzIGRyb3AsIHNpbmNlIHdlIGNhbiBvbmx5IGRyYWcgdG8gdmFsaWQgcG9zaXRpb25zXG4gICAgICogdG9kbzogRVNDIGtleVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIHN1cGVyLmRyYWdFbmQoZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgcmVjb3JkICA9IG1lLmV2ZW50UmVjb3JkLFxuICAgICAgICAgICAgZW5kRGF0ZSwgc3RhcnREYXRlO1xuXG4gICAgICAgIGlmIChtZS5rZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICBlbmREYXRlICAgPSBtZS5uZXdFbmREYXRlO1xuICAgICAgICAgICAgc3RhcnREYXRlID0gbWUubmV3U3RhcnREYXRlIHx8IHJlY29yZC5zdGFydERhdGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQob3duZXIudmRvbSwgbWUucHJveHlQYXJlbnRJZCkudmRvbS5mbGFnICsgJ1QwMDowMDowMC4wMDBaJyk7XG4gICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMobWUuYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhtZS5jdXJyZW50SW50ZXJ2YWwgKiBtZS5pbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICBpZiAobWUua2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICBlbmREYXRlICAgPSBtZS5uZXdFbmREYXRlICAgfHwgcmVjb3JkLmVuZERhdGU7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlID0gbWUubmV3U3RhcnREYXRlIHx8IHN0YXJ0RGF0ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmREYXRlID0gRGF0ZVV0aWwuY2xvbmUoc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZW5kRGF0ZS5nZXRNaW51dGVzKCkgKyBtZS5ldmVudER1cmF0aW9uKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZW5kRGF0ZSA9IG1lLmFkanVzdEVuZERhdGUoZW5kRGF0ZSk7XG5cbiAgICAgICAgcmVjb3JkLnNldFNpbGVudCh7XG4gICAgICAgICAgICBlbmREYXRlLFxuICAgICAgICAgICAgc3RhcnREYXRlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbDogMCxcbiAgICAgICAgICAgIGhhc092ZXJmbG93ICAgIDogZmFsc2UsXG4gICAgICAgICAgICBrZWVwRW5kRGF0ZSAgICA6IGZhbHNlLFxuICAgICAgICAgICAga2VlcFN0YXJ0RGF0ZSAgOiBmYWxzZSxcbiAgICAgICAgICAgIG5ld0VuZERhdGUgICAgIDogbnVsbCxcbiAgICAgICAgICAgIG5ld1N0YXJ0RGF0ZSAgIDogbnVsbCxcbiAgICAgICAgICAgIHByb3h5UGFyZW50SWQgIDogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0b2RvOiB1cGRhdGluZyBhIHJlY29yZCBmaWVsZCB3aGljaCBpcyBpbmNsdWRlZCBpbnNpZGUgYSBzb3J0ZXIgc2hvdWxkIHRyaWdnZXIgY29sbGVjdGlvbi5kb1NvcnQoKVxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMzkyXG5cbiAgICAgICAgb3duZXIuZ2V0TW9kZWwoKS5nZXRTdG9yZSgnZXZlbnRzJykuZG9Tb3J0KCk7XG4gICAgICAgIG93bmVyLnVwZGF0ZUV2ZW50cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBkcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2F4aXNFbmRUaW1lLCBheGlzU3RhcnRUaW1lLCBjb2x1bW5IZWlnaHQsIGV2ZW50RHVyYXRpb24sIGludGVydmFsU2l6ZSwga2VlcEVuZERhdGUsIGtlZXBTdGFydERhdGUsIG93bmVyfSA9IG1lLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIHBhdGggICAgICAgICAgICA9IGRhdGEudGFyZ2V0UGF0aCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgICA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgcmVjb3JkICAgICAgICAgID0gbWUuZXZlbnRSZWNvcmQsXG4gICAgICAgICAgICBzd2l0Y2hEaXJlY3Rpb24gPSBmYWxzZSxcbiAgICAgICAgICAgIHt0aW1lQXhpc30gICAgICA9IG93bmVyLFxuICAgICAgICAgICAgYXhpc1N0YXJ0RGF0ZSwgY3VycmVudEludGVydmFsLCBkZWx0YXMsIGR1cmF0aW9uLCBlbmREYXRlLCBldmVudEludGVydmFscywgaGVpZ2h0LCBpbnRlcnZhbEhlaWdodCxcbiAgICAgICAgICAgIGludGVydmFscywgbGltaXRJbnRlcnZhbCwgbWluaW11bUV2ZW50SW50ZXJ2YWxzLCBwb3NpdGlvbiwgc3RhcnREYXRlLCBzdGFydEludGVydmFsO1xuXG4gICAgICAgIGlmIChtZS5kcmFnUHJveHkpIHtcbiAgICAgICAgICAgIGlmICgha2VlcEVuZERhdGUgJiYgIWtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoW2ldLmNscy5pbmNsdWRlcygnbmVvLWMtdy1jb2x1bW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucHJveHlQYXJlbnRJZCA9IHBhdGhbaV0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnRlcnZhbHMgICAgICA9IChheGlzRW5kVGltZSAtIGF4aXNTdGFydFRpbWUpICogNjAgLyBpbnRlcnZhbFNpemU7IC8vIDE1IG1pbnV0ZXMgZWFjaFxuICAgICAgICAgICAgaW50ZXJ2YWxIZWlnaHQgPSBjb2x1bW5IZWlnaHQgLyBpbnRlcnZhbHM7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gTWF0aC5taW4oY29sdW1uSGVpZ2h0LCBkYXRhLmNsaWVudFkgLSBtZS5vZmZzZXRZIC0gbWUuY29sdW1uVG9wKTtcblxuICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5mbG9vcihwb3NpdGlvbiAvIGludGVydmFsSGVpZ2h0KTtcblxuICAgICAgICAgICAgZW5kRGF0ZSAgID0gRGF0ZVV0aWwuY2xvbmUocmVjb3JkLmVuZERhdGUpO1xuICAgICAgICAgICAgc3RhcnREYXRlID0gRGF0ZVV0aWwuY2xvbmUocmVjb3JkLnN0YXJ0RGF0ZSk7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50cyBjYW4gaGF2ZSBhIHNtYWxsZXIgc3RhcnQgdGltZSB0aGFuIHRoZSBheGlzIG1pbiB2YWx1ZS5cbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIHZpYSB0aGUgbm9ydGggaGFuZGxlIG5lZWRzIHRvIGFkanVzdCB0aGUgZHVyYXRpb24gdG8gaG9ub3IgdGhpcy5cbiAgICAgICAgICAgIGlmIChrZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzU3RhcnRUaW1lID4gc3RhcnREYXRlLmdldEhvdXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcygwKTtcblxuICAgICAgICAgICAgICAgICAgICBldmVudER1cmF0aW9uID0gKGVuZERhdGUgLSBzdGFydERhdGUpIC8gNjAgLyAxMDAwIC8vIGR1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV2ZW50cyBjYW4gaGF2ZSBhIGJpZ2dlciBlbmQgdGltZSB0aGFuIHRoZSBheGlzIG1heCB2YWx1ZS5cbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIHZpYSB0aGUgc291dGggaGFuZGxlIG5lZWRzIHRvIGFkanVzdCB0aGUgZHVyYXRpb24gdG8gaG9ub3IgdGhpcy5cbiAgICAgICAgICAgIGlmIChrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNFbmRUaW1lIDwgZW5kRGF0ZS5nZXRIb3VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoYXhpc0VuZFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnREdXJhdGlvbiA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gMTAwMCAvLyBkdXJhdGlvbiBpbiBtaW51dGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWtlZXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzIG11c3Qgbm90IGVuZCBhZnRlciB0aGUgbGFzdCB2aXNpYmxlIGludGVydmFsXG4gICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5taW4oY3VycmVudEludGVydmFsLCBpbnRlcnZhbHMgLSAoZXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbHRhcyA9IFt7XG4gICAgICAgICAgICAgICAgaWQgICA6IG1lLmRyYWdQcm94eS5pZCxcbiAgICAgICAgICAgICAgICBzdHlsZToge31cbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBpZiAoa2VlcEVuZERhdGUgfHwga2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIGF4aXNTdGFydERhdGUgPSBEYXRlVXRpbC5jbG9uZShyZWNvcmQuc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICBheGlzU3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIGF4aXNTdGFydERhdGUuc2V0TWludXRlcygwKTtcblxuICAgICAgICAgICAgICAgIG1pbmltdW1FdmVudEludGVydmFscyA9IG93bmVyLm1pbmltdW1FdmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplO1xuICAgICAgICAgICAgICAgIHN0YXJ0SW50ZXJ2YWwgICAgICAgICA9IChyZWNvcmQuc3RhcnREYXRlIC0gYXhpc1N0YXJ0RGF0ZSkgLyBpbnRlcnZhbFNpemUgLyA2MCAvIDEwMDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbnRlcnZhbCA9IHN0YXJ0SW50ZXJ2YWwgKyAoZXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWUuZm9yY2VVcGRhdGUgJiYgY3VycmVudEludGVydmFsID4gbGltaXRJbnRlcnZhbCAtbWluaW11bUV2ZW50SW50ZXJ2YWxzICYmIGN1cnJlbnRJbnRlcnZhbCA8IGxpbWl0SW50ZXJ2YWwgKyBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHdlIHJlc2l6ZSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBkaXJlY3Rpb24sIGtlZXAgdGhlIG1pbiBpbnRlcnZhbCB1bnRpbCB3ZSBzbmFwIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEludGVydmFsID49IGxpbWl0SW50ZXJ2YWwgKyBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2hEaXJlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZvcmNlVXBkYXRlICA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcyhjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUgPSBtZS5hZGp1c3RFbmREYXRlKGVuZERhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3RW5kRGF0ZSA9IGVuZERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldE1pbnV0ZXMobGltaXRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdTdGFydERhdGUgPSBzdGFydERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwOyAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhc1swXS5zdHlsZS50b3AgPSBgY2FsYygke2xpbWl0SW50ZXJ2YWwgKiBpbnRlcnZhbEhlaWdodCAvIGNvbHVtbkhlaWdodCAqIDEwMH0lICsgMXB4KWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuZm9yY2VVcGRhdGUgID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3U3RhcnREYXRlID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzd2l0Y2hEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWluKGN1cnJlbnRJbnRlcnZhbCwgbGltaXRJbnRlcnZhbCAtIG1pbmltdW1FdmVudEludGVydmFscylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0SW50ZXJ2YWwgPSBzdGFydEludGVydmFsIC0gKGV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5lbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnRzIG11c3Qgbm90IHN0YXJ0IGJlZm9yZSB0aGUgZmlyc3QgdmlzaWJsZSBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5tYXgoLShldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplKSwgY3VycmVudEludGVydmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbnRlcnZhbCA8PSBsaW1pdEludGVydmFsIC0gbWluaW11bUV2ZW50SW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoRGlyZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5mb3JjZVVwZGF0ZSAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZXZlbnREdXJhdGlvbiArIGxpbWl0SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUgPSBtZS5hZGp1c3RFbmREYXRlKGVuZERhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3RW5kRGF0ZSA9IGVuZERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldE1pbnV0ZXMoZXZlbnREdXJhdGlvbiArIGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdTdGFydERhdGUgPSBzdGFydERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwOyAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAoZXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZSArIGN1cnJlbnRJbnRlcnZhbCkgKiBpbnRlcnZhbEhlaWdodDsgLy8gc25hcCB0byB2YWxpZCBpbnRlcnZhbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIC8gY29sdW1uSGVpZ2h0ICogMTAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzWzBdLnN0eWxlLnRvcCA9IGBjYWxjKCR7cG9zaXRpb259JSArIDFweClgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lLmZvcmNlVXBkYXRlICYmIGN1cnJlbnRJbnRlcnZhbCA8IGxpbWl0SW50ZXJ2YWwgKyBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHdlIHJlc2l6ZSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBkaXJlY3Rpb24sIGtlZXAgdGhlIG1pbiBpbnRlcnZhbCB1bnRpbCB3ZSBzbmFwIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuZm9yY2VVcGRhdGUgJiYgY3VycmVudEludGVydmFsID49IGxpbWl0SW50ZXJ2YWwgKyBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWUuY3VycmVudEludGVydmFsICE9PSBjdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuZm9yY2VVcGRhdGUgID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld1N0YXJ0RGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhc1swXS5zdHlsZS50b3AgPSBgY2FsYygke3N0YXJ0SW50ZXJ2YWwgKiBpbnRlcnZhbEhlaWdodCAvIGNvbHVtbkhlaWdodCAqIDEwMH0lICsgMXB4KWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5tYXgoY3VycmVudEludGVydmFsLCBsaW1pdEludGVydmFsICsgbWluaW11bUV2ZW50SW50ZXJ2YWxzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgbXVzdCBub3Qgc3RhcnQgYmVmb3JlIHRoZSBmaXJzdCB2aXNpYmxlIGludGVydmFsXG4gICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5tYXgoMCwgY3VycmVudEludGVydmFsKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUuY3VycmVudEludGVydmFsICE9PSBjdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtlZXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKGV2ZW50RHVyYXRpb24gKyBjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3RW5kRGF0ZSA9IGVuZERhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IChlbmREYXRlIC0gcmVjb3JkLnN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMCAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldE1pbnV0ZXMoY3VycmVudEludGVydmFsICogaW50ZXJ2YWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbEhlaWdodDsgLy8gc25hcCB0byB2YWxpZCBpbnRlcnZhbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gLyBjb2x1bW5IZWlnaHQgKiAxMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhc1swXS5zdHlsZS50b3AgPSBgY2FsYygke3Bvc2l0aW9ufSUgKyAxcHgpYFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IChyZWNvcmQuZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMCAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZW5kRGF0ZSA9IG1lLmFkanVzdEVuZERhdGUoZW5kRGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogbWUuZHJhZ1Byb3h5LnZkb20uY25bMl0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogb3duZXIuaW50bEZvcm1hdF90aW1lLmZvcm1hdChlbmREYXRlKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlIHx8IGtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIChheGlzRW5kVGltZSAtIGF4aXNTdGFydFRpbWUpICogMTAwICogMTAwMCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUuaGVpZ2h0ID0gYGNhbGMoJHtoZWlnaHR9JSAtIDJweClgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmRyYWdQcm94eS52ZG9tLmNuWzBdLmlkLFxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUw6IG93bmVyLmludGxGb3JtYXRfdGltZS5mb3JtYXQoc3RhcnREYXRlKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5vZGUgZ290IGFkZGVkIHlldFxuICAgICAgICAgICAgICAgIGlmIChtZS5kcmFnUHJveHkudmRvbS5jblswXS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudEludGVydmFscyA9IChkdXJhdGlvbiAmJiBkdXJhdGlvbiAqIDYwIHx8IGV2ZW50RHVyYXRpb24pIC8gdGltZUF4aXMuaW50ZXJ2YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SW50ZXJ2YWxzIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lQXhpcy5yb3dIZWlnaHQgLyBldmVudEludGVydmFscyA8IDI1ICYmICFtZS5oYXNPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgOiBtZS5kcmFnUHJveHkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczoge2FkZDogWyduZW8tb3ZlcmZsb3cnXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmhhc092ZXJmbG93ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lLmhhc092ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgOiBtZS5kcmFnUHJveHkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB7cmVtb3ZlOiBbJ25lby1vdmVyZmxvdyddfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmhhc092ZXJmbG93ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCBkZWx0YXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5jdXJyZW50SW50ZXJ2YWwgPSBjdXJyZW50SW50ZXJ2YWxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGV2ZW50RHVyYXRpb24sIG9mZnNldFgsIG9mZnNldFk7XG5cbiAgICAgICAgbWUub3duZXIuZ2V0RG9tUmVjdChbbWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWQsIGRhdGEucGF0aFsxXS5pZF0pLnRoZW4ocmVjdHMgPT4ge1xuICAgICAgICAgICAgZXZlbnREdXJhdGlvbiA9IChtZS5ldmVudFJlY29yZC5lbmREYXRlIC0gbWUuZXZlbnRSZWNvcmQuc3RhcnREYXRlKSAvIDYwIC8gMTAwMDtcbiAgICAgICAgICAgIG9mZnNldFggICAgICAgPSBkYXRhLmNsaWVudFggLSByZWN0c1swXS5sZWZ0O1xuICAgICAgICAgICAgb2Zmc2V0WSAgICAgICA9IGRhdGEuY2xpZW50WSAtIHJlY3RzWzBdLnRvcDtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGNvbHVtbkhlaWdodCAgIDogcmVjdHNbMV0uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbHVtblRvcCAgICAgIDogcmVjdHNbMV0udG9wLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdDogcmVjdHNbMF0sXG4gICAgICAgICAgICAgICAgZXZlbnREdXJhdGlvbiAgOiBNYXRoLnJvdW5kKGV2ZW50RHVyYXRpb24gLyBtZS5pbnRlcnZhbFNpemUpICogbWUuaW50ZXJ2YWxTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmNyZWF0ZURyYWdQcm94eShyZWN0c1swXSk7XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ2RyYWdTdGFydCcsIHtcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3RzWzBdLFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuZHJhZ01vdmUoZGF0YSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUJvZHlDdXJzb3JDbHMoKSB7XG4gICAgICAgIE5lby5hcHBseURlbHRhcyh0aGlzLmFwcE5hbWUsIHtpZDogJ2RvY3VtZW50LmJvZHknLCBjbHM6IHtyZW1vdmU6IFsnbmVvLWN1cnNvci1tb3ZlJ119fSlcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKEV2ZW50RHJhZ1pvbmUpO1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudERyYWdab25lO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vcGx1Z2luL0Jhc2UubWpzJztcbmltcG9ydCBEYXRlVXRpbCAgICAgIGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvRGF0ZS5tanMnO1xuaW1wb3J0IEV2ZW50RHJhZ1pvbmUgZnJvbSAnLi4vRXZlbnREcmFnWm9uZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbmNvbnN0IG5ld1JlY29yZFN5bWJvbCA9IFN5bWJvbC5mb3IoJ25ld1JlY29yZFN5bWJvbCcpO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy53ZWVrLnBsdWdpbi5EcmFnRHJvcFxuICogQGV4dGVuZHMgTmVvLnBsdWdpbi5CYXNlXG4gKi9cbmNsYXNzIERyYWdEcm9wIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy53ZWVrLnBsdWdpbi5EcmFnRHJvcCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5wbHVnaW4uRHJhZ0Ryb3AnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luLWNhbGVuZGFyLXdlZWstZHJhZ2Ryb3AnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luLWNhbGVuZGFyLXdlZWstZHJhZ2Ryb3AnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNEcmFnZ2luZz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVzaXphYmxlUGx1Z2luVHlwZT0ncGx1Z2luLWNhbGVuZGFyLXdlZWstZHJhZ2Ryb3AnXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemFibGVQbHVnaW5UeXBlOiAnY2FsZW5kYXItd2Vlay1ldmVudHJlc2l6YWJsZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb2x1bW5PcHRzID0ge3Njb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLWMtdy1jb2x1bW4nfSxcbiAgICAgICAgICAgIGV2ZW50T3B0cyAgPSB7c2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tZXZlbnQnfTtcblxuICAgICAgICBtZS5vd25lci5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25Db2x1bW5EcmFnRW5kLCAgIC4uLmNvbHVtbk9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25FdmVudERyYWdFbmQsICAgIC4uLmV2ZW50T3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6bW92ZScgOiBtZS5vbkNvbHVtbkRyYWdNb3ZlLCAgLi4uY29sdW1uT3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6bW92ZScgOiBtZS5vbkV2ZW50RHJhZ01vdmUsICAgLi4uZXZlbnRPcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uQ29sdW1uRHJhZ1N0YXJ0LCAuLi5jb2x1bW5PcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uRXZlbnREcmFnU3RhcnQsICAuLi5ldmVudE9wdHN9XG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgZHJhZyBldmVudHMgd2hpY2ggc3RhcnQgb24gYW4gZXZlbnQgcmVzaXplIGhhbmRsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhZGp1c3RSZXNpemVFdmVudChkYXRhKSB7XG4gICAgICAgIGRhdGEucGF0aC5zaGlmdCgpO1xuICAgICAgICBkYXRhLnRhcmdldFBhdGguc2hpZnQoKTtcbiAgICAgICAgZGF0YS50YXJnZXQgPSBkYXRhLnBhdGhbMF07XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kcmFnRWxlbWVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0cy5lbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmV2ZW50UmVjb3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucHJveHlQYXJlbnRJZFxuICAgICAqIEByZXR1cm5zIHtOZW8uY2FsZW5kYXIudmlldy53ZWVrLkV2ZW50RHJhZ1pvbmV9XG4gICAgICovXG4gICAgZ2V0RXZlbnREcmFnWm9uZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lLCBvd25lcn0gICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIHtldmVudERyYWdab25lLCB0aW1lQXhpc30gPSBvd25lcixcblxuICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGF4aXNFbmRUaW1lICAgICAgICAgICAgICAgICAgICAgOiB0aW1lQXhpcy5nZXRUaW1lKG93bmVyLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIGF4aXNTdGFydFRpbWUgICAgICAgICAgICAgICAgICAgOiB0aW1lQXhpcy5nZXRUaW1lKG93bmVyLnN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQgICAgICAgICAgICAgICAgICAgICA6IG9wdHMuZHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2U6IG9wdHMuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2UsXG4gICAgICAgICAgICAgICAgZXZlbnRSZWNvcmQgICAgICAgICAgICAgICAgICAgICA6IG9wdHMuZXZlbnRSZWNvcmQsXG4gICAgICAgICAgICAgICAgcHJveHlQYXJlbnRJZCAgICAgICAgICAgICAgICAgICA6IG9wdHMucHJveHlQYXJlbnRJZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWV2ZW50RHJhZ1pvbmUpIHtcbiAgICAgICAgICAgIG93bmVyLmV2ZW50RHJhZ1pvbmUgPSBldmVudERyYWdab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICA6IEV2ZW50RHJhZ1pvbmUsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICBzY3JvbGxDb250YWluZXJJZDogb3duZXIuZ2V0U2Nyb2xsQ29udGFpbmVyKCkuaWQsXG4gICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuXG4gICAgICAgICAgICAgICAgZHJhZ1Byb3h5Q29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWxsQ2hhbmdlOiAnaGVpZ2h0J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUuc2V0KGNvbmZpZylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudERyYWdab25lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aXZlIGZpZWxkIHZhbHVlIG9mIHRoZSBhY3RpdmUgb3IgZmlyc3QgY2FsZW5kYXIgcmVjb3JkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBY3RpdmVDYWxlbmRhcigpIHtcbiAgICAgICAgbGV0IHtvd25lcn0gICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2FsZW5kYXJTdG9yZX0gPSBvd25lcixcbiAgICAgICAgICAgIGNhbGVuZGFySWQgICAgICA9IG93bmVyLmRhdGEuYWN0aXZlQ2FsZW5kYXJJZCB8fCBjYWxlbmRhclN0b3JlLmdldEF0KDApW2NhbGVuZGFyU3RvcmUua2V5UHJvcGVydHldO1xuXG4gICAgICAgIHJldHVybiBjYWxlbmRhclN0b3JlLmdldChjYWxlbmRhcklkKS5hY3RpdmVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF0aFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVG9wTGV2ZWxDb2x1bW4ocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1jLXctY29sdW1uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUb3BMZXZlbEV2ZW50KGV2ZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gZXZlbnREYXRhLnBhdGhbMF0uY2xzLmluY2x1ZGVzKCduZW8tZXZlbnQnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db2x1bW5EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgcmVjb3JkICA9IG1lW25ld1JlY29yZFN5bWJvbF07XG5cbiAgICAgICAgaWYgKHJlY29yZCAmJiBtZS5pc1RvcExldmVsQ29sdW1uKGRhdGEucGF0aCkpIHtcbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgZGVsZXRlIG1lW25ld1JlY29yZFN5bWJvbF07XG5cbiAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCB7XG4gICAgICAgICAgICAgICAgaWQgICA6IG93bmVyLmdldEV2ZW50SWQocmVjb3JkLmlkKSxcbiAgICAgICAgICAgICAgICBzdHlsZToge29wYWNpdHk6IDF9XG4gICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvd25lci5ldmVudERyYWdab25lLmRyYWdFbmQoKTtcbiAgICAgICAgICAgICAgICBvd25lci5nZXRQbHVnaW4obWUucmVzaXphYmxlUGx1Z2luVHlwZSkub25EcmFnRW5kKGRhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbHVtbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNBY3RpdmVDYWxlbmRhcigpICYmIG1lLmlzVG9wTGV2ZWxDb2x1bW4oZGF0YS5wYXRoKSkge1xuICAgICAgICAgICAgbWUub3duZXIuZXZlbnREcmFnWm9uZT8uZHJhZ01vdmUoZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db2x1bW5EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0FjdGl2ZUNhbGVuZGFyKCkgJiYgbWUuaXNUb3BMZXZlbENvbHVtbihkYXRhLnRhcmdldFBhdGgpKSB7XG4gICAgICAgICAgICBsZXQge293bmVyfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0VGltZSAgID0gb3duZXIudGltZUF4aXMuZ2V0VGltZShvd25lci5zdGFydFRpbWUpLFxuICAgICAgICAgICAgICAgIHtjYWxlbmRhclN0b3JlfSA9IG93bmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtblJlY3QgICAgICA9IGRhdGEucGF0aFswXS5yZWN0LFxuICAgICAgICAgICAgICAgIGludGVydmFsU2l6ZSAgICA9IDE1LFxuICAgICAgICAgICAgICAgIGludGVydmFscyAgICAgICA9IChvd25lci50aW1lQXhpcy5nZXRUaW1lKG93bmVyLmVuZFRpbWUpIC0gYXhpc1N0YXJ0VGltZSkgKiA2MCAvIGludGVydmFsU2l6ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbEhlaWdodCAgPSBjb2x1bW5SZWN0LmhlaWdodCAvIGludGVydmFscyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiAgICAgICAgPSBNYXRoLm1pbihjb2x1bW5SZWN0LmhlaWdodCwgZGF0YS5jbGllbnRZIC0gY29sdW1uUmVjdC50b3ApLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGguZmxvb3IocG9zaXRpb24gLyBpbnRlcnZhbEhlaWdodCksXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlICAgICAgID0gbmV3IERhdGUoVkRvbVV0aWwuZmluZFZkb21DaGlsZChvd25lci52ZG9tLCBkYXRhLnBhdGhbMF0uaWQpLnZkb20uZmxhZyArICdUMDA6MDA6MDAuMDAwWicpLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50LCBlbmREYXRlLCBldmVudERyYWdab25lLCBldmVudElkLCByZWNvcmQ7XG5cbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhNYXRoLm1pbihjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUsIGludGVydmFscyAqIGludGVydmFsU2l6ZSAtIG93bmVyLm1pbmltdW1FdmVudER1cmF0aW9uKSk7XG5cbiAgICAgICAgICAgIGVuZERhdGUgPSBEYXRlVXRpbC5jbG9uZShzdGFydERhdGUpO1xuXG4gICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZW5kRGF0ZS5nZXRNaW51dGVzKCkgKyBvd25lci5taW5pbXVtRXZlbnREdXJhdGlvbik7XG5cbiAgICAgICAgICAgIC8vIDI0OjAwIGZpeFxuICAgICAgICAgICAgZW5kRGF0ZS5nZXRIb3VycygpID09PSAwICYmIGVuZERhdGUuZ2V0TWludXRlcygpID09PSAwICYmIGVuZERhdGUuc2V0TWludXRlcyhlbmREYXRlLmdldE1pbnV0ZXMoKSAtIDEpO1xuXG4gICAgICAgICAgICByZWNvcmQgPSBvd25lci5ldmVudFN0b3JlLmFkZCh7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJJZDogb3duZXIuZGF0YS5hY3RpdmVDYWxlbmRhcklkIHx8IGNhbGVuZGFyU3RvcmUuZ2V0QXQoMClbY2FsZW5kYXJTdG9yZS5rZXlQcm9wZXJ0eV0sXG4gICAgICAgICAgICAgICAgZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgdGl0bGUgICAgIDogJ05ldyBFdmVudCdcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNhY2hlIGEgcmVmZXJlbmNlIHRvIG1ha2UgdGhlIHJlY29yZCBhY2Nlc3NpYmxlIGZvciBvbkNvbHVtbkRyYWdFbmQoKVxuICAgICAgICAgICAgbWVbbmV3UmVjb3JkU3ltYm9sXSA9IHJlY29yZDtcblxuICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV3IGV2ZW50IGdvdCBtb3VudGVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudElkICAgICA9IG93bmVyLmdldEV2ZW50SWQocmVjb3JkLmlkKTtcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQob3duZXIudmRvbSwgZXZlbnRJZCkudmRvbTtcblxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUgPSBtZS5nZXRFdmVudERyYWdab25lKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBldmVudFJlY29yZCAgICAgICAgICAgICAgICAgICAgIDogcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICBwcm94eVBhcmVudElkICAgICAgICAgICAgICAgICAgIDogZGF0YS5wYXRoWzBdLmlkXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBvd25lci5nZXRQbHVnaW4obWUucmVzaXphYmxlUGx1Z2luVHlwZSkub25EcmFnU3RhcnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5kcmFnU3RhcnQoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNEcmFnZ2luZyAmJiBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICA6IGV2ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge29wYWNpdHk6IDB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSwgNTApXG4gICAgICAgICAgICB9LCA1MClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudERyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gICAgICAgICA9IG1lLFxuICAgICAgICAgICAge2V2ZW50RHJhZ1pvbmV9ID0gb3duZXI7XG5cbiAgICAgICAgaWYgKG93bmVyLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUuZHJhZ0VuZCgpO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmlzVG9wTGV2ZWxFdmVudChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtZS5hZGp1c3RSZXNpemVFdmVudChkYXRhKTtcbiAgICAgICAgICAgICAgICBvd25lci5nZXRQbHVnaW4obWUucmVzaXphYmxlUGx1Z2luVHlwZSkub25EcmFnRW5kKGRhdGEpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUucmVtb3ZlQm9keUN1cnNvckNscygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50RHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWU7XG5cbiAgICAgICAgaWYgKG93bmVyLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIGlmICghbWUuaXNUb3BMZXZlbEV2ZW50KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG1lLmFkanVzdFJlc2l6ZUV2ZW50KGRhdGEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG93bmVyLmV2ZW50RHJhZ1pvbmUuZHJhZ01vdmUoZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudERyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSAgID0gbWUsXG4gICAgICAgICAgICBtb2RlbERhdGEgPSBvd25lci5kYXRhO1xuXG4gICAgICAgIGlmIChvd25lci5lbmFibGVEcmFnKSB7XG4gICAgICAgICAgICBsZXQgaXNUb3BMZXZlbEV2ZW50ID0gbWUuaXNUb3BMZXZlbEV2ZW50KGRhdGEpLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50LCBldmVudERyYWdab25lO1xuXG4gICAgICAgICAgICBpZiAoIWlzVG9wTGV2ZWxFdmVudCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtZS5hZGp1c3RSZXNpemVFdmVudChkYXRhKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgZHJhZ0VsZW1lbnQgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG93bmVyLnZkb20sIGRhdGEucGF0aFswXS5pZCkudmRvbTtcblxuICAgICAgICAgICAgZXZlbnREcmFnWm9uZSA9IG1lLmdldEV2ZW50RHJhZ1pvbmUoe1xuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50LFxuICAgICAgICAgICAgICAgIGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlOiBtb2RlbERhdGEuZXZlbnRzLmVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlLFxuICAgICAgICAgICAgICAgIGV2ZW50UmVjb3JkICAgICAgICAgICAgICAgICAgICAgOiBvd25lci5ldmVudFN0b3JlLmdldChkcmFnRWxlbWVudC5mbGFnKSxcbiAgICAgICAgICAgICAgICBwcm94eVBhcmVudElkICAgICAgICAgICAgICAgICAgIDogZGF0YS5wYXRoWzFdLmlkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzVG9wTGV2ZWxFdmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUuYWRkQm9keUN1cnNvckNscygpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG93bmVyLmdldFBsdWdpbihtZS5yZXNpemFibGVQbHVnaW5UeXBlKS5vbkRyYWdTdGFydChkYXRhKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudERyYWdab25lLmRyYWdTdGFydChkYXRhKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhEcmFnRHJvcCk7XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdEcm9wO1xuIiwiaW1wb3J0IENvcmVCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHBsdWdpbiBpbXBsZW1lbnRhdGlvbnMuXG4gKiBQbHVnaW5zIGFyZSBpbnRlbmRlZCB0byBnZXQgcHV0IGludG8gdGhlIHBsdWdpbnMgY29uZmlnIG9mIGNvbXBvbmVudC5CYXNlXG4gKiB0byBlbmhhbmNlIHRoZW0gb3IgYWRkIGFkZGl0aW9uYWwgZmVhdHVyZXNcbiAqIEBjbGFzcyBOZW8ucGx1Z2luLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvcmVCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5wbHVnaW4uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnBsdWdpbi5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBwbHVnaW4gbnR5cGVzIG5lZWQgdG8gc3RhcnQgd2l0aCAncGx1Z2luLScgdG8gZW5zdXJlIHRoYXQgY29tcG9uZW50LkJhc2U6IGdldFBsdWdpbigpIGNhbiBmaW5kIHRoZW1cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5vd25lci5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyTW91bnRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUub3duZXIub24oJ21vdW50ZWQnLCBtZS5vbk93bmVyTW91bnRlZCwgbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgZG9lcyBnZXQgbW91bnRlZFxuICAgICAqL1xuICAgIG9uT3duZXJNb3VudGVkKCkge1xuXG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhCYXNlKTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==