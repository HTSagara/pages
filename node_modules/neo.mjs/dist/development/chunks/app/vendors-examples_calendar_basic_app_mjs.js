"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_calendar_basic_app_mjs"],{

/***/ "./examples/calendar/basic/MainContainer.mjs":
/*!***************************************************!*\
  !*** ./examples/calendar/basic/MainContainer.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_calendar_view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/calendar/view/MainContainer.mjs */ "./src/calendar/view/MainContainer.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./examples/calendar/basic/MainContainerController.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");






/**
 * @class Neo.examples.calendar.basic.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        className : 'Neo.examples.calendar.basic.MainContainer',
        autoMount : true,
        cls       : ['neo-examples-calendar-maincontainer', 'neo-viewport'],
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        layout    : {ntype: 'vbox', align: 'stretch'},

        items: [{
            module : _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex   : 'none',
            padding: 20,
            reference: 'headerToolbar',

            style: {
                backgroundColor: '#f2f2f2',
                padding        : '10px 5px 10px 10px'
            },

            items: [{
                ntype: 'component',
                cls  : ['neo-header'],
                html : '<i class="fa fa-calendar"></i>neo.mjs Calendar'
            }, '->', {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'onSwitchThemeButtonClick',
                height : 27,
                iconCls: 'fa fa-moon',
                text   : 'Theme Dark'
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                height : 27,
                iconCls: 'fab fa-github',
                style  : {marginLeft: '5px'},
                text   : 'GitHub',
                url    : 'https://github.com/neomjs/neo/tree/dev/src/calendar'
            }]
        }, {
            module   : _src_calendar_view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 1,
            reference: 'calendar',

            calendarStoreConfig: {
                autoLoad: true,
                url     : '../../examples/calendar/basic/data/calendars.json'
            },

            eventStoreConfig: {
                autoLoad: true,
                url     : '../../examples/calendar/basic/data/events.json'
            },

            modelData: {
                currentDate: new Date('2021-07-20')
            }
        }]
    }
}

Neo.setupClass(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./examples/calendar/basic/MainContainerController.mjs":
/*!*************************************************************!*\
  !*** ./examples/calendar/basic/MainContainerController.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.examples.calendar.basic.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.examples.calendar.basic.MainContainerController'
         * @protected
         */
        className: 'Neo.examples.calendar.basic.MainContainerController'
    }

    /**
     * @param {Object} data
     */
    onSwitchThemeButtonClick(data) {
        let me            = this,
            button        = data.component,
            component     = me.component,
            headerToolbar = me.getReference('headerToolbar'),
            buttonText, cls, headerColor, iconCls, style, theme;

        if (button.text === 'Theme Light') {
            buttonText  = 'Theme Dark';
            headerColor = '#f2f2f2';
            iconCls     = 'fa fa-moon';
            theme       = 'neo-theme-light';
        } else {
            buttonText  = 'Theme Light';
            headerColor = '#33343d';
            iconCls     = 'fa fa-sun';
            theme       = 'neo-theme-dark';
        }

        cls = [...component.cls];

        component.cls.forEach(item => {
            if (item.includes('neo-theme')) {
                _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, item);
            }
        });

        _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, theme);
        component.cls = cls;

        button.set({
            iconCls,
            text: buttonText
        });

        style = headerToolbar.style || {};
        style.backgroundColor = headerColor;
        headerToolbar.style = style;
    }
}

Neo.setupClass(MainContainerController);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainerController);


/***/ }),

/***/ "./examples/calendar/basic/app.mjs":
/*!*****************************************!*\
  !*** ./examples/calendar/basic/app.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/calendar/basic/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.calendar.basic'
});


/***/ }),

/***/ "./src/calendar/view/EditEventContainer.mjs":
/*!**************************************************!*\
  !*** ./src/calendar/view/EditEventContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _store_Calendars_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/Calendars.mjs */ "./src/calendar/store/Calendars.mjs");
/* harmony import */ var _form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Color.mjs */ "./src/form/field/Color.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _form_Container_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _form_field_Time_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../form/field/Time.mjs */ "./src/form/field/Time.mjs");








/**
 * @class Neo.calendar.view.EditEventContainer
 * @extends Neo.form.Container
 */
class EditEventContainer extends _form_Container_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.EditEventContainer'
         * @protected
         */
        className: 'Neo.calendar.view.EditEventContainer',
        /**
         * @member {String[]} baseCls=['neo-calendar-edit-event-container']
         */
        baseCls: ['neo-calendar-edit-event-container'],
        /**
         * @member {Object} bind
         */
        bind: {
            endTime             : data => data.endTime,
            intlFormat_time     : data => data.intlFormat_time,
            minimumEventDuration: data => data.minimumEventDuration,
            startTime           : data => data.startTime
        },
        /**
         * @member {Object|null} calendarFieldConfig=null
         */
        calendarFieldConfig: null,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         */
        endTime_: '24:00',
        /**
         * @member {Object|null} endTimeFieldConfig=null
         */
        endTimeFieldConfig: null,
        /**
         * Bound to the view model.
         * @member {Intl.DateTimeFormat|null} intlFormat_time=null
         * @protected
         */
        intlFormat_time: null,
        /**
         * @member {Neo.calendar.view.week.Component|null} owner=null
         */
        owner: null,
        /**
         * @member {Neo.calendar.model.Event|null} record_=null
         */
        record_: null,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         */
        startTime_: '00:00',
        /**
         * @member {Object|null} startTimeFieldConfig=null
         */
        startTimeFieldConfig: null,
        /**
         * @member {Object|null} titleFieldConfig=null
         */
        titleFieldConfig: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        // focus trap, see: https://github.com/neomjs/neo/issues/2306
        this.vdom.tabIndex = -1
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        value && this.getField('title').then(field => field.focus())
    }

    /**
     * Triggered after the record config got changed
     * @param {Neo.calendar.model.Event} value
     * @param {Neo.calendar.model.Event} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        if (value && oldValue) {
            let me                  = this,
                timeFormat          = me.intlFormat_time,
                {calendarId, title} = value;

            me.getField('endTime')  .then(field => field.minValue = me.getEndTimeMinValue(value));
            me.getField('startTime').then(field => field.maxValue = me.getStartTimeMaxValue(value));

            me.reset({
                calendarId,
                endTime  : timeFormat.format(value.endDate),
                startTime: timeFormat.format(value.startDate),
                title
            })
        } else if (value) {
            this.createItems()
        }
    }

    /**
     *
     */
    createItems() {
        let me         = this,
            {record}   = me,
            timeFormat = me.intlFormat_time,
            timeFieldDefaults = {
                module              : _form_field_Time_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                listeners           : {change: me.onTimeFieldChange, scope: me},
                stepSize            : 15 * 60,
                width               : '9em'
            };

        if (record) {
            me.items = [{
                module              : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                labelText           : 'Title',
                listeners           : {change: me.onTitleFieldChange, scope: me},
                name                : 'title',
                required            : true,
                value               : record.title,
                ...me.titleFieldConfig
            }, {
                module              : _form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                clearToOriginalValue: true,
                colorField          : 'color',
                displayField        : 'name',
                flex                : 'none',
                forceSelection      : true,
                labelPosition       : 'inline',
                labelText           : 'Calendar',
                listeners           : {change: me.onCalendarFieldChange, scope: me},
                name                : 'calendarId',
                required            : true,
                triggerAction       : 'all',
                value               : record.calendarId,

                colorFormatter: (scope,data) => {
                    let value = data[scope.colorField];

                    if (value === 'yellow') {
                        return 'var(--event-yellow-border-color)';
                    }

                    return `var(--event-${value}-color)`
                },

                store: {
                    module  : _store_Calendars_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    sourceId: me.model.getStore('calendars').id
                },

                ...me.calendarFieldConfig
            }, {
                labelText: 'Start Time',
                maxValue : me.getStartTimeMaxValue(record),
                minValue : me.startTime,
                name     : 'startTime',
                value    : timeFormat.format(record.startDate),
                ...timeFieldDefaults,
                ...me.startTimeFieldConfig
            }, {
                labelText: 'End Time',
                maxValue : me.endTime,
                minValue : me.getEndTimeMinValue(record),
                name     : 'endTime',
                value    : timeFormat.format(record.endDate),
                ...timeFieldDefaults,
                ...me.endTimeFieldConfig
            }, {
                module : _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                cls    : ['neo-button', 'neo-red'],
                handler: me.onDeleteButtonClick.bind(me),
                iconCls: 'fas fa-trash-alt',
                style  : {marginTop: '3em'},
                text   : 'Delete'
            }];

            super.createItems()
        }
    }

    /**
     * @param {Neo.calendar.model.Event} record
     * @returns {String}
     */
    getEndTimeMinValue(record) {
        let date = new Date(record.startDate.valueOf());

        date.setMinutes(date.getMinutes() + this.minimumEventDuration);

        return this.intlFormat_time.format(date);
    }

    /**
     * @param {Neo.calendar.model.Event} record
     * @returns {String}
     */
    getStartTimeMaxValue(record) {
        let date = new Date(record.endDate.valueOf());

        date.setMinutes(date.getMinutes() - this.minimumEventDuration);

        return this.intlFormat_time.format(date)
    }

    /**
     * @param {Object} data
     */
    onCalendarFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.calendarId = data.record[data.component.store.keyProperty]
        }
    }

    /**
     * todo: we could add a confirm dialog
     * @param {Object} data
     */
    onDeleteButtonClick(data) {
        let me = this;

        me.getModel().getStore('events').remove(me.record);
        me.unmount()
    }

    /**
     * @param {Object} data
     */
    async onFocusLeave(data) {
        let me = this;

        // we need a short delay, since a TimeField picker could be open
        await me.timeout(100);

        me.mounted && me.unmount()
    }

    /**
     * @param {Object} data
     */
    onTimeFieldChange(data) {
        let me     = this,
            name   = data.component.name,
            field  = name === 'endTime' ? 'endDate' : 'startDate',
            record = me.record,
            date   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(me.record[field]),
            value  = data.value.split(':').map(e => Number(e));

        date.setHours(value[0]);
        date.setMinutes(value[1]);

        record[field] = date;

        if (name === 'endTime') {
            me.getField('startTime').then(field => field.maxValue = me.getStartTimeMaxValue(record))
        } else {
            me.getField('endTime')  .then(field => field.minValue = me.getEndTimeMinValue(record))
        }
    }

    /**
     * @param {Object} data
     */
    onTitleFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.title = data.value
        }
    }
}

Neo.setupClass(EditEventContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditEventContainer);


/***/ }),

/***/ "./src/calendar/view/MainContainer.mjs":
/*!*********************************************!*\
  !*** ./src/calendar/view/MainContainer.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _calendars_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calendars/Container.mjs */ "./src/calendar/view/calendars/Container.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_DateSelector_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../component/DateSelector.mjs */ "./src/component/DateSelector.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _calendars_EditContainer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calendars/EditContainer.mjs */ "./src/calendar/view/calendars/EditContainer.mjs");
/* harmony import */ var _EditEventContainer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EditEventContainer.mjs */ "./src/calendar/view/EditEventContainer.mjs");
/* harmony import */ var _MainContainerModel_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MainContainerModel.mjs */ "./src/calendar/view/MainContainerModel.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");









const todayDate = new Date();

/**
 * @class Neo.calendar.view.MainContainer
 * @extends Neo.container.Base
 */
class MainContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Valid entries for the views config
     * @member {String[]} validViews=['day','week','month','year']
     * @static
     */
    static validViews = ['day', 'week', 'month', 'year']

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.MainContainer'
         * @protected
         */
        className: 'Neo.calendar.view.MainContainer',
        /**
         * @member {String} ntype='calendar-maincontainer'
         * @protected
         */
        ntype: 'calendar-maincontainer',
        /**
         * The currently active view. Must be a value included inside the views config.
         * valid values: 'day', 'week', 'month', 'year'
         * @member {String} activeView_='week'
         */
        activeView_: 'week',
        /**
         * @member {String[]} baseCls=['neo-calendar-maincontainer','neo-container']
         */
        baseCls: ['neo-calendar-maincontainer', 'neo-container'],
        /**
         * Scale the calendar with using s different base font-size
         * @member {Number|null} baseFontSize_=null
         */
        baseFontSize_: null,
        /**
         * @member {Neo.calendar.view.Container|null} calendarsContainer=null
         */
        calendarsContainer: null,
        /**
         * @member {Object|null} calendarStoreConfig_=null
         */
        calendarStoreConfig_: null,
        /**
         * @member {Object|null} colorStoreConfig_=null
         */
        colorStoreConfig_: null,
        /**
         * @member {Neo.component.DateSelector|null} dateSelector=null
         */
        dateSelector: null,
        /**
         * @member {Object|null} dateSelectorConfig=null
         */
        dateSelectorConfig: null,
        /**
         * @member {Neo.calendar.view.DayComponent|null} dayComponent=null
         */
        dayComponent: null,
        /**
         * @member {Object|null} dayComponentConfig=null
         */
        dayComponentConfig: null,
        /**
         * Read only
         * @member {Neo.calendar.view.calendars.EditContainer|null} editCalendarContainer_=null
         */
        editCalendarContainer_: null,
        /**
         * @member {Object|null} editCalendarContainerConfig=null
         */
        editCalendarContainerConfig: null,
        /**
         * Read only
         * @member {Neo.calendar.view.EditEventContainer|null} editEventContainer_=null
         */
        editEventContainer_: null,
        /**
         * @member {Object|null} editEventContainerConfig=null
         */
        editEventContainerConfig: null,
        /**
         * @member {Object|null} eventStoreConfig_=null
         */
        eventStoreConfig_: null,
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @protected
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Neo.calendar.view.MainContainerModel} model=MainContainerModel
         */
        model: _MainContainerModel_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
        /**
         * @member {Neo.calendar.view.Component|null} monthComponent=null
         */
        monthComponent: null,
        /**
         * @member {Object|null} monthComponentConfig=null
         */
        monthComponentConfig: null,
        /**
         * True to only keep the active view inside the DOM
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /**
         * @member {Object|null} settingsContainerConfig=null
         */
        settingsContainerConfig: null,
        /**
         * @member {Number} settingsContainerWidth=300
         */
        settingsContainerWidth: 310,
        /**
         * @member {Boolean} settingsExpanded_=false
         */
        settingsExpanded_: false,
        /**
         * @member {Boolean} sideBarExpanded_=true
         */
        sideBarExpanded_: true,
        /**
         * @member {Number} sideBarWidth=220
         */
        sideBarWidth: 220,
        /**
         * @member {Boolean} useSettingsContainer_=true
         */
        useSettingsContainer_: true,
        /**
         * Any combination and order of 'day', 'week', 'month', 'year'
         * @member {String[]} views_=['day','week','month','year']
         */
        views_: ['day', 'week', 'month', 'year'],
        /**
         * @member {Neo.calendar.view.Component|null} weekComponent=null
         */
        weekComponent: null,
        /**
         * @member {Object|null} weekComponentConfig=null
         */
        weekComponentConfig: null,
        /**
         * @member {Neo.calendar.view.YearComponent|null} yearComponent=null
         */
        yearComponent: null,
        /**
         * @member {Object|null} yearComponentConfig=null
         */
        yearComponentConfig: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.createItemsContent();
        !me.sideBarExpanded && me.afterSetSideBarExpanded(false, true)
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items[1].items[1].layout.activeIndex = me.views.indexOf(value);

            me.items[0].items[1].items.forEach(item => {
                if (item.toggleGroup === 'mainViews') {
                    item.pressed = item.value === value
                }
            });
        }
    }

    /**
     * Triggered after the baseFontSize config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetBaseFontSize(value, oldValue) {
        if (oldValue !== undefined) {
            let style = this.style || {};

            if (!value) {
                delete style.fontSize
            } else {
                style.fontSize = `${value}px`
            }

            this.style = style
        }
    }

    /**
     * Triggered after the settingsExpanded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSettingsExpanded(value, oldValue) {
        if (Neo.isBoolean(oldValue)) {
            let me                = this,
                settingsContainer = me.items[1].items[2];

            if (value) {
                if (settingsContainer) {
                    settingsContainer.expand()
                } else {
                    me.createSettingsContainer(true).then(() => {
                        // short delay to ensure the vnode already exists
                        setTimeout(() => {
                            me.items[1].items[2].expand()
                        }, 50)
                    })
                }
            } else {
                settingsContainer.collapse(me.settingsContainerWidth)
            }
        }
    }

    /**
     * Triggered after the sideBarExpanded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSideBarExpanded(value, oldValue) {
        if (oldValue !== undefined) {
            let me      = this,
                sideBar = me.items[1].items[0],
                style   = sideBar.style || {};

            if (value) {
                delete sideBar.vdom.removeDom;

                me.promiseUpdate().then(() => {
                    sideBar.mounted = true;

                    setTimeout(() => {
                        style.marginLeft = '0px';
                        sideBar.style = style;
                    }, 50)
                })
            } else {
                style.marginLeft    = `-${me.sideBarWidth}px`;
                sideBar._style      = style; // silent update
                sideBar._vdom.style = style; // silent update

                me.promiseUpdate().then(() => {
                    setTimeout(() => {
                        sideBar.vdom.removeDom = true;
                        sideBar.update();

                        sideBar.mounted = false
                    }, 400)
                });
            }
        }
    }

    /**
     * Triggered after the useSettingsContainer config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseSettingsContainer(value, oldValue) {
        let me = this;

        if (value) {
            me.settingsExpanded && me.createSettingsContainer(false);

            // we need a short delay to ensure the items already got created
            setTimeout(() => {
                me.items[0].items[1].add({
                    handler: me.toggleSettings.bind(me),
                    iconCls: 'fa fa-cog',
                    style  : {marginLeft: '10px'}
                })
            }, 10)
        } else if (!value && oldValue) {
            // we only need this logic in case we dynamically change the config from true to false
            me.items[1]         .removeLast();
            me.items[0].items[1].removeLast()
        }
    }

    /**
     * Gets triggered before getting the value of the editCalendarContainer config
     * @param {Neo.calendar.view.calendars.EditContainer|null} value
     * @returns {Neo.calendar.view.calendars.EditContainer}
     */
    beforeGetEditCalendarContainer(value) {
        if (!value) {
            let me = this;

            me._editCalendarContainer = value = Neo.create({
                module : _calendars_EditContainer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                appName: me.appName,
                model  : {parent: me.getModel()},
                owner  : me,
                width  : 250,
                ...me.editCalendarContainerConfig
            })
        }

        return value
    }

    /**
     * Gets triggered before getting the value of the editEventContainer config
     * @param {Neo.calendar.view.EditEventContainer|null} value
     * @returns {Neo.calendar.view.EditEventContainer}
     */
    beforeGetEditEventContainer(value) {
        if (!value) {
            let me = this;

            me._editEventContainer = value = Neo.create({
                module : _EditEventContainer_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                appName: me.appName,
                model  : {parent: me.getModel()},
                owner  : me,
                width  : 250,
                ...me.editEventContainerConfig
            })
        }

        return value
    }

    /**
     * Triggered before the activeView config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView', 'validViews')
    }

    /**
     * Triggered before the views config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetViews(value, oldValue) {
        let validViews = this.getStaticConfig('validViews');

        value.forEach(view => {
            if (!validViews.includes(view)) {
                console.error(view, 'is not a valid entry for views. Stick to:', validViews);
                return oldValue
            }
        });

        return value
    }

    /**
     * @param {String} view
     * @protected
     */
    changeActiveView(view) {
        this.activeView = view
    }

    /**
     * @returns {Object[]}
     */
    createHeaderItems() {
        let me = this;

        return [{
            module: _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            cls   : ['neo-calendar-header-toolbar', 'neo-left', 'neo-toolbar'],
            width : me.sideBarWidth,
            items : [{
                handler: me.toggleSidebar.bind(me),
                iconCls: 'fa fa-bars'
            }, '->', {
                handler: me.onPreviousIntervalButtonClick.bind(me),
                iconCls: 'fa fa-chevron-left',
            }, {
                handler: me.onTodayButtonClick.bind(me),
                height : 24,
                text   : 'Today'
            }, {
                handler: me.onNextIntervalButtonClick.bind(me),
                iconCls: 'fa fa-chevron-right'
            }]
        }, {
            module: _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            cls   : ['neo-calendar-header-toolbar', 'neo-toolbar'],
            items : ['->', ...me.createViewHeaderButtons()]
        }]
    }

    /**
     * @protected
     */
    createItemsContent() {
        let me = this;

        me.calendarsContainer = Neo.create({
            module  : _calendars_Container_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex    : 1,
            parentId: me.id, // we need the parentId to access the model inside the ctor
            owner   : me
        });

        me.dateSelector = Neo.create({
            module   : _component_DateSelector_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName  : me.appName,
            flex     : 'none',
            height   : me.sideBarWidth,
            listeners: {change: me.onDateSelectorChange, scope: me},
            parentId : me.id, // we need the parentId to access the model inside the ctor
            value    : null,

            bind: {
                locale              : data => data.locale,
                scrollNewYearFromTop: data => data.scrollNewYearFromTop,
                showWeekends        : data => data.showWeekends,
                value               : data => _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(data.currentDate),
                weekStartDay        : data => data.weekStartDay
            },

            ...me.dateSelectorConfig
        });

        me.items = [{
            module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex  : 'none',
            layout: {ntype: 'hbox', align: 'stretch'},
            items : me.createHeaderItems()
        }, {
            module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex  : 1,
            layout: {ntype: 'hbox', align: 'stretch'},
            items : [{
                module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                cls   : ['neo-calendar-sidebar', 'neo-container'],
                layout: {ntype: 'vbox', align: 'stretch'},
                width : me.sideBarWidth,
                items : [me.dateSelector, me.calendarsContainer]
            }, {
                module   : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                flex     : 1,
                items    : me.createViews(),
                listeners: {cardLoaded: me.onCardLoaded, scope: me},
                layout   : {
                    ntype              : 'card',
                    activeIndex        : me.views.indexOf(me.activeView),
                    removeInactiveCards: me.removeInactiveCards
                }
            }]
        }]
    }

    /**
     * @param {Boolean} collapsed
     * @returns {Promise<*>}
     */
    createSettingsContainer(collapsed) {
        let me = this;

        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_tab_Container_mjs"), __webpack_require__.e("src_calendar_view_SettingsContainer_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./SettingsContainer.mjs */ "./src/calendar/view/SettingsContainer.mjs")).then(module => {
            me.items[1].add({
                module             : module.default,
                collapsed,
                removeInactiveCards: me.removeInactiveCards,
                style              : {marginRight: !collapsed ? '0' : `-${me.settingsContainerWidth}px`},
                width              : me.settingsContainerWidth,
                ...me.settingsContainerConfig
            })
        })
    }

    /**
     * @returns {Object[]}
     */
    createViewHeaderButtons() {
        let me          = this,
            activeIndex = me.views.indexOf(me.activeView),
            buttons     = [];

        me.views.forEach((view, index) => {
            buttons.push({
                handler    : me.changeActiveView.bind(me, view),
                height     : 24,
                pressed    : activeIndex === index,
                text       : Neo.capitalize(view),
                toggleGroup: 'mainViews',
                value      : view
            })
        });

        return buttons
    }

    /**
     * @returns {Neo.component.Base[]}
     */
    createViews() {
        let me    = this,
            cards = [],
            cmp,

        defaultConfig = {
            appName : me.appName,
            owner   : me,
            parentId: me.id
        },

        map = {
            day: {
                module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_calendar_view_week_Component_mjs"), __webpack_require__.e("src_calendar_view_DayComponent_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./DayComponent.mjs */ "./src/calendar/view/DayComponent.mjs")),
                flag  : 'day',
                ...defaultConfig,
                ...me.dayComponentConfig
            },
            month: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_month_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./month/Component.mjs */ "./src/calendar/view/month/Component.mjs")),
                flag  : 'month',
                ...defaultConfig,
                ...me.monthComponentConfig
            },
            week: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_week_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./week/Component.mjs */ "./src/calendar/view/week/Component.mjs")),
                flag  : 'week',
                ...defaultConfig,
                ...me.weekComponentConfig
            },
            year: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_YearComponent_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./YearComponent.mjs */ "./src/calendar/view/YearComponent.mjs")),
                flag  : 'year',
                ...defaultConfig,
                ...me.yearComponentConfig
            }
        };

        me.views.forEach(view => {
            me[`${view}Component`] = cmp = map[view];
            cards.push(cmp);
        });

        return cards
    }

    /**
     * @param data
     */
    onCardLoaded(data) {
        this[`${data.item.flag}Component`] = data.item;

        // fire the event on this instance as well => setting views can subscribe to it more easily
        this.fire('cardLoaded', {item: data.item})
    }

    /**
     * @param {Object} data
     * @param {String} data.oldValue
     * @param {String} data.value
     */
    onDateSelectorChange(data) {
        data.oldValue !== undefined && this.getModel().setData('currentDate', new Date(`${data.value}T00:00:00.000Z`))
    }

    /**
     * @param data
     */
    onNextIntervalButtonClick(data) {
        this.switchInterval(1)
    }

    /**
     * @param data
     */
    onPreviousIntervalButtonClick(data) {
        this.switchInterval(-1)
    }

    /**
     * @param data
     */
    onTodayButtonClick(data) {
        this.model.setData({
            currentDate: todayDate
        })
    }

    /**
     * @protected
     */
    toggleSettings() {
        this.settingsExpanded = !this.settingsExpanded
    }

    /**
     * @protected
     */
    toggleSidebar() {
        this.sideBarExpanded = !this.sideBarExpanded
    }

    /**
     * @param {Number} multiplier
     */
    switchInterval(multiplier) {
        let me          = this,
            currentDate = me.data.currentDate,

        map = {
            day  : () => {currentDate.setDate(    currentDate.getDate()     + multiplier)},
            month: () => {currentDate.setMonth(   currentDate.getMonth()    + multiplier)},
            week : () => {currentDate.setDate(    currentDate.getDate() + 7 * multiplier)},
            year : () => {currentDate.setFullYear(currentDate.getFullYear() + multiplier)}
        };

        map[me.activeView]();

        me.model.setData({currentDate})
    }
}

Neo.setupClass(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./src/calendar/view/calendars/ColorsList.mjs":
/*!****************************************************!*\
  !*** ./src/calendar/view/calendars/ColorsList.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../list/Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.calendar.view.calendars.ColorsList
 * @extends Neo.list.Base
 */
class ColorsList extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.ColorsList'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.ColorsList',
        /**
         * @member {String[]} baseCls=['neo-calendars-colors-list','neo-list']
         */
        baseCls: ['neo-calendars-colors-list', 'neo-list'],
        /**
         * @member {Object} bind
         */
        bind: {
            store: 'stores.colors'
        },
        /**
         * @member {Boolean} useWrapperNode=false
         */
        useWrapperNode: false,
        /**
         * The list gets used as a form field, so we are adjusting the selection based on this config
         * @member {String} value_=null
         */
        value_: null,
        /**
         * Added a tabIndex to enable tabbing through the form
         * @member {Object} _vdom={tag:'ul',cn:[],tabIndex:'0'}
         */
        _vdom:
        {tag: 'ul', cn: [], tabIndex: '0'}
    }

    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this,
            record;

        if (value && oldValue !== undefined && !me.disableSelection) {
            record = me.store.find('name', value)[0];
            me.selectionModel?.select(me.getItemId(record[me.getKeyProperty()]));
        }
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        return {style: {
            backgroundColor: `var(--event-${record.name}-color)`,
            color          : `var(--event-${record.name}-color)` // needed for the box-shadow (CSS currentColor)
        }};
    }

    /**
     * @returns {Object}
     */
    getVdomRoot() {
        return this.vdom;
    }

    /**
     * @returns {Object}
     */
    getVnodeRoot() {
        return this.vnode;
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me      = this,
            {value} = me;

        value && me.afterSetValue(value, null);
    }

    /**
     * Gets triggered from selection.Model: select()
     * @param {String[]} items
     */
    onSelect(items) {
        let me       = this,
            recordId = me.getItemRecordId(items[0]);

        me.fire('change', {
            record: me.store.get(recordId)
        });
    }
}

Neo.setupClass(ColorsList);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorsList);


/***/ }),

/***/ "./src/calendar/view/calendars/Container.mjs":
/*!***************************************************!*\
  !*** ./src/calendar/view/calendars/Container.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _List_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./List.mjs */ "./src/calendar/view/calendars/List.mjs");



/**
 * @class Neo.calendar.view.calendars.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.Container'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.Container',
        /**
         * @member {String[]} baseCls=['neo-calendar-calendarscontainer','neo-container']
         */
        baseCls: ['neo-calendar-calendarscontainer', 'neo-container'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore: 'stores.calendars'
        },
        /**
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore: null,
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _List_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            owner : '@config:owner' // passing the owner config downwards
        }, {
            ntype       : 'button',
            cls         : ['neo-add-calendar-button'],
            flex        : 'none',
            handler     : 'onAddCalendarButtonClick',
            handlerScope: 'this',
            style       : {marginTop: 'auto'},
            text        : 'Add Calendar'
        }],
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @protected
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * @param {Object} data
     */
    onAddCalendarButtonClick(data) {
        this.calendarStore.add({
            active: true,
            color : 'red',
            name  : 'New Calendar'
        });
    }
}

Neo.setupClass(Container);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Container);


/***/ }),

/***/ "./src/calendar/view/calendars/EditContainer.mjs":
/*!*******************************************************!*\
  !*** ./src/calendar/view/calendars/EditContainer.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _ColorsList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorsList.mjs */ "./src/calendar/view/calendars/ColorsList.mjs");
/* harmony import */ var _form_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../form/field/Text.mjs */ "./src/form/field/Text.mjs");





/**
 * @class Neo.calendar.view.calendars.EditContainer
 * @extends Neo.form.Container
 */
class EditContainer extends _form_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.EditContainer'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.EditContainer',
        /**
         * @member {String[]} baseCls=['neo-calendar-edit-container']
         */
        baseCls: ['neo-calendar-edit-container'],
        /**
         * @member {Neo.calendar.view.calendars.ColorsList|null} colorsList=null
         */
        colorsList: null,
        /**
         * @member {Object|null} colorsListConfig=null
         */
        colorsListConfig: null,
        /**
         * @member {Object|null} nameFieldConfig=null
         */
        nameFieldConfig: null,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         */
        owner: null,
        /**
         * @member {Neo.calendar.model.Calendar|null} record_=null
         */
        record_: null,
        /**
         * @member {Number|null} unMountTimeoutId=null
         * @protected
         */
        unMountTimeoutId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        // focus trap, see: https://github.com/neomjs/neo/issues/2306
        this.vdom.tabIndex = -1;
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        value && this.getField('name').focus();
    }

    /**
     * Triggered after the record config got changed
     * @param {Neo.calendar.model.Calendar} value
     * @param {Neo.calendar.model.Calendar} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        let me = this;

        if (value && oldValue) {
            me.reset({
                name: value.name
            });

            me.colorsList.value = value.color;
        } else if (value) {
            me.createItems();
        }
    }

    /**
     * Triggered before the record config gets changed
     * We need the before method to also get clicks on the same edit icon,
     * since it does trigger for not changed values.
     * @param {Neo.calendar.model.Calendar} value
     * @param {Neo.calendar.model.Calendar} oldValue
     * @protected
     */
    beforeSetRecord(value, oldValue) {
        let me = this;

        if (me.unMountTimeoutId) {
            clearTimeout(me.unMountTimeoutId);
            me.unMountTimeoutId = null;
        }

        return value;
    }

    /**
     *
     */
    createItems() {
        let me       = this,
            {record} = me;

        if (record) {
            me.colorsList = Neo.create({
                module      : _ColorsList_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                appName     : me.appName,
                listeners   : {change: me.onColorChange, scope: me},
                parentId    : me.parentId,
                value       : record.color,
                wrapperStyle: {marginTop: '0.2em'},
                ...me.colorsListConfig
            });

            me.items = [{
                module              : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                labelText           : 'Calendar Name',
                listeners           : {change: me.onNameFieldChange, scope: me},
                name                : 'name',
                required            : true,
                value               : record.name,
                ...me.nameFieldConfig
            },
            me.colorsList, {
                module : _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                cls    : ['neo-red'],
                handler: me.onDeleteButtonClick.bind(me),
                iconCls: 'fas fa-trash-alt',
                style  : {marginTop: '3em'},
                text   : 'Delete'
            }];

            super.createItems();
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.record
     */
    onColorChange(data) {
        this.record.color = data.record.name;
    }

    /**
     * @param {Object} data
     */
    onDeleteButtonClick(data) {
        let me = this;

        // todo: we could add a confirm dialog

        me.getModel().getStore('calendars').remove(me.record);
        me.unmount();
    }

    /**
     * @param {Object} [data]
     */
    onFocusLeave(data) {
        let me = this;

        // we need a short delay to get record-changes (clicking on another edit icon)
        me.unMountTimeoutId = setTimeout(() => {
            me.unMountTimeoutId = null;
            me.mounted && me.unmount();
        }, 200);
    }

    /**
     * @param {Object} data
     */
    onNameFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.name = data.value;
        }
    }
}

Neo.setupClass(EditContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditContainer);


/***/ }),

/***/ "./src/calendar/view/calendars/List.mjs":
/*!**********************************************!*\
  !*** ./src/calendar/view/calendars/List.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _list_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../list/Component.mjs */ "./src/list/Component.mjs");



/**
 * @class Neo.calendar.view.calendars.List
 * @extends Neo.list.Component
 */
class List extends _list_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.List'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.List',
        /**
         * @member {String[]} baseCls=['neo-calendars-list','neo-list']
         */
        baseCls: ['neo-calendars-list', 'neo-list'],
        /**
         * @member {Object} bind
         */
        bind: {
            store: 'stores.calendars'
        },
        /**
         * @member {Object} itemDefaults
         */
        itemDefaults: {
            module        : _form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex          : 'none',
            hideLabel     : true,
            iconCls       : ['fas', 'fa-square'],
            iconClsChecked: ['fas', 'fa-check-square']
        },
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me       = this,
            id       = record[me.getKeyProperty()],
            items    = me.items || [],
            checkBox = items[index],

        config = {
            checked       : record.active,
            cls           : [`neo-color-${record.color}`],
            fieldValue    : id,
            id            : me.getComponentId(index),
            valueLabelText: record.name
        };

        if (checkBox) {
            checkBox.setSilent(config)
        } else {
            items[index] = checkBox = Neo.create({
                appName  : me.appName,
                listeners: {change: me.onCheckboxChange, scope: me},
                parentId : me.id,
                ...me.itemDefaults,
                ...config
            })
        }

        me.items = items;

        return [checkBox.vdom, {tag: 'i', cls: ['neo-edit-icon', 'fas fa-edit'], id: me.getEditIconId(index)}]
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getEditIconId(index) {
        return `${this.id}__${index}__edit-icon`
    }

    /**
     * @param {Object} data
     */
    onCheckboxChange(data) {
        this.store.get(data.component.fieldValue).active = data.value
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        // The click even arrives before the CheckBox onInputValueChange() gets triggered.
        // We need a short delay to ensure the vdom of the list item contains the new checked state
        setTimeout(() => {
            super.onClick(data)
        }, 20);

        if (data.path[0].cls.includes('neo-edit-icon')) {
            let me                    = this,
                listItemRect          = data.path[1].rect,
                mainContainer         = me.owner,
                editCalendarContainer = mainContainer.editCalendarContainer,
                {mounted, style}      = editCalendarContainer,
                record                = me.store.get(me.getItemRecordId(data.path[1].id));

            Object.assign(style, {
                left: `${listItemRect.right + 13}px`,
                top : `${listItemRect.top   - 10}px`
            });

            editCalendarContainer[mounted ? 'set' : 'setSilent']({
                parentId: mainContainer.id,
                record,
                style
            });

            if (!mounted) {
                editCalendarContainer.render(true)
            } else {
                editCalendarContainer.afterSetMounted(true, false)
            }
        }
    }

    /**
     * @param {String} itemId
     */
    onKeyDownEnter(itemId) {
        let me       = this,
            recordId = me.getItemRecordId(itemId),
            checkBox = me.items[me.store.indexOf(recordId)];

        checkBox.checked = !checkBox.checked
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        this.getModel().setData('activeCalendarId', this.getItemRecordId(items[0]))
    }
}

Neo.setupClass(List);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (List);


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} text_=''
         */
        text_: '',
        /**
         * @member {Object} _vdom={tag: 'label'}
         */
        _vdom:
        {tag: 'label', draggable: false}
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        this.vdom.html = value;
        this.update()
    }
}

Neo.setupClass(Label);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Label);


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me,
            listenerId;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            listenerId = component.on('constructed', () => {
                component.un('constructed', listenerId);
                me.onComponentConstructed()
            })
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base} component
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            const handlerCb = component.resolveCallback(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent ?
            parent.getHandlerScope(handlerName) : null
    }

    /**
     * sameLevelOnly=false will return the closest VM inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getModel(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.model : component.getModel()
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent;
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut for accessing model.Component based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getModel().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me = this,
            {handler, listeners, reference, validator} = component,
            eventHandler, handlerScope;

        if (handler && typeof handler === 'string') {
            handlerScope = me.getHandlerScope(handler, component);

            // If the handler name was not resolved in the Component itself, bind it
            if (handlerScope !== true) {
                component.handler = handlerScope[handler].bind(component.handlerScope || handlerScope);
            }
        }

        listeners && Object.entries(listeners).forEach(([key, value]) => {
            if (key !== 'scope' && key !== 'delegate') {
                if (Neo.isString(value)) {
                    eventHandler = value;
                    handlerScope = me.getHandlerScope(eventHandler, component);

                    if (!handlerScope) {
                        _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].logError('Unknown event handler for', eventHandler, component)
                    } else if (handlerScope !== true) {
                        listeners[key] = {};
                        listeners[key].fn = handlerScope[eventHandler].bind(handlerScope)
                    }
                } else {
                    value.forEach(listener => {
                        if (Neo.isObject(listener) && listener.hasOwnProperty('fn') && Neo.isString(listener.fn)) {
                            eventHandler = listener.fn;
                            handlerScope = me.getHandlerScope(eventHandler, component);

                            if (!handlerScope) {
                                console.error('Unknown event handler for', eventHandler, component)
                            } else if (handlerScope !== true) {
                                listener.fn = handlerScope[eventHandler].bind(handlerScope)
                            }
                        }
                    })
                }
            }
        });

        if (Neo.isString(validator)) {
            handlerScope = me.getHandlerScope(validator);

            if (!handlerScope) {
                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].logError('Unknown validator for', component.id, component)
            } else {
                component.validator = handlerScope[validator].bind(handlerScope)
            }
        }

        if (reference) {
            me.references[reference] = component
        }
    }

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseDomListeners(component=this.component) {
        let me             = this,
            {domListeners} = component,
            eventHandler, scope;

        domListeners?.forEach(domListener => {
            Object.entries(domListener).forEach(([key, value]) => {
                eventHandler = null;

                if (key !== 'scope' && key !== 'delegate') {
                    if (Neo.isString(value)) {
                        eventHandler = value;
                    } else if (Neo.isObject(value) && value.hasOwnProperty('fn') && Neo.isString(value.fn)) {
                        eventHandler = value.fn;
                    }

                    if (eventHandler) {
                        scope = me.getHandlerScope(eventHandler);

                        if (!scope) {
                            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].logError('Unknown domEvent handler for', eventHandler, component)
                        } else {
                            domListener[key] = scope[eventHandler].bind(scope)
                        }
                    }
                }
            })
        })
    }

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }
}

Neo.setupClass(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ }),

/***/ "./src/form/field/Color.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.ComboBox
 */
class Color extends _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-selectfield','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-selectfield', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getInputWrapperId()});

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getColorIndicatorId()})?.vdom,
            {list, record} = me,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor();
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]))
        } else {
            selectionModel?.deselectAll(true)
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter)
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me              = this,
            {record, value} = me;

        return record ? me.colorFormatter(me, record) : me.forceSelection ? null : value
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let {list} = this,
            index  = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem()
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let {list} = this;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem()
    }
}

Neo.setupClass(Color);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color);


/***/ }),

/***/ "./src/list/Color.mjs":
/*!****************************!*\
  !*** ./src/list/Color.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.list.Color
 * @extends Neo.list.Base
 */
class Color extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Color'
         * @protected
         */
        className: 'Neo.list.Color',
        /**
         * @member {String} ntype='colorlist'
         * @protected
         */
        ntype: 'colorlist',
        /**
         * @member {String[]} baseCls=['neo-color-list','neo-list']
         */
        baseCls: ['neo-color-list', 'neo-list'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField]
    }

    /**
     * form.field.Color needs to trigger a silent vdom update
     * @member {Boolean} silentSelectUpdate=false
     * @protected
     */
    silentSelectUpdate = false

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me         = this,
            id         = record[me.store.keyProperty],
            isSelected = me.selectionModel.isSelected(me.getItemId(id));

        return [{
            tag  : 'i',
            cls  : ['neo-icon', 'fas', `fa-${isSelected ? 'check-' : ''}square`],
            id   : me.getListItemIconId(id),
            style: {
                color: me.colorFormatter(me, record)
            }
        }, {
            vtype: 'text',
            html : record[me.displayField],
            id   : me.getListItemVtextId(id)
        }]
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemIconId(recordId) {
        return `${this.id}__icon__${recordId}`
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemVtextId(recordId) {
        return `${this.id}__vtext__${recordId}`
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        let me = this;

        me.createItems(me.silentSelectUpdate);

        !me.silentSelect && me.focus(items[0])
    }
}

Neo.setupClass(Color);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color);


/***/ }),

/***/ "./src/list/Component.mjs":
/*!********************************!*\
  !*** ./src/list/Component.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * A base class for lists which will use component based list items
 * @class Neo.list.Component
 * @extends Neo.list.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Component'
         * @protected
         */
        className: 'Neo.list.Component',
        /**
         * @member {String} ntype='component-list'
         * @protected
         */
        ntype: 'component-list',
        /**
         * @member {Neo.component.Base[]|null} items=null
         */
        items: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        value && this.items?.forEach(item => {
            item.appName = value
        })
    }

    /**
     *
     */
    destroy(...args) {
        let items = this.items || [];

        items.forEach(item => {
            item.destroy()
        });

        super.destroy(...args)
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getComponentId(index) {
        return `${this.id}__${index}__component`
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getItemId(recordId) {
        return `${this.id}__${this.store.indexOf(recordId)}`
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId = vnodeId.split('__')[1];
        return this.store.getAt(parseInt(itemId))[this.getKeyProperty()]
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        this.sortItems(data);
        super.onStoreSort(data)
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    sortItems(data) {
        let me       = this,
            newItems = [],
            fromIndex, key, previousKeys;

        if (me.items) {
            key          = me.getKeyProperty();
            previousKeys = data.previousItems.map(e => e[key]);

            data.items.forEach(item => {
                fromIndex = previousKeys.indexOf(item[key]);
                newItems.push(me.items[fromIndex])
            });

            me.items = newItems
        }
    }
}

Neo.setupClass(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Base extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype: 'hbox', align: 'center', pack : 'start'}
         */
        layout: {
            ntype: 'hbox',
            align: 'center',
            pack : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions');

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][key === value ? 'add' : 'remove'](cls, 'neo-dock-' + key)
        });

        me.cls    = cls;
        me.layout = me.getLayoutConfig()
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            items.forEach((item, index) => {
                if (item === '->') {
                    items[index] = Neo.create({
                        module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                        flex  : 1
                    })
                }
            })
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch(me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        ntype: 'hbox',
                        align: 'center',
                        pack : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        ntype    : 'vbox',
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        ntype    : 'vbox',
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }
}

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NhbGVuZGFyX2Jhc2ljX2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ2dCO0FBQ2Y7QUFDQTtBQUNNOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBdUI7QUFDM0MscUJBQXFCLGdDQUFnQzs7QUFFckQ7QUFDQSxxQkFBcUIsNkRBQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlCQUF5Qiw0REFBTTtBQUMvQjtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCx1QkFBdUIsNEVBQVE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsYUFBYSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFMkM7QUFDVjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUVBQW1CO0FBQ3pEO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiwyREFBUTtBQUN4QjtBQUNBLFNBQVM7O0FBRVQsUUFB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O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY2FsZW5kYXIvYmFzaWMvTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9hcHAubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9FZGl0RXZlbnRDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvY2FsZW5kYXJzL0NvbG9yc0xpc3QubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9jYWxlbmRhcnMvQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvY2FsZW5kYXJzL0VkaXRDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9jYWxlbmRhcnMvTGlzdC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTGFiZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9Db2xvci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9saXN0L0NvbG9yLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xpc3QvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3Rvb2xiYXIvQmFzZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJ1dHRvbiAgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENhbGVuZGFyICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jYWxlbmRhci92aWV3L01haW5Db250YWluZXIubWpzJztcbmltcG9ydCBNYWluQ29udGFpbmVyQ29udHJvbGxlciBmcm9tICcuL01haW5Db250YWluZXJDb250cm9sbGVyLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL3Rvb2xiYXIvQmFzZS5tanMnO1xuaW1wb3J0IFZpZXdwb3J0ICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmV4YW1wbGVzLmNhbGVuZGFyLmJhc2ljLk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIFZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWUgOiAnTmVvLmV4YW1wbGVzLmNhbGVuZGFyLmJhc2ljLk1haW5Db250YWluZXInLFxuICAgICAgICBhdXRvTW91bnQgOiB0cnVlLFxuICAgICAgICBjbHMgICAgICAgOiBbJ25lby1leGFtcGxlcy1jYWxlbmRhci1tYWluY29udGFpbmVyJywgJ25lby12aWV3cG9ydCddLFxuICAgICAgICBjb250cm9sbGVyOiBNYWluQ29udGFpbmVyQ29udHJvbGxlcixcbiAgICAgICAgbGF5b3V0ICAgIDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlIDogVG9vbGJhcixcbiAgICAgICAgICAgIGZsZXggICA6ICdub25lJyxcbiAgICAgICAgICAgIHBhZGRpbmc6IDIwLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnaGVhZGVyVG9vbGJhcicsXG5cbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2YyZjJmMicsXG4gICAgICAgICAgICAgICAgcGFkZGluZyAgICAgICAgOiAnMTBweCA1cHggMTBweCAxMHB4J1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIGNscyAgOiBbJ25lby1oZWFkZXInXSxcbiAgICAgICAgICAgICAgICBodG1sIDogJzxpIGNsYXNzPVwiZmEgZmEtY2FsZW5kYXJcIj48L2k+bmVvLm1qcyBDYWxlbmRhcidcbiAgICAgICAgICAgIH0sICctPicsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBCdXR0b24sXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogJ29uU3dpdGNoVGhlbWVCdXR0b25DbGljaycsXG4gICAgICAgICAgICAgICAgaGVpZ2h0IDogMjcsXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLW1vb24nLFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdUaGVtZSBEYXJrJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiAyNyxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmFiIGZhLWdpdGh1YicsXG4gICAgICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpbkxlZnQ6ICc1cHgnfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnR2l0SHViJyxcbiAgICAgICAgICAgICAgICB1cmwgICAgOiAnaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vdHJlZS9kZXYvc3JjL2NhbGVuZGFyJ1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDYWxlbmRhcixcbiAgICAgICAgICAgIGZsZXggICAgIDogMSxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ2NhbGVuZGFyJyxcblxuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGF1dG9Mb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVybCAgICAgOiAnLi4vLi4vZXhhbXBsZXMvY2FsZW5kYXIvYmFzaWMvZGF0YS9jYWxlbmRhcnMuanNvbidcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV2ZW50U3RvcmVDb25maWc6IHtcbiAgICAgICAgICAgICAgICBhdXRvTG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1cmwgICAgIDogJy4uLy4uL2V4YW1wbGVzL2NhbGVuZGFyL2Jhc2ljL2RhdGEvZXZlbnRzLmpzb24nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtb2RlbERhdGE6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZTogbmV3IERhdGUoJzIwMjEtMDctMjAnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5Db250YWluZXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29udHJvbGxlciBmcm9tICcuLi8uLi8uLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy5jYWxlbmRhci5iYXNpYy5NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXJDb250cm9sbGVyIGV4dGVuZHMgQ29tcG9uZW50Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5leGFtcGxlcy5jYWxlbmRhci5iYXNpYy5NYWluQ29udGFpbmVyQ29udHJvbGxlcidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU3dpdGNoVGhlbWVCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1dHRvbiAgICAgICAgPSBkYXRhLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGNvbXBvbmVudCAgICAgPSBtZS5jb21wb25lbnQsXG4gICAgICAgICAgICBoZWFkZXJUb29sYmFyID0gbWUuZ2V0UmVmZXJlbmNlKCdoZWFkZXJUb29sYmFyJyksXG4gICAgICAgICAgICBidXR0b25UZXh0LCBjbHMsIGhlYWRlckNvbG9yLCBpY29uQ2xzLCBzdHlsZSwgdGhlbWU7XG5cbiAgICAgICAgaWYgKGJ1dHRvbi50ZXh0ID09PSAnVGhlbWUgTGlnaHQnKSB7XG4gICAgICAgICAgICBidXR0b25UZXh0ICA9ICdUaGVtZSBEYXJrJztcbiAgICAgICAgICAgIGhlYWRlckNvbG9yID0gJyNmMmYyZjInO1xuICAgICAgICAgICAgaWNvbkNscyAgICAgPSAnZmEgZmEtbW9vbic7XG4gICAgICAgICAgICB0aGVtZSAgICAgICA9ICduZW8tdGhlbWUtbGlnaHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnV0dG9uVGV4dCAgPSAnVGhlbWUgTGlnaHQnO1xuICAgICAgICAgICAgaGVhZGVyQ29sb3IgPSAnIzMzMzQzZCc7XG4gICAgICAgICAgICBpY29uQ2xzICAgICA9ICdmYSBmYS1zdW4nO1xuICAgICAgICAgICAgdGhlbWUgICAgICAgPSAnbmVvLXRoZW1lLWRhcmsnO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xzID0gWy4uLmNvbXBvbmVudC5jbHNdO1xuXG4gICAgICAgIGNvbXBvbmVudC5jbHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLmluY2x1ZGVzKCduZW8tdGhlbWUnKSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB0aGVtZSk7XG4gICAgICAgIGNvbXBvbmVudC5jbHMgPSBjbHM7XG5cbiAgICAgICAgYnV0dG9uLnNldCh7XG4gICAgICAgICAgICBpY29uQ2xzLFxuICAgICAgICAgICAgdGV4dDogYnV0dG9uVGV4dFxuICAgICAgICB9KTtcblxuICAgICAgICBzdHlsZSA9IGhlYWRlclRvb2xiYXIuc3R5bGUgfHwge307XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IGhlYWRlckNvbG9yO1xuICAgICAgICBoZWFkZXJUb29sYmFyLnN0eWxlID0gc3R5bGU7XG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyQ29udHJvbGxlcik7XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5Db250YWluZXJDb250cm9sbGVyO1xuIiwiaW1wb3J0IE1haW5Db250YWluZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvblN0YXJ0ID0gKCkgPT4gTmVvLmFwcCh7XG4gICAgbWFpblZpZXc6IE1haW5Db250YWluZXIsXG4gICAgbmFtZSAgICA6ICdOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMnXG59KTtcbiIsImltcG9ydCBCdXR0b24gICAgICAgIGZyb20gJy4uLy4uL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ2FsZW5kYXJTdG9yZSBmcm9tICcuLi9zdG9yZS9DYWxlbmRhcnMubWpzJztcbmltcG9ydCBDb2xvckZpZWxkICAgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvQ29sb3IubWpzJztcbmltcG9ydCBEYXRlVXRpbCAgICAgIGZyb20gJy4uLy4uL3V0aWwvRGF0ZS5tanMnO1xuaW1wb3J0IEZvcm1Db250YWluZXIgZnJvbSAnLi4vLi4vZm9ybS9Db250YWluZXIubWpzJztcbmltcG9ydCBUZXh0RmllbGQgICAgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuaW1wb3J0IFRpbWVGaWVsZCAgICAgZnJvbSAnLi4vLi4vZm9ybS9maWVsZC9UaW1lLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LkVkaXRFdmVudENvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmZvcm0uQ29udGFpbmVyXG4gKi9cbmNsYXNzIEVkaXRFdmVudENvbnRhaW5lciBleHRlbmRzIEZvcm1Db250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuRWRpdEV2ZW50Q29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5FZGl0RXZlbnRDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2FsZW5kYXItZWRpdC1ldmVudC1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItZWRpdC1ldmVudC1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgZW5kVGltZSAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5lbmRUaW1lLFxuICAgICAgICAgICAgaW50bEZvcm1hdF90aW1lICAgICA6IGRhdGEgPT4gZGF0YS5pbnRsRm9ybWF0X3RpbWUsXG4gICAgICAgICAgICBtaW5pbXVtRXZlbnREdXJhdGlvbjogZGF0YSA9PiBkYXRhLm1pbmltdW1FdmVudER1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnRUaW1lICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5zdGFydFRpbWVcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjYWxlbmRhckZpZWxkQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyRmllbGRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGZ1bGwgaG91cnMgYXJlIHZhbGlkIGZvciBub3dcbiAgICAgICAgICogZm9ybWF0OiAnaGg6bW0nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZW5kVGltZV89JzI0OjAwJ1xuICAgICAgICAgKi9cbiAgICAgICAgZW5kVGltZV86ICcyNDowMCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZW5kVGltZUZpZWxkQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGVuZFRpbWVGaWVsZENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsLlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfdGltZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGludGxGb3JtYXRfdGltZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LndlZWsuQ29tcG9uZW50fG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLm1vZGVsLkV2ZW50fG51bGx9IHJlY29yZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVjb3JkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZnVsbCBob3VycyBhcmUgdmFsaWQgZm9yIG5vd1xuICAgICAgICAgKiBmb3JtYXQ6ICdoaDptbSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzdGFydFRpbWVfPScwMDowMCdcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0VGltZV86ICcwMDowMCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc3RhcnRUaW1lRmllbGRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRUaW1lRmllbGRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gdGl0bGVGaWVsZENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZUZpZWxkQ29uZmlnOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgLy8gZm9jdXMgdHJhcCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjMwNlxuICAgICAgICB0aGlzLnZkb20udGFiSW5kZXggPSAtMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLmdldEZpZWxkKCd0aXRsZScpLnRoZW4oZmllbGQgPT4gZmllbGQuZm9jdXMoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlY29yZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5FdmVudH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5FdmVudH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWNvcmQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgICAgICAgICAgPSBtZS5pbnRsRm9ybWF0X3RpbWUsXG4gICAgICAgICAgICAgICAge2NhbGVuZGFySWQsIHRpdGxlfSA9IHZhbHVlO1xuXG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnZW5kVGltZScpICAudGhlbihmaWVsZCA9PiBmaWVsZC5taW5WYWx1ZSA9IG1lLmdldEVuZFRpbWVNaW5WYWx1ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgbWUuZ2V0RmllbGQoJ3N0YXJ0VGltZScpLnRoZW4oZmllbGQgPT4gZmllbGQubWF4VmFsdWUgPSBtZS5nZXRTdGFydFRpbWVNYXhWYWx1ZSh2YWx1ZSkpO1xuXG4gICAgICAgICAgICBtZS5yZXNldCh7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJJZCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lICA6IHRpbWVGb3JtYXQuZm9ybWF0KHZhbHVlLmVuZERhdGUpLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogdGltZUZvcm1hdC5mb3JtYXQodmFsdWUuc3RhcnREYXRlKSxcbiAgICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVJdGVtcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVjb3JkfSAgID0gbWUsXG4gICAgICAgICAgICB0aW1lRm9ybWF0ID0gbWUuaW50bEZvcm1hdF90aW1lLFxuICAgICAgICAgICAgdGltZUZpZWxkRGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgICA6IFRpbWVGaWVsZCxcbiAgICAgICAgICAgICAgICBjbGVhclRvT3JpZ2luYWxWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICAgICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gICAgICAgOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICAgICAgICAgIDoge2NoYW5nZTogbWUub25UaW1lRmllbGRDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgc3RlcFNpemUgICAgICAgICAgICA6IDE1ICogNjAsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgICA6ICc5ZW0nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIG1lLml0ZW1zID0gW3tcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgIGNsZWFyVG9PcmlnaW5hbFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZsZXggICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgICAgICA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgICAgICAgOiAnVGl0bGUnLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vblRpdGxlRmllbGRDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgICAgICAgICAgICA6ICd0aXRsZScsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA6IHJlY29yZC50aXRsZSxcbiAgICAgICAgICAgICAgICAuLi5tZS50aXRsZUZpZWxkQ29uZmlnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgICA6IENvbG9yRmllbGQsXG4gICAgICAgICAgICAgICAgY2xlYXJUb09yaWdpbmFsVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29sb3JGaWVsZCAgICAgICAgICA6ICdjb2xvcicsXG4gICAgICAgICAgICAgICAgZGlzcGxheUZpZWxkICAgICAgICA6ICduYW1lJyxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICAgICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGZvcmNlU2VsZWN0aW9uICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gICAgICAgOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQgICAgICAgICAgIDogJ0NhbGVuZGFyJyxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICAgICAgICAgIDoge2NoYW5nZTogbWUub25DYWxlbmRhckZpZWxkQ2hhbmdlLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgIG5hbWUgICAgICAgICAgICAgICAgOiAnY2FsZW5kYXJJZCcsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdHJpZ2dlckFjdGlvbiAgICAgICA6ICdhbGwnLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgICAgICAgOiByZWNvcmQuY2FsZW5kYXJJZCxcblxuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0dGVyOiAoc2NvcGUsZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW3Njb3BlLmNvbG9yRmllbGRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3llbGxvdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndmFyKC0tZXZlbnQteWVsbG93LWJvcmRlci1jb2xvciknO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB2YXIoLS1ldmVudC0ke3ZhbHVlfS1jb2xvcilgXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHN0b3JlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBDYWxlbmRhclN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZDogbWUubW9kZWwuZ2V0U3RvcmUoJ2NhbGVuZGFycycpLmlkXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC4uLm1lLmNhbGVuZGFyRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQ6ICdTdGFydCBUaW1lJyxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA6IG1lLmdldFN0YXJ0VGltZU1heFZhbHVlKHJlY29yZCksXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgOiBtZS5zdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgOiAnc3RhcnRUaW1lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHRpbWVGb3JtYXQuZm9ybWF0KHJlY29yZC5zdGFydERhdGUpLFxuICAgICAgICAgICAgICAgIC4uLnRpbWVGaWVsZERlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLm1lLnN0YXJ0VGltZUZpZWxkQ29uZmlnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0OiAnRW5kIFRpbWUnLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlIDogbWUuZW5kVGltZSxcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA6IG1lLmdldEVuZFRpbWVNaW5WYWx1ZShyZWNvcmQpLFxuICAgICAgICAgICAgICAgIG5hbWUgICAgIDogJ2VuZFRpbWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgIDogdGltZUZvcm1hdC5mb3JtYXQocmVjb3JkLmVuZERhdGUpLFxuICAgICAgICAgICAgICAgIC4uLnRpbWVGaWVsZERlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLm1lLmVuZFRpbWVGaWVsZENvbmZpZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBjbHMgICAgOiBbJ25lby1idXR0b24nLCAnbmVvLXJlZCddLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uRGVsZXRlQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhcyBmYS10cmFzaC1hbHQnLFxuICAgICAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5Ub3A6ICczZW0nfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnRGVsZXRlJ1xuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLm1vZGVsLkV2ZW50fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEVuZFRpbWVNaW5WYWx1ZShyZWNvcmQpIHtcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShyZWNvcmQuc3RhcnREYXRlLnZhbHVlT2YoKSk7XG5cbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpICsgdGhpcy5taW5pbXVtRXZlbnREdXJhdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50bEZvcm1hdF90aW1lLmZvcm1hdChkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5FdmVudH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdGFydFRpbWVNYXhWYWx1ZShyZWNvcmQpIHtcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShyZWNvcmQuZW5kRGF0ZS52YWx1ZU9mKCkpO1xuXG4gICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSAtIHRoaXMubWluaW11bUV2ZW50RHVyYXRpb24pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmludGxGb3JtYXRfdGltZS5mb3JtYXQoZGF0ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2FsZW5kYXJGaWVsZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkoZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkLmNhbGVuZGFySWQgPSBkYXRhLnJlY29yZFtkYXRhLmNvbXBvbmVudC5zdG9yZS5rZXlQcm9wZXJ0eV1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHdlIGNvdWxkIGFkZCBhIGNvbmZpcm0gZGlhbG9nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRlbGV0ZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5nZXRNb2RlbCgpLmdldFN0b3JlKCdldmVudHMnKS5yZW1vdmUobWUucmVjb3JkKTtcbiAgICAgICAgbWUudW5tb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgYSBzaG9ydCBkZWxheSwgc2luY2UgYSBUaW1lRmllbGQgcGlja2VyIGNvdWxkIGJlIG9wZW5cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMDApO1xuXG4gICAgICAgIG1lLm1vdW50ZWQgJiYgbWUudW5tb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRpbWVGaWVsZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbmFtZSAgID0gZGF0YS5jb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgIGZpZWxkICA9IG5hbWUgPT09ICdlbmRUaW1lJyA/ICdlbmREYXRlJyA6ICdzdGFydERhdGUnLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgZGF0ZSAgID0gRGF0ZVV0aWwuY2xvbmUobWUucmVjb3JkW2ZpZWxkXSksXG4gICAgICAgICAgICB2YWx1ZSAgPSBkYXRhLnZhbHVlLnNwbGl0KCc6JykubWFwKGUgPT4gTnVtYmVyKGUpKTtcblxuICAgICAgICBkYXRlLnNldEhvdXJzKHZhbHVlWzBdKTtcbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKHZhbHVlWzFdKTtcblxuICAgICAgICByZWNvcmRbZmllbGRdID0gZGF0ZTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2VuZFRpbWUnKSB7XG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnc3RhcnRUaW1lJykudGhlbihmaWVsZCA9PiBmaWVsZC5tYXhWYWx1ZSA9IG1lLmdldFN0YXJ0VGltZU1heFZhbHVlKHJlY29yZCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnZW5kVGltZScpICAudGhlbihmaWVsZCA9PiBmaWVsZC5taW5WYWx1ZSA9IG1lLmdldEVuZFRpbWVNaW5WYWx1ZShyZWNvcmQpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRpdGxlRmllbGRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBpZiAoIU5lby5pc0VtcHR5KGRhdGEudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZC50aXRsZSA9IGRhdGEudmFsdWVcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoRWRpdEV2ZW50Q29udGFpbmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgRWRpdEV2ZW50Q29udGFpbmVyO1xuIiwiaW1wb3J0IENhbGVuZGFyc0NvbnRhaW5lciAgICBmcm9tICcuL2NhbGVuZGFycy9Db250YWluZXIubWpzJztcbmltcG9ydCBDb250YWluZXIgICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBEYXRlU2VsZWN0b3IgICAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0RhdGVTZWxlY3Rvci5tanMnO1xuaW1wb3J0IERhdGVVdGlsICAgICAgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBFZGl0Q2FsZW5kYXJDb250YWluZXIgZnJvbSAnLi9jYWxlbmRhcnMvRWRpdENvbnRhaW5lci5tanMnO1xuaW1wb3J0IEVkaXRFdmVudENvbnRhaW5lciAgICBmcm9tICcuL0VkaXRFdmVudENvbnRhaW5lci5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJNb2RlbCAgICBmcm9tICcuL01haW5Db250YWluZXJNb2RlbC5tanMnO1xuaW1wb3J0IFRvb2xiYXIgICAgICAgICAgICAgICBmcm9tICcuLi8uLi90b29sYmFyL0Jhc2UubWpzJztcblxuY29uc3QgdG9kYXlEYXRlID0gbmV3IERhdGUoKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIGVudHJpZXMgZm9yIHRoZSB2aWV3cyBjb25maWdcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdmFsaWRWaWV3cz1bJ2RheScsJ3dlZWsnLCdtb250aCcsJ3llYXInXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRWaWV3cyA9IFsnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhciddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY2FsZW5kYXItbWFpbmNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjYWxlbmRhci1tYWluY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIHZpZXcuIE11c3QgYmUgYSB2YWx1ZSBpbmNsdWRlZCBpbnNpZGUgdGhlIHZpZXdzIGNvbmZpZy5cbiAgICAgICAgICogdmFsaWQgdmFsdWVzOiAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhcidcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhY3RpdmVWaWV3Xz0nd2VlaydcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZVZpZXdfOiAnd2VlaycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhci1tYWluY29udGFpbmVyJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhci1tYWluY29udGFpbmVyJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIHRoZSBjYWxlbmRhciB3aXRoIHVzaW5nIHMgZGlmZmVyZW50IGJhc2UgZm9udC1zaXplXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBiYXNlRm9udFNpemVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VGb250U2l6ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5Db250YWluZXJ8bnVsbH0gY2FsZW5kYXJzQ29udGFpbmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyc0NvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjYWxlbmRhclN0b3JlQ29uZmlnXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjYWxlbmRhclN0b3JlQ29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjb2xvclN0b3JlQ29uZmlnXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvclN0b3JlQ29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuRGF0ZVNlbGVjdG9yfG51bGx9IGRhdGVTZWxlY3Rvcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRlU2VsZWN0b3I6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZGF0ZVNlbGVjdG9yQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGVTZWxlY3RvckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LkRheUNvbXBvbmVudHxudWxsfSBkYXlDb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF5Q29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRheUNvbXBvbmVudENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXlDb21wb25lbnRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXJ8bnVsbH0gZWRpdENhbGVuZGFyQ29udGFpbmVyXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGVkaXRDYWxlbmRhckNvbnRhaW5lckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuRWRpdEV2ZW50Q29udGFpbmVyfG51bGx9IGVkaXRFdmVudENvbnRhaW5lcl89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBlZGl0RXZlbnRDb250YWluZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGV2ZW50U3RvcmVDb25maWdfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50U3RvcmVDb25maWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOid2Ym94JyxhbGlnbjonc3RyZXRjaCd9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lck1vZGVsfSBtb2RlbD1NYWluQ29udGFpbmVyTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBNYWluQ29udGFpbmVyTW9kZWwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5Db21wb25lbnR8bnVsbH0gbW9udGhDb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9udGhDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbW9udGhDb21wb25lbnRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9udGhDb21wb25lbnRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIG9ubHkga2VlcCB0aGUgYWN0aXZlIHZpZXcgaW5zaWRlIHRoZSBET01cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3ZlSW5hY3RpdmVDYXJkcz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHNldHRpbmdzQ29udGFpbmVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNldHRpbmdzQ29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzZXR0aW5nc0NvbnRhaW5lcldpZHRoPTMwMFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0dGluZ3NDb250YWluZXJXaWR0aDogMzEwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2V0dGluZ3NFeHBhbmRlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNldHRpbmdzRXhwYW5kZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpZGVCYXJFeHBhbmRlZF89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lkZUJhckV4cGFuZGVkXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2lkZUJhcldpZHRoPTIyMFxuICAgICAgICAgKi9cbiAgICAgICAgc2lkZUJhcldpZHRoOiAyMjAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VTZXR0aW5nc0NvbnRhaW5lcl89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlU2V0dGluZ3NDb250YWluZXJfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW55IGNvbWJpbmF0aW9uIGFuZCBvcmRlciBvZiAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhcidcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHZpZXdzXz1bJ2RheScsJ3dlZWsnLCdtb250aCcsJ3llYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgdmlld3NfOiBbJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LkNvbXBvbmVudHxudWxsfSB3ZWVrQ29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gd2Vla0NvbXBvbmVudENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3ZWVrQ29tcG9uZW50Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuWWVhckNvbXBvbmVudHxudWxsfSB5ZWFyQ29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHllYXJDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0geWVhckNvbXBvbmVudENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB5ZWFyQ29tcG9uZW50Q29uZmlnOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jcmVhdGVJdGVtc0NvbnRlbnQoKTtcbiAgICAgICAgIW1lLnNpZGVCYXJFeHBhbmRlZCAmJiBtZS5hZnRlclNldFNpZGVCYXJFeHBhbmRlZChmYWxzZSwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFjdGl2ZVZpZXcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWN0aXZlVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zWzFdLml0ZW1zWzFdLmxheW91dC5hY3RpdmVJbmRleCA9IG1lLnZpZXdzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgICAgICAgICBtZS5pdGVtc1swXS5pdGVtc1sxXS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRvZ2dsZUdyb3VwID09PSAnbWFpblZpZXdzJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXNzZWQgPSBpdGVtLnZhbHVlID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBiYXNlRm9udFNpemUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QmFzZUZvbnRTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5zdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZS5mb250U2l6ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5mb250U2l6ZSA9IGAke3ZhbHVlfXB4YFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2V0dGluZ3NFeHBhbmRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNldHRpbmdzRXhwYW5kZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNCb29sZWFuKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0NvbnRhaW5lciA9IG1lLml0ZW1zWzFdLml0ZW1zWzJdO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDb250YWluZXIuZXhwYW5kKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVTZXR0aW5nc0NvbnRhaW5lcih0cnVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3J0IGRlbGF5IHRvIGVuc3VyZSB0aGUgdm5vZGUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLml0ZW1zWzFdLml0ZW1zWzJdLmV4cGFuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCA1MClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ29udGFpbmVyLmNvbGxhcHNlKG1lLnNldHRpbmdzQ29udGFpbmVyV2lkdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNpZGVCYXJFeHBhbmRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNpZGVCYXJFeHBhbmRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzaWRlQmFyID0gbWUuaXRlbXNbMV0uaXRlbXNbMF0sXG4gICAgICAgICAgICAgICAgc3R5bGUgICA9IHNpZGVCYXIuc3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWRlQmFyLnZkb20ucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzaWRlQmFyLm1vdW50ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUubWFyZ2luTGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZUJhci5zdHlsZSA9IHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICB9LCA1MClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5tYXJnaW5MZWZ0ICAgID0gYC0ke21lLnNpZGVCYXJXaWR0aH1weGA7XG4gICAgICAgICAgICAgICAgc2lkZUJhci5fc3R5bGUgICAgICA9IHN0eWxlOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICAgICAgc2lkZUJhci5fdmRvbS5zdHlsZSA9IHN0eWxlOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZUJhci52ZG9tLnJlbW92ZURvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlQmFyLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlQmFyLm1vdW50ZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LCA0MDApXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZVNldHRpbmdzQ29udGFpbmVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlU2V0dGluZ3NDb250YWluZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS5zZXR0aW5nc0V4cGFuZGVkICYmIG1lLmNyZWF0ZVNldHRpbmdzQ29udGFpbmVyKGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIGVuc3VyZSB0aGUgaXRlbXMgYWxyZWFkeSBnb3QgY3JlYXRlZFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuaXRlbXNbMF0uaXRlbXNbMV0uYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogbWUudG9nZ2xlU2V0dGluZ3MuYmluZChtZSksXG4gICAgICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYSBmYS1jb2cnLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSAgOiB7bWFyZ2luTGVmdDogJzEwcHgnfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LCAxMClcbiAgICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0aGlzIGxvZ2ljIGluIGNhc2Ugd2UgZHluYW1pY2FsbHkgY2hhbmdlIHRoZSBjb25maWcgZnJvbSB0cnVlIHRvIGZhbHNlXG4gICAgICAgICAgICBtZS5pdGVtc1sxXSAgICAgICAgIC5yZW1vdmVMYXN0KCk7XG4gICAgICAgICAgICBtZS5pdGVtc1swXS5pdGVtc1sxXS5yZW1vdmVMYXN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJlZm9yZSBnZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgZWRpdENhbGVuZGFyQ29udGFpbmVyIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXJ9XG4gICAgICovXG4gICAgYmVmb3JlR2V0RWRpdENhbGVuZGFyQ29udGFpbmVyKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLl9lZGl0Q2FsZW5kYXJDb250YWluZXIgPSB2YWx1ZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEVkaXRDYWxlbmRhckNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIG1vZGVsICA6IHtwYXJlbnQ6IG1lLmdldE1vZGVsKCl9LFxuICAgICAgICAgICAgICAgIG93bmVyICA6IG1lLFxuICAgICAgICAgICAgICAgIHdpZHRoICA6IDI1MCxcbiAgICAgICAgICAgICAgICAuLi5tZS5lZGl0Q2FsZW5kYXJDb250YWluZXJDb25maWdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGVkaXRFdmVudENvbnRhaW5lciBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci52aWV3LkVkaXRFdmVudENvbnRhaW5lcnxudWxsfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY2FsZW5kYXIudmlldy5FZGl0RXZlbnRDb250YWluZXJ9XG4gICAgICovXG4gICAgYmVmb3JlR2V0RWRpdEV2ZW50Q29udGFpbmVyKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLl9lZGl0RXZlbnRDb250YWluZXIgPSB2YWx1ZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEVkaXRFdmVudENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIG1vZGVsICA6IHtwYXJlbnQ6IG1lLmdldE1vZGVsKCl9LFxuICAgICAgICAgICAgICAgIG93bmVyICA6IG1lLFxuICAgICAgICAgICAgICAgIHdpZHRoICA6IDI1MCxcbiAgICAgICAgICAgICAgICAuLi5tZS5lZGl0RXZlbnRDb250YWluZXJDb25maWdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhY3RpdmVWaWV3IGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEFjdGl2ZVZpZXcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdhY3RpdmVWaWV3JywgJ3ZhbGlkVmlld3MnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZpZXdzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWaWV3cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbGlkVmlld3MgPSB0aGlzLmdldFN0YXRpY0NvbmZpZygndmFsaWRWaWV3cycpO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2godmlldyA9PiB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkVmlld3MuaW5jbHVkZXModmlldykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHZpZXcsICdpcyBub3QgYSB2YWxpZCBlbnRyeSBmb3Igdmlld3MuIFN0aWNrIHRvOicsIHZhbGlkVmlld3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmlld1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjaGFuZ2VBY3RpdmVWaWV3KHZpZXcpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3ID0gdmlld1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBjcmVhdGVIZWFkZXJJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG1vZHVsZTogVG9vbGJhcixcbiAgICAgICAgICAgIGNscyAgIDogWyduZW8tY2FsZW5kYXItaGVhZGVyLXRvb2xiYXInLCAnbmVvLWxlZnQnLCAnbmVvLXRvb2xiYXInXSxcbiAgICAgICAgICAgIHdpZHRoIDogbWUuc2lkZUJhcldpZHRoLFxuICAgICAgICAgICAgaXRlbXMgOiBbe1xuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLnRvZ2dsZVNpZGViYXIuYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLWJhcnMnXG4gICAgICAgICAgICB9LCAnLT4nLCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUub25QcmV2aW91c0ludGVydmFsQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLWNoZXZyb24tbGVmdCcsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUub25Ub2RheUJ1dHRvbkNsaWNrLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA6IDI0LFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdUb2RheSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS5vbk5leHRJbnRlcnZhbEJ1dHRvbkNsaWNrLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYSBmYS1jaGV2cm9uLXJpZ2h0J1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlOiBUb29sYmFyLFxuICAgICAgICAgICAgY2xzICAgOiBbJ25lby1jYWxlbmRhci1oZWFkZXItdG9vbGJhcicsICduZW8tdG9vbGJhciddLFxuICAgICAgICAgICAgaXRlbXMgOiBbJy0+JywgLi4ubWUuY3JlYXRlVmlld0hlYWRlckJ1dHRvbnMoKV1cbiAgICAgICAgfV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXNDb250ZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNhbGVuZGFyc0NvbnRhaW5lciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICA6IENhbGVuZGFyc0NvbnRhaW5lcixcbiAgICAgICAgICAgIGZsZXggICAgOiAxLFxuICAgICAgICAgICAgcGFyZW50SWQ6IG1lLmlkLCAvLyB3ZSBuZWVkIHRoZSBwYXJlbnRJZCB0byBhY2Nlc3MgdGhlIG1vZGVsIGluc2lkZSB0aGUgY3RvclxuICAgICAgICAgICAgb3duZXIgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRhdGVTZWxlY3RvciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBEYXRlU2VsZWN0b3IsXG4gICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBmbGV4ICAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGhlaWdodCAgIDogbWUuc2lkZUJhcldpZHRoLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkRhdGVTZWxlY3RvckNoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHBhcmVudElkIDogbWUuaWQsIC8vIHdlIG5lZWQgdGhlIHBhcmVudElkIHRvIGFjY2VzcyB0aGUgbW9kZWwgaW5zaWRlIHRoZSBjdG9yXG4gICAgICAgICAgICB2YWx1ZSAgICA6IG51bGwsXG5cbiAgICAgICAgICAgIGJpbmQ6IHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmxvY2FsZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxOZXdZZWFyRnJvbVRvcDogZGF0YSA9PiBkYXRhLnNjcm9sbE5ld1llYXJGcm9tVG9wLFxuICAgICAgICAgICAgICAgIHNob3dXZWVrZW5kcyAgICAgICAgOiBkYXRhID0+IGRhdGEuc2hvd1dlZWtlbmRzLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgICAgICAgOiBkYXRhID0+IERhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGEuY3VycmVudERhdGUpLFxuICAgICAgICAgICAgICAgIHdlZWtTdGFydERheSAgICAgICAgOiBkYXRhID0+IGRhdGEud2Vla1N0YXJ0RGF5XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAuLi5tZS5kYXRlU2VsZWN0b3JDb25maWdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBbe1xuICAgICAgICAgICAgbW9kdWxlOiBDb250YWluZXIsXG4gICAgICAgICAgICBmbGV4ICA6ICdub25lJyxcbiAgICAgICAgICAgIGxheW91dDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAgICAgaXRlbXMgOiBtZS5jcmVhdGVIZWFkZXJJdGVtcygpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZTogQ29udGFpbmVyLFxuICAgICAgICAgICAgZmxleCAgOiAxLFxuICAgICAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICdoYm94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgICAgICBpdGVtcyA6IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBDb250YWluZXIsXG4gICAgICAgICAgICAgICAgY2xzICAgOiBbJ25lby1jYWxlbmRhci1zaWRlYmFyJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IG1lLnNpZGVCYXJXaWR0aCxcbiAgICAgICAgICAgICAgICBpdGVtcyA6IFttZS5kYXRlU2VsZWN0b3IsIG1lLmNhbGVuZGFyc0NvbnRhaW5lcl1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICA6IENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBmbGV4ICAgICA6IDEsXG4gICAgICAgICAgICAgICAgaXRlbXMgICAgOiBtZS5jcmVhdGVWaWV3cygpLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge2NhcmRMb2FkZWQ6IG1lLm9uQ2FyZExvYWRlZCwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBsYXlvdXQgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgICAgICAgICAgIDogJ2NhcmQnLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVJbmRleCAgICAgICAgOiBtZS52aWV3cy5pbmRleE9mKG1lLmFjdGl2ZVZpZXcpLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiBtZS5yZW1vdmVJbmFjdGl2ZUNhcmRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxhcHNlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIGNyZWF0ZVNldHRpbmdzQ29udGFpbmVyKGNvbGxhcHNlZCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBpbXBvcnQoJy4vU2V0dGluZ3NDb250YWluZXIubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgbWUuaXRlbXNbMV0uYWRkKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWQsXG4gICAgICAgICAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogbWUucmVtb3ZlSW5hY3RpdmVDYXJkcyxcbiAgICAgICAgICAgICAgICBzdHlsZSAgICAgICAgICAgICAgOiB7bWFyZ2luUmlnaHQ6ICFjb2xsYXBzZWQgPyAnMCcgOiBgLSR7bWUuc2V0dGluZ3NDb250YWluZXJXaWR0aH1weGB9LFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICAgICAgICA6IG1lLnNldHRpbmdzQ29udGFpbmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgLi4ubWUuc2V0dGluZ3NDb250YWluZXJDb25maWdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXdIZWFkZXJCdXR0b25zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBtZS52aWV3cy5pbmRleE9mKG1lLmFjdGl2ZVZpZXcpLFxuICAgICAgICAgICAgYnV0dG9ucyAgICAgPSBbXTtcblxuICAgICAgICBtZS52aWV3cy5mb3JFYWNoKCh2aWV3LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyICAgIDogbWUuY2hhbmdlQWN0aXZlVmlldy5iaW5kKG1lLCB2aWV3KSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgICAgIDogMjQsXG4gICAgICAgICAgICAgICAgcHJlc3NlZCAgICA6IGFjdGl2ZUluZGV4ID09PSBpbmRleCxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgICAgIDogTmVvLmNhcGl0YWxpemUodmlldyksXG4gICAgICAgICAgICAgICAgdG9nZ2xlR3JvdXA6ICdtYWluVmlld3MnLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgOiB2aWV3XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYnV0dG9uc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3cygpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhcmRzID0gW10sXG4gICAgICAgICAgICBjbXAsXG5cbiAgICAgICAgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGFwcE5hbWUgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgcGFyZW50SWQ6IG1lLmlkXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgZGF5OiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiAoKSA9PiBpbXBvcnQoJy4vRGF5Q29tcG9uZW50Lm1qcycpLFxuICAgICAgICAgICAgICAgIGZsYWcgIDogJ2RheScsXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5tZS5kYXlDb21wb25lbnRDb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb250aDoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogKCkgPT4gaW1wb3J0KCcuL21vbnRoL0NvbXBvbmVudC5tanMnKSxcbiAgICAgICAgICAgICAgICBmbGFnICA6ICdtb250aCcsXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5tZS5tb250aENvbXBvbmVudENvbmZpZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdlZWs6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6ICgpID0+IGltcG9ydCgnLi93ZWVrL0NvbXBvbmVudC5tanMnKSxcbiAgICAgICAgICAgICAgICBmbGFnICA6ICd3ZWVrJyxcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAgICAgICAgIC4uLm1lLndlZWtDb21wb25lbnRDb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5ZWFyOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiAoKSA9PiBpbXBvcnQoJy4vWWVhckNvbXBvbmVudC5tanMnKSxcbiAgICAgICAgICAgICAgICBmbGFnICA6ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAgICAgICAgIC4uLm1lLnllYXJDb21wb25lbnRDb25maWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBtZS52aWV3cy5mb3JFYWNoKHZpZXcgPT4ge1xuICAgICAgICAgICAgbWVbYCR7dmlld31Db21wb25lbnRgXSA9IGNtcCA9IG1hcFt2aWV3XTtcbiAgICAgICAgICAgIGNhcmRzLnB1c2goY21wKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhcmRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvbkNhcmRMb2FkZWQoZGF0YSkge1xuICAgICAgICB0aGlzW2Ake2RhdGEuaXRlbS5mbGFnfUNvbXBvbmVudGBdID0gZGF0YS5pdGVtO1xuXG4gICAgICAgIC8vIGZpcmUgdGhlIGV2ZW50IG9uIHRoaXMgaW5zdGFuY2UgYXMgd2VsbCA9PiBzZXR0aW5nIHZpZXdzIGNhbiBzdWJzY3JpYmUgdG8gaXQgbW9yZSBlYXNpbHlcbiAgICAgICAgdGhpcy5maXJlKCdjYXJkTG9hZGVkJywge2l0ZW06IGRhdGEuaXRlbX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5vbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnZhbHVlXG4gICAgICovXG4gICAgb25EYXRlU2VsZWN0b3JDaGFuZ2UoZGF0YSkge1xuICAgICAgICBkYXRhLm9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRNb2RlbCgpLnNldERhdGEoJ2N1cnJlbnREYXRlJywgbmV3IERhdGUoYCR7ZGF0YS52YWx1ZX1UMDA6MDA6MDAuMDAwWmApKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25OZXh0SW50ZXJ2YWxCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuc3dpdGNoSW50ZXJ2YWwoMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uUHJldmlvdXNJbnRlcnZhbEJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hJbnRlcnZhbCgtMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uVG9kYXlCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMubW9kZWwuc2V0RGF0YSh7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZTogdG9kYXlEYXRlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRvZ2dsZVNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzRXhwYW5kZWQgPSAhdGhpcy5zZXR0aW5nc0V4cGFuZGVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRvZ2dsZVNpZGViYXIoKSB7XG4gICAgICAgIHRoaXMuc2lkZUJhckV4cGFuZGVkID0gIXRoaXMuc2lkZUJhckV4cGFuZGVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG11bHRpcGxpZXJcbiAgICAgKi9cbiAgICBzd2l0Y2hJbnRlcnZhbChtdWx0aXBsaWVyKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IG1lLmRhdGEuY3VycmVudERhdGUsXG5cbiAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgZGF5ICA6ICgpID0+IHtjdXJyZW50RGF0ZS5zZXREYXRlKCAgICBjdXJyZW50RGF0ZS5nZXREYXRlKCkgICAgICsgbXVsdGlwbGllcil9LFxuICAgICAgICAgICAgbW9udGg6ICgpID0+IHtjdXJyZW50RGF0ZS5zZXRNb250aCggICBjdXJyZW50RGF0ZS5nZXRNb250aCgpICAgICsgbXVsdGlwbGllcil9LFxuICAgICAgICAgICAgd2VlayA6ICgpID0+IHtjdXJyZW50RGF0ZS5zZXREYXRlKCAgICBjdXJyZW50RGF0ZS5nZXREYXRlKCkgKyA3ICogbXVsdGlwbGllcil9LFxuICAgICAgICAgICAgeWVhciA6ICgpID0+IHtjdXJyZW50RGF0ZS5zZXRGdWxsWWVhcihjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpICsgbXVsdGlwbGllcil9XG4gICAgICAgIH07XG5cbiAgICAgICAgbWFwW21lLmFjdGl2ZVZpZXddKCk7XG5cbiAgICAgICAgbWUubW9kZWwuc2V0RGF0YSh7Y3VycmVudERhdGV9KVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5Db250YWluZXI7XG4iLCJpbXBvcnQgTGlzdCBmcm9tICcuLi8uLi8uLi9saXN0L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkNvbG9yc0xpc3RcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqL1xuY2xhc3MgQ29sb3JzTGlzdCBleHRlbmRzIExpc3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkNvbG9yc0xpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db2xvcnNMaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFycy1jb2xvcnMtbGlzdCcsJ25lby1saXN0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFycy1jb2xvcnMtbGlzdCcsICduZW8tbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBzdG9yZTogJ3N0b3Jlcy5jb2xvcnMnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VXcmFwcGVyTm9kZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlV3JhcHBlck5vZGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ2V0cyB1c2VkIGFzIGEgZm9ybSBmaWVsZCwgc28gd2UgYXJlIGFkanVzdGluZyB0aGUgc2VsZWN0aW9uIGJhc2VkIG9uIHRoaXMgY29uZmlnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdmFsdWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGVkIGEgdGFiSW5kZXggdG8gZW5hYmxlIHRhYmJpbmcgdGhyb3VnaCB0aGUgZm9ybVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt0YWc6J3VsJyxjbjpbXSx0YWJJbmRleDonMCd9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ3VsJywgY246IFtdLCB0YWJJbmRleDogJzAnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFtZS5kaXNhYmxlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBtZS5zdG9yZS5maW5kKCduYW1lJywgdmFsdWUpWzBdO1xuICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdChtZS5nZXRJdGVtSWQocmVjb3JkW21lLmdldEtleVByb3BlcnR5KCldKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIHJlbmRlcmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ30gRWl0aGVyIGEgY29uZmlnIG9iamVjdCB0byBhc3NpZ24gdG8gdGhlIGl0ZW0sIGEgdmRvbSBjbiBhcnJheSBvciBhIGh0bWwgc3RyaW5nXG4gICAgICovXG4gICAgY3JlYXRlSXRlbUNvbnRlbnQocmVjb3JkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4ge3N0eWxlOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGB2YXIoLS1ldmVudC0ke3JlY29yZC5uYW1lfS1jb2xvcilgLFxuICAgICAgICAgICAgY29sb3IgICAgICAgICAgOiBgdmFyKC0tZXZlbnQtJHtyZWNvcmQubmFtZX0tY29sb3IpYCAvLyBuZWVkZWQgZm9yIHRoZSBib3gtc2hhZG93IChDU1MgY3VycmVudENvbG9yKVxuICAgICAgICB9fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmFsdWV9ID0gbWU7XG5cbiAgICAgICAgdmFsdWUgJiYgbWUuYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgZnJvbSBzZWxlY3Rpb24uTW9kZWw6IHNlbGVjdCgpXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkSWQgPSBtZS5nZXRJdGVtUmVjb3JkSWQoaXRlbXNbMF0pO1xuXG4gICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgIHJlY29yZDogbWUuc3RvcmUuZ2V0KHJlY29yZElkKVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKENvbG9yc0xpc3QpO1xuXG5leHBvcnQgZGVmYXVsdCBDb2xvcnNMaXN0O1xuIiwiaW1wb3J0IEJhc2VDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMaXN0ICAgICAgICAgIGZyb20gJy4vTGlzdC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLWNhbGVuZGFyc2NvbnRhaW5lcicsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItY2FsZW5kYXJzY29udGFpbmVyJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZTogJ3N0b3Jlcy5jYWxlbmRhcnMnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IGNhbGVuZGFyU3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyU3RvcmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBMaXN0LFxuICAgICAgICAgICAgb3duZXIgOiAnQGNvbmZpZzpvd25lcicgLy8gcGFzc2luZyB0aGUgb3duZXIgY29uZmlnIGRvd253YXJkc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBudHlwZSAgICAgICA6ICdidXR0b24nLFxuICAgICAgICAgICAgY2xzICAgICAgICAgOiBbJ25lby1hZGQtY2FsZW5kYXItYnV0dG9uJ10sXG4gICAgICAgICAgICBmbGV4ICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGhhbmRsZXIgICAgIDogJ29uQWRkQ2FsZW5kYXJCdXR0b25DbGljaycsXG4gICAgICAgICAgICBoYW5kbGVyU2NvcGU6ICd0aGlzJyxcbiAgICAgICAgICAgIHN0eWxlICAgICAgIDoge21hcmdpblRvcDogJ2F1dG8nfSxcbiAgICAgICAgICAgIHRleHQgICAgICAgIDogJ0FkZCBDYWxlbmRhcidcbiAgICAgICAgfV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J3Zib3gnLGFsaWduOidzdHJldGNoJ31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQWRkQ2FsZW5kYXJCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdG9yZS5hZGQoe1xuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgY29sb3IgOiAncmVkJyxcbiAgICAgICAgICAgIG5hbWUgIDogJ05ldyBDYWxlbmRhcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhDb250YWluZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iLCJpbXBvcnQgQnV0dG9uICAgICAgICBmcm9tICcuLi8uLi8uLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbG9yc0xpc3QgICAgZnJvbSAnLi9Db2xvcnNMaXN0Lm1qcyc7XG5pbXBvcnQgRm9ybUNvbnRhaW5lciBmcm9tICcuLi8uLi8uLi9mb3JtL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCAgICAgZnJvbSAnLi4vLi4vLi4vZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5Db250YWluZXJcbiAqL1xuY2xhc3MgRWRpdENvbnRhaW5lciBleHRlbmRzIEZvcm1Db250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLWVkaXQtY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFyLWVkaXQtY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29sb3JzTGlzdHxudWxsfSBjb2xvcnNMaXN0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yc0xpc3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY29sb3JzTGlzdENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvcnNMaXN0Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IG5hbWVGaWVsZENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lRmllbGRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLm1vZGVsLkNhbGVuZGFyfG51bGx9IHJlY29yZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVjb3JkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB1bk1vdW50VGltZW91dElkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdW5Nb3VudFRpbWVvdXRJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIC8vIGZvY3VzIHRyYXAsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIzMDZcbiAgICAgICAgdGhpcy52ZG9tLnRhYkluZGV4ID0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy5nZXRGaWVsZCgnbmFtZScpLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZWNvcmQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVjb3JkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUucmVzZXQoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlLm5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0LnZhbHVlID0gdmFsdWUuY29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSByZWNvcmQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIFdlIG5lZWQgdGhlIGJlZm9yZSBtZXRob2QgdG8gYWxzbyBnZXQgY2xpY2tzIG9uIHRoZSBzYW1lIGVkaXQgaWNvbixcbiAgICAgKiBzaW5jZSBpdCBkb2VzIHRyaWdnZXIgZm9yIG5vdCBjaGFuZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5DYWxlbmRhcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5DYWxlbmRhcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UmVjb3JkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS51bk1vdW50VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWUudW5Nb3VudFRpbWVvdXRJZCk7XG4gICAgICAgICAgICBtZS51bk1vdW50VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3JlY29yZH0gPSBtZTtcblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0ID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgOiBDb2xvcnNMaXN0LFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICA6IHtjaGFuZ2U6IG1lLm9uQ29sb3JDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgICAgOiBtZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA6IHJlY29yZC5jb2xvcixcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGU6IHttYXJnaW5Ub3A6ICcwLjJlbSd9LFxuICAgICAgICAgICAgICAgIC4uLm1lLmNvbG9yc0xpc3RDb25maWdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgICAgICBjbGVhclRvT3JpZ2luYWxWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICAgICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gICAgICAgOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQgICAgICAgICAgIDogJ0NhbGVuZGFyIE5hbWUnLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vbk5hbWVGaWVsZENoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgICAgICAgIDogJ25hbWUnLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgICAgICAgOiByZWNvcmQubmFtZSxcbiAgICAgICAgICAgICAgICAuLi5tZS5uYW1lRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGNscyAgICA6IFsnbmVvLXJlZCddLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uRGVsZXRlQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhcyBmYS10cmFzaC1hbHQnLFxuICAgICAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5Ub3A6ICczZW0nfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnRGVsZXRlJ1xuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnJlY29yZFxuICAgICAqL1xuICAgIG9uQ29sb3JDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnJlY29yZC5jb2xvciA9IGRhdGEucmVjb3JkLm5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRlbGV0ZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvOiB3ZSBjb3VsZCBhZGQgYSBjb25maXJtIGRpYWxvZ1xuXG4gICAgICAgIG1lLmdldE1vZGVsKCkuZ2V0U3RvcmUoJ2NhbGVuZGFycycpLnJlbW92ZShtZS5yZWNvcmQpO1xuICAgICAgICBtZS51bm1vdW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXVxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gd2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIGdldCByZWNvcmQtY2hhbmdlcyAoY2xpY2tpbmcgb24gYW5vdGhlciBlZGl0IGljb24pXG4gICAgICAgIG1lLnVuTW91bnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG1lLnVuTW91bnRUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgbWUubW91bnRlZCAmJiBtZS51bm1vdW50KCk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk5hbWVGaWVsZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkoZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkLm5hbWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhFZGl0Q29udGFpbmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgRWRpdENvbnRhaW5lcjtcbiIsImltcG9ydCBDaGVja0JveEZpZWxkIGZyb20gJy4uLy4uLy4uL2Zvcm0vZmllbGQvQ2hlY2tCb3gubWpzJztcbmltcG9ydCBDb21wb25lbnRMaXN0IGZyb20gJy4uLy4uLy4uL2xpc3QvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5MaXN0XG4gKiBAZXh0ZW5kcyBOZW8ubGlzdC5Db21wb25lbnRcbiAqL1xuY2xhc3MgTGlzdCBleHRlbmRzIENvbXBvbmVudExpc3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5MaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFycy1saXN0JywnbmVvLWxpc3QnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXJzLWxpc3QnLCAnbmVvLWxpc3QnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgc3RvcmU6ICdzdG9yZXMuY2FsZW5kYXJzJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IENoZWNrQm94RmllbGQsXG4gICAgICAgICAgICBmbGV4ICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICA6IHRydWUsXG4gICAgICAgICAgICBpY29uQ2xzICAgICAgIDogWydmYXMnLCAnZmEtc3F1YXJlJ10sXG4gICAgICAgICAgICBpY29uQ2xzQ2hlY2tlZDogWydmYXMnLCAnZmEtY2hlY2stc3F1YXJlJ11cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXJ8bnVsbH0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICA9IHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSxcbiAgICAgICAgICAgIGl0ZW1zICAgID0gbWUuaXRlbXMgfHwgW10sXG4gICAgICAgICAgICBjaGVja0JveCA9IGl0ZW1zW2luZGV4XSxcblxuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICBjaGVja2VkICAgICAgIDogcmVjb3JkLmFjdGl2ZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgOiBbYG5lby1jb2xvci0ke3JlY29yZC5jb2xvcn1gXSxcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgICAgOiBpZCxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgOiBtZS5nZXRDb21wb25lbnRJZChpbmRleCksXG4gICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogcmVjb3JkLm5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY2hlY2tCb3gpIHtcbiAgICAgICAgICAgIGNoZWNrQm94LnNldFNpbGVudChjb25maWcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtc1tpbmRleF0gPSBjaGVja0JveCA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWUgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ2hlY2tib3hDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAuLi5tZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXRlbXMgPSBpdGVtcztcblxuICAgICAgICByZXR1cm4gW2NoZWNrQm94LnZkb20sIHt0YWc6ICdpJywgY2xzOiBbJ25lby1lZGl0LWljb24nLCAnZmFzIGZhLWVkaXQnXSwgaWQ6IG1lLmdldEVkaXRJY29uSWQoaW5kZXgpfV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEVkaXRJY29uSWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X18ke2luZGV4fV9fZWRpdC1pY29uYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DaGVja2JveENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZ2V0KGRhdGEuY29tcG9uZW50LmZpZWxkVmFsdWUpLmFjdGl2ZSA9IGRhdGEudmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2xpY2soZGF0YSkge1xuICAgICAgICAvLyBUaGUgY2xpY2sgZXZlbiBhcnJpdmVzIGJlZm9yZSB0aGUgQ2hlY2tCb3ggb25JbnB1dFZhbHVlQ2hhbmdlKCkgZ2V0cyB0cmlnZ2VyZWQuXG4gICAgICAgIC8vIFdlIG5lZWQgYSBzaG9ydCBkZWxheSB0byBlbnN1cmUgdGhlIHZkb20gb2YgdGhlIGxpc3QgaXRlbSBjb250YWlucyB0aGUgbmV3IGNoZWNrZWQgc3RhdGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzdXBlci5vbkNsaWNrKGRhdGEpXG4gICAgICAgIH0sIDIwKTtcblxuICAgICAgICBpZiAoZGF0YS5wYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLWVkaXQtaWNvbicpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBsaXN0SXRlbVJlY3QgICAgICAgICAgPSBkYXRhLnBhdGhbMV0ucmVjdCxcbiAgICAgICAgICAgICAgICBtYWluQ29udGFpbmVyICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXIgPSBtYWluQ29udGFpbmVyLmVkaXRDYWxlbmRhckNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICB7bW91bnRlZCwgc3R5bGV9ICAgICAgPSBlZGl0Q2FsZW5kYXJDb250YWluZXIsXG4gICAgICAgICAgICAgICAgcmVjb3JkICAgICAgICAgICAgICAgID0gbWUuc3RvcmUuZ2V0KG1lLmdldEl0ZW1SZWNvcmRJZChkYXRhLnBhdGhbMV0uaWQpKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGAke2xpc3RJdGVtUmVjdC5yaWdodCArIDEzfXB4YCxcbiAgICAgICAgICAgICAgICB0b3AgOiBgJHtsaXN0SXRlbVJlY3QudG9wICAgLSAxMH1weGBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJbbW91bnRlZCA/ICdzZXQnIDogJ3NldFNpbGVudCddKHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogbWFpbkNvbnRhaW5lci5pZCxcbiAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgc3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXIucmVuZGVyKHRydWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkaXRDYWxlbmRhckNvbnRhaW5lci5hZnRlclNldE1vdW50ZWQodHJ1ZSwgZmFsc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkXG4gICAgICovXG4gICAgb25LZXlEb3duRW50ZXIoaXRlbUlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmRJZCA9IG1lLmdldEl0ZW1SZWNvcmRJZChpdGVtSWQpLFxuICAgICAgICAgICAgY2hlY2tCb3ggPSBtZS5pdGVtc1ttZS5zdG9yZS5pbmRleE9mKHJlY29yZElkKV07XG5cbiAgICAgICAgY2hlY2tCb3guY2hlY2tlZCA9ICFjaGVja0JveC5jaGVja2VkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICB0aGlzLmdldE1vZGVsKCkuc2V0RGF0YSgnYWN0aXZlQ2FsZW5kYXJJZCcsIHRoaXMuZ2V0SXRlbVJlY29yZElkKGl0ZW1zWzBdKSlcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKExpc3QpO1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjbGFzcyB0byByZW5kZXIgYSBsYWJlbCB3aXRoIGEgdGV4dFxuICogQGNsYXNzIE5lby5jb21wb25lbnQuTGFiZWxcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBMYWJlbCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkxhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkxhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWxhYmVsJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWxhYmVsJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRleHRfPScnXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0XzogJycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt0YWc6ICdsYWJlbCd9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ2xhYmVsJywgZHJhZ2dhYmxlOiBmYWxzZX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLmh0bWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoTGFiZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBMYWJlbDtcbiIsImltcG9ydCBCYXNlICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1jb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1jb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZWZlcmVuY2VzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29tcG9uZW50fSA9IG1lLFxuICAgICAgICAgICAgbGlzdGVuZXJJZDtcblxuICAgICAgICBtZS5yZWZlcmVuY2VzID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVySWQgPSBjb21wb25lbnQub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bignY29uc3RydWN0ZWQnLCBsaXN0ZW5lcklkKTtcbiAgICAgICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwYXJlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGFyZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgdGhpcy5nZXRQYXJlbnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVyTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fEJvb2xlYW58bnVsbH1cbiAgICAgKi9cbiAgICBnZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudH0gPSBtZTtcblxuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciB0aHMgZnVuY3Rpb24gKm5hbWUqIGZpcnN0IGluIHRoZSBDb21wb25lbnQgaXRzZWxmLlxuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBpdCwgcmV0dXJuIHRydWUgc28gY2FsbGluZyBjb2RlIGtub3dzIG5vdCB0byBjb250aW51ZSB0byBzZWFyY2guXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyQ2IgPSBjb21wb25lbnQucmVzb2x2ZUNhbGxiYWNrKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyIGZuIGlzIHJlc29sdmVkIGluIHRoZSBDb21wb25lbnQgb3IgaXRzIG93biBwYXJlbnQgY2hhaW4uXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBzdGF0dXMgaW5kaWNhdGluZyB0aGF0IHdlIGRvIG5vdCBuZWVkIGFuIGVhcmx5IGJpbmRpbmdcbiAgICAgICAgICAgIGlmIChoYW5kbGVyQ2IuZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5pc0Z1bmN0aW9uKG1lW2hhbmRsZXJOYW1lXSkgP1xuICAgICAgICAgICAgbWUgOiBwYXJlbnQgP1xuICAgICAgICAgICAgcGFyZW50LmdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSkgOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2FtZUxldmVsT25seT1mYWxzZSB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBWTSBpbnNpZGUgdGhlIGNvbXBvbmVudCBwYXJlbnQgdHJlZSxcbiAgICAgKiBpbiBjYXNlIHRoZXJlIGlzIG5vbmUgb24gdGhlIHNhbWUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2FtZUxldmVsT25seT1mYWxzZV1cbiAgICAgKi9cbiAgICBnZXRNb2RlbChzYW1lTGV2ZWxPbmx5PWZhbHNlKSB7XG4gICAgICAgIGxldCB7Y29tcG9uZW50fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzYW1lTGV2ZWxPbmx5ID8gY29tcG9uZW50Lm1vZGVsIDogY29tcG9uZW50LmdldE1vZGVsKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsb3Nlc3QgY29udHJvbGxlciBpbnNpZGUgdGhlIGNvbXBvbmVudHMgcGFyZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudH0gPSBtZTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLmNvbXBvbmVudC5wYXJlbnQ/LmdldENvbnRyb2xsZXIoKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9kbzogdXBkYXRlIGNoYW5nZWQgcmVmZXJlbmNlcyAoZS5nLiBjb250YWluZXIucmVtb3ZlKCkgdGhlbiBjb250YWluZXIuYWRkKCkgdXNpbmcgdGhlIHNhbWUga2V5KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5yZWZlcmVuY2VzW25hbWVdO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5jb21wb25lbnQuZG93bih7cmVmZXJlbmNlOiBuYW1lfSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZWZlcmVuY2VzW25hbWVdID0gY29tcG9uZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50IHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgYWNjZXNzaW5nIG1vZGVsLkNvbXBvbmVudCBiYXNlZCBkYXRhLlN0b3Jlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vZGVsKCkuZ2V0U3RvcmUoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluc2lkZSB5b3VyIHZpZXcgY29udHJvbGxlcnMgYXMgYSBzdGFydGluZyBwb2ludCBpbiBjYXNlIHlvdSBuZWVkIHJlZmVyZW5jZXNcbiAgICAgKiAoaW5zdGVhZCBvZiB1c2luZyBvbkNvbnN0cnVjdGVkKCkgaW5zaWRlIHlvdXIgY29udHJvbGxlcilcbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudENvbnN0cnVjdGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnQ9dGhpcy5jb21wb25lbnRcbiAgICAgKi9cbiAgICBwYXJzZUNvbmZpZyhjb21wb25lbnQ9dGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHtoYW5kbGVyLCBsaXN0ZW5lcnMsIHJlZmVyZW5jZSwgdmFsaWRhdG9yfSA9IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgaGFuZGxlclNjb3BlO1xuXG4gICAgICAgIGlmIChoYW5kbGVyICYmIHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXIsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIG5hbWUgd2FzIG5vdCByZXNvbHZlZCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZiwgYmluZCBpdFxuICAgICAgICAgICAgaWYgKGhhbmRsZXJTY29wZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5oYW5kbGVyID0gaGFuZGxlclNjb3BlW2hhbmRsZXJdLmJpbmQoY29tcG9uZW50LmhhbmRsZXJTY29wZSB8fCBoYW5kbGVyU2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXJzICYmIE9iamVjdC5lbnRyaWVzKGxpc3RlbmVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnc2NvcGUnICYmIGtleSAhPT0gJ2RlbGVnYXRlJykge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyU2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUoZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBmb3InLCBldmVudEhhbmRsZXIsIGNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyU2NvcGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5mbiA9IGhhbmRsZXJTY29wZVtldmVudEhhbmRsZXJdLmJpbmQoaGFuZGxlclNjb3BlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGxpc3RlbmVyKSAmJiBsaXN0ZW5lci5oYXNPd25Qcm9wZXJ0eSgnZm4nKSAmJiBOZW8uaXNTdHJpbmcobGlzdGVuZXIuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gbGlzdGVuZXIuZm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlciwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBmb3InLCBldmVudEhhbmRsZXIsIGNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXJTY29wZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5mbiA9IGhhbmRsZXJTY29wZVtldmVudEhhbmRsZXJdLmJpbmQoaGFuZGxlclNjb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsaWRhdG9yKSkge1xuICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKHZhbGlkYXRvcik7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9yKCdVbmtub3duIHZhbGlkYXRvciBmb3InLCBjb21wb25lbnQuaWQsIGNvbXBvbmVudClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnZhbGlkYXRvciA9IGhhbmRsZXJTY29wZVt2YWxpZGF0b3JdLmJpbmQoaGFuZGxlclNjb3BlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tyZWZlcmVuY2VdID0gY29tcG9uZW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50PXRoaXMuY29tcG9uZW50XG4gICAgICovXG4gICAgcGFyc2VEb21MaXN0ZW5lcnMoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZG9tTGlzdGVuZXJzfSA9IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgc2NvcGU7XG5cbiAgICAgICAgZG9tTGlzdGVuZXJzPy5mb3JFYWNoKGRvbUxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRvbUxpc3RlbmVyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3Njb3BlJyAmJiBrZXkgIT09ICdkZWxlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ2ZuJykgJiYgTmVvLmlzU3RyaW5nKHZhbHVlLmZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gdmFsdWUuZm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShldmVudEhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9yKCdVbmtub3duIGRvbUV2ZW50IGhhbmRsZXIgZm9yJywgZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbUxpc3RlbmVyW2tleV0gPSBzY29wZVtldmVudEhhbmRsZXJdLmJpbmQoc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgZ2V0IGNhbGxlZCBieSBjb21wb25lbnQuQmFzZTogZGVzdHJveSgpIGluIGNhc2UgdGhlIGNvbXBvbmVudCBoYXMgYSByZWZlcmVuY2UgY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVmZXJlbmNlc30gPSBtZSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSByZWZlcmVuY2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVmZXJlbmNlc1trZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRQYXJlbnQoKT8ucmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudClcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiIsImltcG9ydCBDb2xvckxpc3QgZnJvbSAnLi4vLi4vbGlzdC9Db2xvci5tanMnXG5pbXBvcnQgQ29tYm9Cb3ggIGZyb20gJy4vQ29tYm9Cb3gubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLkNvbG9yXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5Db21ib0JveFxuICovXG5jbGFzcyBDb2xvciBleHRlbmRzIENvbWJvQm94IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLmZpZWxkLkNvbG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5Db2xvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb2xvcmZpZWxkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbG9yZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY29sb3JmaWVsZCcsJ25lby1zZWxlY3RmaWVsZCcsJ25lby1waWNrZXJmaWVsZCcsJ25lby10ZXh0ZmllbGQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY29sb3JmaWVsZCcsICduZW8tc2VsZWN0ZmllbGQnLCAnbmVvLXBpY2tlcmZpZWxkJywgJ25lby10ZXh0ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhLk1vZGVsIGZpZWxkIHdoaWNoIGNvbnRhaW5zIHRoZSBjb2xvciB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbG9yRmllbGQ9J25hbWUnXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZpZWxkOiAnbmFtZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSB0aGUgZm9ybWF0dGVyIHRvIGFwcGx5IGEgY3VzdG9tIGJhY2tncm91bmQtY29sb3Igc3R5bGluZy5cbiAgICAgICAgICogRS5nLiB1c2luZyBDU1MgdmFycyBmb3IgZGlmZmVyZW50IHRoZW1lc1xuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gY29sb3JGaWVsZD0oc2NvcGUsZGF0YSk9PmRhdGFbc2NvcGUuY29sb3JGaWVsZF1cbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRm9ybWF0dGVyOiAoc2NvcGUsZGF0YSkgPT4gZGF0YVtzY29wZS5jb2xvckZpZWxkXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBsaXN0Q29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0Q29uZmlnOiB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICA6IENvbG9yTGlzdCxcbiAgICAgICAgICAgIGNvbG9yRmllbGQgICAgICAgIDogJ0Bjb25maWc6Y29sb3JGaWVsZCcsXG4gICAgICAgICAgICBjb2xvckZvcm1hdHRlciAgICA6ICdAY29uZmlnOmNvbG9yRm9ybWF0dGVyJyxcbiAgICAgICAgICAgIHNpbGVudFNlbGVjdFVwZGF0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnB1dFdyYXBwZXIgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG1lLnZkb20sIHtpZDogbWUuZ2V0SW5wdXRXcmFwcGVySWQoKX0pO1xuXG4gICAgICAgIGlucHV0V3JhcHBlci52ZG9tLmNuLnVuc2hpZnQoe1xuICAgICAgICAgICAgY2xzICA6ICduZW8tY29sb3InLFxuICAgICAgICAgICAgaWQgICA6IG1lLmdldENvbG9ySW5kaWNhdG9ySWQoKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtZS5nZXRDb2xvcigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudEZpbHRlcj1mYWxzZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHByZXZlbnRGaWx0ZXI9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbG9ySW5kaWNhdG9yID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCB7aWQ6IG1lLmdldENvbG9ySW5kaWNhdG9ySWQoKX0pPy52ZG9tLFxuICAgICAgICAgICAge2xpc3QsIHJlY29yZH0gPSBtZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsID0gbWUubGlzdD8uc2VsZWN0aW9uTW9kZWw7XG5cbiAgICAgICAgaWYgKGNvbG9ySW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBjb2xvckluZGljYXRvci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtZS5nZXRDb2xvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LnNlbGVjdChsaXN0LmdldEl0ZW1JZChyZWNvcmRbbWUuc3RvcmUua2V5UHJvcGVydHldKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCh0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHN1cGVyIGNhbGwgd2lsbCB0cmlnZ2VyIHRoZSB2ZG9tIHVwZGF0ZVxuICAgICAgICBzdXBlci5hZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgcHJldmVudEZpbHRlcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbG9yKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWNvcmQsIHZhbHVlfSA9IG1lO1xuXG4gICAgICAgIHJldHVybiByZWNvcmQgPyBtZS5jb2xvckZvcm1hdHRlcihtZSwgcmVjb3JkKSA6IG1lLmZvcmNlU2VsZWN0aW9uID8gbnVsbCA6IHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2xvckluZGljYXRvcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2NvbG9yLWluZGljYXRvcmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TZWxlY3RQb3N0TGFzdEl0ZW0oKSB7XG4gICAgICAgIGxldCB7bGlzdH0gPSB0aGlzLFxuICAgICAgICAgICAgaW5kZXggID0gbGlzdC5zdG9yZS5nZXRDb3VudCgpIC0gMTtcblxuICAgICAgICBsaXN0LnZkb20uY25baW5kZXhdID0gbGlzdC5jcmVhdGVJdGVtKGxpc3Quc3RvcmUuZ2V0QXQoaW5kZXgpLCBpbmRleCk7XG5cbiAgICAgICAgc3VwZXIub25TZWxlY3RQb3N0TGFzdEl0ZW0oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNlbGVjdFByZUZpcnN0SXRlbSgpIHtcbiAgICAgICAgbGV0IHtsaXN0fSA9IHRoaXM7XG5cbiAgICAgICAgbGlzdC52ZG9tLmNuWzBdID0gbGlzdC5jcmVhdGVJdGVtKGxpc3Quc3RvcmUuZ2V0QXQoMCksIDApO1xuXG4gICAgICAgIHN1cGVyLm9uU2VsZWN0UHJlRmlyc3RJdGVtKClcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKENvbG9yKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29sb3I7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxpc3QuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqL1xuY2xhc3MgQ29sb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5saXN0LkNvbG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGlzdC5Db2xvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb2xvcmxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29sb3JsaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvbG9yLWxpc3QnLCduZW8tbGlzdCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb2xvci1saXN0JywgJ25lby1saXN0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YS5Nb2RlbCBmaWVsZCB3aGljaCBjb250YWlucyB0aGUgY29sb3IgdmFsdWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb2xvckZpZWxkPSduYW1lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgdGhlIGZvcm1hdHRlciB0byBhcHBseSBhIGN1c3RvbSBiYWNrZ3JvdW5kLWNvbG9yIHN0eWxpbmcuXG4gICAgICAgICAqIEUuZy4gdXNpbmcgQ1NTIHZhcnMgZm9yIGRpZmZlcmVudCB0aGVtZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGNvbG9yRmllbGQ9KHNjb3BlLGRhdGEpPT5kYXRhW3Njb3BlLmNvbG9yRmllbGRdXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZvcm1hdHRlcjogKHNjb3BlLGRhdGEpID0+IGRhdGFbc2NvcGUuY29sb3JGaWVsZF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmb3JtLmZpZWxkLkNvbG9yIG5lZWRzIHRvIHRyaWdnZXIgYSBzaWxlbnQgdmRvbSB1cGRhdGVcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWxlbnRTZWxlY3RVcGRhdGU9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2lsZW50U2VsZWN0VXBkYXRlID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgICAgICAgPSByZWNvcmRbbWUuc3RvcmUua2V5UHJvcGVydHldLFxuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IG1lLnNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQobWUuZ2V0SXRlbUlkKGlkKSk7XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICB0YWcgIDogJ2knLFxuICAgICAgICAgICAgY2xzICA6IFsnbmVvLWljb24nLCAnZmFzJywgYGZhLSR7aXNTZWxlY3RlZCA/ICdjaGVjay0nIDogJyd9c3F1YXJlYF0sXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0TGlzdEl0ZW1JY29uSWQoaWQpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbWUuY29sb3JGb3JtYXR0ZXIobWUsIHJlY29yZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdnR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGh0bWwgOiByZWNvcmRbbWUuZGlzcGxheUZpZWxkXSxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRMaXN0SXRlbVZ0ZXh0SWQoaWQpXG4gICAgICAgIH1dXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TGlzdEl0ZW1JY29uSWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pY29uX18ke3JlY29yZElkfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRMaXN0SXRlbVZ0ZXh0SWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X192dGV4dF9fJHtyZWNvcmRJZH1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zKG1lLnNpbGVudFNlbGVjdFVwZGF0ZSk7XG5cbiAgICAgICAgIW1lLnNpbGVudFNlbGVjdCAmJiBtZS5mb2N1cyhpdGVtc1swXSlcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKENvbG9yKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29sb3I7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGxpc3RzIHdoaWNoIHdpbGwgdXNlIGNvbXBvbmVudCBiYXNlZCBsaXN0IGl0ZW1zXG4gKiBAY2xhc3MgTmVvLmxpc3QuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8ubGlzdC5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxpc3QuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGlzdC5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LWxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LWxpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlW118bnVsbH0gaXRlbXM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIHZhbHVlICYmIHRoaXMuaXRlbXM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uZGVzdHJveSgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbXBvbmVudElkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHtpbmRleH1fX2NvbXBvbmVudGBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJdGVtSWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X18ke3RoaXMuc3RvcmUuaW5kZXhPZihyZWNvcmRJZCl9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2bm9kZUlkXG4gICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9IGl0ZW1JZFxuICAgICAqL1xuICAgIGdldEl0ZW1SZWNvcmRJZCh2bm9kZUlkKSB7XG4gICAgICAgIGxldCBpdGVtSWQgPSB2bm9kZUlkLnNwbGl0KCdfXycpWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRBdChwYXJzZUludChpdGVtSWQpKVt0aGlzLmdldEtleVByb3BlcnR5KCldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wcmV2aW91c0l0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIG9uU3RvcmVTb3J0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5zb3J0SXRlbXMoZGF0YSk7XG4gICAgICAgIHN1cGVyLm9uU3RvcmVTb3J0KGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wcmV2aW91c0l0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIHNvcnRJdGVtcyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuZXdJdGVtcyA9IFtdLFxuICAgICAgICAgICAgZnJvbUluZGV4LCBrZXksIHByZXZpb3VzS2V5cztcblxuICAgICAgICBpZiAobWUuaXRlbXMpIHtcbiAgICAgICAgICAgIGtleSAgICAgICAgICA9IG1lLmdldEtleVByb3BlcnR5KCk7XG4gICAgICAgICAgICBwcmV2aW91c0tleXMgPSBkYXRhLnByZXZpb3VzSXRlbXMubWFwKGUgPT4gZVtrZXldKTtcblxuICAgICAgICAgICAgZGF0YS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGZyb21JbmRleCA9IHByZXZpb3VzS2V5cy5pbmRleE9mKGl0ZW1ba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaChtZS5pdGVtc1tmcm9tSW5kZXhdKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zID0gbmV3SXRlbXNcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuIiwiaW1wb3J0IEJ1dHRvbiAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExhYmVsICAgICBmcm9tICcuLi9jb21wb25lbnQvTGFiZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udG9vbGJhci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBkb2NrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRvY2tQb3NpdGlvbnM9Wyd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnLCBudWxsXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9ja1Bvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2xiYXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2xiYXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZG9ja189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZG9ja186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1EZWZhdWx0cz17bnR5cGU6J2J1dHRvbid9XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOiAnaGJveCcsIGFsaWduOiAnY2VudGVyJywgcGFjayA6ICdzdGFydCd9XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlOiAnaGJveCcsXG4gICAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICBwYWNrIDogJ3N0YXJ0J1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc29ydGFibGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS50b29sYmFyLlNvcnRab25lfG51bGx9IHNvcnRab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzb3J0Wm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZUNvbmZpZzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXBwTmFtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFpvbmUuYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRvY2sgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgZG9ja1Bvc2l0aW9ucyA9IG1lLmdldFN0YXRpY0NvbmZpZygnZG9ja1Bvc2l0aW9ucycpO1xuXG4gICAgICAgIGRvY2tQb3NpdGlvbnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5ICE9PSBudWxsICYmIE5lb0FycmF5W2tleSA9PT0gdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tZG9jay0nICsga2V5KVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5jbHMgICAgPSBjbHM7XG4gICAgICAgIG1lLmxheW91dCA9IG1lLmdldExheW91dENvbmZpZygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLnNvcnRab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyBkb2NrIHBvc2l0aW9uIG1hdGNoZXMgYSB2YWx1ZSBvZiB0aGUgc3RhdGljIGRvY2tQb3NpdGlvbnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RvY2snLCAnZG9ja1Bvc2l0aW9ucycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSAnLT4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2luZGV4XSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4ICA6IDFcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF5b3V0IGNvbmZpZyBkZXBlbmRpbmcgb24gdGhpcy5kb2NrXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5b3V0Q29uZmlnXG4gICAgICovXG4gICAgZ2V0TGF5b3V0Q29uZmlnKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnO1xuXG4gICAgICAgIGlmIChtZS5kb2NrKSB7XG4gICAgICAgICAgICBzd2l0Y2gobWUuZG9jaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnR5cGU6ICdoYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG50eXBlICAgIDogJ3Zib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgOiAndmJveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheW91dENvbmZpZyB8fCBtZS5sYXlvdXRcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKEJhc2UpO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9