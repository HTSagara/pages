"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_field_Select_mjs"],{

/***/ "./src/form/field/Picker.mjs":
/*!***********************************!*\
  !*** ./src/form/field/Picker.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _trigger_Picker_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trigger/Picker.mjs */ "./src/form/field/trigger/Picker.mjs");
/* harmony import */ var _Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Text.mjs */ "./src/form/field/Text.mjs");





/**
 * The abstract picker field provides an arrow down trigger which opens a floating container to provide
 * more data selection options
 * @class Neo.form.field.Picker
 * @extends Neo.form.field.Text
 * @abstract
 */
class Picker extends _Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Picker'
         * @protected
         */
        className: 'Neo.form.field.Picker',
        /**
         * @member {String} ntype='pickerfield'
         * @protected
         */
        ntype: 'pickerfield',
        /**
         * @member {String[]} baseCls=['neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-pickerfield', 'neo-textfield'],
        /**
         * Stores the data from the getBoundingClientRect() call (picker & body DomRects)
         * @member {Array} clientRects=null
         * @protected
         */
        clientRects: null,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {
            Enter : 'onKeyDownEnter',
            Escape: 'onKeyDownEscape'
        },
        /**
         * @member {Neo.container.Base|null} picker=null
         * @protected
         */
        picker: null,
        /**
         * Configs to pass to the picker container
         * @member {Object|null} pickerConfig=null
         */
        pickerConfig: null,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerHeight=100
         */
        pickerHeight: 100,
        /**
         * @member {Boolean} pickerIsMounted_=false
         * @protected
         */
        pickerIsMounted_: false,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerMaxHeight=200
         */
        pickerMaxHeight: 200,
        /**
         * The width of the picker container. Defaults to px.
         * By default, the width of the picker matches the width of the input wrap element.
         * @member {Number|null} pickerWidth=null
         */
        pickerWidth: null,
        /**
         * @member {Boolean} showPickerOnFocus=false
         * @protected
         */
        showPickerOnFocus: false,
        /**
         * @member {Object|Object[]} triggers=[]
         * @protected
         */
        triggers: [{
            module: _trigger_Picker_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]
        }]
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            click: me.onInputClick,
            scope: me
        })
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (value === false && oldValue && this.pickerIsMounted) {
            this.picker.hide()
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        if (this.picker) {
            this.picker.theme = value
        }
    }

    /**
     * @returns {Neo.container.Base}
     */
    createPicker() {
        const
            me              = this,
            { pickerWidth } = me,
            pickerComponent = me.createPickerComponent();

        me.picker =  Neo.create(_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], {
            parentId : 'document.body',
            floating : true,
            align    : {
                edgeAlign : pickerWidth ? 't0-b0' : 't-b',
                matchSize : !pickerWidth,
                axisLock  : true,
                target    : me.getInputWrapperId()
            },
            appName  : me.appName,
            cls      : ['neo-picker-container', 'neo-container'],
            height   : me.pickerHeight,
            hidden   : true,
            id       : me.getPickerId(),
            items    : pickerComponent ? [pickerComponent] : [],
            maxHeight: me.pickerMaxHeight,
            theme    : me.theme,
            width    : pickerWidth,
            ...me.pickerConfig,

            // scoped to the field instance
            onFocusLeave: data => {
                let insideField = false,
                    item;

                for (item of data.oldPath) {
                    if (item.id === me.id) {
                        insideField = true;
                        break
                    }
                }

                if (!insideField) {
                    me.hidePicker();
                    super.onFocusLeave(data)
                }
            }
        });

        me.picker.on('hiddenChange', me.onPickerHiddenChange, me);

        return me.picker
    }

    /**
     * Override this method to create your picker content as needed
     * @returns {Neo.component.Base|null}
     */
    createPickerComponent() {
        return null
    }

    /**
     * @param args
     */
    destroy(...args) {
        let picker = this.picker;

        if (picker?.hidden === false) {
            picker.unmount()
        }

        picker?.destroy();
        super.destroy(...args)
    }

    /**
     * Returns the picker instance and creates it in case it does not exist yet
     * @returns {Neo.container.Base}
     */
    getPicker() {
        return this.picker || this.createPicker()
    }

    /**
     * @returns {String}
     */
    getPickerId() {
        return `${this.id}__picker`
    }

    /**
     *
     */
    async hidePicker() {
        if (this.picker) {
            this.picker.hidden = true
        }
    }

    /**
     * @param {Object} data
     * @protected
     */
    onFocusEnter(data) {
        super.onFocusEnter(data);

        let me = this;

        me.showPickerOnFocus && me.showPicker()
    }

    /**
     * @param {Object} data
     * @protected
     */
    onFocusLeave(data) {
        let me           = this,
            insidePicker = false,
            item;

        for (item of data.oldPath) {
            if (item.id === me.getPickerId()) {
                insidePicker = true;
                break
            }
        }

        if (!insidePicker) {
            me.hidePicker();
            super.onFocusLeave(data)
        }
    }

    /**
     * @param {Object} data
     */
    onInputClick(data) {
        !this.editable && this.togglePicker()
    }

    /**
     * @param {Object} data
     * @param {Function} [callback]
     * @param {Object} [callbackScope]
     * @protected
     */
    onKeyDownEnter(data, callback, callbackScope) {
        !this.pickerIsMounted && this.showPicker(callback, callbackScope)
    }

    /**
     * @param {Object} data
     * @protected
     */
    onKeyDownEscape(data) {
        if (this.pickerIsMounted) {
            this.hidePicker();

            // We processed this event, and it should not proceed to ancestor components
            data.cancelBubble = true;

            // And no further listeers should be notified
            return false;
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Boolean} data.oldValue
     * @param {Boolean} data.value
     * @protected
     */
    onPickerHiddenChange(data) {
        this.pickerIsMounted = !data.value
    }

    /**
     * Called by form.field.trigger.Picker
     * @protected
     */
    onPickerTriggerClick() {
        this.editable && this.togglePicker()
    }

    /**
     *
     */
    showPicker() {
        this.getPicker().hidden = false
    }

    /**
     *
     */
    togglePicker() {
        let picker = this.getPicker();
        picker.hidden = !picker.hidden
    }
}

Neo.setupClass(Picker);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Picker);


/***/ }),

/***/ "./src/form/field/Select.mjs":
/*!***********************************!*\
  !*** ./src/form/field/Select.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../list/Base.mjs */ "./src/list/Base.mjs");
/* harmony import */ var _Picker_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Picker.mjs */ "./src/form/field/Picker.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");








/**
 * Provides a dropdown list to select one or multiple items.
 *
 * Conforms to ARIA accessibility standards outlines in https://www.w3.org/WAI/ARIA/apg/patterns/combobox/
 * @class Neo.form.field.Select
 * @extends Neo.form.field.Picker
 */
class Select extends _Picker_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    /**
     * Valid values for triggerAction
     * @member {String[]} triggerActions=['all','filtered']
     * @protected
     * @static
     */
    static triggerActions = ['all', 'filtered']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Select'
         * @protected
         */
        className: 'Neo.form.field.Select',
        /**
         * @member {String} ntype='selectfield'
         * @protected
         */
        ntype: 'selectfield',
        /**
         * @member {String|Number|null} activeRecordId=null
         */
        activeRecordId: null,
        /**
         * @member {String[]} baseCls=['neo-selectfield','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-selectfield', 'neo-pickerfield', 'neo-textfield'],
        /**
         * @member {String} displayField='name'
         */
        displayField: 'name',
        /**
         * The millisecond time to delay between input field mutation and applying the input field's
         * new value to the filter
         * @member {Number} filterDelay=300
         */
        filterDelay : 300,
        /**
         * @member {String} filterOperator_='like'
         */
        filterOperator_: 'like',
        /**
         * True will only fire a change event, in case the TextField input value matches a record.
         * onFocusLeave() will try to select a hint record, if needed and possible.
         * @member {Boolean} forceSelection=true
         */
        forceSelection: true,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {
            Down  : 'onKeyDownDown',
            Escape: 'onKeyDownEscape'
        },
        /**
         * @member {String|null} lastManualInput=null
         * @protected
         */
        lastManualInput: null,
        /**
         * @member {Neo.list.Base} list=null
         * @protected
         */
        list: null,
        /**
         * @member {Object|null} listConfig_=null
         */
        listConfig_: null,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerHeight=null
         */
        pickerHeight: null,
        /**
         * @member {Object} record_=null
         * @protected
         */
        record_: null,
        /**
         * @member {String|null} role='combobox'
         */
        role: 'combobox',
        /**
         * @member {Neo.data.Store|null} store_=null
         */
        store_: null,
        /**
         * Showing the list via the down trigger can either show all list items or only show items which
         * match the filter string inside the input field.
         * Valid values: all, filtered
         * @member {String} triggerAction_='all'
         */
        triggerAction_: 'all',
        /**
         * Display the first matching result while typing
         * @member {Boolean} typeAhead_=true
         */
        typeAhead_: true,
        /**
         * Set this config to false, in case typing into the input field should not filter list items
         * @member {Boolean} useFilter_=true
         */
        useFilter_: true,
        /**
         * This config should point to the store keyProperty or a different model field,
         * which you want to submit instead
         * @member {Number|String} valueField='id'
         */
        valueField: 'id'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // Create buffered function to respond to input field mutation
        me.filterOnInput = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.buffer)(me.filterOnInput, me, me.filterDelay);

        me.typeAhead && me.updateTypeAhead()
    }

    /**
     * Triggered after the record config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        if (this._picker?.isVisible) {
            let selectionModel = this.list?.selectionModel;

            if (value) {
                oldValue && selectionModel?.deselect(oldValue);
                selectionModel?.select(value)
            } else {
                selectionModel.deselectAll()
            }
        }
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me = this,
            filters;

        if (value) {
            if (me.useFilter) {
                filters = value.filters || [];

                filters.push({
                    includeEmptyValues: true,
                    operator          : me.filterOperator,
                    property          : me.displayField,
                    value             : value.get(me.value)?.[me.displayField] || me.value
                });

                value.filters = filters
            }

            if (me.list) {
                me.list.store = value
            }

            value.on('load', me.onStoreLoad, me)
        }
    }

    /**
     * Triggered after the typeAhead config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetTypeAhead(value, oldValue) {
        this.rendered && this.updateTypeAhead()
    }

    /**
     * Triggered before the listConfig config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetListConfig(value, oldValue) {
        value && this.parseItemConfigs(value);
        return value
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store|null} value
     * @param {Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        const
            me                          = this,
            { valueField, displayField} = me;

        oldValue?.destroy();

        // Promote an array of items to be a Store
        if (Array.isArray(value)) {
            value = {
                data : value.map((v, i) => {
                    // Simplest case is just picking string values.
                    if (typeof v === 'string') {
                        v = {
                            [valueField]   : v,
                            [displayField] : v
                        };
                    }
                    return v;
                })
            };
        }

        // to reduce boilerplate code, a store config object without a defined model should default
        // to displayField & valueField defaults
        if (Neo.typeOf(value) === 'Object' && !value.model && !value.module && !value.ntype) {
            value.model = {
                fields: [
                    {name: valueField,   type: 'String'},
                    {name: displayField, type: 'String'}
                ]
            }
        }

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"])
    }

    /**
     * Triggered before the triggerAction config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTriggerAction(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'triggerAction')
    }

    /**
     * Triggered before the value config gets changed.
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @returns {Number|String|null}
     * @protected
     */
    beforeSetValue(value, oldValue) {
        let me           = this,
            displayField = me.displayField,
            store        = me.store,
            record;

        if (Neo.isObject(value)) {
            me.record = value;
            return value[displayField];
        } else {
            record = store.isFiltered() ? store.allItems.get(value) : store.get(value);

            if (record) {
                me.record = record;
                return record[displayField];
            }
        }

        me.record = store.find(displayField, value)[0] || null;

        return value
    }

    /**
     * @returns {Neo.list.Base}
     */
    createPickerComponent() {
        const me = this;

        me.list = Neo.create({
            module        : _list_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            appName       : me.appName,
            displayField  : me.displayField,
            itemRole      : 'option',
            itemsFocusable: false,
            navigator     : {eventSource: me.getInputElId()},
            parentId      : me.id,
            role          : 'listbox',
            selectionModel: {stayInList: false},
            store         : me.store,
            ...me.listConfig
        });

        me.getInputEl()['aria-controls'] = me.list.id;

        me.list.addDomListeners({
            neonavigate: {
                fn   : me.onListItemNavigate,
                scope: me
            }
        });

        me.list.selectionModel.on({
            noChange       : me.onListItemSelectionNoChange,
            selectionChange: me.onListItemSelectionChange,
            scope          : me
        });

        return me.list;
    }

    /**
     * All routes which expect to open the picker route through here. This updates the
     * filter and ensures that the picker is visible and reflecting the state of the filter.
     *
     * Input event processing passes the current input field value in as the filter value.
     *
     * Invocation of the expand trigger passes `null` so as to clear filtering.
     * @private
     * @param {String|null} value The value to filter the picker by
     */
    doFilter(value) {
        let me     = this,
            store  = me.store,
            filter = store.getFilter(me.displayField),
            {
                picker,
                record
            }      = me;

        if (filter) {
            filter.value = value
        }

        // Filter resulting in something to show
        if (store.getCount()) {
            me.getPicker().hidden = false;

            // List might not exist until the picker is created
            const
                { list }           = me,
                { selectionModel } = list;

            // On show, set the active item to be the current selected record or the first
            if (record) {
                // We do not want to hear back about our own selection
                selectionModel.suspendEvents = true;
                selectionModel.select(record);
                selectionModel.suspendEvents = false
            }
            setTimeout(() => {
                const index = store.indexOf(record);
                list._focusIndex = -1; // silent update to ensure afterSetFocusIndex() always gets called
                list.focusIndex  = index > -1 ? index : 0
            }, 100)
        }
        // Filtered down to nothing - hide picker if it has been created.
        else {
            picker?.hide()
        }
    }

    /**
     * @param {Object} data
     */
    filterOnInput(data) {
        if (data.value) {
            this.doFilter(data.value)
        } else {
            this.picker?.hide()
        }
    }

    /**
     * Overrides form.field.Base
     * @param {*} value
     * @param {*} oldValue
     * @override
     */
    fireChangeEvent(value, oldValue) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            record        = me.record,
            oldRecord, params;

        if (!(me.forceSelection && !record)) {
            oldRecord = me.store.get(oldValue) || null;

            params = {
                component: me,
                oldRecord,
                oldValue,
                record,
                value
            };

            me.fire('change', params);

            if (!me.suspendEvents) {
                _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(me).forEach(parent => {
                    if (FormContainer && parent instanceof FormContainer) {
                        parent.fire('fieldChange', params)
                    }
                })
            }
        }
    }

    /**
     * @returns {Object}
     */
    getInputHintEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].findVdomChild(this.vdom, this.getInputHintId())?.vdom
    }

    /**
     * @returns {String}
     */
    getInputHintId() {
        return this.id + '__input-hint'
    }

    /**
     * Returns the first selected record or null
     * @returns {Object}
     */
    getRecord() {
        let list      = this.list,
            recordKey = list.selectionModel.getSelection()[0];

        return recordKey && this.store.get(list.getItemRecordId(recordKey)) || null
    }

    /**
     * @returns {Number|String}
     */
    getValue() {
        let me = this;

        return me.record?.[me.valueField] || me.value
    }

    /**
     *
     */
    onConstructed() {
        const inputEl = this.getInputEl();

        inputEl['aria-activedescendant'] = '';
        inputEl['aria-expanded']         = false;
        inputEl['aria-haspopup']         = 'listbox';

        super.onConstructed(...arguments)
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        let me = this;

        console.log(me.forceSelection, me.record, me.activeRecordId);

        if (me.forceSelection && !me.record) {
            me.value = me.store.get(me.activeRecordId)
        }

        super.onFocusLeave(data)
    }

    /**
     * @param {Object} data
     * @protected
     */
    onInputValueChange(data) {
        // We do not call super here. The value of the Select is *not* connected to the value
        // typed into the input area. The input area is just a filter value to filter the list.
        this.lastManualInput = data.value
        this.filterOnInput(data);
    }

    /**
     * @param {Object} data
     * @protected
     */
    onKeyDownDown(data) {
        let me = this;

        if (!me.picker || me.picker?.hidden) {
            me.onPickerTriggerClick()
        }
    }

    // TODO:
    // When we are using a `Collection` as our `valueCollection`, and that `Collection` is the
    // `items` of the List's `selectionModel`, then this will be `onValueCollectionChange`,
    // a `mutate` listener on our own `valueCollection` which backs our `value` field which
    // will be implemented by a getter which accesses `valueCollection`.
    // This will become important for implementing multiSelect
    /**
     * @param {Object} selectionChangeEvent
     * @param {Object[]} selectionChangeEvent.selection
     * @protected
     */
    onListItemSelectionChange({ selection }) {
        if (selection?.length) {
            const
                me           = this,
                oldValue     = me.value,
                selected     = selection[0],
                record       = typeof selected === 'string' ? me.store.get(me.list.getItemRecordId(selected)) : selected,
                value        = record[me.displayField];

            me.hidePicker();
            me.hintRecordId = null;
            me.record       = record;
            me._value       = value;
            me.getInputHintEl().value = null;

            me.afterSetValue(value, oldValue, true); // prevent the list from getting filtered

            me.fire('select', {
                record,
                value
            })
        }
    }

    /**
     * Selection was attempted to be changed but resulted in no action.
     * For example clicking on already selected list item.
     */
    onListItemSelectionNoChange() {
        this.hidePicker();
    }

    /**
     * @param {Object} record
     * @protected
     */
    onListItemNavigate({ activeItem, activeIndex }) {
        if (activeIndex >= 0) {
            const
                me        = this,
                { store } = me;

            me.activeRecord   = store.getAt(activeIndex);
            me.activeRecordId = me.activeRecord[store.keyProperty || model.keyProperty];

            // Update typeahead hint (which updates DOM), or update DOM
            me.typeAhead ? me.updateTypeAheadValue(me.lastManualInput) : me.update();
        }
    }

    /**
     * @param {Object} data
     */
    onPickerHiddenChange({ value }) {
        const inputEl = this.getInputEl();

        super.onPickerHiddenChange(...arguments);
        if (value) {
            inputEl['aria-activedescendant'] = '';
        }
        inputEl['aria-expanded'] = !value;
        this.update();
    }

    /**
     *
     */
    onPickerTriggerClick() {
        let me = this;

        if (me.picker?.isVisible) {
            me.picker.hidden = true
        }
        else if (!me.readOnly && !me.disabled) {
            me.doFilter(null)
        }
    }

    /**
     * Selecting a record, if required
     * @param {Object[]} items
     */
    onStoreLoad(items) {
        let me    = this,
            value = me.value;

        if (value) {
            me._value = null; // silent update
            me.value  = value
        }
    }

    /**
     *
     */
    selectFirstListItem() {
        this.selectListItem(0)
    }

    /**
     *
     */
    selectLastListItem() {
        this.selectListItem(this.store.getCount() -1)
    }

    /**
     * If no index is passed, the index matching to the field input will get used (0 if none)
     * @param {Number} [index]
     */
    selectListItem(index) {
        let me = this;

        if (!Neo.isNumber(index)) {
            if (me.activeRecordId) {
                index = me.store.indexOfKey(me.activeRecordId);
            } else {
                index = 0;
            }
        }

        me.list.selectItem(index);
    }

    /**
     * @param {Boolean} [silent=false]
     * @protected
     */
    updateTypeAhead(silent=false) {
        let me      = this,
            inputEl = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].findVdomChild(me.vdom, {flag: 'neo-real-input'}),
            vdom    = me.vdom;

        if (me.typeAhead) {
            inputEl.parentNode.cn[inputEl.index] = {
                tag: 'span',
                cls: ['neo-input-field-wrapper'],
                cn : [{
                    tag         : 'input',
                    autocomplete: 'no', // while "off" is the correct value, browser vendors ignore it. Arbitrary strings do the trick.
                    autocorrect : 'off',
                    cls         : ['neo-textfield-input', 'neo-typeahead-input'],
                    disabled    : true,
                    id          : me.getInputHintId(),
                    spellcheck  : 'false'
                }, inputEl.vdom]
            }
        } else {
            _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].replaceVdomChild(vdom, inputEl.parentNode.id, inputEl.vdom)
        }

        !silent && me.update()
    }

    /**
     * @param {String|null} value=this.lastManualInput
     * @param {Boolean} silent=false
     * @protected
     */
    updateTypeAheadValue(value=this.lastManualInput, silent=false) {
        let me          = this,
            match       = false,
            {
                store,
                displayField
            }
                        = me,
            inputHintEl = me.getInputHintEl();

        if (!me.record && value?.length > 0) {
            const search = value.toLocaleLowerCase();
            match = store.items.find(r => r[displayField]?.toLowerCase?.()?.startsWith(search));

            if (match && inputHintEl) {
                inputHintEl.value = value + match[displayField].substr(value.length);
                me.activeRecord = match;
                me.activeRecordId = match[store.keyProperty || store.model.keyProperty]
            }
        }

        if (!match && inputHintEl) {
            inputHintEl.value = me.activeRecord = me.activeRecordId = null;
        }

        !silent && me.update()
    }
}

/**
 * The select event fires when a list item gets selected
 * @event select
 * @param {Object} record
 * @param {value} record[store.keyProperty]
 * @returns {Object}
 */

Neo.setupClass(Select);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Select);


/***/ }),

/***/ "./src/form/field/trigger/Picker.mjs":
/*!*******************************************!*\
  !*** ./src/form/field/trigger/Picker.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");


/**
 * Used by form.field.Picker
 * @class Neo.form.field.trigger.Picker
 * @extends Neo.form.field.trigger.Base
 */
class Picker extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Picker'
         * @protected
         */
        className: 'Neo.form.field.trigger.Picker',
        /**
         * @member {String} ntype='trigger-picker'
         * @protected
         */
        ntype: 'trigger-picker',
        /**
         * @member {String|null} iconCls='fa fa-caret-down'
         */
        iconCls: 'fa fa-caret-down',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='picker'
         * @protected
         */
        type: 'picker'
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        this.field.onPickerTriggerClick();
    } 
}

Neo.setupClass(Picker);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Picker);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1NlbGVjdF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDSjtBQUNBO0FBQ1Y7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFJO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBYTtBQUNqQyxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7O0FBRUEsaUVBQWUsTUFBTSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDMXRCUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvUGlja2VyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvU2VsZWN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvdHJpZ2dlci9QaWNrZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb250YWluZXIgICAgIGZyb20gJy4uLy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgUGlja2VyVHJpZ2dlciBmcm9tICcuL3RyaWdnZXIvUGlja2VyLm1qcyc7XG5pbXBvcnQgVGV4dCAgICAgICAgICBmcm9tICcuL1RleHQubWpzJztcblxuLyoqXG4gKiBUaGUgYWJzdHJhY3QgcGlja2VyIGZpZWxkIHByb3ZpZGVzIGFuIGFycm93IGRvd24gdHJpZ2dlciB3aGljaCBvcGVucyBhIGZsb2F0aW5nIGNvbnRhaW5lciB0byBwcm92aWRlXG4gKiBtb3JlIGRhdGEgc2VsZWN0aW9uIG9wdGlvbnNcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5QaWNrZXJcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLlRleHRcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBQaWNrZXIgZXh0ZW5kcyBUZXh0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLmZpZWxkLlBpY2tlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuUGlja2VyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BpY2tlcmZpZWxkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BpY2tlcmZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXBpY2tlcmZpZWxkJywnbmVvLXRleHRmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1waWNrZXJmaWVsZCcsICduZW8tdGV4dGZpZWxkJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGRhdGEgZnJvbSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgY2FsbCAocGlja2VyICYgYm9keSBEb21SZWN0cylcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGNsaWVudFJlY3RzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xpZW50UmVjdHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHVzZWQga2V5cyBmb3IgdGhlIHNlbGVjdGlvbiBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGtleXNcbiAgICAgICAgICovXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICAgIEVudGVyIDogJ29uS2V5RG93bkVudGVyJyxcbiAgICAgICAgICAgIEVzY2FwZTogJ29uS2V5RG93bkVzY2FwZSdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250YWluZXIuQmFzZXxudWxsfSBwaWNrZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwaWNrZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWdzIHRvIHBhc3MgdG8gdGhlIHBpY2tlciBjb250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHBpY2tlckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwaWNrZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBwaWNrZXIgY29udGFpbmVyLiBEZWZhdWx0cyB0byBweC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHBpY2tlckhlaWdodD0xMDBcbiAgICAgICAgICovXG4gICAgICAgIHBpY2tlckhlaWdodDogMTAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcGlja2VySXNNb3VudGVkXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwaWNrZXJJc01vdW50ZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHBpY2tlciBjb250YWluZXIuIERlZmF1bHRzIHRvIHB4LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gcGlja2VyTWF4SGVpZ2h0PTIwMFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VyTWF4SGVpZ2h0OiAyMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHBpY2tlciBjb250YWluZXIuIERlZmF1bHRzIHRvIHB4LlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgd2lkdGggb2YgdGhlIHBpY2tlciBtYXRjaGVzIHRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgd3JhcCBlbGVtZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gcGlja2VyV2lkdGg9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VyV2lkdGg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93UGlja2VyT25Gb2N1cz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaG93UGlja2VyT25Gb2N1czogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8T2JqZWN0W119IHRyaWdnZXJzPVtdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXJzOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBQaWNrZXJUcmlnZ2VyXG4gICAgICAgIH1dXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgY2xpY2s6IG1lLm9uSW5wdXRDbGljayxcbiAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgJiYgb2xkVmFsdWUgJiYgdGhpcy5waWNrZXJJc01vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLmhpZGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRoZW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5waWNrZXIudGhlbWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5jb250YWluZXIuQmFzZX1cbiAgICAgKi9cbiAgICBjcmVhdGVQaWNrZXIoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgeyBwaWNrZXJXaWR0aCB9ID0gbWUsXG4gICAgICAgICAgICBwaWNrZXJDb21wb25lbnQgPSBtZS5jcmVhdGVQaWNrZXJDb21wb25lbnQoKTtcblxuICAgICAgICBtZS5waWNrZXIgPSAgTmVvLmNyZWF0ZShDb250YWluZXIsIHtcbiAgICAgICAgICAgIHBhcmVudElkIDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAgICAgZmxvYXRpbmcgOiB0cnVlLFxuICAgICAgICAgICAgYWxpZ24gICAgOiB7XG4gICAgICAgICAgICAgICAgZWRnZUFsaWduIDogcGlja2VyV2lkdGggPyAndDAtYjAnIDogJ3QtYicsXG4gICAgICAgICAgICAgICAgbWF0Y2hTaXplIDogIXBpY2tlcldpZHRoLFxuICAgICAgICAgICAgICAgIGF4aXNMb2NrICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICAgIDogbWUuZ2V0SW5wdXRXcmFwcGVySWQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcE5hbWUgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGNscyAgICAgIDogWyduZW8tcGlja2VyLWNvbnRhaW5lcicsICduZW8tY29udGFpbmVyJ10sXG4gICAgICAgICAgICBoZWlnaHQgICA6IG1lLnBpY2tlckhlaWdodCxcbiAgICAgICAgICAgIGhpZGRlbiAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGlkICAgICAgIDogbWUuZ2V0UGlja2VySWQoKSxcbiAgICAgICAgICAgIGl0ZW1zICAgIDogcGlja2VyQ29tcG9uZW50ID8gW3BpY2tlckNvbXBvbmVudF0gOiBbXSxcbiAgICAgICAgICAgIG1heEhlaWdodDogbWUucGlja2VyTWF4SGVpZ2h0LFxuICAgICAgICAgICAgdGhlbWUgICAgOiBtZS50aGVtZSxcbiAgICAgICAgICAgIHdpZHRoICAgIDogcGlja2VyV2lkdGgsXG4gICAgICAgICAgICAuLi5tZS5waWNrZXJDb25maWcsXG5cbiAgICAgICAgICAgIC8vIHNjb3BlZCB0byB0aGUgZmllbGQgaW5zdGFuY2VcbiAgICAgICAgICAgIG9uRm9jdXNMZWF2ZTogZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGluc2lkZUZpZWxkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGl0ZW0gb2YgZGF0YS5vbGRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkID09PSBtZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlRmllbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlRmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaGlkZVBpY2tlcigpO1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5vbkZvY3VzTGVhdmUoZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnBpY2tlci5vbignaGlkZGVuQ2hhbmdlJywgbWUub25QaWNrZXJIaWRkZW5DaGFuZ2UsIG1lKTtcblxuICAgICAgICByZXR1cm4gbWUucGlja2VyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY3JlYXRlIHlvdXIgcGlja2VyIGNvbnRlbnQgYXMgbmVlZGVkXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGNyZWF0ZVBpY2tlckNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQgcGlja2VyID0gdGhpcy5waWNrZXI7XG5cbiAgICAgICAgaWYgKHBpY2tlcj8uaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcGlja2VyLnVubW91bnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgcGlja2VyPy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwaWNrZXIgaW5zdGFuY2UgYW5kIGNyZWF0ZXMgaXQgaW4gY2FzZSBpdCBkb2VzIG5vdCBleGlzdCB5ZXRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRhaW5lci5CYXNlfVxuICAgICAqL1xuICAgIGdldFBpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyIHx8IHRoaXMuY3JlYXRlUGlja2VyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFBpY2tlcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX3BpY2tlcmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGhpZGVQaWNrZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5waWNrZXIuaGlkZGVuID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0VudGVyKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0VudGVyKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2hvd1BpY2tlck9uRm9jdXMgJiYgbWUuc2hvd1BpY2tlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnNpZGVQaWNrZXIgPSBmYWxzZSxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgZm9yIChpdGVtIG9mIGRhdGEub2xkUGF0aCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT09IG1lLmdldFBpY2tlcklkKCkpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGVQaWNrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluc2lkZVBpY2tlcikge1xuICAgICAgICAgICAgbWUuaGlkZVBpY2tlcigpO1xuICAgICAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSW5wdXRDbGljayhkYXRhKSB7XG4gICAgICAgICF0aGlzLmVkaXRhYmxlICYmIHRoaXMudG9nZ2xlUGlja2VyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrU2NvcGVdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uS2V5RG93bkVudGVyKGRhdGEsIGNhbGxiYWNrLCBjYWxsYmFja1Njb3BlKSB7XG4gICAgICAgICF0aGlzLnBpY2tlcklzTW91bnRlZCAmJiB0aGlzLnNob3dQaWNrZXIoY2FsbGJhY2ssIGNhbGxiYWNrU2NvcGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25LZXlEb3duRXNjYXBlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2VySXNNb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVQaWNrZXIoKTtcblxuICAgICAgICAgICAgLy8gV2UgcHJvY2Vzc2VkIHRoaXMgZXZlbnQsIGFuZCBpdCBzaG91bGQgbm90IHByb2NlZWQgdG8gYW5jZXN0b3IgY29tcG9uZW50c1xuICAgICAgICAgICAgZGF0YS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBbmQgbm8gZnVydGhlciBsaXN0ZWVycyBzaG91bGQgYmUgbm90aWZpZWRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEub2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEudmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25QaWNrZXJIaWRkZW5DaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnBpY2tlcklzTW91bnRlZCA9ICFkYXRhLnZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGZvcm0uZmllbGQudHJpZ2dlci5QaWNrZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25QaWNrZXJUcmlnZ2VyQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuZWRpdGFibGUgJiYgdGhpcy50b2dnbGVQaWNrZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgc2hvd1BpY2tlcigpIHtcbiAgICAgICAgdGhpcy5nZXRQaWNrZXIoKS5oaWRkZW4gPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlUGlja2VyKCkge1xuICAgICAgICBsZXQgcGlja2VyID0gdGhpcy5nZXRQaWNrZXIoKTtcbiAgICAgICAgcGlja2VyLmhpZGRlbiA9ICFwaWNrZXIuaGlkZGVuXG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhQaWNrZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBQaWNrZXI7XG4iLCJpbXBvcnQgeyBidWZmZXIgfSAgICAgICBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi8uLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IExpc3QgICAgICAgICAgICAgZnJvbSAnLi4vLi4vbGlzdC9CYXNlLm1qcyc7XG5pbXBvcnQgUGlja2VyICAgICAgICAgICBmcm9tICcuL1BpY2tlci5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICAgZnJvbSAnLi4vLi4vZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBkcm9wZG93biBsaXN0IHRvIHNlbGVjdCBvbmUgb3IgbXVsdGlwbGUgaXRlbXMuXG4gKlxuICogQ29uZm9ybXMgdG8gQVJJQSBhY2Nlc3NpYmlsaXR5IHN0YW5kYXJkcyBvdXRsaW5lcyBpbiBodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2NvbWJvYm94L1xuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLlNlbGVjdFxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuUGlja2VyXG4gKi9cbmNsYXNzIFNlbGVjdCBleHRlbmRzIFBpY2tlciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciB0cmlnZ2VyQWN0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHRyaWdnZXJBY3Rpb25zPVsnYWxsJywnZmlsdGVyZWQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHRyaWdnZXJBY3Rpb25zID0gWydhbGwnLCAnZmlsdGVyZWQnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5TZWxlY3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLlNlbGVjdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3RmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3RmaWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8TnVtYmVyfG51bGx9IGFjdGl2ZVJlY29yZElkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZVJlY29yZElkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tc2VsZWN0ZmllbGQnLCduZW8tcGlja2VyZmllbGQnLCduZW8tdGV4dGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXNlbGVjdGZpZWxkJywgJ25lby1waWNrZXJmaWVsZCcsICduZW8tdGV4dGZpZWxkJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRpc3BsYXlGaWVsZD0nbmFtZSdcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BsYXlGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbGxpc2Vjb25kIHRpbWUgdG8gZGVsYXkgYmV0d2VlbiBpbnB1dCBmaWVsZCBtdXRhdGlvbiBhbmQgYXBwbHlpbmcgdGhlIGlucHV0IGZpZWxkJ3NcbiAgICAgICAgICogbmV3IHZhbHVlIHRvIHRoZSBmaWx0ZXJcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBmaWx0ZXJEZWxheT0zMDBcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlckRlbGF5IDogMzAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmaWx0ZXJPcGVyYXRvcl89J2xpa2UnXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJPcGVyYXRvcl86ICdsaWtlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgd2lsbCBvbmx5IGZpcmUgYSBjaGFuZ2UgZXZlbnQsIGluIGNhc2UgdGhlIFRleHRGaWVsZCBpbnB1dCB2YWx1ZSBtYXRjaGVzIGEgcmVjb3JkLlxuICAgICAgICAgKiBvbkZvY3VzTGVhdmUoKSB3aWxsIHRyeSB0byBzZWxlY3QgYSBoaW50IHJlY29yZCwgaWYgbmVlZGVkIGFuZCBwb3NzaWJsZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZm9yY2VTZWxlY3Rpb249dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9yY2VTZWxlY3Rpb246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHVzZWQga2V5cyBmb3IgdGhlIHNlbGVjdGlvbiBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGtleXNcbiAgICAgICAgICovXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICAgIERvd24gIDogJ29uS2V5RG93bkRvd24nLFxuICAgICAgICAgICAgRXNjYXBlOiAnb25LZXlEb3duRXNjYXBlJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGxhc3RNYW51YWxJbnB1dD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxhc3RNYW51YWxJbnB1dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5saXN0LkJhc2V9IGxpc3Q9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxpc3RDb25maWdfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb25maWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgcGlja2VyIGNvbnRhaW5lci4gRGVmYXVsdHMgdG8gcHguXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBwaWNrZXJIZWlnaHQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VySGVpZ2h0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZWNvcmRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVjb3JkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSByb2xlPSdjb21ib2JveCdcbiAgICAgICAgICovXG4gICAgICAgIHJvbGU6ICdjb21ib2JveCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBzdG9yZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvd2luZyB0aGUgbGlzdCB2aWEgdGhlIGRvd24gdHJpZ2dlciBjYW4gZWl0aGVyIHNob3cgYWxsIGxpc3QgaXRlbXMgb3Igb25seSBzaG93IGl0ZW1zIHdoaWNoXG4gICAgICAgICAqIG1hdGNoIHRoZSBmaWx0ZXIgc3RyaW5nIGluc2lkZSB0aGUgaW5wdXQgZmllbGQuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogYWxsLCBmaWx0ZXJlZFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRyaWdnZXJBY3Rpb25fPSdhbGwnXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyQWN0aW9uXzogJ2FsbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBmaXJzdCBtYXRjaGluZyByZXN1bHQgd2hpbGUgdHlwaW5nXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHR5cGVBaGVhZF89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZUFoZWFkXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGNvbmZpZyB0byBmYWxzZSwgaW4gY2FzZSB0eXBpbmcgaW50byB0aGUgaW5wdXQgZmllbGQgc2hvdWxkIG5vdCBmaWx0ZXIgbGlzdCBpdGVtc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VGaWx0ZXJfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHVzZUZpbHRlcl86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNvbmZpZyBzaG91bGQgcG9pbnQgdG8gdGhlIHN0b3JlIGtleVByb3BlcnR5IG9yIGEgZGlmZmVyZW50IG1vZGVsIGZpZWxkLFxuICAgICAgICAgKiB3aGljaCB5b3Ugd2FudCB0byBzdWJtaXQgaW5zdGVhZFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZUZpZWxkPSdpZCdcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlRmllbGQ6ICdpZCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIENyZWF0ZSBidWZmZXJlZCBmdW5jdGlvbiB0byByZXNwb25kIHRvIGlucHV0IGZpZWxkIG11dGF0aW9uXG4gICAgICAgIG1lLmZpbHRlck9uSW5wdXQgPSBidWZmZXIobWUuZmlsdGVyT25JbnB1dCwgbWUsIG1lLmZpbHRlckRlbGF5KTtcblxuICAgICAgICBtZS50eXBlQWhlYWQgJiYgbWUudXBkYXRlVHlwZUFoZWFkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlY29yZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWNvcmQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9waWNrZXI/LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbk1vZGVsID0gdGhpcy5saXN0Py5zZWxlY3Rpb25Nb2RlbDtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgJiYgc2VsZWN0aW9uTW9kZWw/LmRlc2VsZWN0KG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uc2VsZWN0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdEFsbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGZpbHRlcnM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWUudXNlRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IHZhbHVlLmZpbHRlcnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlRW1wdHlWYWx1ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yICAgICAgICAgIDogbWUuZmlsdGVyT3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ICAgICAgICAgIDogbWUuZGlzcGxheUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgICAgICA6IHZhbHVlLmdldChtZS52YWx1ZSk/LlttZS5kaXNwbGF5RmllbGRdIHx8IG1lLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZS5maWx0ZXJzID0gZmlsdGVyc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUubGlzdCkge1xuICAgICAgICAgICAgICAgIG1lLmxpc3Quc3RvcmUgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZS5vbignbG9hZCcsIG1lLm9uU3RvcmVMb2FkLCBtZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHlwZUFoZWFkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHlwZUFoZWFkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVkICYmIHRoaXMudXBkYXRlVHlwZUFoZWFkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBsaXN0Q29uZmlnIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TGlzdENvbmZpZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5wYXJzZUl0ZW1Db25maWdzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5kYXRhLlN0b3JlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7IHZhbHVlRmllbGQsIGRpc3BsYXlGaWVsZH0gPSBtZTtcblxuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIFByb21vdGUgYW4gYXJyYXkgb2YgaXRlbXMgdG8gYmUgYSBTdG9yZVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIGRhdGEgOiB2YWx1ZS5tYXAoKHYsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGxlc3QgY2FzZSBpcyBqdXN0IHBpY2tpbmcgc3RyaW5nIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVGaWVsZF0gICA6IHYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc3BsYXlGaWVsZF0gOiB2XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG8gcmVkdWNlIGJvaWxlcnBsYXRlIGNvZGUsIGEgc3RvcmUgY29uZmlnIG9iamVjdCB3aXRob3V0IGEgZGVmaW5lZCBtb2RlbCBzaG91bGQgZGVmYXVsdFxuICAgICAgICAvLyB0byBkaXNwbGF5RmllbGQgJiB2YWx1ZUZpZWxkIGRlZmF1bHRzXG4gICAgICAgIGlmIChOZW8udHlwZU9mKHZhbHVlKSA9PT0gJ09iamVjdCcgJiYgIXZhbHVlLm1vZGVsICYmICF2YWx1ZS5tb2R1bGUgJiYgIXZhbHVlLm50eXBlKSB7XG4gICAgICAgICAgICB2YWx1ZS5tb2RlbCA9IHtcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6IHZhbHVlRmllbGQsICAgdHlwZTogJ1N0cmluZyd9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTogZGlzcGxheUZpZWxkLCB0eXBlOiAnU3RyaW5nJ31cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBTdG9yZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB0cmlnZ2VyQWN0aW9uIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VHJpZ2dlckFjdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3RyaWdnZXJBY3Rpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcnxTdHJpbmd8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGlzcGxheUZpZWxkID0gbWUuZGlzcGxheUZpZWxkLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgID0gbWUuc3RvcmUsXG4gICAgICAgICAgICByZWNvcmQ7XG5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIG1lLnJlY29yZCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2Rpc3BsYXlGaWVsZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5pc0ZpbHRlcmVkKCkgPyBzdG9yZS5hbGxJdGVtcy5nZXQodmFsdWUpIDogc3RvcmUuZ2V0KHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIG1lLnJlY29yZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkW2Rpc3BsYXlGaWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5yZWNvcmQgPSBzdG9yZS5maW5kKGRpc3BsYXlGaWVsZCwgdmFsdWUpWzBdIHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5saXN0LkJhc2V9XG4gICAgICovXG4gICAgY3JlYXRlUGlja2VyQ29tcG9uZW50KCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubGlzdCA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IExpc3QsXG4gICAgICAgICAgICBhcHBOYW1lICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGRpc3BsYXlGaWVsZCAgOiBtZS5kaXNwbGF5RmllbGQsXG4gICAgICAgICAgICBpdGVtUm9sZSAgICAgIDogJ29wdGlvbicsXG4gICAgICAgICAgICBpdGVtc0ZvY3VzYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBuYXZpZ2F0b3IgICAgIDoge2V2ZW50U291cmNlOiBtZS5nZXRJbnB1dEVsSWQoKX0sXG4gICAgICAgICAgICBwYXJlbnRJZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICByb2xlICAgICAgICAgIDogJ2xpc3Rib3gnLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw6IHtzdGF5SW5MaXN0OiBmYWxzZX0sXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgIDogbWUuc3RvcmUsXG4gICAgICAgICAgICAuLi5tZS5saXN0Q29uZmlnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmdldElucHV0RWwoKVsnYXJpYS1jb250cm9scyddID0gbWUubGlzdC5pZDtcblxuICAgICAgICBtZS5saXN0LmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBuZW9uYXZpZ2F0ZToge1xuICAgICAgICAgICAgICAgIGZuICAgOiBtZS5vbkxpc3RJdGVtTmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmxpc3Quc2VsZWN0aW9uTW9kZWwub24oe1xuICAgICAgICAgICAgbm9DaGFuZ2UgICAgICAgOiBtZS5vbkxpc3RJdGVtU2VsZWN0aW9uTm9DaGFuZ2UsXG4gICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2U6IG1lLm9uTGlzdEl0ZW1TZWxlY3Rpb25DaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtZS5saXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCByb3V0ZXMgd2hpY2ggZXhwZWN0IHRvIG9wZW4gdGhlIHBpY2tlciByb3V0ZSB0aHJvdWdoIGhlcmUuIFRoaXMgdXBkYXRlcyB0aGVcbiAgICAgKiBmaWx0ZXIgYW5kIGVuc3VyZXMgdGhhdCB0aGUgcGlja2VyIGlzIHZpc2libGUgYW5kIHJlZmxlY3RpbmcgdGhlIHN0YXRlIG9mIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBJbnB1dCBldmVudCBwcm9jZXNzaW5nIHBhc3NlcyB0aGUgY3VycmVudCBpbnB1dCBmaWVsZCB2YWx1ZSBpbiBhcyB0aGUgZmlsdGVyIHZhbHVlLlxuICAgICAqXG4gICAgICogSW52b2NhdGlvbiBvZiB0aGUgZXhwYW5kIHRyaWdnZXIgcGFzc2VzIGBudWxsYCBzbyBhcyB0byBjbGVhciBmaWx0ZXJpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsdGVyIHRoZSBwaWNrZXIgYnlcbiAgICAgKi9cbiAgICBkb0ZpbHRlcih2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0b3JlICA9IG1lLnN0b3JlLFxuICAgICAgICAgICAgZmlsdGVyID0gc3RvcmUuZ2V0RmlsdGVyKG1lLmRpc3BsYXlGaWVsZCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGlja2VyLFxuICAgICAgICAgICAgICAgIHJlY29yZFxuICAgICAgICAgICAgfSAgICAgID0gbWU7XG5cbiAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgZmlsdGVyLnZhbHVlID0gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbHRlciByZXN1bHRpbmcgaW4gc29tZXRoaW5nIHRvIHNob3dcbiAgICAgICAgaWYgKHN0b3JlLmdldENvdW50KCkpIHtcbiAgICAgICAgICAgIG1lLmdldFBpY2tlcigpLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBMaXN0IG1pZ2h0IG5vdCBleGlzdCB1bnRpbCB0aGUgcGlja2VyIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgeyBsaXN0IH0gICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgeyBzZWxlY3Rpb25Nb2RlbCB9ID0gbGlzdDtcblxuICAgICAgICAgICAgLy8gT24gc2hvdywgc2V0IHRoZSBhY3RpdmUgaXRlbSB0byBiZSB0aGUgY3VycmVudCBzZWxlY3RlZCByZWNvcmQgb3IgdGhlIGZpcnN0XG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gaGVhciBiYWNrIGFib3V0IG91ciBvd24gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc3VzcGVuZEV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHJlY29yZCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc3VzcGVuZEV2ZW50cyA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0b3JlLmluZGV4T2YocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBsaXN0Ll9mb2N1c0luZGV4ID0gLTE7IC8vIHNpbGVudCB1cGRhdGUgdG8gZW5zdXJlIGFmdGVyU2V0Rm9jdXNJbmRleCgpIGFsd2F5cyBnZXRzIGNhbGxlZFxuICAgICAgICAgICAgICAgIGxpc3QuZm9jdXNJbmRleCAgPSBpbmRleCA+IC0xID8gaW5kZXggOiAwXG4gICAgICAgICAgICB9LCAxMDApXG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsdGVyZWQgZG93biB0byBub3RoaW5nIC0gaGlkZSBwaWNrZXIgaWYgaXQgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwaWNrZXI/LmhpZGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBmaWx0ZXJPbklucHV0KGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9GaWx0ZXIoZGF0YS52YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyPy5oaWRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBmb3JtLmZpZWxkLkJhc2VcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICByZWNvcmQgICAgICAgID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgb2xkUmVjb3JkLCBwYXJhbXM7XG5cbiAgICAgICAgaWYgKCEobWUuZm9yY2VTZWxlY3Rpb24gJiYgIXJlY29yZCkpIHtcbiAgICAgICAgICAgIG9sZFJlY29yZCA9IG1lLnN0b3JlLmdldChvbGRWYWx1ZSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbWUsXG4gICAgICAgICAgICAgICAgb2xkUmVjb3JkLFxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywgcGFyYW1zKTtcblxuICAgICAgICAgICAgaWYgKCFtZS5zdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5maXJlKCdmaWVsZENoYW5nZScsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldElucHV0SGludEVsKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZmluZFZkb21DaGlsZCh0aGlzLnZkb20sIHRoaXMuZ2V0SW5wdXRIaW50SWQoKSk/LnZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElucHV0SGludElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCArICdfX2lucHV0LWhpbnQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3Qgc2VsZWN0ZWQgcmVjb3JkIG9yIG51bGxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJlY29yZCgpIHtcbiAgICAgICAgbGV0IGxpc3QgICAgICA9IHRoaXMubGlzdCxcbiAgICAgICAgICAgIHJlY29yZEtleSA9IGxpc3Quc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9uKClbMF07XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZEtleSAmJiB0aGlzLnN0b3JlLmdldChsaXN0LmdldEl0ZW1SZWNvcmRJZChyZWNvcmRLZXkpKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLnJlY29yZD8uW21lLnZhbHVlRmllbGRdIHx8IG1lLnZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBjb25zdCBpbnB1dEVsID0gdGhpcy5nZXRJbnB1dEVsKCk7XG5cbiAgICAgICAgaW5wdXRFbFsnYXJpYS1hY3RpdmVkZXNjZW5kYW50J10gPSAnJztcbiAgICAgICAgaW5wdXRFbFsnYXJpYS1leHBhbmRlZCddICAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgaW5wdXRFbFsnYXJpYS1oYXNwb3B1cCddICAgICAgICAgPSAnbGlzdGJveCc7XG5cbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCguLi5hcmd1bWVudHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBjb25zb2xlLmxvZyhtZS5mb3JjZVNlbGVjdGlvbiwgbWUucmVjb3JkLCBtZS5hY3RpdmVSZWNvcmRJZCk7XG5cbiAgICAgICAgaWYgKG1lLmZvcmNlU2VsZWN0aW9uICYmICFtZS5yZWNvcmQpIHtcbiAgICAgICAgICAgIG1lLnZhbHVlID0gbWUuc3RvcmUuZ2V0KG1lLmFjdGl2ZVJlY29yZElkKVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25JbnB1dFZhbHVlQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IGNhbGwgc3VwZXIgaGVyZS4gVGhlIHZhbHVlIG9mIHRoZSBTZWxlY3QgaXMgKm5vdCogY29ubmVjdGVkIHRvIHRoZSB2YWx1ZVxuICAgICAgICAvLyB0eXBlZCBpbnRvIHRoZSBpbnB1dCBhcmVhLiBUaGUgaW5wdXQgYXJlYSBpcyBqdXN0IGEgZmlsdGVyIHZhbHVlIHRvIGZpbHRlciB0aGUgbGlzdC5cbiAgICAgICAgdGhpcy5sYXN0TWFudWFsSW5wdXQgPSBkYXRhLnZhbHVlXG4gICAgICAgIHRoaXMuZmlsdGVyT25JbnB1dChkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbktleURvd25Eb3duKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLnBpY2tlciB8fCBtZS5waWNrZXI/LmhpZGRlbikge1xuICAgICAgICAgICAgbWUub25QaWNrZXJUcmlnZ2VyQ2xpY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzpcbiAgICAvLyBXaGVuIHdlIGFyZSB1c2luZyBhIGBDb2xsZWN0aW9uYCBhcyBvdXIgYHZhbHVlQ29sbGVjdGlvbmAsIGFuZCB0aGF0IGBDb2xsZWN0aW9uYCBpcyB0aGVcbiAgICAvLyBgaXRlbXNgIG9mIHRoZSBMaXN0J3MgYHNlbGVjdGlvbk1vZGVsYCwgdGhlbiB0aGlzIHdpbGwgYmUgYG9uVmFsdWVDb2xsZWN0aW9uQ2hhbmdlYCxcbiAgICAvLyBhIGBtdXRhdGVgIGxpc3RlbmVyIG9uIG91ciBvd24gYHZhbHVlQ29sbGVjdGlvbmAgd2hpY2ggYmFja3Mgb3VyIGB2YWx1ZWAgZmllbGQgd2hpY2hcbiAgICAvLyB3aWxsIGJlIGltcGxlbWVudGVkIGJ5IGEgZ2V0dGVyIHdoaWNoIGFjY2Vzc2VzIGB2YWx1ZUNvbGxlY3Rpb25gLlxuICAgIC8vIFRoaXMgd2lsbCBiZWNvbWUgaW1wb3J0YW50IGZvciBpbXBsZW1lbnRpbmcgbXVsdGlTZWxlY3RcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uQ2hhbmdlRXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBzZWxlY3Rpb25DaGFuZ2VFdmVudC5zZWxlY3Rpb25cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25MaXN0SXRlbVNlbGVjdGlvbkNoYW5nZSh7IHNlbGVjdGlvbiB9KSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG9sZFZhbHVlICAgICA9IG1lLnZhbHVlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkICAgICA9IHNlbGVjdGlvblswXSxcbiAgICAgICAgICAgICAgICByZWNvcmQgICAgICAgPSB0eXBlb2Ygc2VsZWN0ZWQgPT09ICdzdHJpbmcnID8gbWUuc3RvcmUuZ2V0KG1lLmxpc3QuZ2V0SXRlbVJlY29yZElkKHNlbGVjdGVkKSkgOiBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgPSByZWNvcmRbbWUuZGlzcGxheUZpZWxkXTtcblxuICAgICAgICAgICAgbWUuaGlkZVBpY2tlcigpO1xuICAgICAgICAgICAgbWUuaGludFJlY29yZElkID0gbnVsbDtcbiAgICAgICAgICAgIG1lLnJlY29yZCAgICAgICA9IHJlY29yZDtcbiAgICAgICAgICAgIG1lLl92YWx1ZSAgICAgICA9IHZhbHVlO1xuICAgICAgICAgICAgbWUuZ2V0SW5wdXRIaW50RWwoKS52YWx1ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIG1lLmFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCB0cnVlKTsgLy8gcHJldmVudCB0aGUgbGlzdCBmcm9tIGdldHRpbmcgZmlsdGVyZWRcblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0Jywge1xuICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGlvbiB3YXMgYXR0ZW1wdGVkIHRvIGJlIGNoYW5nZWQgYnV0IHJlc3VsdGVkIGluIG5vIGFjdGlvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSBjbGlja2luZyBvbiBhbHJlYWR5IHNlbGVjdGVkIGxpc3QgaXRlbS5cbiAgICAgKi9cbiAgICBvbkxpc3RJdGVtU2VsZWN0aW9uTm9DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuaGlkZVBpY2tlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25MaXN0SXRlbU5hdmlnYXRlKHsgYWN0aXZlSXRlbSwgYWN0aXZlSW5kZXggfSkge1xuICAgICAgICBpZiAoYWN0aXZlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHsgc3RvcmUgfSA9IG1lO1xuXG4gICAgICAgICAgICBtZS5hY3RpdmVSZWNvcmQgICA9IHN0b3JlLmdldEF0KGFjdGl2ZUluZGV4KTtcbiAgICAgICAgICAgIG1lLmFjdGl2ZVJlY29yZElkID0gbWUuYWN0aXZlUmVjb3JkW3N0b3JlLmtleVByb3BlcnR5IHx8IG1vZGVsLmtleVByb3BlcnR5XTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHR5cGVhaGVhZCBoaW50ICh3aGljaCB1cGRhdGVzIERPTSksIG9yIHVwZGF0ZSBET01cbiAgICAgICAgICAgIG1lLnR5cGVBaGVhZCA/IG1lLnVwZGF0ZVR5cGVBaGVhZFZhbHVlKG1lLmxhc3RNYW51YWxJbnB1dCkgOiBtZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25QaWNrZXJIaWRkZW5DaGFuZ2UoeyB2YWx1ZSB9KSB7XG4gICAgICAgIGNvbnN0IGlucHV0RWwgPSB0aGlzLmdldElucHV0RWwoKTtcblxuICAgICAgICBzdXBlci5vblBpY2tlckhpZGRlbkNoYW5nZSguLi5hcmd1bWVudHMpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlucHV0RWxbJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCddID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRFbFsnYXJpYS1leHBhbmRlZCddID0gIXZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25QaWNrZXJUcmlnZ2VyQ2xpY2soKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnBpY2tlcj8uaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBtZS5waWNrZXIuaGlkZGVuID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFtZS5yZWFkT25seSAmJiAhbWUuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIG1lLmRvRmlsdGVyKG51bGwpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RpbmcgYSByZWNvcmQsIGlmIHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZChpdGVtcykge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmFsdWUgPSBtZS52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLl92YWx1ZSA9IG51bGw7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgICAgIG1lLnZhbHVlICA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdEZpcnN0TGlzdEl0ZW0oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0TGlzdEl0ZW0oMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdExhc3RMaXN0SXRlbSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RMaXN0SXRlbSh0aGlzLnN0b3JlLmdldENvdW50KCkgLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgbm8gaW5kZXggaXMgcGFzc2VkLCB0aGUgaW5kZXggbWF0Y2hpbmcgdG8gdGhlIGZpZWxkIGlucHV0IHdpbGwgZ2V0IHVzZWQgKDAgaWYgbm9uZSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XVxuICAgICAqL1xuICAgIHNlbGVjdExpc3RJdGVtKGluZGV4KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFOZW8uaXNOdW1iZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICBpZiAobWUuYWN0aXZlUmVjb3JkSWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1lLnN0b3JlLmluZGV4T2ZLZXkobWUuYWN0aXZlUmVjb3JkSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5saXN0LnNlbGVjdEl0ZW0oaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlVHlwZUFoZWFkKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnB1dEVsID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCB7ZmxhZzogJ25lby1yZWFsLWlucHV0J30pLFxuICAgICAgICAgICAgdmRvbSAgICA9IG1lLnZkb207XG5cbiAgICAgICAgaWYgKG1lLnR5cGVBaGVhZCkge1xuICAgICAgICAgICAgaW5wdXRFbC5wYXJlbnROb2RlLmNuW2lucHV0RWwuaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICAgICAgICAgIGNsczogWyduZW8taW5wdXQtZmllbGQtd3JhcHBlciddLFxuICAgICAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgICAgOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6ICdubycsIC8vIHdoaWxlIFwib2ZmXCIgaXMgdGhlIGNvcnJlY3QgdmFsdWUsIGJyb3dzZXIgdmVuZG9ycyBpZ25vcmUgaXQuIEFyYml0cmFyeSBzdHJpbmdzIGRvIHRoZSB0cmljay5cbiAgICAgICAgICAgICAgICAgICAgYXV0b2NvcnJlY3QgOiAnb2ZmJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgICAgOiBbJ25lby10ZXh0ZmllbGQtaW5wdXQnLCAnbmVvLXR5cGVhaGVhZC1pbnB1dCddLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICAgIDogbWUuZ2V0SW5wdXRIaW50SWQoKSxcbiAgICAgICAgICAgICAgICAgICAgc3BlbGxjaGVjayAgOiAnZmFsc2UnXG4gICAgICAgICAgICAgICAgfSwgaW5wdXRFbC52ZG9tXVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVkRvbVV0aWwucmVwbGFjZVZkb21DaGlsZCh2ZG9tLCBpbnB1dEVsLnBhcmVudE5vZGUuaWQsIGlucHV0RWwudmRvbSlcbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZT10aGlzLmxhc3RNYW51YWxJbnB1dFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVR5cGVBaGVhZFZhbHVlKHZhbHVlPXRoaXMubGFzdE1hbnVhbElucHV0LCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1hdGNoICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgZGlzcGxheUZpZWxkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAgaW5wdXRIaW50RWwgPSBtZS5nZXRJbnB1dEhpbnRFbCgpO1xuXG4gICAgICAgIGlmICghbWUucmVjb3JkICYmIHZhbHVlPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2ggPSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgbWF0Y2ggPSBzdG9yZS5pdGVtcy5maW5kKHIgPT4gcltkaXNwbGF5RmllbGRdPy50b0xvd2VyQ2FzZT8uKCk/LnN0YXJ0c1dpdGgoc2VhcmNoKSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBpbnB1dEhpbnRFbCkge1xuICAgICAgICAgICAgICAgIGlucHV0SGludEVsLnZhbHVlID0gdmFsdWUgKyBtYXRjaFtkaXNwbGF5RmllbGRdLnN1YnN0cih2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG1lLmFjdGl2ZVJlY29yZCA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIG1lLmFjdGl2ZVJlY29yZElkID0gbWF0Y2hbc3RvcmUua2V5UHJvcGVydHkgfHwgc3RvcmUubW9kZWwua2V5UHJvcGVydHldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoICYmIGlucHV0SGludEVsKSB7XG4gICAgICAgICAgICBpbnB1dEhpbnRFbC52YWx1ZSA9IG1lLmFjdGl2ZVJlY29yZCA9IG1lLmFjdGl2ZVJlY29yZElkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIHNlbGVjdCBldmVudCBmaXJlcyB3aGVuIGEgbGlzdCBpdGVtIGdldHMgc2VsZWN0ZWRcbiAqIEBldmVudCBzZWxlY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAqIEBwYXJhbSB7dmFsdWV9IHJlY29yZFtzdG9yZS5rZXlQcm9wZXJ0eV1cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuTmVvLnNldHVwQ2xhc3MoU2VsZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0O1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogVXNlZCBieSBmb3JtLmZpZWxkLlBpY2tlclxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuUGlja2VyXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkJhc2VcbiAqL1xuY2xhc3MgUGlja2VyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLlBpY2tlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQudHJpZ2dlci5QaWNrZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndHJpZ2dlci1waWNrZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndHJpZ2dlci1waWNrZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGljb25DbHM9J2ZhIGZhLWNhcmV0LWRvd24nXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY2FyZXQtZG93bicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHVzZWQgYnkgZmllbGQuZ2V0VHJpZ2dlcigpXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0ncGlja2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAncGlja2VyJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25UcmlnZ2VyQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmZpZWxkLm9uUGlja2VyVHJpZ2dlckNsaWNrKCk7XG4gICAgfSBcbn1cblxuTmVvLnNldHVwQ2xhc3MoUGlja2VyKTtcblxuZXhwb3J0IGRlZmF1bHQgUGlja2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9