"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_field_Text_mjs"],{

/***/ "./src/form/field/Text.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Text.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _trigger_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trigger/Base.mjs */ "./src/form/field/trigger/Base.mjs");
/* harmony import */ var _trigger_Clear_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trigger/Clear.mjs */ "./src/form/field/trigger/Clear.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/VNode.mjs */ "./src/util/VNode.mjs");








/**
 * @class Neo.form.field.Text
 * @extends Neo.form.field.Base
 */
class Text extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for autoCapitalize
     * @member {String[]} autoCapitalizeValues=['characters','none','on','off','sentences','words']
     * @protected
     * @static
     */
    static autoCapitalizeValues = ['characters', 'none', 'on', 'off', 'sentences', 'words']
    /**
     * Valid values for labelPosition
     * @member {String[]} labelPositions=['bottom','inline','left','right','top']
     * @protected
     * @static
     */
    static labelPositions = ['bottom', 'inline', 'left', 'right', 'top']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Text'
         * @protected
         */
        className: 'Neo.form.field.Text',
        /**
         * @member {String} ntype='textfield'
         * @protected
         */
        ntype: 'textfield',
        /**
         * An enumerated attribute that controls whether and how text input is automatically capitalized as it is
         * entered/edited by the user.
         * Valid values: 'characters', 'none', 'on', 'off', 'sentences', 'words'
         * @member {String} autoCapitalize=off'
         */
        autoCapitalize_: 'off',
        /**
         * @member {Boolean} autoComplete_=false
         */
        autoComplete_: false,
        /**
         * @member {String[]} baseCls=['neo-textfield']
         */
        baseCls: ['neo-textfield'],
        /**
         * Internal variable to store the actual width for the label centerBorderEl
         * (only needed for labelPosition: 'inline')
         * @member {Number|null} centerBorderElWidth=null
         * @protected
         */
        centerBorderElWidth: null,
        /**
         * True shows a clear trigger in case the field has a non-empty value.
         * @member {Boolean} clearable_=true
         */
        clearable_: true,
        /**
         * True will reset the field to its initial value config.
         * Recommended for fields with required: true
         * @member {Boolean} clearToOriginalValue_=false
         */
        clearToOriginalValue_: false,
        /**
         * Prevent users from typing specific characters.
         * E.g. disabling +-e for NumberFields
         * @member {String[]|null} disabledChars_=null
         */
        disabledChars_: null,
        /**
         * Setting `editable` to `false` means that the input field will be read-only
         * but the field is still workable and may have its value changed by user interaction.
         *
         * For example picker fields such as `Date` and `Select` may still have their
         * values changed by selecting from the picker using keyboard or pointer.
         * @member {Boolean} editable_=true
         */
        editable_: true,
        /**
         * Configure the value of empty fields. null or an empty string is recommended.
         * @member {String|null} emptyValue=null
         */
        emptyValue: null,
        /**
         * @member {String|null} error_=null
         */
        error_: null,
        /**
         * Useful for fields inside a css grid where errors should live outside the layout
         * @member {Boolean} errorPositionAbsolute_=false
         */
        errorPositionAbsolute_: false,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextInputPattern=data=>`Input pattern violation: ${data.inputPattern}`
         */
        errorTextInputPattern: data => `Input pattern violation: ${data.inputPattern}`,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextMaxLength=data=>`Max length violation: ${valueLength} / ${maxLength}`
         */
        errorTextMaxLength: data => `Max length violation: ${data.valueLength} / ${data.maxLength}`,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextMinLength=data=>`Min length violation: ${data.valueLength} / ${data.minLength}`
         */
        errorTextMinLength: data => `Min length violation: ${data.valueLength} / ${data.minLength}`,
        /**
         * @member {String} errorTextRequired='Required'
         */
        errorTextRequired: 'Required',
        /**
         * @member {Boolean} hideLabel_=false
         */
        hideLabel_: false,
        /**
         * @member {RegExp|null} inputPattern_=null
         */
        inputPattern_: null,
        /**
         * If false, the inputPattern will only get validated via JavaScript, but not getting applied on DOM level.
         * The regex support for input based patterns is not fully there yet, so feel free to disable this feature
         * if needed (E.g. form.field.Phone).
         * @member {Boolean} inputPatternDOM_=true
         */
        inputPatternDOM_: true,
        /**
         * @member {String} inputType_='text'
         */
        inputType_: 'text',
        /**
         * @member {String|null} inputValue_=null
         */
        inputValue_: null,
        /**
         * @member {String[]} labelBaseCls=['neo-textfield-label']
         */
        labelBaseCls: ['neo-textfield-label'],
        /**
         * @member {String[]} labelCls_=[]
         */
        labelCls_: [],
        /**
         * Edge-case config in case we want to render leading content with their own selectors like:
         * <span class="my-label-id-cls">E10</span> • Firstname
         * @member {String|null} labelId_=null
         */
        labelId_: null,
        /**
         * CSS rules for labelId
         * @member {String[]} labelIdCls_=[]
         */
        labelIdCls_: [],
        /**
         * Separator between labelId & labelText
         * @member {String} labelIdSeparator_=' · '
         */
        labelIdSeparator_: ' · ',
        /**
         * @member {String} labelOptionalText_=' (Optional)'
         */
        labelOptionalText_: ' (Optional)',
        /**
         * Valid values: 'bottom', 'inline', 'left', 'right', 'top'
         * @member {String} labelPosition_='left'
         */
        labelPosition_: 'left',
        /**
         * @member {String} labelText_='LabelText'
         */
        labelText_: 'LabelText',
        /**
         * defaults to px
         * @member {Number|String} labelWidth_=150
         */
        labelWidth_: 150,
        /**
         * The maximum amount of chars which you can enter into this field
         * @member {Number|null} maxLength_=null
         */
        maxLength_: null,
        /**
         * The minimum amount of chars which you can enter into this field
         * @member {Number|null} minLength_=null
         */
        minLength_: null,
        /**
         * @member {String|null} placeholderText_=null
         */
        placeholderText_: null,
        /**
         * Setting `readOnly` means that the field may not be changed by user interaction.
         *
         * The input field will be read-only and other ways of changing the field's value
         * (such as by operating pickers) will be disabled.
         * @member {Boolean} readOnly_=false
         */
        readOnly_: false,
        /**
         * @member {Boolean} required_=false
         */
        required_: false,
        /**
         * @member {Boolean} showOptionalText_=false
         */
        showOptionalText_: false,
        /**
         * null => Follow the element's default behavior for spell checking
         * @member {Boolean|null} spellCheck_=false
         */
        spellCheck_: false,
        /**
         * @member {String[]} subLabelBaseCls=['neo-textfield-sublabel']
         */
        subLabelBaseCls: ['neo-textfield-sublabel'],
        /**
         * @member {String[]} subLabelCls_=[]
         */
        subLabelCls_: [],
        /**
         * @member {String} subLabelText_=null
         */
        subLabelText_: null,
        /**
         * @member {Object|Object[]|null} triggers_=null
         */
        triggers_: null,
        /**
         * Using the alert state will display an empty but required field in orange instead of red.
         * Intended to get combined with form.Container: getFormState().
         * See apps/form as an example.
         * @member {Boolean} useAlertState_=false
         */
        useAlertState_: false,
        /**
         * A string based value will get resolved into the closest controller which implements it
         * @member {Function|String|null} validator=null
         */
        validator: null,
        /**
         * getVlue can be xssProtected and values are escaped
         * @member {Boolean} xssProtected=false
         */
        xssProtected_: false,
        /**
         * @member {Object} _vdom
         */
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'label', cls: [], style: {}},
            {tag: 'label', cls: []},
            {tag: 'input', cls: ['neo-textfield-input'], flag: 'neo-real-input', style: {}},
            {cls: ['neo-textfield-error-wrapper'], removeDom: true, cn: [
                {cls: ['neo-textfield-error']}
            ]}
        ]}
    }

    /**
     * Set this value to false, in case a field should display errors up front.
     * Otherwise, errors will stay hidden on mounting, unless you trigger validate(false).
     * @member {Boolean} clean=true
     */
    clean = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {input     : me.onInputValueChange, scope: me},
            {mouseenter: me.onMouseEnter,       scope: me},
            {mouseleave: me.onMouseLeave,       scope: me}
        ])
    }

    /**
     * Triggered after the appName config got changed
     * @param {String} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        value && this.triggers?.forEach(item => {
            item.appName = value
        })
    }

    /**
     * Triggered after the autoCapitalize config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetAutoCapitalize(value, oldValue) {
        this.changeInputElKey('autocapitalize', value === 'off' || value === 'none' ? null : value)
    }

    /**
     * Triggered after the autoComplete config got changed
     * Chrome ignores a value of "off", so we stick to a different value instead
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAutoComplete(value, oldValue) {
        // while "off" is the correct value, browser vendors ignore it. Arbitrary strings do the trick.
        this.changeInputElKey('autocomplete', value ? null : 'no')
    }

    /**
     * Triggered after the clearable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetClearable(value, oldValue) {
        let me = this,
            triggers;

        if (value) {
            triggers = me.triggers || [];
            triggers.unshift(_trigger_Clear_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]);
            me.triggers = triggers
        } else {
            me.removeTrigger('clear')
        }
    }

    /**
     * Triggered after the clearToOriginalValue config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetClearToOriginalValue(value, oldValue) {
        this.fire('changeClearToOriginalValue', {
            oldValue,
            value
        })
    }

    /**
     * Triggered after the disabledChars config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetDisabledChars(value, oldValue) {
        if (value) {
            let me = this;

            Neo.main.DomEvents.registerDisabledInputChars({
                appName: me.appName,
                chars  : value,
                id     : me.getInputEl().id
            })
        }
    }

    /**
     * Triggered after the editable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetEditable(value, oldValue) {
        const
            me      = this,
            { cls } = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-not-editable', !value);
        me.cls = cls;

        me.updateReadOnlyState()
    }

    /**
     * Triggered after the error config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetError(value, oldValue) {
        this.updateError(value)
    }

    /**
     * Triggered after the errorPositionAbsolute config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetErrorPositionAbsolute(value, oldValue) {
        let me  = this,
            cls = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(me.vdom, {cls: 'neo-textfield-error'}).vdom.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-absolute');

        me.update()
    }

    /**
     * Triggered after the hideLabel config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHideLabel(value, oldValue) {
        let me   = this,
            node = me.labelPosition === 'inline' ? me.getCenterBorderEl() : me.vdom.cn[0];

        node.removeDom = value;
        me.updateInputWidth()
    }

    /**
     * Triggered after the id config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me        = this,
            inputEl   = me.getInputEl(),
            inputElId = me.getInputElId(),
            labelEl   = me.getLabelEl();

        inputEl.id  = inputElId;
        labelEl.id  = me.getLabelId();
        labelEl.for = inputElId;

        // silent vdom update, the super call will trigger the engine
        super.afterSetId(value, oldValue)
    }

    /**
     * Triggered after the inputPattern config got changed
     * @param {RegExp|null} value
     * @param {RegExp|null} oldValue
     * @protected
     */
    afterSetInputPattern(value, oldValue) {
        if (this.inputPatternDOM) {
            if (value) {
                value = value.toString();
                value = value.substring(1, value.length - 1)
            }

            this.changeInputElKey('pattern', value)
        }
    }

    /**
     * Triggered after the inputType config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetInputType(value, oldValue) {
        this.changeInputElKey('type', value)
    }

    /**
     * Triggered after the inputValue config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetInputValue(value, oldValue) {
        let me  = this,
            cls = me.cls;

        me.getInputEl().value = me.containsFocus ? value : me.inputValueRenderer(value);

        me.useAlertState && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-empty-required', me.isEmpty() && me.required);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-has-content', me.hasContent());
        me.cls = cls;

        me.value = me.updateValueFromInputValue(value)
    }

    /**
     * Triggered after the labelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetLabelCls(value, oldValue) {
        let me  = this,
            cls = me.getLabelEl().cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, value);

        me.update()
    }

    /**
     * Triggered after the labelOptionalText config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelOptionalText(value, oldValue) {
        this.labelText = this.labelText // triggers a vdom update
    }

    /**
     * Triggered after the labelPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelPosition(value, oldValue) {
        let me   = this,
            cls  = me.cls,
            vdom = me.vdom,
            centerBorderElCls, isEmpty;

        vdom.cn[1].removeDom = value !== 'top' ? true : !Boolean(me.subLabelText);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'label-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'label-' + value);
        me.cls = cls; // todo: silent update if needed

        if (oldValue === 'inline') {
            vdom.cn[0] = me.getLabelEl(); // remove the wrapper

            vdom.cn[0].removeDom = me.hideLabel;
            vdom.cn[0].width     = me.labelWidth;
            me.updateInputWidth()
        } else if (value === 'inline') {
            centerBorderElCls = ['neo-center-border'];
            isEmpty           = me.isEmpty();
            vdom              = me.vdom;

            !isEmpty && centerBorderElCls.push('neo-float-above');

            delete vdom.cn[0].width;

            vdom.cn[0] = {
                cls: ['neo-label-wrapper'],
                cn : [{
                    cls: ['neo-left-border']
                }, {
                    cls      : centerBorderElCls,
                    cn       : [vdom.cn[0]],
                    removeDom: me.hideLabel
                }, {
                    cls: ['neo-right-border']
                }]
            };

            me.updateInputWidth();

            !isEmpty && setTimeout(() => {
                me.updateCenterBorderElWidth(false)
            }, 20)
        } else {
            // changes from e.g. left to top
            me.updateInputWidth()
        }
    }

    /**
     * Triggered after the labelText config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelText(value, oldValue) {
        let me      = this,
            isEmpty = me.isEmpty();

        if (me.labelId) {
            value = `<span class="${me.labelIdCls.join(',')}">${me.labelId}</span>${me.labelIdSeparator + value}`
        }

        me.getLabelEl().innerHTML = value;

        if (!me.hideLabel) {
            if (me.labelPosition === 'inline') {
                if (!isEmpty) {
                    delete me.getCenterBorderEl()?.width
                }

                me.promiseUpdate().then(() => {
                    me.updateCenterBorderElWidth(isEmpty)
                })
            } else {
                me.update()
            }
        }
    }

    /**
     * Triggered after the labelWidth config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetLabelWidth(value, oldValue) {
        if (this.labelPosition !== 'inline') {
            let me    = this,
                vdom  = me.vdom,
                label = vdom.cn[0];

            label.width = value;
            !me.hideLabel && me.updateInputWidth()
        }
    }

    /**
     * Triggered after the maxLength config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetMaxLength(value, oldValue) {
        this.validate(); // silent
        this.changeInputElKey('maxlength', value)
    }

    /**
     * Triggered after the minLength config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetMinLength(value, oldValue) {
        this.validate(); // silent
        this.changeInputElKey('minlength', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (oldValue !== undefined) {
            let triggers = me.triggers || [],
                i        = 0,
                len      = triggers.length;

            for (; i < len; i++) {
                if (!triggers[i].vdom.removeDom) {
                    triggers[i].mounted = value
                }
            }

            if (me.labelPosition === 'inline') {
                if (value) {
                    me.updateCenterBorderElWidth()
                } else {
                    delete me.getCenterBorderEl().width
                }
            }
        }
    }

    /**
     * Triggered after the placeholderText config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetPlaceholderText(value, oldValue) {
        let me  = this,
            cls = me.cls;

        me.changeInputElKey('placeholder', value === '' ? null : value);

        // a non-empty placeholder needs to keep the 'neo-has-content' rule
        // => labelPosition: 'inline' should keep the label at the top
        if (Neo.isEmpty(value) !== Neo.isEmpty(oldValue)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value !== null && value.toString().length > 0 ? 'add' : 'remove'](cls, 'neo-has-content');
            me.cls = cls
        }
    }

    /**
     * Triggered after the readOnly config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetReadOnly(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-readonly');
        me.cls = cls;

        me.updateReadOnlyState();

        me.triggers?.forEach(trigger => {
            trigger.hidden = value ? true : trigger.getHiddenState?.() || false
        })
    }

    /**
     * Triggered after the required config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRequired(value, oldValue) {
        let me = this;

        me.silentVdomUpdate = true;

        oldValue !== undefined && me.validate(me.clean);
        me.changeInputElKey('required', value ? value : null);
        me.labelText = me.labelText; // apply the optional text if needed

        me.silentVdomUpdate = false;

        me.update()
    }

    /**
     * Triggered after the showOptionalText config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowOptionalText(value, oldValue) {
        this.labelText = this.labelText // triggers a vdom update
    }

    /**
     * Triggered after the spellCheck config got changed
     * @param {Boolean|null} value
     * @param {Boolean|null} oldValue
     * @protected
     */
    afterSetSpellCheck(value, oldValue) {
        this.changeInputElKey('spellcheck', Neo.isBoolean(value) ? value : null)
    }

    /**
     * Triggered after the subLabelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetSubLabelCls(value, oldValue) {
        let me  = this,
            cls = me.vdom.cn[1].cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, value);

        me.update()
    }

    /**
     * Triggered after the subLabelText config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetSubLabelText(value, oldValue) {
        let me        = this,
            showLabel = me.labelPosition === 'top',
            subLabel  = me.vdom.cn[1];

        subLabel.html      = value;
        subLabel.removeDom = !showLabel;

        me.update()
    }

    /**
     * Triggered after the triggers config got changed
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetTriggers(value, oldValue) {
        let me           = this,
            vdom         = me.vdom,
            inputEl      = vdom.cn[2], // inputEl or inputWrapperEl
            preTriggers  = [],
            postTriggers = [],
            width;

        oldValue?.forEach(item => {
            if (!me.getTrigger(item.type)) {
                item.destroy()
            }
        });

        if (value.length > 0) {
            value.forEach(item => {
                if (item.align === 'start') {
                    preTriggers.push(item);
                } else {
                    postTriggers.push(item);
                }
            });

            postTriggers.sort((a, b) => b.weight - a.weight); // DESC
            preTriggers.sort((a, b) => a.weight - b.weight); // ASC

            postTriggers = postTriggers.map(a => a.vdom);
            preTriggers  = preTriggers.map(a => a.vdom);

            if (inputEl.tag === 'input') {
                // wrap the input tag
                vdom.cn[2] = {
                    cls  : ['neo-input-wrapper'],
                    cn   : [...preTriggers, inputEl, ...postTriggers],
                    id   : me.getInputWrapperId(),
                    width: inputEl.width
                };

                delete inputEl.width
            } else {
                inputEl.cn = [...preTriggers, me.getInputEl(), ...postTriggers]
            }
        } else {
            if (inputEl.tag !== 'input') {
                // replacing the input wrapper div with the input tag
                width            = inputEl.width;
                vdom.cn[2]       = me.getInputEl();
                vdom.cn[2].width = width;
            }
        }

        me.promiseUpdate().then(() => {
            me.updateTriggerVnodes()
        })
    }

    /**
     * Triggered after the value config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me            = this,
            originalValue = me.originalConfig.value,
            isDirty       = value !== originalValue && Neo.isEmpty(value) !== Neo.isEmpty(originalValue),
            cls;

        me.silentVdomUpdate = true;
        me.inputValue       = me.updateInputValueFromValue(value);

        me.validate(); // silent

        cls = me.cls;
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-is-dirty', isDirty);
        me.cls = cls;

        me.silentVdomUpdate = false;

        me.update();

        super.afterSetValue(value, oldValue) // fires the change event
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        super.afterSetWidth(value, oldValue);
        this.updateInputWidth()
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && this.triggers?.forEach(item => {
            item.windowId = value
        })
    }

    /**
     * Return a shallow copy of the triggers config
     * @param {Array|null} value
     * @protected
     */
    beforeGetTriggers(value) {
        if (Array.isArray(value)) {
            return [...value]
        }

        return value
    }

    /**
     * Triggered before the autoCapitalize config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetAutoCapitalize(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'autoCapitalize', 'autoCapitalizeValues')
    }

    /**
     * Triggered before the labelCls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(value || [], this.labelBaseCls)
    }

    /**
     * Triggered before the labelPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'labelPosition')
    }

    /**
     * Triggered before the labelText config gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelText(value, oldValue) {
        let me                = this,
            labelOptionalText = me.labelOptionalText,
            hasOptionalText   = value.endsWith(labelOptionalText);

        if (me.showOptionalText && !me.required) {
            if (!hasOptionalText) {
                value += labelOptionalText
            }
        } else if (value && hasOptionalText) {
            value = value.replace(labelOptionalText, '')
        }

        return value
    }

    /**
     * Triggered before the subLabelCls config gets changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetSubLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(value || [], this.subLabelBaseCls)
    }

    /**
     * Triggered before the triggers config gets changed
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]} the parsed triggers config
     * @protected
     * @returns {Object|Object[]}
     */
    beforeSetTriggers(value, oldValue) {
        if (!value) {
            value = [];
        } else if (!Array.isArray(value)) {
            value = [value]
        }

        let me = this;

        value.forEach((item, index) => {
            if (item.isClass) {
                value[index] = Neo.create(item, {
                    appName: me.appName,
                    id     : me.getTriggerId(item.prototype.type),
                    field  : me
                })
            } else if (!(item instanceof _trigger_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])) {
                if (!item.module && !item.ntype) {
                    item.ntype = 'trigger'
                }

                if (item.module) {
                    item.className = item.module.prototype.className;
                    item.id        = me.getTriggerId(item.module.prototype.type)
                }

                value[index] = Neo[item.className ? 'create' : 'ntype']({
                    ...item,
                    appName: me.appName,
                    field  : me
                })
            }
        });

        return value
    }

    /**
     * Triggered before the value config gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @returns {String|null}
     * @protected
     */
    beforeSetValue(value, oldValue) {
        if (value === null || value === '') {
            return this.emptyValue
        }

        return value
    }

    /**
     * Resets the field to its original value or null depending on the clearToOriginalValue config
     */
    clear() {
        let me = this;

        me.value = me.clearToOriginalValue ? me.originalConfig.value : null;
        me.fire('clear')
    }

    /**
     *
     * @param args
     */
    destroy(...args) {
        let me = this;

        if (me.disabledChars) {
            Neo.main.DomEvents.unregisterDisabledInputChars({
                appName: me.appName,
                id     : me.getInputEl().id
            })
        }

        super.destroy(...args)
    }

    /**
     * Calls focus() on the inputEl node instead
     * @param {String} id
     * @override
     */
    focus(id) {
        super.focus(this.getInputElId())
    }

    /**
     * @returns {Object|null}
     */
    getCenterBorderEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(this.vdom, {cls: 'neo-center-border'})?.vdom || null
    }

    /**
     * @returns {Object|null}
     */
    getInputEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(this.vdom, {flag: 'neo-real-input'})?.vdom || null
    }

    /**
     * @returns {String}
     */
    getInputElId() {
        return `${this.id}__input`
    }

    /**
     * Calculates the new inputWidth based on the labelWidth & total width
     * @returns {Number|null} null in case this.width is unknown
     */
    getInputWidth() {
        let me          = this,
            ignoreLabel = me.hideLabel || me.labelPosition === 'bottom' || me.labelPosition === 'inline' || me.labelPosition === 'top',
            labelWidth  = ignoreLabel ? 0 : me.labelWidth,
            width       = me.width;

        if (labelWidth && width) {
            return parseInt(width) - parseInt(labelWidth)
        } else if (width) {
            return width
        }

        return null
    }

    /**
     * @returns {String}
     */
    getInputWrapperId() {
        return `${this.id}__input-wrapper`
    }

    /**
     * @returns {Object|null}
     */
    getLabelEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(this.vdom, {tag: 'label'})?.vdom || null
    }

    /**
     * @returns {String}
     */
    getLabelId() {
        return `${this.id}__label`
    }

    /**
     * @param {String} type
     * @returns {Neo.form.field.trigger.Base|null}
     */
    getTrigger(type) {
        let me       = this,
            triggers = me.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].type === type) {
                return triggers[i]
            }
        }

        return null
    }

    /**
     * @param {String} id
     * @returns {Neo.form.field.trigger.Base|null}
     */
    getTriggerById(id) {
        let me       = this,
            triggers = me.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].id === id) {
                return triggers[i]
            }
        }

        return null
    }

    /**
     * @param {String} type
     * @protected
     * @returns {String} The trigger node id
     */
    getTriggerId(type) {
        return this.id + '-trigger-' + type
    }

    /**
     * @returns {*}
    */
    getValue() {
        if (this.xssProtected) {
            return _util_String_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].escapeHtml(super.getValue())
        } else {
            return super.getValue()
        }
    }

    /**
     * @returns {Boolean}
     */
    hasContent() {
        let value = this.inputValue;

        return this.placeholderText?.length > 0 || value !== null && value.toString().length > 0
    }

    /**
     * Finds a trigger by a given type config
     * @param {String} type
     * @returns {Boolean}
     */
    hasTrigger(type) {
        let triggers = this.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].type === type) {
                return true
            }
        }

        return false
    }

    /**
     * Transform an input node value before applied to this.value.
     * Override as needed
     * @param {*} value
     * @returns {*}
     */
    inputValueAdjustor(value) {
        return value
    }

    /**
     * Transform a value before getting rendered.
     * Override as needed
     * @param {*} value
     * @returns {*}
     */
    inputValueRenderer(value) {
        return value
    }

    /**
     * @returns {Boolean}
     */
    isEmpty() {
        return !(this.value?.toString().length > 0)
    }

    /**
     * @returns {Boolean}
     */
    isEmptyAndRequired() {
        return this.isEmpty() && this.required
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        this.validate(true); // silent

        return this.error ? false : super.isValid()
    }

    /**
     * @param args
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let me       = this,
            config   = super.mergeConfig(...args),
            triggers = config.triggers || me.triggers;

        me[triggers ? 'triggers' : '_triggers'] = triggers;

        delete config.triggers;
        return config
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.path
     * @protected
     */
    onFocusEnter(data) {
        super.onFocusEnter(data);

        let me  = this,
            cls = me.cls;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'neo-focus');
            me.cls = cls;

            if (me.labelPosition === 'inline') {
                if (me.centerBorderElWidth) {
                    me.getCenterBorderEl().width = me.centerBorderElWidth;
                    me.update()
                } else {
                    me.updateCenterBorderElWidth(false)
                }
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        let me             = this,
            centerBorderEl = me.getCenterBorderEl(), // labelPosition: 'inline'
            cls;

        if (!me.readOnly) {
            me.validate(false);

            cls = me.cls; // has to get set after validate()

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'neo-focus');
            me.cls = cls;

            if (centerBorderEl && me.isEmpty()) {
                delete centerBorderEl.width
            }
        }

        if (Neo.isString(me.value)) {
            me.value = me.value.trim()
        }

        me.update();

        super.onFocusLeave(data)
    }

    /**
     * Gets triggered by the 'input' DOM event.
     * @param {Object} data
     * @protected
     */
    onInputValueChange(data) {
        let me         = this,
            oldValue   = me.value,
            inputValue = data.value,
            vnode      = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].findChildVnode(me.vnode, {nodeName: 'input'});

        if (vnode) {
            // Update the current state (modified DOM by the user) to enable the delta-updates logic.
            // Required e.g. for validation -> revert a wrong user input
            vnode.vnode.attributes.value = inputValue
        }

        if (Neo.isString(inputValue)) {
            inputValue = inputValue.trim()
        }

        me.clean      = false;
        me.inputValue = me.inputValueAdjustor(inputValue); // updates this.value

        me.fireUserChangeEvent(me.value, oldValue)
    }

    /**
     * @param {Object} data
     */
    onMouseEnter(data) {
        let me  = this,
            cls = me.cls;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'neo-hovered');
            me.cls = cls
        }
    }

    /**
     * @param {Object} data
     */
    onMouseLeave(data) {
        let me  = this,
            cls = me.cls;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'neo-hovered');
            me.cls = cls
        }
    }

    /**
     * Removes all triggers of a given type
     * @param {String} type
     * @param {Boolean} [silent=false] true prevents a vdom update
     * @param {Array} [triggerSource] pass a shallow copy of this.triggers
     * @returns {Boolean} true in case a trigger was found & removed
     */
    removeTrigger(type, silent = false, triggerSource) {
        let me       = this,
            hasMatch = false,
            triggers = triggerSource || me.triggers || [],
            i        = 0,
            len      = triggers.length,
            trigger;

        for (; i < len; i++) {
            trigger = triggers[i];

            if (trigger.type === type) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(triggers, trigger);
                len--;
                hasMatch = true
            }
        }

        if (hasMatch && !silent) {
            me.triggers = triggers
        }

        return hasMatch
    }

    /**
     * Resets the field to its original value or null depending on the clearToOriginalValue config
     * You can optionally pass a new value, which will adjust the originalConfig.value if needed.
     * @param {String|null} [value=null]
     */
    reset(value = null) {
        let me = this;

        if (me.clearToOriginalValue) {
            if (value) {
                me.originalConfig.value = value
            } else {
                value = me.originalConfig.value
            }
        }

        super.reset(value);

        if (value === null && me.clean) {
            me.updateError(null)
        }
    }

    /**
     * Used for labelPosition: 'inline' to adjust the top border matching to the length of the label
     * @param {Boolean} [silent=false] true to get the value, but not apply it to the DOM
     * @protected
     */
    updateCenterBorderElWidth(silent = false) {
        let me = this;

        me.mounted && me.getDomRect(me.getCenterBorderEl().id).then(data => {
            me.centerBorderElWidth = Math.round(data.width * .7) + 8;

            if (!silent) {
                me.getCenterBorderEl().width = me.centerBorderElWidth;
                me.update()
            }
        })
    }

    /**
     @param {String|null} value
     @param {Boolean} silent=false
     */
    updateError(value, silent = false) {
        let me  = this,
            cls = me.cls,
            errorNode, errorWrapper;

        if (!(me.clean && !me.mounted)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-invalid');
            me.cls = cls;

            errorWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(me.vdom, {cls: 'neo-textfield-error-wrapper'}).vdom;
            errorNode    = errorWrapper.cn[0];

            if (value) {
                errorNode.html = value
            } else {
                delete errorNode.html
            }

            errorWrapper.removeDom = !value;

            !silent && me.update()
        }
    }

    /**
     * Override this method as needed inside class extensions.
     * @param {*} value
     * @returns {String}
     * @protected
     */
    updateInputValueFromValue(value) {
        return value
    }

    /**
     * Calculates the new inputWidth based on the labelWidth & total width
     * @protected
     */
    updateInputWidth() {
        let me         = this,
            inputWidth = me.getInputWidth();

        if (inputWidth !== null && inputWidth !== me.width) {
            me.vdom.cn[1].width = inputWidth
        } else {
            delete me.vdom.cn[1].width
        }

        me.update()
    }

    /**
     * The DOM based readonly attribute needs to honor the editable & readOnly configs
     */
    updateReadOnlyState() {
        let me = this;

        me.changeInputElKey('readonly', !me.editable || me.readOnly || null)
    }

    /**
     * Since triggers do not get rendered, assign the relevant props
     * todo: this could be handled by component.Base
     */
    updateTriggerVnodes() {
        let me          = this,
            triggerRoot = me.vnode?.childNodes[1],
            childNodes  = triggerRoot?.childNodes || [],
            trigger;

        childNodes.forEach(vnode => {
            trigger = me.getTriggerById(vnode.id);

            trigger && Object.assign(trigger, {
                vnode,
                _rendered: true,
                _mounted : true
            })
        })
    }

    /**
     * Override this method as needed inside class extensions.
     * @param {String} inputValue
     * @returns {*}
     * @protected
     */
    updateValueFromInputValue(inputValue) {
        return inputValue
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        let me           = this,
            maxLength    = me.maxLength,
            minLength    = me.minLength,
            required     = me.required,
            returnValue  = true,
            value        = me.value,
            valueLength  = value?.toString().length,
            inputPattern = me.inputPattern,
            isEmpty      = value !== 0 && (!value || valueLength < 1),
            errorParam   = {inputPattern, maxLength, minLength, valueLength},
            errorText;

        if (!silent) {
            // in case we manually call validate(false) on a form or field before it is mounted, we do want to see errors.
            me.clean = false
        }

        if (isEmpty) {
            if (required) {
                me._error   = me.errorTextRequired;
                returnValue = false
            }
        } else {
            if (Neo.isNumber(maxLength) && valueLength > maxLength) {
                me._error   = me.errorTextMaxLength(errorParam);
                returnValue = false
            } else if (Neo.isNumber(minLength) && valueLength < minLength) {
                me._error   = me.errorTextMinLength(errorParam);
                returnValue = false
            } else if (inputPattern && !inputPattern.test(value)) {
                me._error   = me.errorTextInputPattern(errorParam);
                returnValue = false
            } else if (Neo.isFunction(me.validator)) {
                errorText = me.validator(me);

                if (errorText !== true) {
                    me._error   = errorText;
                    returnValue = false
                }
            }
        }

        if (returnValue) {
            me._error = null
        }

        !me.clean && me.updateError(me._error, silent);

        return !returnValue ? false : super.validate(silent)
    }
}

Neo.setupClass(Text);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Text);


/***/ }),

/***/ "./src/form/field/trigger/Base.mjs":
/*!*****************************************!*\
  !*** ./src/form/field/trigger/Base.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * Base class for form field Triggers
 * @class Neo.form.field.trigger.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} alignValues=['end', 'start']
     * @protected
     * @static
     */
    static alignValues = ['end', 'start']

    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Base'
         * @protected
         */
        className: 'Neo.form.field.trigger.Base',
        /**
         * @member {String} ntype='trigger'
         * @protected
         */
        ntype: 'trigger',
        /**
         * @member {String} align_='end'
         */
        align: 'end',
        /**
         * @member {String[]} baseCls=['neo-field-trigger']
         */
        baseCls: ['neo-field-trigger'],
        /**
         * @member {Neo.form.field.Base|null} field=null
         */
        field_: null,
        /**
         * @member {String|null} iconCls_=null
         */
        iconCls_: null,
        /**
         * @member {Boolean} isHovered=false
         * @protected
         */
        isHovered: false,
        /**
         * The scope of the trigger handler
         * @member {Neo.core.Base|null} scope=null
         */
        scope: null,
        /**
         * @member {Boolean} showOnHover=false
         */
        showOnHover: false,
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='base'
         * @protected
         */
        type: 'base',
        /**
         * @member {Number} weight_=10
         */
        weight_: 10
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners(
            {click: me.onTriggerClick, scope: me}
        );

        if (me.showOnHover) {
            me.hidden = true;

            me.field.on('constructed', () => {
                me.field.addDomListeners([
                    {mouseenter: me.onMouseEnter, scope: me},
                    {mouseleave: me.onMouseLeave, scope: me}
                ]);
            }, me);
        }
    }

    /**
     * Triggered after the align config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetAlign(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value === 'start' ? 'add' : 'remove'](cls, 'neo-align-start');
        this.cls = cls;
    }

    afterSetField(field) {
        (this.vdom.data || (this.vdom.data = {})).focus = field && field.getInputElId();
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let style = this.style;

        style.display = value ? 'none' : 'inherit';
        this.style = style;
    }

    /**
     * Triggered after the iconCls config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetIconCls(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, oldValue);

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, value);
        }

        this.cls = cls;
    }

    /**
     * Triggered before the align config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'align', 'alignValues');
    }

    /**
     * @param {Boolean} updateParentVdom
     * @param {Boolean} silent
     */
    destroy(updateParentVdom, silent) {
        let me = this;

        me.removeDomListeners(
            {click: me.onTriggerClick, scope: me}
        );

        delete me.field;

        super.destroy(updateParentVdom, silent);
    }

    /**
     *
     */
    onMouseEnter() {
        this.isHovered = true;
        this.hidden    = false;
    }

    /**
     *
     */
    onMouseLeave() {
        this.isHovered = false;
        this.hidden    = true;
    }

    /**
     * click domEvent listener
     * @param {Object} data
     * @protected
     */
    onTriggerClick(data) {
        let me    = this,
            scope = me.scope || me;

        if (me.handler) {
            scope[me.handler].call(scope);
        }
    }
}

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/form/field/trigger/Clear.mjs":
/*!******************************************!*\
  !*** ./src/form/field/trigger/Clear.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * Clear Trigger to remove the input value of TextFields or subclasses
 * @class Neo.form.field.trigger.Clear
 * @extends Neo.form.field.trigger.Base
 */
class Clear extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Clear'
         * @protected
         */
        className: 'Neo.form.field.trigger.Clear',
        /**
         * @member {String} ntype='trigger-clear'
         * @protected
         */
        ntype: 'trigger-clear',
        /**
         * @member {String[]} baseCls=['neo-field-trigger','neo-trigger-clear']
         */
        baseCls: ['neo-field-trigger', 'neo-trigger-clear'],
        /**
         * @member {String|null} iconCls='fa fa-times'
         */
        iconCls: 'fa fa-times',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='clear'
         * @protected
         */
        type: 'clear',
        /**
         * @member {Number} weight_=20
         */
        weight: 20
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value ? 'add' : 'remove'](cls, 'neo-is-hidden');
        this.cls = cls;
    }

    /**
     * Triggered before the hidden config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    beforeSetHidden(value, oldValue) {
        if (this.showOnHover && !this.isHovered) {
            return true;
        }

        return value;
    }

    /**
     *
     */
    destroy(...args) {
        let me = this;

        me.field.un({
            change                    : me.onFieldChange,
            changeClearToOriginalValue: me.onFieldChange,
            scope                     : me
        });

        super.destroy(...args);
    }

    /**
     * @returns {Boolean} true in case the trigger should be hidden
     */
    getHiddenState() {
        let me    = this,
            field = me.field,
            value = field.value;

        if (field.clearToOriginalValue) {
            return value === field.originalConfig.value;
        } else {
            if (value === 0) {
                value = '0';
            }

            return !field.value || value.toString().length < 1;
        }
    }

    /**
     * @param {Object} opts
     */
    onFieldChange(opts) {
        this.hidden = this.getHiddenState();
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.field.on({
            change                    : me.onFieldChange,
            changeClearToOriginalValue: me.onFieldChange,
            scope                     : me
        });

        me.hidden = me.getHiddenState();
    }

    /**
     * @override
     */
    onMouseEnter() {
        let me = this;

        me.isHovered = true;
        me.hidden    = me.getHiddenState();
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        this.field.clear();
    }
}

Neo.setupClass(Clear);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Clear);


/***/ }),

/***/ "./src/util/String.mjs":
/*!*****************************!*\
  !*** ./src/util/String.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.String
 * @extends Neo.core.Base
 */
class StringUtil extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} charEntityMap
     * @static
     */
    static charEntityMap = {
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        '\'': '&apos;',
        '$' : '&dollar;',
        '\\': '&bsol;',
        '/' : '&sol;'
    }
    /**
     * @member {RegExp} charPattern
     * @static
     */
    static charPattern = /[&<>"'$\\]/g
    /**
     * @member {RegExp} entityPattern
     * @static
     */
    static entityPattern = /(&amp;)|(&lt;)|(&gt;)|(&quot;)|(&apos;)|(&dollar;)|(&bsol;)|(&sol;)/g

    static config = {
        /**
         * @member {String} className='Neo.util.String'
         * @protected
         */
        className: 'Neo.util.String'
    }

    /**
     * Escape HTML special characters
     * @param {String} value
     */
    static escapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (Neo.typeOf(value) !== 'String') {
            return value;
        }

        return value.replace(me.charPattern, me.getEntityFromChar.bind(me));
    }

    /**
     * Get char equivalent of a mapped entity
     * @param {String} entity
     */
    static getCharFromEntity(entity) {
        const mappedChar = Object.keys(this.charEntityMap).find(key => this.charEntityMap[key] === entity);
        return mappedChar || entity;
    }

    /**
     * Get entity equivalent of a mapped char
     * @param {String} char
     */
    static getEntityFromChar(char) {
        return this.charEntityMap[char] || char;
    }

    /**
     * Unescape HTML special characters
     * @param {String} value
     */
    static unescapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (Neo.typeOf(value) !== 'String') {
            return value;
        }

        return value.replace(me.entityPattern, me.getCharFromEntity.bind(me));
    }

    /**
     * Returns the passed string with the first letter uncapitalized.
     * @param {String} value
     * @returns  {String}
     */
    static uncapitalize(value) {
        return value && value[0].toLowerCase() + value.substring(1)
    }
}

Neo.setupClass(StringUtil);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringUtil);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ1E7QUFDQztBQUNDO0FBQ0M7QUFDRjtBQUNDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBSTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVLHdEQUF3RCxrQkFBa0I7QUFDeEc7QUFDQSxtRUFBbUUsa0JBQWtCO0FBQ3JGO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVSxrREFBa0QsYUFBYSxJQUFJLFVBQVU7QUFDM0c7QUFDQSw2REFBNkQsa0JBQWtCLElBQUksZUFBZTtBQUNsRztBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsa0RBQWtELGtCQUFrQixJQUFJLGVBQWU7QUFDckg7QUFDQSw2REFBNkQsa0JBQWtCLElBQUksZUFBZTtBQUNsRztBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLDhFQUE4RTtBQUMzRixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFELGFBQWEsNkNBQTZDO0FBQzFELGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVk7QUFDekM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTs7QUFFcEIsUUFBUSx1REFBUTtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVEseUJBQXlCLDJCQUEyQjs7QUFFOUUsUUFBUSx1REFBUTs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsdURBQVE7O0FBRXBDLFFBQVEsdURBQVE7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTtBQUNoQixzQkFBc0I7O0FBRXRCO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHdCQUF3QixJQUFJLFdBQVcsU0FBUyw0QkFBNEI7QUFDaEg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQixRQUFRLHVEQUFROztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYiw4REFBOEQ7QUFDOUQsNkRBQTZEOztBQUU3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBLFFBQVEsdURBQVE7QUFDaEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjLDJCQUEyQix5REFBVztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZUFBZSxzREFBUSwyQkFBMkIseUJBQXlCO0FBQzNFOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlLHNEQUFRLDJCQUEyQix1QkFBdUI7QUFDekU7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlLHNEQUFRLDJCQUEyQixhQUFhO0FBQy9EOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQVU7QUFDN0IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksdURBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQixZQUFZLHVEQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFTLDJCQUEyQixrQkFBa0I7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx1REFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHVEQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQSxnQkFBZ0IsdURBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksdURBQVE7QUFDcEI7O0FBRUEsMkJBQTJCLHNEQUFRLHlCQUF5QixtQ0FBbUM7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxJQUFJLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL2xEZ0M7QUFDSjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBUztBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix1Q0FBdUM7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQjtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVEQUFROztBQUVoQjtBQUNBLFlBQVksdURBQVE7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxJQUFJLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDek1jO0FBQ2E7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsdURBQVE7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLEtBQUssRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pKZTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUk7QUFDN0I7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTyxPQUFPLFNBQVMsU0FBUyxXQUFXLFNBQVMsUUFBUTs7QUFFOUY7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9UZXh0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvdHJpZ2dlci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvdHJpZ2dlci9DbGVhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1N0cmluZy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBCYXNlVHJpZ2dlciAgZnJvbSAnLi90cmlnZ2VyL0Jhc2UubWpzJztcbmltcG9ydCBDbGVhclRyaWdnZXIgZnJvbSAnLi90cmlnZ2VyL0NsZWFyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBTdHJpbmdVdGlsICAgZnJvbSAnLi4vLi4vdXRpbC9TdHJpbmcubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5pbXBvcnQgVk5vZGVVdGlsICAgIGZyb20gJy4uLy4uL3V0aWwvVk5vZGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuVGV4dFxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuQmFzZVxuICovXG5jbGFzcyBUZXh0IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBhdXRvQ2FwaXRhbGl6ZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhdXRvQ2FwaXRhbGl6ZVZhbHVlcz1bJ2NoYXJhY3RlcnMnLCdub25lJywnb24nLCdvZmYnLCdzZW50ZW5jZXMnLCd3b3JkcyddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXV0b0NhcGl0YWxpemVWYWx1ZXMgPSBbJ2NoYXJhY3RlcnMnLCAnbm9uZScsICdvbicsICdvZmYnLCAnc2VudGVuY2VzJywgJ3dvcmRzJ11cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGxhYmVsUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxQb3NpdGlvbnM9Wydib3R0b20nLCdpbmxpbmUnLCdsZWZ0JywncmlnaHQnLCd0b3AnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGxhYmVsUG9zaXRpb25zID0gWydib3R0b20nLCAnaW5saW5lJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuVGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0ZXh0ZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGV4dGZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVudW1lcmF0ZWQgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgd2hldGhlciBhbmQgaG93IHRleHQgaW5wdXQgaXMgYXV0b21hdGljYWxseSBjYXBpdGFsaXplZCBhcyBpdCBpc1xuICAgICAgICAgKiBlbnRlcmVkL2VkaXRlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnY2hhcmFjdGVycycsICdub25lJywgJ29uJywgJ29mZicsICdzZW50ZW5jZXMnLCAnd29yZHMnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYXV0b0NhcGl0YWxpemU9b2ZmJ1xuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0NhcGl0YWxpemVfOiAnb2ZmJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Db21wbGV0ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Db21wbGV0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdGV4dGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgdmFyaWFibGUgdG8gc3RvcmUgdGhlIGFjdHVhbCB3aWR0aCBmb3IgdGhlIGxhYmVsIGNlbnRlckJvcmRlckVsXG4gICAgICAgICAqIChvbmx5IG5lZWRlZCBmb3IgbGFiZWxQb3NpdGlvbjogJ2lubGluZScpXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBjZW50ZXJCb3JkZXJFbFdpZHRoPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2VudGVyQm9yZGVyRWxXaWR0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgc2hvd3MgYSBjbGVhciB0cmlnZ2VyIGluIGNhc2UgdGhlIGZpZWxkIGhhcyBhIG5vbi1lbXB0eSB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2xlYXJhYmxlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcmFibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aWxsIHJlc2V0IHRoZSBmaWVsZCB0byBpdHMgaW5pdGlhbCB2YWx1ZSBjb25maWcuXG4gICAgICAgICAqIFJlY29tbWVuZGVkIGZvciBmaWVsZHMgd2l0aCByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjbGVhclRvT3JpZ2luYWxWYWx1ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyVG9PcmlnaW5hbFZhbHVlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2ZW50IHVzZXJzIGZyb20gdHlwaW5nIHNwZWNpZmljIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEUuZy4gZGlzYWJsaW5nICstZSBmb3IgTnVtYmVyRmllbGRzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGRpc2FibGVkQ2hhcnNfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkQ2hhcnNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dGluZyBgZWRpdGFibGVgIHRvIGBmYWxzZWAgbWVhbnMgdGhhdCB0aGUgaW5wdXQgZmllbGQgd2lsbCBiZSByZWFkLW9ubHlcbiAgICAgICAgICogYnV0IHRoZSBmaWVsZCBpcyBzdGlsbCB3b3JrYWJsZSBhbmQgbWF5IGhhdmUgaXRzIHZhbHVlIGNoYW5nZWQgYnkgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGV4YW1wbGUgcGlja2VyIGZpZWxkcyBzdWNoIGFzIGBEYXRlYCBhbmQgYFNlbGVjdGAgbWF5IHN0aWxsIGhhdmUgdGhlaXJcbiAgICAgICAgICogdmFsdWVzIGNoYW5nZWQgYnkgc2VsZWN0aW5nIGZyb20gdGhlIHBpY2tlciB1c2luZyBrZXlib2FyZCBvciBwb2ludGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlZGl0YWJsZV89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdGFibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlIHRoZSB2YWx1ZSBvZiBlbXB0eSBmaWVsZHMuIG51bGwgb3IgYW4gZW1wdHkgc3RyaW5nIGlzIHJlY29tbWVuZGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZW1wdHlWYWx1ZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlbXB0eVZhbHVlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGVycm9yXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGZpZWxkcyBpbnNpZGUgYSBjc3MgZ3JpZCB3aGVyZSBlcnJvcnMgc2hvdWxkIGxpdmUgb3V0c2lkZSB0aGUgbGF5b3V0XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVycm9yUG9zaXRpb25BYnNvbHV0ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGVycm9yUG9zaXRpb25BYnNvbHV0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwYXNzZXMgaW5wdXRQYXR0ZXJuLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCAmIHZhbHVlTGVuZ3RoIHByb3BlcnRpZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGVycm9yVGV4dElucHV0UGF0dGVybj1kYXRhPT5gSW5wdXQgcGF0dGVybiB2aW9sYXRpb246ICR7ZGF0YS5pbnB1dFBhdHRlcm59YFxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0SW5wdXRQYXR0ZXJuOiBkYXRhID0+IGBJbnB1dCBwYXR0ZXJuIHZpb2xhdGlvbjogJHtkYXRhLmlucHV0UGF0dGVybn1gLFxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwYXNzZXMgaW5wdXRQYXR0ZXJuLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCAmIHZhbHVlTGVuZ3RoIHByb3BlcnRpZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGVycm9yVGV4dE1heExlbmd0aD1kYXRhPT5gTWF4IGxlbmd0aCB2aW9sYXRpb246ICR7dmFsdWVMZW5ndGh9IC8gJHttYXhMZW5ndGh9YFxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0TWF4TGVuZ3RoOiBkYXRhID0+IGBNYXggbGVuZ3RoIHZpb2xhdGlvbjogJHtkYXRhLnZhbHVlTGVuZ3RofSAvICR7ZGF0YS5tYXhMZW5ndGh9YCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcGFzc2VzIGlucHV0UGF0dGVybiwgbWF4TGVuZ3RoLCBtaW5MZW5ndGggJiB2YWx1ZUxlbmd0aCBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBlcnJvclRleHRNaW5MZW5ndGg9ZGF0YT0+YE1pbiBsZW5ndGggdmlvbGF0aW9uOiAke2RhdGEudmFsdWVMZW5ndGh9IC8gJHtkYXRhLm1pbkxlbmd0aH1gXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvclRleHRNaW5MZW5ndGg6IGRhdGEgPT4gYE1pbiBsZW5ndGggdmlvbGF0aW9uOiAke2RhdGEudmFsdWVMZW5ndGh9IC8gJHtkYXRhLm1pbkxlbmd0aH1gLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBlcnJvclRleHRSZXF1aXJlZD0nUmVxdWlyZWQnXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvclRleHRSZXF1aXJlZDogJ1JlcXVpcmVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhpZGVMYWJlbF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVMYWJlbF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7UmVnRXhwfG51bGx9IGlucHV0UGF0dGVybl89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRQYXR0ZXJuXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGZhbHNlLCB0aGUgaW5wdXRQYXR0ZXJuIHdpbGwgb25seSBnZXQgdmFsaWRhdGVkIHZpYSBKYXZhU2NyaXB0LCBidXQgbm90IGdldHRpbmcgYXBwbGllZCBvbiBET00gbGV2ZWwuXG4gICAgICAgICAqIFRoZSByZWdleCBzdXBwb3J0IGZvciBpbnB1dCBiYXNlZCBwYXR0ZXJucyBpcyBub3QgZnVsbHkgdGhlcmUgeWV0LCBzbyBmZWVsIGZyZWUgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmVcbiAgICAgICAgICogaWYgbmVlZGVkIChFLmcuIGZvcm0uZmllbGQuUGhvbmUpLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbnB1dFBhdHRlcm5ET01fPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGlucHV0UGF0dGVybkRPTV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlucHV0VHlwZV89J3RleHQnXG4gICAgICAgICAqL1xuICAgICAgICBpbnB1dFR5cGVfOiAndGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaW5wdXRWYWx1ZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRWYWx1ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxCYXNlQ2xzPVsnbmVvLXRleHRmaWVsZC1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbEJhc2VDbHM6IFsnbmVvLXRleHRmaWVsZC1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGxhYmVsQ2xzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVkZ2UtY2FzZSBjb25maWcgaW4gY2FzZSB3ZSB3YW50IHRvIHJlbmRlciBsZWFkaW5nIGNvbnRlbnQgd2l0aCB0aGVpciBvd24gc2VsZWN0b3JzIGxpa2U6XG4gICAgICAgICAqIDxzcGFuIGNsYXNzPVwibXktbGFiZWwtaWQtY2xzXCI+RTEwPC9zcGFuPiDigKIgRmlyc3RuYW1lXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBsYWJlbElkXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbElkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBydWxlcyBmb3IgbGFiZWxJZFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxJZENsc189W11cbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsSWRDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlcGFyYXRvciBiZXR3ZWVuIGxhYmVsSWQgJiBsYWJlbFRleHRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsYWJlbElkU2VwYXJhdG9yXz0nIMK3ICdcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsSWRTZXBhcmF0b3JfOiAnIMK3ICcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxhYmVsT3B0aW9uYWxUZXh0Xz0nIChPcHRpb25hbCknXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbE9wdGlvbmFsVGV4dF86ICcgKE9wdGlvbmFsKScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6ICdib3R0b20nLCAnaW5saW5lJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxhYmVsUG9zaXRpb25fPSdsZWZ0J1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxQb3NpdGlvbl86ICdsZWZ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGFiZWxUZXh0Xz0nTGFiZWxUZXh0J1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxUZXh0XzogJ0xhYmVsVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBsYWJlbFdpZHRoXz0xNTBcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsV2lkdGhfOiAxNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgY2hhcnMgd2hpY2ggeW91IGNhbiBlbnRlciBpbnRvIHRoaXMgZmllbGRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG1heExlbmd0aF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4TGVuZ3RoXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIGFtb3VudCBvZiBjaGFycyB3aGljaCB5b3UgY2FuIGVudGVyIGludG8gdGhpcyBmaWVsZFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbWluTGVuZ3RoXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtaW5MZW5ndGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHBsYWNlaG9sZGVyVGV4dF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGxhY2Vob2xkZXJUZXh0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHRpbmcgYHJlYWRPbmx5YCBtZWFucyB0aGF0IHRoZSBmaWVsZCBtYXkgbm90IGJlIGNoYW5nZWQgYnkgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGlucHV0IGZpZWxkIHdpbGwgYmUgcmVhZC1vbmx5IGFuZCBvdGhlciB3YXlzIG9mIGNoYW5naW5nIHRoZSBmaWVsZCdzIHZhbHVlXG4gICAgICAgICAqIChzdWNoIGFzIGJ5IG9wZXJhdGluZyBwaWNrZXJzKSB3aWxsIGJlIGRpc2FibGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZWFkT25seV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRPbmx5XzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZXF1aXJlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93T3B0aW9uYWxUZXh0Xz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd09wdGlvbmFsVGV4dF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogbnVsbCA9PiBGb2xsb3cgdGhlIGVsZW1lbnQncyBkZWZhdWx0IGJlaGF2aW9yIGZvciBzcGVsbCBjaGVja2luZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufG51bGx9IHNwZWxsQ2hlY2tfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzcGVsbENoZWNrXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gc3ViTGFiZWxCYXNlQ2xzPVsnbmVvLXRleHRmaWVsZC1zdWJsYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBzdWJMYWJlbEJhc2VDbHM6IFsnbmVvLXRleHRmaWVsZC1zdWJsYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHN1YkxhYmVsQ2xzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgc3ViTGFiZWxDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc3ViTGFiZWxUZXh0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdWJMYWJlbFRleHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fE9iamVjdFtdfG51bGx9IHRyaWdnZXJzXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2Vyc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2luZyB0aGUgYWxlcnQgc3RhdGUgd2lsbCBkaXNwbGF5IGFuIGVtcHR5IGJ1dCByZXF1aXJlZCBmaWVsZCBpbiBvcmFuZ2UgaW5zdGVhZCBvZiByZWQuXG4gICAgICAgICAqIEludGVuZGVkIHRvIGdldCBjb21iaW5lZCB3aXRoIGZvcm0uQ29udGFpbmVyOiBnZXRGb3JtU3RhdGUoKS5cbiAgICAgICAgICogU2VlIGFwcHMvZm9ybSBhcyBhbiBleGFtcGxlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VBbGVydFN0YXRlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQWxlcnRTdGF0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgYmFzZWQgdmFsdWUgd2lsbCBnZXQgcmVzb2x2ZWQgaW50byB0aGUgY2xvc2VzdCBjb250cm9sbGVyIHdoaWNoIGltcGxlbWVudHMgaXRcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb258U3RyaW5nfG51bGx9IHZhbGlkYXRvcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWxpZGF0b3I6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRWbHVlIGNhbiBiZSB4c3NQcm90ZWN0ZWQgYW5kIHZhbHVlcyBhcmUgZXNjYXBlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB4c3NQcm90ZWN0ZWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHhzc1Byb3RlY3RlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHt0YWc6ICdsYWJlbCcsIGNsczogW10sIHN0eWxlOiB7fX0sXG4gICAgICAgICAgICB7dGFnOiAnbGFiZWwnLCBjbHM6IFtdfSxcbiAgICAgICAgICAgIHt0YWc6ICdpbnB1dCcsIGNsczogWyduZW8tdGV4dGZpZWxkLWlucHV0J10sIGZsYWc6ICduZW8tcmVhbC1pbnB1dCcsIHN0eWxlOiB7fX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby10ZXh0ZmllbGQtZXJyb3Itd3JhcHBlciddLCByZW1vdmVEb206IHRydWUsIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tdGV4dGZpZWxkLWVycm9yJ119XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHZhbHVlIHRvIGZhbHNlLCBpbiBjYXNlIGEgZmllbGQgc2hvdWxkIGRpc3BsYXkgZXJyb3JzIHVwIGZyb250LlxuICAgICAqIE90aGVyd2lzZSwgZXJyb3JzIHdpbGwgc3RheSBoaWRkZW4gb24gbW91bnRpbmcsIHVubGVzcyB5b3UgdHJpZ2dlciB2YWxpZGF0ZShmYWxzZSkuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2xlYW49dHJ1ZVxuICAgICAqL1xuICAgIGNsZWFuID0gdHJ1ZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAge2lucHV0ICAgICA6IG1lLm9uSW5wdXRWYWx1ZUNoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHttb3VzZWVudGVyOiBtZS5vbk1vdXNlRW50ZXIsICAgICAgIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCAgICAgICBzY29wZTogbWV9XG4gICAgICAgIF0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy50cmlnZ2Vycz8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdXRvQ2FwaXRhbGl6ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvQ2FwaXRhbGl6ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VJbnB1dEVsS2V5KCdhdXRvY2FwaXRhbGl6ZScsIHZhbHVlID09PSAnb2ZmJyB8fCB2YWx1ZSA9PT0gJ25vbmUnID8gbnVsbCA6IHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXV0b0NvbXBsZXRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIENocm9tZSBpZ25vcmVzIGEgdmFsdWUgb2YgXCJvZmZcIiwgc28gd2Ugc3RpY2sgdG8gYSBkaWZmZXJlbnQgdmFsdWUgaW5zdGVhZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0NvbXBsZXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyB3aGlsZSBcIm9mZlwiIGlzIHRoZSBjb3JyZWN0IHZhbHVlLCBicm93c2VyIHZlbmRvcnMgaWdub3JlIGl0LiBBcmJpdHJhcnkgc3RyaW5ncyBkbyB0aGUgdHJpY2suXG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnYXV0b2NvbXBsZXRlJywgdmFsdWUgPyBudWxsIDogJ25vJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNsZWFyYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENsZWFyYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHRyaWdnZXJzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdHJpZ2dlcnMgPSBtZS50cmlnZ2VycyB8fCBbXTtcbiAgICAgICAgICAgIHRyaWdnZXJzLnVuc2hpZnQoQ2xlYXJUcmlnZ2VyKTtcbiAgICAgICAgICAgIG1lLnRyaWdnZXJzID0gdHJpZ2dlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZVRyaWdnZXIoJ2NsZWFyJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2xlYXJUb09yaWdpbmFsVmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDbGVhclRvT3JpZ2luYWxWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2VDbGVhclRvT3JpZ2luYWxWYWx1ZScsIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpc2FibGVkQ2hhcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREaXNhYmxlZENoYXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE5lby5tYWluLkRvbUV2ZW50cy5yZWdpc3RlckRpc2FibGVkSW5wdXRDaGFycyh7XG4gICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjaGFycyAgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgOiBtZS5nZXRJbnB1dEVsKCkuaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVkaXRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RWRpdGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHsgY2xzIH0gPSBtZTtcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLW5vdC1lZGl0YWJsZScsICF2YWx1ZSk7XG4gICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICBtZS51cGRhdGVSZWFkT25seVN0YXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVycm9yIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFcnJvcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFcnJvcih2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVycm9yUG9zaXRpb25BYnNvbHV0ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEVycm9yUG9zaXRpb25BYnNvbHV0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG1lLnZkb20sIHtjbHM6ICduZW8tdGV4dGZpZWxkLWVycm9yJ30pLnZkb20uY2xzO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWFic29sdXRlJyk7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGhpZGVMYWJlbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhpZGVMYWJlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSA9IG1lLmxhYmVsUG9zaXRpb24gPT09ICdpbmxpbmUnID8gbWUuZ2V0Q2VudGVyQm9yZGVyRWwoKSA6IG1lLnZkb20uY25bMF07XG5cbiAgICAgICAgbm9kZS5yZW1vdmVEb20gPSB2YWx1ZTtcbiAgICAgICAgbWUudXBkYXRlSW5wdXRXaWR0aCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnB1dEVsICAgPSBtZS5nZXRJbnB1dEVsKCksXG4gICAgICAgICAgICBpbnB1dEVsSWQgPSBtZS5nZXRJbnB1dEVsSWQoKSxcbiAgICAgICAgICAgIGxhYmVsRWwgICA9IG1lLmdldExhYmVsRWwoKTtcblxuICAgICAgICBpbnB1dEVsLmlkICA9IGlucHV0RWxJZDtcbiAgICAgICAgbGFiZWxFbC5pZCAgPSBtZS5nZXRMYWJlbElkKCk7XG4gICAgICAgIGxhYmVsRWwuZm9yID0gaW5wdXRFbElkO1xuXG4gICAgICAgIC8vIHNpbGVudCB2ZG9tIHVwZGF0ZSwgdGhlIHN1cGVyIGNhbGwgd2lsbCB0cmlnZ2VyIHRoZSBlbmdpbmVcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpbnB1dFBhdHRlcm4gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtSZWdFeHB8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElucHV0UGF0dGVybih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRQYXR0ZXJuRE9NKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VJbnB1dEVsS2V5KCdwYXR0ZXJuJywgdmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlucHV0VHlwZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbnB1dFR5cGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgndHlwZScsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW5wdXRWYWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBtZS5jbHM7XG5cbiAgICAgICAgbWUuZ2V0SW5wdXRFbCgpLnZhbHVlID0gbWUuY29udGFpbnNGb2N1cyA/IHZhbHVlIDogbWUuaW5wdXRWYWx1ZVJlbmRlcmVyKHZhbHVlKTtcblxuICAgICAgICBtZS51c2VBbGVydFN0YXRlICYmIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8tZW1wdHktcmVxdWlyZWQnLCBtZS5pc0VtcHR5KCkgJiYgbWUucmVxdWlyZWQpO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8taGFzLWNvbnRlbnQnLCBtZS5oYXNDb250ZW50KCkpO1xuICAgICAgICBtZS5jbHMgPSBjbHM7XG5cbiAgICAgICAgbWUudmFsdWUgPSBtZS51cGRhdGVWYWx1ZUZyb21JbnB1dFZhbHVlKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxDbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmdldExhYmVsRWwoKS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxhYmVsT3B0aW9uYWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsT3B0aW9uYWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmxhYmVsVGV4dCA9IHRoaXMubGFiZWxUZXh0IC8vIHRyaWdnZXJzIGEgdmRvbSB1cGRhdGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxhYmVsUG9zaXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzICA9IG1lLmNscyxcbiAgICAgICAgICAgIHZkb20gPSBtZS52ZG9tLFxuICAgICAgICAgICAgY2VudGVyQm9yZGVyRWxDbHMsIGlzRW1wdHk7XG5cbiAgICAgICAgdmRvbS5jblsxXS5yZW1vdmVEb20gPSB2YWx1ZSAhPT0gJ3RvcCcgPyB0cnVlIDogIUJvb2xlYW4obWUuc3ViTGFiZWxUZXh0KTtcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbGFiZWwtJyArIG9sZFZhbHVlKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ2xhYmVsLScgKyB2YWx1ZSk7XG4gICAgICAgIG1lLmNscyA9IGNsczsgLy8gdG9kbzogc2lsZW50IHVwZGF0ZSBpZiBuZWVkZWRcblxuICAgICAgICBpZiAob2xkVmFsdWUgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICB2ZG9tLmNuWzBdID0gbWUuZ2V0TGFiZWxFbCgpOyAvLyByZW1vdmUgdGhlIHdyYXBwZXJcblxuICAgICAgICAgICAgdmRvbS5jblswXS5yZW1vdmVEb20gPSBtZS5oaWRlTGFiZWw7XG4gICAgICAgICAgICB2ZG9tLmNuWzBdLndpZHRoICAgICA9IG1lLmxhYmVsV2lkdGg7XG4gICAgICAgICAgICBtZS51cGRhdGVJbnB1dFdpZHRoKClcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgIGNlbnRlckJvcmRlckVsQ2xzID0gWyduZW8tY2VudGVyLWJvcmRlciddO1xuICAgICAgICAgICAgaXNFbXB0eSAgICAgICAgICAgPSBtZS5pc0VtcHR5KCk7XG4gICAgICAgICAgICB2ZG9tICAgICAgICAgICAgICA9IG1lLnZkb207XG5cbiAgICAgICAgICAgICFpc0VtcHR5ICYmIGNlbnRlckJvcmRlckVsQ2xzLnB1c2goJ25lby1mbG9hdC1hYm92ZScpO1xuXG4gICAgICAgICAgICBkZWxldGUgdmRvbS5jblswXS53aWR0aDtcblxuICAgICAgICAgICAgdmRvbS5jblswXSA9IHtcbiAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLWxhYmVsLXdyYXBwZXInXSxcbiAgICAgICAgICAgICAgICBjbiA6IFt7XG4gICAgICAgICAgICAgICAgICAgIGNsczogWyduZW8tbGVmdC1ib3JkZXInXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBjZW50ZXJCb3JkZXJFbENscyxcbiAgICAgICAgICAgICAgICAgICAgY24gICAgICAgOiBbdmRvbS5jblswXV0sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogbWUuaGlkZUxhYmVsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLXJpZ2h0LWJvcmRlciddXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZUlucHV0V2lkdGgoKTtcblxuICAgICAgICAgICAgIWlzRW1wdHkgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlQ2VudGVyQm9yZGVyRWxXaWR0aChmYWxzZSlcbiAgICAgICAgICAgIH0sIDIwKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hhbmdlcyBmcm9tIGUuZy4gbGVmdCB0byB0b3BcbiAgICAgICAgICAgIG1lLnVwZGF0ZUlucHV0V2lkdGgoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbFRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpc0VtcHR5ID0gbWUuaXNFbXB0eSgpO1xuXG4gICAgICAgIGlmIChtZS5sYWJlbElkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGA8c3BhbiBjbGFzcz1cIiR7bWUubGFiZWxJZENscy5qb2luKCcsJyl9XCI+JHttZS5sYWJlbElkfTwvc3Bhbj4ke21lLmxhYmVsSWRTZXBhcmF0b3IgKyB2YWx1ZX1gXG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRMYWJlbEVsKCkuaW5uZXJIVE1MID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKCFtZS5oaWRlTGFiZWwpIHtcbiAgICAgICAgICAgIGlmIChtZS5sYWJlbFBvc2l0aW9uID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUuZ2V0Q2VudGVyQm9yZGVyRWwoKT8ud2lkdGhcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUNlbnRlckJvcmRlckVsV2lkdGgoaXNFbXB0eSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbFdpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxQb3NpdGlvbiAhPT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmRvbSAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgICAgIGxhYmVsID0gdmRvbS5jblswXTtcblxuICAgICAgICAgICAgbGFiZWwud2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICFtZS5oaWRlTGFiZWwgJiYgbWUudXBkYXRlSW5wdXRXaWR0aCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heExlbmd0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWF4TGVuZ3RoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7IC8vIHNpbGVudFxuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ21heGxlbmd0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluTGVuZ3RoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNaW5MZW5ndGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTsgLy8gc2lsZW50XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnbWlubGVuZ3RoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHRyaWdnZXJzID0gbWUudHJpZ2dlcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmlnZ2Vyc1tpXS52ZG9tLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2Vyc1tpXS5tb3VudGVkID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZS5sYWJlbFBvc2l0aW9uID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUuZ2V0Q2VudGVyQm9yZGVyRWwoKS53aWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcGxhY2Vob2xkZXJUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQbGFjZWhvbGRlclRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIG1lLmNoYW5nZUlucHV0RWxLZXkoJ3BsYWNlaG9sZGVyJywgdmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlKTtcblxuICAgICAgICAvLyBhIG5vbi1lbXB0eSBwbGFjZWhvbGRlciBuZWVkcyB0byBrZWVwIHRoZSAnbmVvLWhhcy1jb250ZW50JyBydWxlXG4gICAgICAgIC8vID0+IGxhYmVsUG9zaXRpb246ICdpbmxpbmUnIHNob3VsZCBrZWVwIHRoZSBsYWJlbCBhdCB0aGUgdG9wXG4gICAgICAgIGlmIChOZW8uaXNFbXB0eSh2YWx1ZSkgIT09IE5lby5pc0VtcHR5KG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgTmVvQXJyYXlbdmFsdWUgIT09IG51bGwgJiYgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPiAwID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWhhcy1jb250ZW50Jyk7XG4gICAgICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVhZE9ubHkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWFkT25seSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBtZS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tcmVhZG9ubHknKTtcbiAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgIG1lLnVwZGF0ZVJlYWRPbmx5U3RhdGUoKTtcblxuICAgICAgICBtZS50cmlnZ2Vycz8uZm9yRWFjaCh0cmlnZ2VyID0+IHtcbiAgICAgICAgICAgIHRyaWdnZXIuaGlkZGVuID0gdmFsdWUgPyB0cnVlIDogdHJpZ2dlci5nZXRIaWRkZW5TdGF0ZT8uKCkgfHwgZmFsc2VcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlcXVpcmVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVxdWlyZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2lsZW50VmRvbVVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtZS52YWxpZGF0ZShtZS5jbGVhbik7XG4gICAgICAgIG1lLmNoYW5nZUlucHV0RWxLZXkoJ3JlcXVpcmVkJywgdmFsdWUgPyB2YWx1ZSA6IG51bGwpO1xuICAgICAgICBtZS5sYWJlbFRleHQgPSBtZS5sYWJlbFRleHQ7IC8vIGFwcGx5IHRoZSBvcHRpb25hbCB0ZXh0IGlmIG5lZWRlZFxuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd09wdGlvbmFsVGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dPcHRpb25hbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMubGFiZWxUZXh0ID0gdGhpcy5sYWJlbFRleHQgLy8gdHJpZ2dlcnMgYSB2ZG9tIHVwZGF0ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3BlbGxDaGVjayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTcGVsbENoZWNrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ3NwZWxsY2hlY2snLCBOZW8uaXNCb29sZWFuKHZhbHVlKSA/IHZhbHVlIDogbnVsbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN1YkxhYmVsQ2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdWJMYWJlbENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBtZS52ZG9tLmNuWzFdLmNscztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3ViTGFiZWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdWJMYWJlbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc2hvd0xhYmVsID0gbWUubGFiZWxQb3NpdGlvbiA9PT0gJ3RvcCcsXG4gICAgICAgICAgICBzdWJMYWJlbCAgPSBtZS52ZG9tLmNuWzFdO1xuXG4gICAgICAgIHN1YkxhYmVsLmh0bWwgICAgICA9IHZhbHVlO1xuICAgICAgICBzdWJMYWJlbC5yZW1vdmVEb20gPSAhc2hvd0xhYmVsO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0cmlnZ2VycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJpZ2dlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIGlucHV0RWwgICAgICA9IHZkb20uY25bMl0sIC8vIGlucHV0RWwgb3IgaW5wdXRXcmFwcGVyRWxcbiAgICAgICAgICAgIHByZVRyaWdnZXJzICA9IFtdLFxuICAgICAgICAgICAgcG9zdFRyaWdnZXJzID0gW10sXG4gICAgICAgICAgICB3aWR0aDtcblxuICAgICAgICBvbGRWYWx1ZT8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghbWUuZ2V0VHJpZ2dlcihpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5kZXN0cm95KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlVHJpZ2dlcnMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3N0VHJpZ2dlcnMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcG9zdFRyaWdnZXJzLnNvcnQoKGEsIGIpID0+IGIud2VpZ2h0IC0gYS53ZWlnaHQpOyAvLyBERVNDXG4gICAgICAgICAgICBwcmVUcmlnZ2Vycy5zb3J0KChhLCBiKSA9PiBhLndlaWdodCAtIGIud2VpZ2h0KTsgLy8gQVNDXG5cbiAgICAgICAgICAgIHBvc3RUcmlnZ2VycyA9IHBvc3RUcmlnZ2Vycy5tYXAoYSA9PiBhLnZkb20pO1xuICAgICAgICAgICAgcHJlVHJpZ2dlcnMgID0gcHJlVHJpZ2dlcnMubWFwKGEgPT4gYS52ZG9tKTtcblxuICAgICAgICAgICAgaWYgKGlucHV0RWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGUgaW5wdXQgdGFnXG4gICAgICAgICAgICAgICAgdmRvbS5jblsyXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLWlucHV0LXdyYXBwZXInXSxcbiAgICAgICAgICAgICAgICAgICAgY24gICA6IFsuLi5wcmVUcmlnZ2VycywgaW5wdXRFbCwgLi4ucG9zdFRyaWdnZXJzXSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IG1lLmdldElucHV0V3JhcHBlcklkKCksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbnB1dEVsLndpZHRoXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnB1dEVsLndpZHRoXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0RWwuY24gPSBbLi4ucHJlVHJpZ2dlcnMsIG1lLmdldElucHV0RWwoKSwgLi4ucG9zdFRyaWdnZXJzXVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlucHV0RWwudGFnICE9PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjaW5nIHRoZSBpbnB1dCB3cmFwcGVyIGRpdiB3aXRoIHRoZSBpbnB1dCB0YWdcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgID0gaW5wdXRFbC53aWR0aDtcbiAgICAgICAgICAgICAgICB2ZG9tLmNuWzJdICAgICAgID0gbWUuZ2V0SW5wdXRFbCgpO1xuICAgICAgICAgICAgICAgIHZkb20uY25bMl0ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZVRyaWdnZXJWbm9kZXMoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG9yaWdpbmFsVmFsdWUgPSBtZS5vcmlnaW5hbENvbmZpZy52YWx1ZSxcbiAgICAgICAgICAgIGlzRGlydHkgICAgICAgPSB2YWx1ZSAhPT0gb3JpZ2luYWxWYWx1ZSAmJiBOZW8uaXNFbXB0eSh2YWx1ZSkgIT09IE5lby5pc0VtcHR5KG9yaWdpbmFsVmFsdWUpLFxuICAgICAgICAgICAgY2xzO1xuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuICAgICAgICBtZS5pbnB1dFZhbHVlICAgICAgID0gbWUudXBkYXRlSW5wdXRWYWx1ZUZyb21WYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgbWUudmFsaWRhdGUoKTsgLy8gc2lsZW50XG5cbiAgICAgICAgY2xzID0gbWUuY2xzO1xuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLWlzLWRpcnR5JywgaXNEaXJ0eSk7XG4gICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICBtZS5zaWxlbnRWZG9tVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIC8vIGZpcmVzIHRoZSBjaGFuZ2UgZXZlbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2lkdGgodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbnB1dFdpZHRoKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMudHJpZ2dlcnM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzaGFsbG93IGNvcHkgb2YgdGhlIHRyaWdnZXJzIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0VHJpZ2dlcnModmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgYXV0b0NhcGl0YWxpemUgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNldEF1dG9DYXBpdGFsaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYXV0b0NhcGl0YWxpemUnLCAnYXV0b0NhcGl0YWxpemVWYWx1ZXMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGxhYmVsQ2xzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRMYWJlbENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lb0FycmF5LnVuaW9uKHZhbHVlIHx8IFtdLCB0aGlzLmxhYmVsQmFzZUNscylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBsYWJlbFBvc2l0aW9uIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRMYWJlbFBvc2l0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnbGFiZWxQb3NpdGlvbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbGFiZWxUZXh0IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgYmVmb3JlU2V0TGFiZWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbGFiZWxPcHRpb25hbFRleHQgPSBtZS5sYWJlbE9wdGlvbmFsVGV4dCxcbiAgICAgICAgICAgIGhhc09wdGlvbmFsVGV4dCAgID0gdmFsdWUuZW5kc1dpdGgobGFiZWxPcHRpb25hbFRleHQpO1xuXG4gICAgICAgIGlmIChtZS5zaG93T3B0aW9uYWxUZXh0ICYmICFtZS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPcHRpb25hbFRleHQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBsYWJlbE9wdGlvbmFsVGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIGhhc09wdGlvbmFsVGV4dCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGxhYmVsT3B0aW9uYWxUZXh0LCAnJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN1YkxhYmVsQ2xzIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdWJMYWJlbENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lb0FycmF5LnVuaW9uKHZhbHVlIHx8IFtdLCB0aGlzLnN1YkxhYmVsQmFzZUNscylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB0cmlnZ2VycyBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119IHRoZSBwYXJzZWQgdHJpZ2dlcnMgY29uZmlnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W119XG4gICAgICovXG4gICAgYmVmb3JlU2V0VHJpZ2dlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLmlzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBOZW8uY3JlYXRlKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgIDogbWUuZ2V0VHJpZ2dlcklkKGl0ZW0ucHJvdG90eXBlLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZCAgOiBtZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEJhc2VUcmlnZ2VyKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5tb2R1bGUgJiYgIWl0ZW0ubnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5udHlwZSA9ICd0cmlnZ2VyJ1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTmFtZSA9IGl0ZW0ubW9kdWxlLnByb3RvdHlwZS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaWQgICAgICAgID0gbWUuZ2V0VHJpZ2dlcklkKGl0ZW0ubW9kdWxlLnByb3RvdHlwZS50eXBlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IE5lb1tpdGVtLmNsYXNzTmFtZSA/ICdjcmVhdGUnIDogJ250eXBlJ10oe1xuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZCAgOiBtZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBmaWVsZCB0byBpdHMgb3JpZ2luYWwgdmFsdWUgb3IgbnVsbCBkZXBlbmRpbmcgb24gdGhlIGNsZWFyVG9PcmlnaW5hbFZhbHVlIGNvbmZpZ1xuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZhbHVlID0gbWUuY2xlYXJUb09yaWdpbmFsVmFsdWUgPyBtZS5vcmlnaW5hbENvbmZpZy52YWx1ZSA6IG51bGw7XG4gICAgICAgIG1lLmZpcmUoJ2NsZWFyJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmRpc2FibGVkQ2hhcnMpIHtcbiAgICAgICAgICAgIE5lby5tYWluLkRvbUV2ZW50cy51bnJlZ2lzdGVyRGlzYWJsZWRJbnB1dENoYXJzKHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGlkICAgICA6IG1lLmdldElucHV0RWwoKS5pZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBmb2N1cygpIG9uIHRoZSBpbnB1dEVsIG5vZGUgaW5zdGVhZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGZvY3VzKGlkKSB7XG4gICAgICAgIHN1cGVyLmZvY3VzKHRoaXMuZ2V0SW5wdXRFbElkKCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldENlbnRlckJvcmRlckVsKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZmluZFZkb21DaGlsZCh0aGlzLnZkb20sIHtjbHM6ICduZW8tY2VudGVyLWJvcmRlcid9KT8udmRvbSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldElucHV0RWwoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKHRoaXMudmRvbSwge2ZsYWc6ICduZW8tcmVhbC1pbnB1dCd9KT8udmRvbSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJbnB1dEVsSWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9faW5wdXRgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbmV3IGlucHV0V2lkdGggYmFzZWQgb24gdGhlIGxhYmVsV2lkdGggJiB0b3RhbCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVsbH0gbnVsbCBpbiBjYXNlIHRoaXMud2lkdGggaXMgdW5rbm93blxuICAgICAqL1xuICAgIGdldElucHV0V2lkdGgoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZ25vcmVMYWJlbCA9IG1lLmhpZGVMYWJlbCB8fCBtZS5sYWJlbFBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBtZS5sYWJlbFBvc2l0aW9uID09PSAnaW5saW5lJyB8fCBtZS5sYWJlbFBvc2l0aW9uID09PSAndG9wJyxcbiAgICAgICAgICAgIGxhYmVsV2lkdGggID0gaWdub3JlTGFiZWwgPyAwIDogbWUubGFiZWxXaWR0aCxcbiAgICAgICAgICAgIHdpZHRoICAgICAgID0gbWUud2lkdGg7XG5cbiAgICAgICAgaWYgKGxhYmVsV2lkdGggJiYgd2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh3aWR0aCkgLSBwYXJzZUludChsYWJlbFdpZHRoKVxuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGhcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJbnB1dFdyYXBwZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pbnB1dC13cmFwcGVyYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRMYWJlbEVsKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZmluZFZkb21DaGlsZCh0aGlzLnZkb20sIHt0YWc6ICdsYWJlbCd9KT8udmRvbSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRMYWJlbElkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2xhYmVsYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybnMge05lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldFRyaWdnZXIodHlwZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdHJpZ2dlcnMgPSBtZS50cmlnZ2VycyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2Vyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJzW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRUcmlnZ2VyQnlJZChpZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdHJpZ2dlcnMgPSBtZS50cmlnZ2VycyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2Vyc1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJpZ2dlcnNbaV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRyaWdnZXIgbm9kZSBpZFxuICAgICAqL1xuICAgIGdldFRyaWdnZXJJZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJy10cmlnZ2VyLScgKyB0eXBlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgKi9cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMueHNzUHJvdGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbC5lc2NhcGVIdG1sKHN1cGVyLmdldFZhbHVlKCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0VmFsdWUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzQ29udGVudCgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5pbnB1dFZhbHVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBsYWNlaG9sZGVyVGV4dD8ubGVuZ3RoID4gMCB8fCB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCA+IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIHRyaWdnZXIgYnkgYSBnaXZlbiB0eXBlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzVHJpZ2dlcih0eXBlKSB7XG4gICAgICAgIGxldCB0cmlnZ2VycyA9IHRoaXMudHJpZ2dlcnMgfHwgW10sXG4gICAgICAgICAgICBpICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlcnNbaV0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYW4gaW5wdXQgbm9kZSB2YWx1ZSBiZWZvcmUgYXBwbGllZCB0byB0aGlzLnZhbHVlLlxuICAgICAqIE92ZXJyaWRlIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpbnB1dFZhbHVlQWRqdXN0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgdmFsdWUgYmVmb3JlIGdldHRpbmcgcmVuZGVyZWQuXG4gICAgICogT3ZlcnJpZGUgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlucHV0VmFsdWVSZW5kZXJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLnZhbHVlPy50b1N0cmluZygpLmxlbmd0aCA+IDApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eUFuZFJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgJiYgdGhpcy5yZXF1aXJlZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodHJ1ZSk7IC8vIHNpbGVudFxuXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yID8gZmFsc2UgOiBzdXBlci5pc1ZhbGlkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIG1lcmdlQ29uZmlnKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgID0gc3VwZXIubWVyZ2VDb25maWcoLi4uYXJncyksXG4gICAgICAgICAgICB0cmlnZ2VycyA9IGNvbmZpZy50cmlnZ2VycyB8fCBtZS50cmlnZ2VycztcblxuICAgICAgICBtZVt0cmlnZ2VycyA/ICd0cmlnZ2VycycgOiAnX3RyaWdnZXJzJ10gPSB0cmlnZ2VycztcblxuICAgICAgICBkZWxldGUgY29uZmlnLnRyaWdnZXJzO1xuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnBhdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0VudGVyKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0VudGVyKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIGlmICghbWUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tZm9jdXMnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICAgICAgaWYgKG1lLmxhYmVsUG9zaXRpb24gPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lLmNlbnRlckJvcmRlckVsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZ2V0Q2VudGVyQm9yZGVyRWwoKS53aWR0aCA9IG1lLmNlbnRlckJvcmRlckVsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlQ2VudGVyQm9yZGVyRWxXaWR0aChmYWxzZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2VudGVyQm9yZGVyRWwgPSBtZS5nZXRDZW50ZXJCb3JkZXJFbCgpLCAvLyBsYWJlbFBvc2l0aW9uOiAnaW5saW5lJ1xuICAgICAgICAgICAgY2xzO1xuXG4gICAgICAgIGlmICghbWUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIG1lLnZhbGlkYXRlKGZhbHNlKTtcblxuICAgICAgICAgICAgY2xzID0gbWUuY2xzOyAvLyBoYXMgdG8gZ2V0IHNldCBhZnRlciB2YWxpZGF0ZSgpXG5cbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tZm9jdXMnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICAgICAgaWYgKGNlbnRlckJvcmRlckVsICYmIG1lLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjZW50ZXJCb3JkZXJFbC53aWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhtZS52YWx1ZSkpIHtcbiAgICAgICAgICAgIG1lLnZhbHVlID0gbWUudmFsdWUudHJpbSgpXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICBzdXBlci5vbkZvY3VzTGVhdmUoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBieSB0aGUgJ2lucHV0JyBET00gZXZlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25JbnB1dFZhbHVlQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb2xkVmFsdWUgICA9IG1lLnZhbHVlLFxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGRhdGEudmFsdWUsXG4gICAgICAgICAgICB2bm9kZSAgICAgID0gVk5vZGVVdGlsLmZpbmRDaGlsZFZub2RlKG1lLnZub2RlLCB7bm9kZU5hbWU6ICdpbnB1dCd9KTtcblxuICAgICAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBzdGF0ZSAobW9kaWZpZWQgRE9NIGJ5IHRoZSB1c2VyKSB0byBlbmFibGUgdGhlIGRlbHRhLXVwZGF0ZXMgbG9naWMuXG4gICAgICAgICAgICAvLyBSZXF1aXJlZCBlLmcuIGZvciB2YWxpZGF0aW9uIC0+IHJldmVydCBhIHdyb25nIHVzZXIgaW5wdXRcbiAgICAgICAgICAgIHZub2RlLnZub2RlLmF0dHJpYnV0ZXMudmFsdWUgPSBpbnB1dFZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGlucHV0VmFsdWUpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS50cmltKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNsZWFuICAgICAgPSBmYWxzZTtcbiAgICAgICAgbWUuaW5wdXRWYWx1ZSA9IG1lLmlucHV0VmFsdWVBZGp1c3RvcihpbnB1dFZhbHVlKTsgLy8gdXBkYXRlcyB0aGlzLnZhbHVlXG5cbiAgICAgICAgbWUuZmlyZVVzZXJDaGFuZ2VFdmVudChtZS52YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlRW50ZXIoZGF0YSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBpZiAoIW1lLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLWhvdmVyZWQnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBpZiAoIW1lLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLWhvdmVyZWQnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdHJpZ2dlcnMgb2YgYSBnaXZlbiB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHRydWUgcHJldmVudHMgYSB2ZG9tIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmlnZ2VyU291cmNlXSBwYXNzIGEgc2hhbGxvdyBjb3B5IG9mIHRoaXMudHJpZ2dlcnNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIGEgdHJpZ2dlciB3YXMgZm91bmQgJiByZW1vdmVkXG4gICAgICovXG4gICAgcmVtb3ZlVHJpZ2dlcih0eXBlLCBzaWxlbnQgPSBmYWxzZSwgdHJpZ2dlclNvdXJjZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZSxcbiAgICAgICAgICAgIHRyaWdnZXJzID0gdHJpZ2dlclNvdXJjZSB8fCBtZS50cmlnZ2VycyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoLFxuICAgICAgICAgICAgdHJpZ2dlcjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0cmlnZ2VyID0gdHJpZ2dlcnNbaV07XG5cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUodHJpZ2dlcnMsIHRyaWdnZXIpO1xuICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc01hdGNoICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLnRyaWdnZXJzID0gdHJpZ2dlcnNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNNYXRjaFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZmllbGQgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIG9yIG51bGwgZGVwZW5kaW5nIG9uIHRoZSBjbGVhclRvT3JpZ2luYWxWYWx1ZSBjb25maWdcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIG5ldyB2YWx1ZSwgd2hpY2ggd2lsbCBhZGp1c3QgdGhlIG9yaWdpbmFsQ29uZmlnLnZhbHVlIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBbdmFsdWU9bnVsbF1cbiAgICAgKi9cbiAgICByZXNldCh2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuY2xlYXJUb09yaWdpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLm9yaWdpbmFsQ29uZmlnLnZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtZS5vcmlnaW5hbENvbmZpZy52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIucmVzZXQodmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBtZS5jbGVhbikge1xuICAgICAgICAgICAgbWUudXBkYXRlRXJyb3IobnVsbClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGxhYmVsUG9zaXRpb246ICdpbmxpbmUnIHRvIGFkanVzdCB0aGUgdG9wIGJvcmRlciBtYXRjaGluZyB0byB0aGUgbGVuZ3RoIG9mIHRoZSBsYWJlbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gdHJ1ZSB0byBnZXQgdGhlIHZhbHVlLCBidXQgbm90IGFwcGx5IGl0IHRvIHRoZSBET01cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlQ2VudGVyQm9yZGVyRWxXaWR0aChzaWxlbnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm1vdW50ZWQgJiYgbWUuZ2V0RG9tUmVjdChtZS5nZXRDZW50ZXJCb3JkZXJFbCgpLmlkKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgbWUuY2VudGVyQm9yZGVyRWxXaWR0aCA9IE1hdGgucm91bmQoZGF0YS53aWR0aCAqIC43KSArIDg7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgbWUuZ2V0Q2VudGVyQm9yZGVyRWwoKS53aWR0aCA9IG1lLmNlbnRlckJvcmRlckVsV2lkdGg7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICB1cGRhdGVFcnJvcih2YWx1ZSwgc2lsZW50ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBtZS5jbHMsXG4gICAgICAgICAgICBlcnJvck5vZGUsIGVycm9yV3JhcHBlcjtcblxuICAgICAgICBpZiAoIShtZS5jbGVhbiAmJiAhbWUubW91bnRlZCkpIHtcbiAgICAgICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWludmFsaWQnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICAgICAgZXJyb3JXcmFwcGVyID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCB7Y2xzOiAnbmVvLXRleHRmaWVsZC1lcnJvci13cmFwcGVyJ30pLnZkb207XG4gICAgICAgICAgICBlcnJvck5vZGUgICAgPSBlcnJvcldyYXBwZXIuY25bMF07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVycm9yTm9kZS5odG1sID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVycm9yTm9kZS5odG1sXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yV3JhcHBlci5yZW1vdmVEb20gPSAhdmFsdWU7XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZCBpbnNpZGUgY2xhc3MgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlSW5wdXRWYWx1ZUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgaW5wdXRXaWR0aCBiYXNlZCBvbiB0aGUgbGFiZWxXaWR0aCAmIHRvdGFsIHdpZHRoXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUlucHV0V2lkdGgoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0V2lkdGggPSBtZS5nZXRJbnB1dFdpZHRoKCk7XG5cbiAgICAgICAgaWYgKGlucHV0V2lkdGggIT09IG51bGwgJiYgaW5wdXRXaWR0aCAhPT0gbWUud2lkdGgpIHtcbiAgICAgICAgICAgIG1lLnZkb20uY25bMV0ud2lkdGggPSBpbnB1dFdpZHRoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbS5jblsxXS53aWR0aFxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRE9NIGJhc2VkIHJlYWRvbmx5IGF0dHJpYnV0ZSBuZWVkcyB0byBob25vciB0aGUgZWRpdGFibGUgJiByZWFkT25seSBjb25maWdzXG4gICAgICovXG4gICAgdXBkYXRlUmVhZE9ubHlTdGF0ZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jaGFuZ2VJbnB1dEVsS2V5KCdyZWFkb25seScsICFtZS5lZGl0YWJsZSB8fCBtZS5yZWFkT25seSB8fCBudWxsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHRyaWdnZXJzIGRvIG5vdCBnZXQgcmVuZGVyZWQsIGFzc2lnbiB0aGUgcmVsZXZhbnQgcHJvcHNcbiAgICAgKiB0b2RvOiB0aGlzIGNvdWxkIGJlIGhhbmRsZWQgYnkgY29tcG9uZW50LkJhc2VcbiAgICAgKi9cbiAgICB1cGRhdGVUcmlnZ2VyVm5vZGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdHJpZ2dlclJvb3QgPSBtZS52bm9kZT8uY2hpbGROb2Rlc1sxXSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXMgID0gdHJpZ2dlclJvb3Q/LmNoaWxkTm9kZXMgfHwgW10sXG4gICAgICAgICAgICB0cmlnZ2VyO1xuXG4gICAgICAgIGNoaWxkTm9kZXMuZm9yRWFjaCh2bm9kZSA9PiB7XG4gICAgICAgICAgICB0cmlnZ2VyID0gbWUuZ2V0VHJpZ2dlckJ5SWQodm5vZGUuaWQpO1xuXG4gICAgICAgICAgICB0cmlnZ2VyICYmIE9iamVjdC5hc3NpZ24odHJpZ2dlciwge1xuICAgICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICAgIF9yZW5kZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBfbW91bnRlZCA6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkIGluc2lkZSBjbGFzcyBleHRlbnNpb25zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVZhbHVlRnJvbUlucHV0VmFsdWUoaW5wdXRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY2xpZW50LXNpZGUgZmllbGQgZXJyb3JzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2xpZW50LXNpZGUgZXJyb3JzXG4gICAgICovXG4gICAgdmFsaWRhdGUoc2lsZW50PXRydWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtYXhMZW5ndGggICAgPSBtZS5tYXhMZW5ndGgsXG4gICAgICAgICAgICBtaW5MZW5ndGggICAgPSBtZS5taW5MZW5ndGgsXG4gICAgICAgICAgICByZXF1aXJlZCAgICAgPSBtZS5yZXF1aXJlZCxcbiAgICAgICAgICAgIHJldHVyblZhbHVlICA9IHRydWUsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgPSBtZS52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlTGVuZ3RoICA9IHZhbHVlPy50b1N0cmluZygpLmxlbmd0aCxcbiAgICAgICAgICAgIGlucHV0UGF0dGVybiA9IG1lLmlucHV0UGF0dGVybixcbiAgICAgICAgICAgIGlzRW1wdHkgICAgICA9IHZhbHVlICE9PSAwICYmICghdmFsdWUgfHwgdmFsdWVMZW5ndGggPCAxKSxcbiAgICAgICAgICAgIGVycm9yUGFyYW0gICA9IHtpbnB1dFBhdHRlcm4sIG1heExlbmd0aCwgbWluTGVuZ3RoLCB2YWx1ZUxlbmd0aH0sXG4gICAgICAgICAgICBlcnJvclRleHQ7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgbWFudWFsbHkgY2FsbCB2YWxpZGF0ZShmYWxzZSkgb24gYSBmb3JtIG9yIGZpZWxkIGJlZm9yZSBpdCBpcyBtb3VudGVkLCB3ZSBkbyB3YW50IHRvIHNlZSBlcnJvcnMuXG4gICAgICAgICAgICBtZS5jbGVhbiA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgbWUuX2Vycm9yICAgPSBtZS5lcnJvclRleHRSZXF1aXJlZDtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKG1heExlbmd0aCkgJiYgdmFsdWVMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtZS5fZXJyb3IgICA9IG1lLmVycm9yVGV4dE1heExlbmd0aChlcnJvclBhcmFtKTtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc051bWJlcihtaW5MZW5ndGgpICYmIHZhbHVlTGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWUuX2Vycm9yICAgPSBtZS5lcnJvclRleHRNaW5MZW5ndGgoZXJyb3JQYXJhbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFBhdHRlcm4gJiYgIWlucHV0UGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG1lLl9lcnJvciAgID0gbWUuZXJyb3JUZXh0SW5wdXRQYXR0ZXJuKGVycm9yUGFyYW0pO1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzRnVuY3Rpb24obWUudmFsaWRhdG9yKSkge1xuICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IG1lLnZhbGlkYXRvcihtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JUZXh0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLl9lcnJvciAgID0gZXJyb3JUZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICBtZS5fZXJyb3IgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICAhbWUuY2xlYW4gJiYgbWUudXBkYXRlRXJyb3IobWUuX2Vycm9yLCBzaWxlbnQpO1xuXG4gICAgICAgIHJldHVybiAhcmV0dXJuVmFsdWUgPyBmYWxzZSA6IHN1cGVyLnZhbGlkYXRlKHNpbGVudClcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKFRleHQpO1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tICcuLi8uLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZm9ybSBmaWVsZCBUcmlnZ2Vyc1xuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgYWxpZ25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYWxpZ25WYWx1ZXM9WydlbmQnLCAnc3RhcnQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGFsaWduVmFsdWVzID0gWydlbmQnLCAnc3RhcnQnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0cmlnZ2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RyaWdnZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhbGlnbl89J2VuZCdcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiAnZW5kJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWZpZWxkLXRyaWdnZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZmllbGQtdHJpZ2dlciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmZvcm0uZmllbGQuQmFzZXxudWxsfSBmaWVsZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaWNvbkNsc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0hvdmVyZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY29wZSBvZiB0aGUgdHJpZ2dlciBoYW5kbGVyXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb3JlLkJhc2V8bnVsbH0gc2NvcGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93T25Ib3Zlcj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd09uSG92ZXI6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB1c2VkIGJ5IGZpZWxkLmdldFRyaWdnZXIoKVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGU9J2Jhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdiYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gd2VpZ2h0Xz0xMFxuICAgICAgICAgKi9cbiAgICAgICAgd2VpZ2h0XzogMTBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhcbiAgICAgICAgICAgIHtjbGljazogbWUub25UcmlnZ2VyQ2xpY2ssIHNjb3BlOiBtZX1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobWUuc2hvd09uSG92ZXIpIHtcbiAgICAgICAgICAgIG1lLmhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgICAgIG1lLmZpZWxkLm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5maWVsZC5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgICAgICAgICB7bW91c2VlbnRlcjogbWUub25Nb3VzZUVudGVyLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCBzY29wZTogbWV9XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9LCBtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFsaWduIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPT09ICdzdGFydCcgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tYWxpZ24tc3RhcnQnKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHM7XG4gICAgfVxuXG4gICAgYWZ0ZXJTZXRGaWVsZChmaWVsZCkge1xuICAgICAgICAodGhpcy52ZG9tLmRhdGEgfHwgKHRoaXMudmRvbS5kYXRhID0ge30pKS5mb2N1cyA9IGZpZWxkICYmIGZpZWxkLmdldElucHV0RWxJZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZGVuIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGlkZGVuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgICAgIHN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICdub25lJyA6ICdpbmhlcml0JztcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWNvbkNscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJY29uQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xzID0gY2xzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGFsaWduIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0QWxpZ24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdhbGlnbicsICdhbGlnblZhbHVlcycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlUGFyZW50VmRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50XG4gICAgICovXG4gICAgZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tLCBzaWxlbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZW1vdmVEb21MaXN0ZW5lcnMoXG4gICAgICAgICAgICB7Y2xpY2s6IG1lLm9uVHJpZ2dlckNsaWNrLCBzY29wZTogbWV9XG4gICAgICAgICk7XG5cbiAgICAgICAgZGVsZXRlIG1lLmZpZWxkO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbSwgc2lsZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgdGhpcy5pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhpZGRlbiAgICA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Nb3VzZUxlYXZlKCkge1xuICAgICAgICB0aGlzLmlzSG92ZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGRlbiAgICA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xpY2sgZG9tRXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblRyaWdnZXJDbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBzY29wZSA9IG1lLnNjb3BlIHx8IG1lO1xuXG4gICAgICAgIGlmIChtZS5oYW5kbGVyKSB7XG4gICAgICAgICAgICBzY29wZVttZS5oYW5kbGVyXS5jYWxsKHNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIENsZWFyIFRyaWdnZXIgdG8gcmVtb3ZlIHRoZSBpbnB1dCB2YWx1ZSBvZiBUZXh0RmllbGRzIG9yIHN1YmNsYXNzZXNcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkNsZWFyXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkJhc2VcbiAqL1xuY2xhc3MgQ2xlYXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLmZpZWxkLnRyaWdnZXIuQ2xlYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLnRyaWdnZXIuQ2xlYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndHJpZ2dlci1jbGVhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0cmlnZ2VyLWNsZWFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWZpZWxkLXRyaWdnZXInLCduZW8tdHJpZ2dlci1jbGVhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1maWVsZC10cmlnZ2VyJywgJ25lby10cmlnZ2VyLWNsZWFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaWNvbkNscz0nZmEgZmEtdGltZXMnXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiAnZmEgZmEtdGltZXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB1c2VkIGJ5IGZpZWxkLmdldFRyaWdnZXIoKVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGU9J2NsZWFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnY2xlYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWlnaHRfPTIwXG4gICAgICAgICAqL1xuICAgICAgICB3ZWlnaHQ6IDIwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoaWRkZW4gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRIaWRkZW4odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1pcy1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaGlkZGVuIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0SGlkZGVuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zaG93T25Ib3ZlciAmJiAhdGhpcy5pc0hvdmVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZmllbGQudW4oe1xuICAgICAgICAgICAgY2hhbmdlICAgICAgICAgICAgICAgICAgICA6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICAgICAgICBjaGFuZ2VDbGVhclRvT3JpZ2luYWxWYWx1ZTogbWUub25GaWVsZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgICAgICAgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIHRyaWdnZXIgc2hvdWxkIGJlIGhpZGRlblxuICAgICAqL1xuICAgIGdldEhpZGRlblN0YXRlKCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmllbGQgPSBtZS5maWVsZCxcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG5cbiAgICAgICAgaWYgKGZpZWxkLmNsZWFyVG9PcmlnaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZpZWxkLm9yaWdpbmFsQ29uZmlnLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhZmllbGQudmFsdWUgfHwgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPCAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkZpZWxkQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0aGlzLmdldEhpZGRlblN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5maWVsZC5vbih7XG4gICAgICAgICAgICBjaGFuZ2UgICAgICAgICAgICAgICAgICAgIDogbWUub25GaWVsZENoYW5nZSxcbiAgICAgICAgICAgIGNoYW5nZUNsZWFyVG9PcmlnaW5hbFZhbHVlOiBtZS5vbkZpZWxkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgICAgICAgICAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmhpZGRlbiA9IG1lLmdldEhpZGRlblN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgb25Nb3VzZUVudGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzSG92ZXJlZCA9IHRydWU7XG4gICAgICAgIG1lLmhpZGRlbiAgICA9IG1lLmdldEhpZGRlblN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRyaWdnZXJDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmllbGQuY2xlYXIoKTtcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKENsZWFyKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2xlYXI7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuU3RyaW5nXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFN0cmluZ1V0aWwgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNoYXJFbnRpdHlNYXBcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNoYXJFbnRpdHlNYXAgPSB7XG4gICAgICAgICcmJyA6ICcmYW1wOycsXG4gICAgICAgICc8JyA6ICcmbHQ7JyxcbiAgICAgICAgJz4nIDogJyZndDsnLFxuICAgICAgICAnXCInIDogJyZxdW90OycsXG4gICAgICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAgICAgJyQnIDogJyZkb2xsYXI7JyxcbiAgICAgICAgJ1xcXFwnOiAnJmJzb2w7JyxcbiAgICAgICAgJy8nIDogJyZzb2w7J1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IGNoYXJQYXR0ZXJuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBjaGFyUGF0dGVybiA9IC9bJjw+XCInJFxcXFxdL2dcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IGVudGl0eVBhdHRlcm5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGVudGl0eVBhdHRlcm4gPSAvKCZhbXA7KXwoJmx0Oyl8KCZndDspfCgmcXVvdDspfCgmYXBvczspfCgmZG9sbGFyOyl8KCZic29sOyl8KCZzb2w7KS9nXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLlN0cmluZydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuU3RyaW5nJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBIVE1MIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7IC8vIGluc2lkZSBhIHN0YXRpYyBtZXRob2QsIHdlIGFyZSBwb2ludGluZyB0byB0aGUgY2xhc3MgcHJvdG90eXBlXG5cbiAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpICE9PSAnU3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobWUuY2hhclBhdHRlcm4sIG1lLmdldEVudGl0eUZyb21DaGFyLmJpbmQobWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2hhciBlcXVpdmFsZW50IG9mIGEgbWFwcGVkIGVudGl0eVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhckZyb21FbnRpdHkoZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZENoYXIgPSBPYmplY3Qua2V5cyh0aGlzLmNoYXJFbnRpdHlNYXApLmZpbmQoa2V5ID0+IHRoaXMuY2hhckVudGl0eU1hcFtrZXldID09PSBlbnRpdHkpO1xuICAgICAgICByZXR1cm4gbWFwcGVkQ2hhciB8fCBlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGVudGl0eSBlcXVpdmFsZW50IG9mIGEgbWFwcGVkIGNoYXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRFbnRpdHlGcm9tQ2hhcihjaGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJFbnRpdHlNYXBbY2hhcl0gfHwgY2hhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmVzY2FwZSBIVE1MIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmVzY2FwZUh0bWwodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpczsgLy8gaW5zaWRlIGEgc3RhdGljIG1ldGhvZCwgd2UgYXJlIHBvaW50aW5nIHRvIHRoZSBjbGFzcyBwcm90b3R5cGVcblxuICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgIT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShtZS5lbnRpdHlQYXR0ZXJuLCBtZS5nZXRDaGFyRnJvbUVudGl0eS5iaW5kKG1lKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFzc2VkIHN0cmluZyB3aXRoIHRoZSBmaXJzdCBsZXR0ZXIgdW5jYXBpdGFsaXplZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyAge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdW5jYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZVswXS50b0xvd2VyQ2FzZSgpICsgdmFsdWUuc3Vic3RyaW5nKDEpXG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhTdHJpbmdVdGlsKTtcblxuZXhwb3J0IGRlZmF1bHQgU3RyaW5nVXRpbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==