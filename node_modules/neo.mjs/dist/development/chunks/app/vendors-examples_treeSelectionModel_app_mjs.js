"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_treeSelectionModel_app_mjs"],{

/***/ "./examples/treeSelectionModel/MainContainer.mjs":
/*!*******************************************************!*\
  !*** ./examples/treeSelectionModel/MainContainer.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_tree_Accordion_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/tree/Accordion.mjs */ "./src/tree/Accordion.mjs");
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");







/**
 * @class Neo.examples.treeSelectionModel.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className           : 'Neo.examples.treeSelectionModel.MainContainer',
        autoMount           : true,
        configItemLabelWidth: 100,
        configItemWidth     : 230,
        layout              : {ntype: 'hbox', align: 'stretch'},
        cls                 : ['examples-container-accordion']
    }

    onConfigChange(config, opts) {
        this.exampleComponent.items[0][config] = opts.value;
    }

    createConfigurationComponents() {
        let me       = this,
            treeList = me.exampleComponent.items[0];

        return [{
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            checked       : treeList.rootParentsAreCollapsible,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'rootParentsAreCollapsible')},
            valueLabelText: 'rootParentsAreCollapsible'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            checked       : treeList.firstParentIsVisible,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'firstParentIsVisible')},
            style         : {marginTop: '10px'},
            valueLabelText: 'firstParentIsVisible'
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: true,
            labelText: 'height',
            listeners: {change: me.onConfigChange.bind(me, 'height')},
            maxValue : 1200,
            minValue : 400,
            stepSize : 5,
            value    : treeList.height,
            style    : {marginTop: '10px'}
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: true,
            labelText: 'width',
            listeners: {change: me.onConfigChange.bind(me, 'width')},
            maxValue : 1200,
            minValue : 200,
            stepSize : 5,
            style    : {marginTop: '10px'},
            value    : treeList.width
        }];
    }

    /**
     * @returns {*}
     */
    createExampleComponent() {
        const store = Neo.create(_src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], {
            keyProperty: 'id',
            model      : {
                fields: [
                    {name: 'collapsed', type: 'Boolean'},
                    {name: 'content', type: 'String'},
                    {name: 'iconCls', type: 'String'},
                    {name: 'id', type: 'Integer'},
                    {name: 'isLeaf', type: 'Boolean'},
                    {name: 'name', type: 'String'},
                    {name: 'parentId', type: 'Integer'}
                ]
            }
        });

        return Neo.ntype({
            ntype : 'container',
            layout: {ntype: 'hbox', align: 'stretch'},
            items : [{
                //     module: TextField,
                //     label: 'Test',
                //     plugin: {
                //         Plugin: {
                //             bold: true
                //         }
                //     }
                // },{
                module: _src_tree_Accordion_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                store : store,
                height: 800,
                width : 400,

                // ensure afterSetMounted runs only once
                storeLoaded: false,
                afterSetMounted() {
                    if (!this.storeLoaded) {
                        this.storeLoaded = true;
                    } else {
                        return;
                    }

                    let me = this;

                    Neo.Xhr.promiseJson({
                        url: '../../examples/treeSelectionModel/tree.json'
                    }).then(data => {
                        const items      = data.json,
                              colorArray = ['red', 'yellow', 'green'],
                              iconArray  = ['home', 'industry', 'user'];

                        // create random iconCls colors
                        items.forEach((item) => {
                            if (!item.iconCls) {
                                const rand = Math.floor(Math.random() * 3);

                                item.iconCls = 'fa fa-' + iconArray[rand] + ' color-' + colorArray[rand];
                            }
                        });

                        me.store.data = data.json;
                        me.createItems(null, me.getListItemsRoot(), 0);
                    });
                }
            }]
        });
    }
}

Neo.applyClassConfig(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./examples/treeSelectionModel/app.mjs":
/*!*********************************************!*\
  !*** ./examples/treeSelectionModel/app.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/treeSelectionModel/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.treeSelectionModel'
});


/***/ }),

/***/ "./src/selection/TreeAccordionModel.mjs":
/*!**********************************************!*\
  !*** ./src/selection/TreeAccordionModel.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TreeModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeModel.mjs */ "./src/selection/TreeModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.selection.TreeAccordionModel
 * @extends Neo.selection.TreeModel
 */
class TreeAccordionModel extends _TreeModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.TreeAccordionModel'
         * @protected
         */
        className: 'Neo.selection.TreeAccordionModel',
        /**
         * @member {String} ntype='selection-treeaccordionmodel'
         * @protected
         */
        ntype: 'selection-treeaccordionmodel'
    }

    /**
     * Tries to find a child and returns it
     * @param {Object} record
     * @returns {Object|null}
     */
    checkForChild(record) {
        const view     = this.view,
              recordId = record[view.getKeyProperty()];
        let childRecord = null;

        for (const item of view.store.items) {
            if (item.parentId === recordId) {
                childRecord = item;
                break;
            }
        }

        return childRecord;
    }

    /**
     * Return the parent record if any
     * @param {Object} record
     * @returns {Object|null}
     */
    checkForParent(record) {
        if (record.parentId) {
            const view = this.view;

            return view.store.get(record.parentId);
        } else {
            return null;
        }
    }

    /**
     * Depending on {-1|1} step return
     * -1: previous record OR parent record
     *  1: next record or null
     *
     * @param {Object} record
     * @param {Number} step
     * @returns {Object|null}
     */
    checkForSibling(record, step) {
        const view           = this.view,
              store          = view.store,
              parentRecordId = record.parentId,
              recordId       = record[view.getKeyProperty()];
        let hasFoundNext   = false,
            nextItemRecord = null,
            previousItemRecord;

        for (let item of store.items) {
            if (hasFoundNext && item.parentId === parentRecordId) {
                nextItemRecord = item;
                break;
            }

            if (!hasFoundNext && item.parentId === parentRecordId) {
                if (!hasFoundNext && item[view.getKeyProperty()] === recordId) {
                    if (step === -1) break;
                    hasFoundNext = true;
                } else {
                    previousItemRecord = item;
                }
            }
        }

        return step === 1 ? nextItemRecord : (previousItemRecord || store.get(parentRecordId));
    }

    /**
     * Find the next sibling of a parent item
     * @param {Object} record
     * @returns {Object|null}
     */
    checkNextParentSibling(record) {
        const parent = this.view.store.get(record.parentId);
        let parentSibling = this.checkForSibling(parent, 1);

        if (!parentSibling && parent.parentId) this.checkNextParentSibling(parent);

        return parentSibling;
    }

    /**
     * Called by keys (List.mjs:register)
     * Toggle collapse or if isLeaf select next item
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        let me     = this,
            view   = me.view,
            itemId = me.getSelection()[0],
            record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || record.collapsed) {
            me.onKeyDownRight(data);
        } else {
            me.onKeyDownLeft(data);
        }
    }

    /**
     * Called by keys (List.mjs:register)
     * Deselect all and fire event selectPostLastItem
     * @param {Object} data
     */
    onKeyDownEscape(data) {
        let me = this;

        me.deselectAll();
    }

    /**
     * Collapse folder or select previous
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        const me     = this,
              view   = me.view,
              itemId = me.getSelection()[0];

        if (!itemId) {
            me.selectRoot();
            return;
        }

        const record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || record.collapsed || !view.rootParentsAreCollapsible) {
            me.onNavKey(data, -1);
        } else {
            me.toggleCollapsed(record, itemId, true);
        }
    }

    /**
     * Open folder or select next
     * @param {Object} data
     */
    onKeyDownRight(data) {
        const me     = this,
              view   = me.view,
              itemId = me.getSelection()[0];

        if (!itemId) {
            me.selectRoot();
            return;
        }

        const record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || !record.collapsed) {
            me.onNavKey(data, 1);
        } else {
            me.toggleCollapsed(record, itemId, false);
        }
    }

    /**
     * Handles 'up' and 'down' keys
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        const me   = this,
              view = me.view,
              item = me.getSelection()[0];
        let newRecord;

        if (item) {
            const recordId = view.getItemRecordId(item);
            let record = view.store.get(recordId);

            if (step === 1) {
                if (!record.isLeaf && !record.collapsed) {
                    // find first child
                    newRecord = this.checkForChild(record);
                } else {
                    // find next sibling
                    newRecord = this.checkForSibling(record, step);
                    // no ==> loop through parent next siblings until no parent
                    if (!newRecord) {
                        newRecord = this.checkNextParentSibling(record);
                    }
                }
                // current item was the last item
                if (!newRecord) {
                    me.deselectAll();
                    view.fire('selectPostLastItem');
                }
            } else if (step === -1) {
                // check previous sibling
                newRecord = this.checkForSibling(record, step);
                // no ==> get parent
                if (!newRecord) {
                    newRecord = this.checkForParent(record);
                }
                // current item was the first item
                if (!newRecord) {
                    me.deselectAll();
                    view.fire('selectPreFirstItem');
                }
            }
        } else {
            me.selectRoot();
        }

        if (newRecord) {
            const itemId = view.getItemId(newRecord[me.view.getKeyProperty()]);

            me.selectAndScrollIntoView(itemId);
        }
    }

    /**
     * Select an item and scroll the tree to show the item in the center
     * @param {String} itemId
     */
    selectAndScrollIntoView(itemId) {
        const me = this;

        me.select(itemId);

        Neo.main.DomAccess.scrollIntoView({
            id   : itemId,
            block: 'center'
        });
    }

    /**
     * Select the root item of the tree
     */
    selectRoot() {
        const me    = this,
              view  = me.view,
              store = view.store;
        let rootItemId;

        for (let record of store.items) {
            if (!record.parentId) {
                rootItemId = view.getItemId(record[me.view.getKeyProperty()]);
                break;
            }
        }

        me.selectAndScrollIntoView(rootItemId);
    }

    /**
     * Return the parent record if any
     * @param {Object} record
     * @param {String} itemId
     * @param {Boolean} collapse
     */
    toggleCollapsed(record, itemId, collapse) {
        const me    = this,
              item  = me.view.getVdomChild(itemId),
              clsFn = collapse ? 'remove' : 'add';

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][clsFn](item.cls, 'neo-folder-open');
        me.view.update();

        record.collapsed = collapse;
    }
}

Neo.applyClassConfig(TreeAccordionModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TreeAccordionModel);

/***/ }),

/***/ "./src/tree/Accordion.mjs":
/*!********************************!*\
  !*** ./src/tree/Accordion.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tree_List_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/List.mjs */ "./src/tree/List.mjs");
/* harmony import */ var _selection_TreeAccordionModel_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection/TreeAccordionModel.mjs */ "./src/selection/TreeAccordionModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");





/**
 * @class Neo.tree.Accordion
 * @extends Neo.tree.List
 */
class AccordionTree extends _tree_List_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tree.Accordion'
         * @protected
         */
        className: 'Neo.tree.Accordion',
        /**
         * @member {String} ntype='treeaccordion'
         * @protected
         */
        ntype: 'treeaccordion',
        /**
         * @member {String[]} baseCls=['neo-tree-accordion']
         */
        baseCls: ['neo-tree-list'],
        /**
         * @member {Boolean} showCollapseExpandAllIcons=true
         */
        showCollapseExpandAllIcons: false,
        /**
         * Set to false will auto expand root parent items and disallow collapsing
         * @member {Boolean} rootParentIsCollapsible=false
         */
        rootParentsAreCollapsible_: false,
        /**
         * Set to false to hide the initial root item
         * @member {Boolean} firstParentIsVisible=true
         */
        firstParentIsVisible_: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
            {
                cn: [
                    {tag: 'ul', cls: ['neo-list-container', 'neo-list', 'neo-accordion-style'], tabIndex: -1, cn: []}
                ]
            }
    }

    onConstructed() {
        super.onConstructed();
        let me = this;

        me.addDomListeners({
            focusin: me.onFocus,
            scope  : me
        })
    }

    /**
     * Called when changing firstParentIsVisible
     * First store item gets marked and additional css class
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetFirstParentIsVisible(value, oldValue) {
        const toggleFn = !value ? 'addCls' : 'removeCls';

        this[toggleFn]('first-parent-not-visible');

        if (this.store.first()) {
            this.store.first().visible = value;
        }
    }

    /**
     * Called when changing rootParentsAreCollapsible
     * Ensures that root items are expanded if not collapsible
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetRootParentsAreCollapsible(value, oldValue) {
        const me       = this,
              toggleFn = !value ? 'addCls' : 'removeCls';

        me[toggleFn]('root-not-collapsible');

        if (me.rendered && value === false) {
            const store = me.store;

            store.items.forEach(record => {
                if (record.parentId === null && !record.isLeaf) {
                    me.expandItem(record);
                }
            })
        }
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].beforeSetInstance(value, _selection_TreeAccordionModel_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }

    /**
     * @param {String} [parentId] The parent node
     * @param {Object} [vdomRoot] The vdom template root for the current sub tree
     * @param {Number} level The hierarchy level of the tree
     * @returns {Object} vdomRoot
     * @protected
     */
    createItems(parentId, vdomRoot, level) {
        let me        = this,
            items     = me.store.find('parentId', parentId),
            itemCls   = me.itemCls,
            folderCls = me.folderCls,
            cls, tmpRoot;

        if (items.length > 0) {
            if (!vdomRoot.cn) {
                vdomRoot.cn = [];
            }

            if (parentId !== null) {
                vdomRoot.cn.push({
                    tag  : 'ul',
                    cls  : ['neo-list'],
                    cn   : [],
                    style: {
                        paddingLeft: '15px'
                    }
                });

                tmpRoot = vdomRoot.cn[vdomRoot.cn.length - 1];
            } else {
                tmpRoot = vdomRoot;
            }

            items.forEach(item => {
                cls = [itemCls];

                if (item.isLeaf) {
                    cls.push(itemCls + (item.singleton ? '-leaf-singleton' : '-leaf'));
                } else {
                    cls.push(folderCls);

                    if (!item.parentId && !me.rootParentsAreCollapsible) {

                        cls.push('neo-not-collapsible');
                        if (item.collapsed) {
                            item.collapsed = false;
                        }
                    }
                    if (!item.collapsed) {
                        cls.push('neo-folder-open');
                    }
                }

                tmpRoot.cn.push({
                    tag  : 'li',
                    cls,
                    id   : me.getItemId(item.id),
                    cn   : [{
                        tag      : 'span',
                        cls      : ['neo-accordion-item-icon', item.iconCls],
                        removeDom: !item.isLeaf
                    }, {
                        cls  : [itemCls + '-content'],
                        style: {pointerEvents: 'none'},
                        cn   : [{
                            tag      : 'span',
                            cls      : [itemCls + '-content-header'],
                            innerHTML: item.name
                        }, {
                            tag      : 'span',
                            cls      : [itemCls + '-content-text'],
                            innerHTML: item.content
                        }]
                    }],
                    style: {
                        padding : '10px',
                        position: item.isLeaf ? null : 'sticky',
                        top     : item.isLeaf ? null : (level * 38) + 'px',
                        zIndex  : item.isLeaf ? null : (20 / (level + 1)),
                    }
                });

                tmpRoot = me.createItems(item.id, tmpRoot, level + 1);
            });
        }

        return vdomRoot;
    }


    /**
     * Expands an item based on the reord
     * @param {Object} record
     */
    expandItem(record) {
        const me     = this,
              itemId = me.getItemId(record[me.getKeyProperty()]),
              item   = me.getVdomChild(itemId);

        record.collapsed = false;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(item.cls, 'neo-folder-open');
        me.update();
    }

    /**
     * @param {Object} item
     * @param {Object} data
     */
    onItemClick(item, data) {
        super.onItemClick(item, data);

        const me             = this,
              selectionModel = me.selectionModel,
              itemId         = item.id,
              // ! todo make it String
              id             = Number(itemId.split('__')[1]),
              record         = me.store.get(id);

        selectionModel.select(item.id);

        if (!record.isLeaf) {
            /**
             * The folderItemClick event fires when a click occurs on a list item which does have child items.
             * Passes the item record to the event handler.
             * @event folderItemClick
             * @returns {Object} record
             */
            me.fire('folderItemClick', {record});

            record.collapsed = !record.collapsed
        }
    }

    /**
     * To place the root item at the correct location
     * @returns {Object}
     */
    getListItemsRoot() {
        return this.vdom.cn[0];
    }

    /**
     * Accordion gaining focus without selection => setSelection
     * @param {Object} data
     */
    onFocus(data) {
        const me        = this,
              selModel  = me.selectionModel,
              selection = selModel.getSelection()[0];

        if (!selection) selModel.selectRoot();
    }

    // Todo Might be needed
    onStoreLoad() {
    }

    onStoreRecordChange() {
    }
}

Neo.applyClassConfig(AccordionTree);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AccordionTree);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX3RyZWVTZWxlY3Rpb25Nb2RlbF9hcHBfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTs7QUFFWjtBQUNPO0FBQ0g7QUFDSzs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixvRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWdFO0FBQzdGO0FBQ0EsU0FBUztBQUNULDRCQUE0QixvRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkRBQTJEO0FBQ3hGLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLGtFQUFXO0FBQ2xDO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQTZDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVCx1QkFBdUIsa0VBQVc7QUFDbEM7QUFDQTtBQUNBLHdCQUF3Qiw0Q0FBNEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUNBQWlDLDJEQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQ0FBbUM7QUFDeEQscUJBQXFCLGdDQUFnQztBQUNyRCxxQkFBcUIsZ0NBQWdDO0FBQ3JELHFCQUFxQiw0QkFBNEI7QUFDakQscUJBQXFCLGdDQUFnQztBQUNyRCxxQkFBcUIsNkJBQTZCO0FBQ2xELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHdCQUF3QiwrREFBYTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsYUFBYSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDN0ltQjs7QUFFekM7QUFDUCxjQUFjLDBEQUFhO0FBQzNCO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMdUM7QUFDRTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVM7QUFDMUM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxrQkFBa0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BTaUI7QUFDbUI7QUFDbEI7QUFDTTs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVE7QUFDcEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSw2REFBZSwwQkFBMEIseUVBQWtCO0FBQzFFOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esd0NBQXdDLE9BQU87O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy90cmVlU2VsZWN0aW9uTW9kZWwvTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL3RyZWVTZWxlY3Rpb25Nb2RlbC9hcHAubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL1RyZWVBY2NvcmRpb25Nb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90cmVlL0FjY29yZGlvbi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbmZpZ3VyYXRpb25WaWV3cG9ydCBmcm9tICcuLi9Db25maWd1cmF0aW9uVmlld3BvcnQubWpzJztcblxuaW1wb3J0IFN0b3JlICAgICAgICAgZnJvbSAnLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcbmltcG9ydCBOdW1iZXJGaWVsZCAgIGZyb20gJy4uLy4uL3NyYy9mb3JtL2ZpZWxkL051bWJlci5tanMnO1xuaW1wb3J0IEFjY29yZGlvblRyZWUgZnJvbSAnLi4vLi4vc3JjL3RyZWUvQWNjb3JkaW9uLm1qcyc7XG5pbXBvcnQgQ2hlY2tCb3ggICAgICBmcm9tIFwiLi4vLi4vc3JjL2Zvcm0vZmllbGQvQ2hlY2tCb3gubWpzXCI7XG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy50cmVlU2VsZWN0aW9uTW9kZWwuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmV4YW1wbGVzLkNvbmZpZ3VyYXRpb25WaWV3cG9ydFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgQ29uZmlndXJhdGlvblZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWUgICAgICAgICAgIDogJ05lby5leGFtcGxlcy50cmVlU2VsZWN0aW9uTW9kZWwuTWFpbkNvbnRhaW5lcicsXG4gICAgICAgIGF1dG9Nb3VudCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICBjb25maWdJdGVtTGFiZWxXaWR0aDogMTAwLFxuICAgICAgICBjb25maWdJdGVtV2lkdGggICAgIDogMjMwLFxuICAgICAgICBsYXlvdXQgICAgICAgICAgICAgIDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICBjbHMgICAgICAgICAgICAgICAgIDogWydleGFtcGxlcy1jb250YWluZXItYWNjb3JkaW9uJ11cbiAgICB9XG5cbiAgICBvbkNvbmZpZ0NoYW5nZShjb25maWcsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5leGFtcGxlQ29tcG9uZW50Lml0ZW1zWzBdW2NvbmZpZ10gPSBvcHRzLnZhbHVlO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnRzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdHJlZUxpc3QgPSBtZS5leGFtcGxlQ29tcG9uZW50Lml0ZW1zWzBdO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IENoZWNrQm94LFxuICAgICAgICAgICAgY2hlY2tlZCAgICAgICA6IHRyZWVMaXN0LnJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUsXG4gICAgICAgICAgICBoaWRlTGFiZWwgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGhpZGVWYWx1ZUxhYmVsOiBmYWxzZSxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICAgOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAncm9vdFBhcmVudHNBcmVDb2xsYXBzaWJsZScpfSxcbiAgICAgICAgICAgIHZhbHVlTGFiZWxUZXh0OiAncm9vdFBhcmVudHNBcmVDb2xsYXBzaWJsZSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IENoZWNrQm94LFxuICAgICAgICAgICAgY2hlY2tlZCAgICAgICA6IHRyZWVMaXN0LmZpcnN0UGFyZW50SXNWaXNpYmxlLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICA6IHRydWUsXG4gICAgICAgICAgICBoaWRlVmFsdWVMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgIDoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2ZpcnN0UGFyZW50SXNWaXNpYmxlJyl9LFxuICAgICAgICAgICAgc3R5bGUgICAgICAgICA6IHttYXJnaW5Ub3A6ICcxMHB4J30sXG4gICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogJ2ZpcnN0UGFyZW50SXNWaXNpYmxlJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IE51bWJlckZpZWxkLFxuICAgICAgICAgICAgY2xlYXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2hlaWdodCcpfSxcbiAgICAgICAgICAgIG1heFZhbHVlIDogMTIwMCxcbiAgICAgICAgICAgIG1pblZhbHVlIDogNDAwLFxuICAgICAgICAgICAgc3RlcFNpemUgOiA1LFxuICAgICAgICAgICAgdmFsdWUgICAgOiB0cmVlTGlzdC5oZWlnaHQsXG4gICAgICAgICAgICBzdHlsZSAgICA6IHttYXJnaW5Ub3A6ICcxMHB4J31cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBOdW1iZXJGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ3dpZHRoJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ3dpZHRoJyl9LFxuICAgICAgICAgICAgbWF4VmFsdWUgOiAxMjAwLFxuICAgICAgICAgICAgbWluVmFsdWUgOiAyMDAsXG4gICAgICAgICAgICBzdGVwU2l6ZSA6IDUsXG4gICAgICAgICAgICBzdHlsZSAgICA6IHttYXJnaW5Ub3A6ICcxMHB4J30sXG4gICAgICAgICAgICB2YWx1ZSAgICA6IHRyZWVMaXN0LndpZHRoXG4gICAgICAgIH1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNyZWF0ZUV4YW1wbGVDb21wb25lbnQoKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gTmVvLmNyZWF0ZShTdG9yZSwge1xuICAgICAgICAgICAga2V5UHJvcGVydHk6ICdpZCcsXG4gICAgICAgICAgICBtb2RlbCAgICAgIDoge1xuICAgICAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2NvbGxhcHNlZCcsIHR5cGU6ICdCb29sZWFuJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnY29udGVudCcsIHR5cGU6ICdTdHJpbmcnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdpY29uQ2xzJywgdHlwZTogJ1N0cmluZyd9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgdHlwZTogJ0ludGVnZXInfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdpc0xlYWYnLCB0eXBlOiAnQm9vbGVhbid9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ25hbWUnLCB0eXBlOiAnU3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncGFyZW50SWQnLCB0eXBlOiAnSW50ZWdlcid9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gTmVvLm50eXBlKHtcbiAgICAgICAgICAgIG50eXBlIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgIGl0ZW1zIDogW3tcbiAgICAgICAgICAgICAgICAvLyAgICAgbW9kdWxlOiBUZXh0RmllbGQsXG4gICAgICAgICAgICAgICAgLy8gICAgIGxhYmVsOiAnVGVzdCcsXG4gICAgICAgICAgICAgICAgLy8gICAgIHBsdWdpbjoge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgUGx1Z2luOiB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYm9sZDogdHJ1ZVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfSx7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBBY2NvcmRpb25UcmVlLFxuICAgICAgICAgICAgICAgIHN0b3JlIDogc3RvcmUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MDAsXG4gICAgICAgICAgICAgICAgd2lkdGggOiA0MDAsXG5cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgYWZ0ZXJTZXRNb3VudGVkIHJ1bnMgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgc3RvcmVMb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFmdGVyU2V0TW91bnRlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0b3JlTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgTmVvLlhoci5wcm9taXNlSnNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICcuLi8uLi9leGFtcGxlcy90cmVlU2VsZWN0aW9uTW9kZWwvdHJlZS5qc29uJ1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgICAgICA9IGRhdGEuanNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyYXkgPSBbJ3JlZCcsICd5ZWxsb3cnLCAnZ3JlZW4nXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25BcnJheSAgPSBbJ2hvbWUnLCAnaW5kdXN0cnknLCAndXNlciddO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcmFuZG9tIGljb25DbHMgY29sb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLmljb25DbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaWNvbkNscyA9ICdmYSBmYS0nICsgaWNvbkFycmF5W3JhbmRdICsgJyBjb2xvci0nICsgY29sb3JBcnJheVtyYW5kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc3RvcmUuZGF0YSA9IGRhdGEuanNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKG51bGwsIG1lLmdldExpc3RJdGVtc1Jvb3QoKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoTWFpbkNvbnRhaW5lcik7XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5Db250YWluZXI7XG4iLCJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL01haW5Db250YWluZXIubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogTWFpbkNvbnRhaW5lcixcbiAgICBuYW1lICAgIDogJ05lby5leGFtcGxlcy50cmVlU2VsZWN0aW9uTW9kZWwnXG59KTtcbiIsImltcG9ydCBUcmVlTW9kZWwgZnJvbSAnLi9UcmVlTW9kZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSBcIi4uL3V0aWwvQXJyYXkubWpzXCI7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uVHJlZUFjY29yZGlvbk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uc2VsZWN0aW9uLlRyZWVNb2RlbFxuICovXG5jbGFzcyBUcmVlQWNjb3JkaW9uTW9kZWwgZXh0ZW5kcyBUcmVlTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5UcmVlQWNjb3JkaW9uTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uVHJlZUFjY29yZGlvbk1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi10cmVlYWNjb3JkaW9ubW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLXRyZWVhY2NvcmRpb25tb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmllcyB0byBmaW5kIGEgY2hpbGQgYW5kIHJldHVybnMgaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGNoZWNrRm9yQ2hpbGQocmVjb3JkKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgICAgID0gdGhpcy52aWV3LFxuICAgICAgICAgICAgICByZWNvcmRJZCA9IHJlY29yZFt2aWV3LmdldEtleVByb3BlcnR5KCldO1xuICAgICAgICBsZXQgY2hpbGRSZWNvcmQgPSBudWxsO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2aWV3LnN0b3JlLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnRJZCA9PT0gcmVjb3JkSWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFJlY29yZCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGRSZWNvcmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXJlbnQgcmVjb3JkIGlmIGFueVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgY2hlY2tGb3JQYXJlbnQocmVjb3JkKSB7XG4gICAgICAgIGlmIChyZWNvcmQucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZpZXc7XG5cbiAgICAgICAgICAgIHJldHVybiB2aWV3LnN0b3JlLmdldChyZWNvcmQucGFyZW50SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXBlbmRpbmcgb24gey0xfDF9IHN0ZXAgcmV0dXJuXG4gICAgICogLTE6IHByZXZpb3VzIHJlY29yZCBPUiBwYXJlbnQgcmVjb3JkXG4gICAgICogIDE6IG5leHQgcmVjb3JkIG9yIG51bGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja0ZvclNpYmxpbmcocmVjb3JkLCBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgICAgICAgICAgID0gdGhpcy52aWV3LFxuICAgICAgICAgICAgICBzdG9yZSAgICAgICAgICA9IHZpZXcuc3RvcmUsXG4gICAgICAgICAgICAgIHBhcmVudFJlY29yZElkID0gcmVjb3JkLnBhcmVudElkLFxuICAgICAgICAgICAgICByZWNvcmRJZCAgICAgICA9IHJlY29yZFt2aWV3LmdldEtleVByb3BlcnR5KCldO1xuICAgICAgICBsZXQgaGFzRm91bmROZXh0ICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG5leHRJdGVtUmVjb3JkID0gbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzSXRlbVJlY29yZDtcblxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHN0b3JlLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaGFzRm91bmROZXh0ICYmIGl0ZW0ucGFyZW50SWQgPT09IHBhcmVudFJlY29yZElkKSB7XG4gICAgICAgICAgICAgICAgbmV4dEl0ZW1SZWNvcmQgPSBpdGVtO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc0ZvdW5kTmV4dCAmJiBpdGVtLnBhcmVudElkID09PSBwYXJlbnRSZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzRm91bmROZXh0ICYmIGl0ZW1bdmlldy5nZXRLZXlQcm9wZXJ0eSgpXSA9PT0gcmVjb3JkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXAgPT09IC0xKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaGFzRm91bmROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0l0ZW1SZWNvcmQgPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGVwID09PSAxID8gbmV4dEl0ZW1SZWNvcmQgOiAocHJldmlvdXNJdGVtUmVjb3JkIHx8IHN0b3JlLmdldChwYXJlbnRSZWNvcmRJZCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG5leHQgc2libGluZyBvZiBhIHBhcmVudCBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja05leHRQYXJlbnRTaWJsaW5nKHJlY29yZCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnZpZXcuc3RvcmUuZ2V0KHJlY29yZC5wYXJlbnRJZCk7XG4gICAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gdGhpcy5jaGVja0ZvclNpYmxpbmcocGFyZW50LCAxKTtcblxuICAgICAgICBpZiAoIXBhcmVudFNpYmxpbmcgJiYgcGFyZW50LnBhcmVudElkKSB0aGlzLmNoZWNrTmV4dFBhcmVudFNpYmxpbmcocGFyZW50KTtcblxuICAgICAgICByZXR1cm4gcGFyZW50U2libGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkga2V5cyAoTGlzdC5tanM6cmVnaXN0ZXIpXG4gICAgICogVG9nZ2xlIGNvbGxhcHNlIG9yIGlmIGlzTGVhZiBzZWxlY3QgbmV4dCBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25FbnRlcihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmlldyAgID0gbWUudmlldyxcbiAgICAgICAgICAgIGl0ZW1JZCA9IG1lLmdldFNlbGVjdGlvbigpWzBdLFxuICAgICAgICAgICAgcmVjb3JkID0gdmlldy5zdG9yZS5nZXQodmlldy5nZXRJdGVtUmVjb3JkSWQoaXRlbUlkKSk7XG5cbiAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgfHwgcmVjb3JkLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgbWUub25LZXlEb3duUmlnaHQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5vbktleURvd25MZWZ0KGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGtleXMgKExpc3QubWpzOnJlZ2lzdGVyKVxuICAgICAqIERlc2VsZWN0IGFsbCBhbmQgZmlyZSBldmVudCBzZWxlY3RQb3N0TGFzdEl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVzY2FwZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZGVzZWxlY3RBbGwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSBmb2xkZXIgb3Igc2VsZWN0IHByZXZpb3VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25MZWZ0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgdmlldyAgID0gbWUudmlldyxcbiAgICAgICAgICAgICAgaXRlbUlkID0gbWUuZ2V0U2VsZWN0aW9uKClbMF07XG5cbiAgICAgICAgaWYgKCFpdGVtSWQpIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdFJvb3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHZpZXcuc3RvcmUuZ2V0KHZpZXcuZ2V0SXRlbVJlY29yZElkKGl0ZW1JZCkpO1xuXG4gICAgICAgIGlmIChyZWNvcmQuaXNMZWFmIHx8IHJlY29yZC5jb2xsYXBzZWQgfHwgIXZpZXcucm9vdFBhcmVudHNBcmVDb2xsYXBzaWJsZSkge1xuICAgICAgICAgICAgbWUub25OYXZLZXkoZGF0YSwgLTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUudG9nZ2xlQ29sbGFwc2VkKHJlY29yZCwgaXRlbUlkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gZm9sZGVyIG9yIHNlbGVjdCBuZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25SaWdodChkYXRhKSB7XG4gICAgICAgIGNvbnN0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgIHZpZXcgICA9IG1lLnZpZXcsXG4gICAgICAgICAgICAgIGl0ZW1JZCA9IG1lLmdldFNlbGVjdGlvbigpWzBdO1xuXG4gICAgICAgIGlmICghaXRlbUlkKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3RSb290KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWNvcmQgPSB2aWV3LnN0b3JlLmdldCh2aWV3LmdldEl0ZW1SZWNvcmRJZChpdGVtSWQpKTtcblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiB8fCAhcmVjb3JkLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgbWUub25OYXZLZXkoZGF0YSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS50b2dnbGVDb2xsYXBzZWQocmVjb3JkLCBpdGVtSWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgJ3VwJyBhbmQgJ2Rvd24nIGtleXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgb25OYXZLZXkoZGF0YSwgc3RlcCkge1xuICAgICAgICBjb25zdCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgICAgdmlldyA9IG1lLnZpZXcsXG4gICAgICAgICAgICAgIGl0ZW0gPSBtZS5nZXRTZWxlY3Rpb24oKVswXTtcbiAgICAgICAgbGV0IG5ld1JlY29yZDtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkSWQgPSB2aWV3LmdldEl0ZW1SZWNvcmRJZChpdGVtKTtcbiAgICAgICAgICAgIGxldCByZWNvcmQgPSB2aWV3LnN0b3JlLmdldChyZWNvcmRJZCk7XG5cbiAgICAgICAgICAgIGlmIChzdGVwID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNvcmQuaXNMZWFmICYmICFyZWNvcmQuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlyc3QgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVjb3JkID0gdGhpcy5jaGVja0ZvckNoaWxkKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBuZXh0IHNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVjb3JkID0gdGhpcy5jaGVja0ZvclNpYmxpbmcocmVjb3JkLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gPT0+IGxvb3AgdGhyb3VnaCBwYXJlbnQgbmV4dCBzaWJsaW5ncyB1bnRpbCBubyBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JlY29yZCA9IHRoaXMuY2hlY2tOZXh0UGFyZW50U2libGluZyhyZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaXRlbSB3YXMgdGhlIGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgIGlmICghbmV3UmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRlc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZmlyZSgnc2VsZWN0UG9zdExhc3RJdGVtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHByZXZpb3VzIHNpYmxpbmdcbiAgICAgICAgICAgICAgICBuZXdSZWNvcmQgPSB0aGlzLmNoZWNrRm9yU2libGluZyhyZWNvcmQsIHN0ZXApO1xuICAgICAgICAgICAgICAgIC8vIG5vID09PiBnZXQgcGFyZW50XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVjb3JkID0gdGhpcy5jaGVja0ZvclBhcmVudChyZWNvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGl0ZW0gd2FzIHRoZSBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3RQcmVGaXJzdEl0ZW0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zZWxlY3RSb290KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3UmVjb3JkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtSWQgPSB2aWV3LmdldEl0ZW1JZChuZXdSZWNvcmRbbWUudmlldy5nZXRLZXlQcm9wZXJ0eSgpXSk7XG5cbiAgICAgICAgICAgIG1lLnNlbGVjdEFuZFNjcm9sbEludG9WaWV3KGl0ZW1JZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYW4gaXRlbSBhbmQgc2Nyb2xsIHRoZSB0cmVlIHRvIHNob3cgdGhlIGl0ZW0gaW4gdGhlIGNlbnRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKi9cbiAgICBzZWxlY3RBbmRTY3JvbGxJbnRvVmlldyhpdGVtSWQpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbGVjdChpdGVtSWQpO1xuXG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICBpZCAgIDogaXRlbUlkLFxuICAgICAgICAgICAgYmxvY2s6ICdjZW50ZXInXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgcm9vdCBpdGVtIG9mIHRoZSB0cmVlXG4gICAgICovXG4gICAgc2VsZWN0Um9vdCgpIHtcbiAgICAgICAgY29uc3QgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgICB2aWV3ICA9IG1lLnZpZXcsXG4gICAgICAgICAgICAgIHN0b3JlID0gdmlldy5zdG9yZTtcbiAgICAgICAgbGV0IHJvb3RJdGVtSWQ7XG5cbiAgICAgICAgZm9yIChsZXQgcmVjb3JkIG9mIHN0b3JlLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIXJlY29yZC5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIHJvb3RJdGVtSWQgPSB2aWV3LmdldEl0ZW1JZChyZWNvcmRbbWUudmlldy5nZXRLZXlQcm9wZXJ0eSgpXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5zZWxlY3RBbmRTY3JvbGxJbnRvVmlldyhyb290SXRlbUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBhcmVudCByZWNvcmQgaWYgYW55XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxhcHNlXG4gICAgICovXG4gICAgdG9nZ2xlQ29sbGFwc2VkKHJlY29yZCwgaXRlbUlkLCBjb2xsYXBzZSkge1xuICAgICAgICBjb25zdCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICAgIGl0ZW0gID0gbWUudmlldy5nZXRWZG9tQ2hpbGQoaXRlbUlkKSxcbiAgICAgICAgICAgICAgY2xzRm4gPSBjb2xsYXBzZSA/ICdyZW1vdmUnIDogJ2FkZCc7XG5cbiAgICAgICAgTmVvQXJyYXlbY2xzRm5dKGl0ZW0uY2xzLCAnbmVvLWZvbGRlci1vcGVuJyk7XG4gICAgICAgIG1lLnZpZXcudXBkYXRlKCk7XG5cbiAgICAgICAgcmVjb3JkLmNvbGxhcHNlZCA9IGNvbGxhcHNlO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoVHJlZUFjY29yZGlvbk1vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgVHJlZUFjY29yZGlvbk1vZGVsOyIsImltcG9ydCBUcmVlTGlzdCAgICAgICAgICAgZnJvbSAnLi4vdHJlZS9MaXN0Lm1qcyc7XG5pbXBvcnQgVHJlZUFjY29yZGlvbk1vZGVsIGZyb20gXCIuLi9zZWxlY3Rpb24vVHJlZUFjY29yZGlvbk1vZGVsLm1qc1wiO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgICBmcm9tIFwiLi4vdXRpbC9BcnJheS5tanNcIjtcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgICAgZnJvbSBcIi4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzXCI7XG5cbi8qKlxuICogQGNsYXNzIE5lby50cmVlLkFjY29yZGlvblxuICogQGV4dGVuZHMgTmVvLnRyZWUuTGlzdFxuICovXG5jbGFzcyBBY2NvcmRpb25UcmVlIGV4dGVuZHMgVHJlZUxpc3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRyZWUuQWNjb3JkaW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udHJlZS5BY2NvcmRpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndHJlZWFjY29yZGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0cmVlYWNjb3JkaW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRyZWUtYWNjb3JkaW9uJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRyZWUtbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0NvbGxhcHNlRXhwYW5kQWxsSWNvbnM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0NvbGxhcHNlRXhwYW5kQWxsSWNvbnM6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGZhbHNlIHdpbGwgYXV0byBleHBhbmQgcm9vdCBwYXJlbnQgaXRlbXMgYW5kIGRpc2FsbG93IGNvbGxhcHNpbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcm9vdFBhcmVudElzQ29sbGFwc2libGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byBmYWxzZSB0byBoaWRlIHRoZSBpbml0aWFsIHJvb3QgaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmaXJzdFBhcmVudElzVmlzaWJsZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBmaXJzdFBhcmVudElzVmlzaWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7dGFnOiAndWwnLCBjbHM6IFsnbmVvLWxpc3QtY29udGFpbmVyJywgJ25lby1saXN0JywgJ25lby1hY2NvcmRpb24tc3R5bGUnXSwgdGFiSW5kZXg6IC0xLCBjbjogW119XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgZm9jdXNpbjogbWUub25Gb2N1cyxcbiAgICAgICAgICAgIHNjb3BlICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gY2hhbmdpbmcgZmlyc3RQYXJlbnRJc1Zpc2libGVcbiAgICAgKiBGaXJzdCBzdG9yZSBpdGVtIGdldHMgbWFya2VkIGFuZCBhZGRpdGlvbmFsIGNzcyBjbGFzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldEZpcnN0UGFyZW50SXNWaXNpYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCB0b2dnbGVGbiA9ICF2YWx1ZSA/ICdhZGRDbHMnIDogJ3JlbW92ZUNscyc7XG5cbiAgICAgICAgdGhpc1t0b2dnbGVGbl0oJ2ZpcnN0LXBhcmVudC1ub3QtdmlzaWJsZScpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0b3JlLmZpcnN0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZmlyc3QoKS52aXNpYmxlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2luZyByb290UGFyZW50c0FyZUNvbGxhcHNpYmxlXG4gICAgICogRW5zdXJlcyB0aGF0IHJvb3QgaXRlbXMgYXJlIGV4cGFuZGVkIGlmIG5vdCBjb2xsYXBzaWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgdG9nZ2xlRm4gPSAhdmFsdWUgPyAnYWRkQ2xzJyA6ICdyZW1vdmVDbHMnO1xuXG4gICAgICAgIG1lW3RvZ2dsZUZuXSgncm9vdC1ub3QtY29sbGFwc2libGUnKTtcblxuICAgICAgICBpZiAobWUucmVuZGVyZWQgJiYgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZSA9IG1lLnN0b3JlO1xuXG4gICAgICAgICAgICBzdG9yZS5pdGVtcy5mb3JFYWNoKHJlY29yZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5wYXJlbnRJZCA9PT0gbnVsbCAmJiAhcmVjb3JkLmlzTGVhZikge1xuICAgICAgICAgICAgICAgICAgICBtZS5leHBhbmRJdGVtKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnNlbGVjdGlvbi5Nb2RlbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgVHJlZUFjY29yZGlvbk1vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmVudElkXSBUaGUgcGFyZW50IG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Zkb21Sb290XSBUaGUgdmRvbSB0ZW1wbGF0ZSByb290IGZvciB0aGUgY3VycmVudCBzdWIgdHJlZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgaGllcmFyY2h5IGxldmVsIG9mIHRoZSB0cmVlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdmRvbVJvb3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMocGFyZW50SWQsIHZkb21Sb290LCBsZXZlbCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICAgICA9IG1lLnN0b3JlLmZpbmQoJ3BhcmVudElkJywgcGFyZW50SWQpLFxuICAgICAgICAgICAgaXRlbUNscyAgID0gbWUuaXRlbUNscyxcbiAgICAgICAgICAgIGZvbGRlckNscyA9IG1lLmZvbGRlckNscyxcbiAgICAgICAgICAgIGNscywgdG1wUm9vdDtcblxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCF2ZG9tUm9vdC5jbikge1xuICAgICAgICAgICAgICAgIHZkb21Sb290LmNuID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZkb21Sb290LmNuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0YWcgIDogJ3VsJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLWxpc3QnXSxcbiAgICAgICAgICAgICAgICAgICAgY24gICA6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICcxNXB4J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0bXBSb290ID0gdmRvbVJvb3QuY25bdmRvbVJvb3QuY24ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSB2ZG9tUm9vdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjbHMgPSBbaXRlbUNsc107XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzLnB1c2goaXRlbUNscyArIChpdGVtLnNpbmdsZXRvbiA/ICctbGVhZi1zaW5nbGV0b24nIDogJy1sZWFmJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKGZvbGRlckNscyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLnBhcmVudElkICYmICFtZS5yb290UGFyZW50c0FyZUNvbGxhcHNpYmxlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tbm90LWNvbGxhcHNpYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZm9sZGVyLW9wZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRtcFJvb3QuY24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRhZyAgOiAnbGknLFxuICAgICAgICAgICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiBtZS5nZXRJdGVtSWQoaXRlbS5pZCksXG4gICAgICAgICAgICAgICAgICAgIGNuICAgOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWFjY29yZGlvbi1pdGVtLWljb24nLCBpdGVtLmljb25DbHNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiAhaXRlbS5pc0xlYWZcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzICA6IFtpdGVtQ2xzICsgJy1jb250ZW50J10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge3BvaW50ZXJFdmVudHM6ICdub25lJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjbiAgIDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcgICAgICA6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IFtpdGVtQ2xzICsgJy1jb250ZW50LWhlYWRlciddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogaXRlbS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbaXRlbUNscyArICctY29udGVudC10ZXh0J10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MOiBpdGVtLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA6ICcxMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpdGVtLmlzTGVhZiA/IG51bGwgOiAnc3RpY2t5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBpdGVtLmlzTGVhZiA/IG51bGwgOiAobGV2ZWwgKiAzOCkgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4ICA6IGl0ZW0uaXNMZWFmID8gbnVsbCA6ICgyMCAvIChsZXZlbCArIDEpKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdG1wUm9vdCA9IG1lLmNyZWF0ZUl0ZW1zKGl0ZW0uaWQsIHRtcFJvb3QsIGxldmVsICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZG9tUm9vdDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYW4gaXRlbSBiYXNlZCBvbiB0aGUgcmVvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICovXG4gICAgZXhwYW5kSXRlbShyZWNvcmQpIHtcbiAgICAgICAgY29uc3QgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgaXRlbUlkID0gbWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSksXG4gICAgICAgICAgICAgIGl0ZW0gICA9IG1lLmdldFZkb21DaGlsZChpdGVtSWQpO1xuXG4gICAgICAgIHJlY29yZC5jb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgICAgICBOZW9BcnJheS5hZGQoaXRlbS5jbHMsICduZW8tZm9sZGVyLW9wZW4nKTtcbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKGl0ZW0sIGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25JdGVtQ2xpY2soaXRlbSwgZGF0YSk7XG5cbiAgICAgICAgY29uc3QgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbCA9IG1lLnNlbGVjdGlvbk1vZGVsLFxuICAgICAgICAgICAgICBpdGVtSWQgICAgICAgICA9IGl0ZW0uaWQsXG4gICAgICAgICAgICAgIC8vICEgdG9kbyBtYWtlIGl0IFN0cmluZ1xuICAgICAgICAgICAgICBpZCAgICAgICAgICAgICA9IE51bWJlcihpdGVtSWQuc3BsaXQoJ19fJylbMV0pLFxuICAgICAgICAgICAgICByZWNvcmQgICAgICAgICA9IG1lLnN0b3JlLmdldChpZCk7XG5cbiAgICAgICAgc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGl0ZW0uaWQpO1xuXG4gICAgICAgIGlmICghcmVjb3JkLmlzTGVhZikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZm9sZGVySXRlbUNsaWNrIGV2ZW50IGZpcmVzIHdoZW4gYSBjbGljayBvY2N1cnMgb24gYSBsaXN0IGl0ZW0gd2hpY2ggZG9lcyBoYXZlIGNoaWxkIGl0ZW1zLlxuICAgICAgICAgICAgICogUGFzc2VzIHRoZSBpdGVtIHJlY29yZCB0byB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICAgICAqIEBldmVudCBmb2xkZXJJdGVtQ2xpY2tcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlY29yZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtZS5maXJlKCdmb2xkZXJJdGVtQ2xpY2snLCB7cmVjb3JkfSk7XG5cbiAgICAgICAgICAgIHJlY29yZC5jb2xsYXBzZWQgPSAhcmVjb3JkLmNvbGxhcHNlZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gcGxhY2UgdGhlIHJvb3QgaXRlbSBhdCB0aGUgY29ycmVjdCBsb2NhdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TGlzdEl0ZW1zUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2NvcmRpb24gZ2FpbmluZyBmb2N1cyB3aXRob3V0IHNlbGVjdGlvbiA9PiBzZXRTZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXMoZGF0YSkge1xuICAgICAgICBjb25zdCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICBzZWxNb2RlbCAgPSBtZS5zZWxlY3Rpb25Nb2RlbCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VsTW9kZWwuZ2V0U2VsZWN0aW9uKClbMF07XG5cbiAgICAgICAgaWYgKCFzZWxlY3Rpb24pIHNlbE1vZGVsLnNlbGVjdFJvb3QoKTtcbiAgICB9XG5cbiAgICAvLyBUb2RvIE1pZ2h0IGJlIG5lZWRlZFxuICAgIG9uU3RvcmVMb2FkKCkge1xuICAgIH1cblxuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2UoKSB7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhBY2NvcmRpb25UcmVlKTtcblxuZXhwb3J0IGRlZmF1bHQgQWNjb3JkaW9uVHJlZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9