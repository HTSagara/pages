"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_list_Base_mjs"],{

/***/ "./src/list/Base.mjs":
/*!***************************!*\
  !*** ./src/list/Base.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _selection_ListModel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selection/ListModel.mjs */ "./src/selection/ListModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");






/**
 * @class Neo.list.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Base'
         * @protected
         */
        className: 'Neo.list.Base',
        /**
         * @member {String} ntype='list'
         * @protected
         */
        ntype: 'list',
        /**
         * @member {Boolean} animate_=false
         */
        animate_: false,
        /**
         * True will destroy the used collection / store when the component gets destroyed
         * @member {Boolean} autoDestroyStore=true
         */
        autoDestroyStore: true,
        /**
         * @member {String[]} baseCls=['neo-list']
         */
        baseCls: ['neo-list'],
        /**
         * An optional record field to make items non-clickable and visually greyed out.
         * The field expects the Boolean type.
         * @member {String} disabledField='disabled'
         */
        disabledField: 'disabled',
        /**
         * @member {Boolean} disableSelection_=false
         */
        disableSelection_: false,
        /**
         * @member {String} displayField='name'
         */
        displayField: 'name',
        /**
         * @member {Boolean} draggable_=false
         */
        draggable_: false,
        /**
         * @member {Neo.draggable.list.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * Keeps track of the focussed item index and allows bindings and programmatic changes.
         * You can either pass the index or the related record
         * @member {Number|Object|null} focusIndex_=null
         */
        focusIndex_: null,
        /**
         * In case we are using list item headers and want to bind list item indexes to e.g. a card layout
         * for e.g. a sidenav, this config comes in handy.
         * @member {Number|null} headerlessSelectedIndex_=null
         */
        headerlessSelectedIndex_: null,
        /**
         * @member {Boolean} highlightFilterValue=true
         */
        highlightFilterValue: true,
        /**
         * @member {String} itemCls='neo-list-item'
         */
        itemCls: 'neo-list-item',
        /**
         * Defaults to px
         * @member {Number|null} itemHeight_=null
         */
        itemHeight_: null,
        /**
         * The type of the node / tag for each list item
         * @member {String} itemTagName='li'
         */
        itemTagName: 'li',
        /**
         * Defaults to px
         * @member {Number|null} itemWidth_=null
         */
        itemWidth_: null,
        /**
         * @member {Boolean} itemsFocusable=true
         */
        itemsFocusable: true,
        /**
         * The config will get passed to the navigator main thread addon.
         * E.g. for ComboBoxes, which shall preserve their focussed list item when filtering the store, use true.
         * @member {Boolean} keepFocusIndex=false
         */
        keepFocusIndex: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * config values for Neo.list.plugin.Animate
         * @member {Object} pluginAnimateConfig=null
         */
        pluginAnimateConfig: null,
        /**
         * Keeps track of the selected item index and allows bindings and programmatic changes
         * @member {Number|null} selectedIndex_=null
         */
        selectedIndex_: null,
        /**
         * Either pass a selection.Model module, an instance or a config object
         * @member {Object|Neo.selection.Model} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * Set this to true in case a select event should only update _vdom (e.g. when used inside a form.field.Select
         * @member {Boolean} silentSelect=false
         */
        silentSelect: false,
        /**
         * @member {Neo.data.Store|null} store_=null
         */
        store_: null,
        /**
         * True will add a checkbox in front of each list item
         * @member {Boolean} stacked_=true
         */
        useCheckBoxes_: false,
        /**
         * Setting this config to true will switch to dl, dt & dd tags instead of using ul & li.
         * Use the {Boolean} model field isHeader.
         * @member {Boolean} useHeaders_=false
         */
        useHeaders_: false,
        /**
         * @member {Boolean} useWrapperNode_=false
         */
        useWrapperNode_: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
            {tag: 'ul', cn: []}
    }

    /**
     * @member {String|null} itemRole=null
     */
    itemRole = null
    /**
     * An object to help configure the navigation. Used to pass to {@link Neo.main.addon.Navigator#subscribe}.
     * @member {Object} navigator={}
     */
    navigator = {}
    /**
     * Defaults to false in case useHeaders is set to true
     * @member {Boolean} scrollIntoViewOnFocus=true
     */
    scrollIntoViewOnFocus = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.useHeaders) {
            me.scrollIntoViewOnFocus = false;
        }

        me.addDomListeners({
            click: me.onClick,
            scope: me
        })
    }

    /**
     * Triggered after the animate config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAnimate(value, oldValue) {
        value && __webpack_require__.e(/*! import() */ "vendors-src_list_plugin_Animate_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/Animate.mjs */ "./src/list/plugin/Animate.mjs")).then(module => {
            let me      = this,
                plugins = me.plugins || [];

            plugins.push({
                module : module.default,
                appName: me.appName,
                id     : 'animate',
                ...me.pluginAnimateConfig
            });

            me.plugins = plugins
        })
    }

    /**
     * Triggered after the disableSelection config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisableSelection(value, oldValue) {
        value && this.rendered && this.selectionModel?.deselectAll()
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value && !me.dragZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_list_DragZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/list/DragZone.mjs */ "./src/draggable/list/DragZone.mjs")).then(module => {
                me.dragZone = Neo.create({
                    module : module.default,
                    appName: me.appName,
                    owner  : me,
                    ...me.dragZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the focusIndex config got changed
     * @param {Number|Object|null} value
     * @param {Number|Object|null} oldValue
     * @protected
     */
    afterSetFocusIndex(value, oldValue) {
        let me = this;

        if (Neo.isNumber(value)) {
            Neo.main.addon.Navigator.navigateTo([me.getHeaderlessIndex(value), me.navigator])
        } else if (value) {
            Neo.main.addon.Navigator.navigateTo([me.getItemId(value[me.getKeyProperty()]), me.navigator])
        }
    }

    /**
     * Triggered after the headerlessSelectedIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetHeaderlessSelectedIndex(value, oldValue) {
        let me = this;

        if (Neo.isNumber(value)) {
            me.selectedIndex = me.store.getCount() ? me.getSelectedIndex(value) : null
        } else if (Neo.isNumber(oldValue)) {
            me.selectedIndex = null
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        const me = this;

        // Tear down navigation before we lose the element
        if (!value && me.hasNavigator) {
            Neo.main.addon.Navigator.unsubscribe(me.navigator);

            me.hasNavigator  = false;
            me.selectedIndex = null
        }

        if (value) {
            // Set up item navigation in the list
            if (!me.hasNavigator) {
                me.navigator = {
                    appName       : me.appName,
                    id            : me.id,
                    keepFocusIndex: me.keepFocusIndex,
                    selector      : `.${me.itemCls}:not(.neo-disabled,.neo-list-header)`,
                    windowId      : me.windowId,
                    ...me.navigator
                };

                me.hasNavigator = true
            }

            Neo.main.addon.Navigator.subscribe(me.navigator)
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * Triggered after the selectedIndex config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetSelectedIndex(value, oldValue) {
        let me             = this,
            selectionModel = me.selectionModel;

        if (Neo.isNumber(value)) {
            selectionModel?.selectAt(value);
            me.headerlessSelectedIndex = me.getHeaderlessIndex(value)
        } else if (Neo.isNumber(oldValue)) {
            selectionModel.deselectAll();
            me.headerlessSelectedIndex = null
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.rendered && value.register(this)
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me = this;

        value?.on({
            filter      : 'onStoreFilter',
            load        : 'onStoreLoad',
            recordChange: 'onStoreRecordChange',
            sort        : 'onStoreSort',
            scope       : me
        });

        value?.getCount() > 0 && me.onStoreLoad()
    }

    /**
     * Triggered after the useCheckBoxes config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseCheckBoxes(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-use-checkicons', !!value);
        me.cls = cls
    }

    /**
     * Triggered after the useHeaders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseHeaders(value, oldValue) {
        if (value) {
            let me = this;

            me.vdom.tag = 'dl';
            me.itemTagName = 'dd'
        }
    }

    /**
     * Triggered after the useWrapperNode config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseWrapperNode(value, oldValue) {
        let me         = this,
            cls        = me.cls,
            wrapperCls = me.wrapperCls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-use-wrapper-node');
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](wrapperCls, 'neo-list-wrapper');

        me.wrapperCls = wrapperCls;
        me.cls        = cls
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_ListModel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store} value
     * @param {Object|Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Override this method for custom list items
     * @param {Object} record
     * @param {Number} index
     * @returns {Object} The list item vdom object
     */
    createItem(record, index) {
        let me             = this,
            cls            = [me.itemCls],
            hasItemHeight  = me.itemHeight !== null,
            hasItemWidth   = me.itemWidth  !== null,
            isHeader       = me.useHeaders && record.isHeader,
            itemContent    = me.createItemContent(record, index),
            itemId         = me.getItemId(record[me.getKeyProperty()]),
            selectionModel = me.selectionModel,
            isSelected     = !me.disableSelection && selectionModel?.isSelected(itemId),
            item;

        isHeader && cls.push('neo-list-header');

        if (isSelected){
            cls.push(selectionModel.selectedCls)
        }

        if (record.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, record.cls)
        }

        if (record[me.disabledField]) {
            cls.push('neo-disabled')
        }

        item = {
            id  : itemId,
            tag : isHeader ? 'dt' : me.itemTagName,
            'aria-selected' : isSelected,
            cls
        };

        if (me.itemsFocusable) {
            item.tabIndex = -1
        }

        if (record.hidden) {
            item.removeDom = true
        }

        if (me.itemRole) {
            item.role = me.itemRole
        }

        switch (Neo.typeOf(itemContent)) {
            case null: {
                return null;
            }

            case 'Array': {
                item.cn = itemContent;
                break;
            }

            case 'Object': {
                // We want a merge for custom cls rules
                if (itemContent.cls) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(item.cls, itemContent.cls);
                    delete itemContent.cls
                }

                Object.assign(item, itemContent);
                break;
            }

            case 'Number':
            case 'String': {
                item.html = itemContent;
                break;
            }
        }

        if (hasItemHeight || hasItemWidth) {
            item.style = item.style || {};

            if (hasItemHeight && !item.hasOwnProperty('height')) {
                item.style.height = `${me.itemHeight}px`
            }

            if (hasItemWidth && !item.hasOwnProperty('width')) {
                item.style.width = `${me.itemWidth}px`
            }
        }

        return item
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me       = this,
            itemText = record[me.displayField],
            filter;

        if (me.highlightFilterValue) {
            filter = me.store.getFilter(me.displayField);

            if (filter && filter.value !== null && filter.value !== '') {
                itemText = itemText.replace(new RegExp(filter.value, 'gi'), function(match) {
                    return '<span class="neo-highlight-search">' + match + '</span>'
                })
            }
        }

        return itemText
    }

    /**
     * @param {Boolean} silent=false
     */
    createItems(silent=false) {
        let me                      = this,
            headerlessSelectedIndex = me.headerlessSelectedIndex,
            vdom                    = me.getVdomRoot(),
            listItem;

        // in case we set headerlessSelectedIndex before the store was loaded, selectedIndex can be null
        // and the wanted selection is not initially there
        if (Neo.isNumber(headerlessSelectedIndex) && !Neo.isNumber(me.selectedIndex)) {
            me.afterSetHeaderlessSelectedIndex(headerlessSelectedIndex, null)
        }

        if (!(me.animate && !me.getPlugin('animate'))) {
            vdom.cn = [];

            me.store.items.forEach((item, index) => {
                listItem = me.createItem(item, index);
                listItem && vdom.cn.push(listItem)
            });

            !silent && me.promiseUpdate().then(() => {
                me.fire('createItems')
            })
        }
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.selectionModel?.destroy();

        me.autoDestroyStore && me.store?.destroy();

        super.destroy(...args)
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} id
     */
    focus(id) {
        Neo.main.addon.Navigator.navigateTo([id, this.navigator])
    }

    /**
     * Transforms an index excluding list item headers into the real store index
     * @param {Number} headerlessSelectedIndex
     * @returns {Number}
     */
    getSelectedIndex(headerlessSelectedIndex) {
        let delta   = 0,
            i       = 0,
            records = this.store.items,
            len     = headerlessSelectedIndex;

        if (records.length < 1) {
            return null
        }

        for (; i <= len; i++) {
            if (records[i].isHeader) {
                delta++;
                len++
            }
        }

        return headerlessSelectedIndex + delta
    }

    /**
     * Returns the index of a list item excluding item headers
     * @param {Number} index
     * @returns {Number}
     */
    getHeaderlessIndex(index) {
        let headerlessIndex = 0,
            i               = 0,
            records         = this.store.items;

        for (; i < index; i++) {
            if (!records[i].isHeader) {
                headerlessIndex++
            }
        }

        return headerlessIndex
    }

    /**
     * @param {Number|String|object} recordOrId
     * @returns {String}
     */
    getItemId(recordOrId) {
        return `${this.id}__${recordOrId.isRecord ? recordOrId[this.getKeyProperty()] : recordOrId}`
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId   = vnodeId.split('__')[1],
            model    = this.store.model,
            keyField = model?.getField(model.keyProperty),
            keyType  = keyField?.type?.toLowerCase();

        if (keyType === 'int' || keyType === 'integer') {
            itemId = parseInt(itemId)
        }

        return itemId
    }

    /**
     * Support collections & stores
     * @returns {String}
     */
    getKeyProperty() {
        return this.store.keyProperty || this.store.model.keyProperty
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        let me = this,
            item;

        if (data.path[0].id === me.id) {
            me.onContainerClick(data)
        } else {
            for (item of data.path) {
                if (item.cls.includes(me.itemCls)) {
                    me.onItemClick(item, data);
                    break
                }
            }
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onContainerClick(data) {
        /**
         * The containerClick event fires when a click occurs on the component, but not on a list item
         * @event containerClick
         * @param {String[]} cls the classList of the target node (converted to an array)
         * @param {String} id the target dom id
         * @param {String[]} path the event path
         * @returns {Object}
         */
        this.fire('containerClick', data)
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me     = this,
            record = me.store.get(me.getItemRecordId(node.id));

        // pass the record to class extensions
        data.record = record;

        /**
         * The itemClick event fires when a click occurs on a list item
         * @event itemClick
         * @param {String} id the record matching the list item
         * @returns {Object}
         */
        me.fire('itemClick', {
            record
        })
    }

    /**
     *
     */
    onStoreFilter() {
        this.createItems()
    }

    /**
     *
     */
    onStoreLoad() {
        let me = this,
            listenerId;

        if (!me.mounted && me.rendering) {
            listenerId = me.on('mounted', () => {
                me.un('mounted', listenerId);
                me.createItems()
            });
        } else {
            me.createItems()
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Number} data.index
     * @param {Neo.data.Model} data.model
     * @param {Object} data.record
     *
     */
    onStoreRecordChange(data) {
        let me    = this,
            index = data.index;

        // ignore changes for records which have not been added to the list yet
        if (index > -1) {
            me.vdom.cn[index] = me.createItem(data.record, index);
            me.update()
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        this.createItems()
    }

    /**
     * Convenience shortcut
     * @param {Number|String} item
     */
    selectItem(item) {
        let me = this;

        if (!me.disableSelection) {
            // Selecting index
            if (Neo.isNumber(item)) {
                me.selectionModel?.selectAt(item)
            }
            // Selecting record
            else if (item) {
                me.selectionModel?.selectAt(me.store.indexOf(item))
            }
        }
    }
}

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/selection/ListModel.mjs":
/*!*************************************!*\
  !*** ./src/selection/ListModel.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");


/**
 * @class Neo.selection.ListModel
 * @extends Neo.selection.Model
 */
class ListModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.ListModel'
         * @protected
         */
        className: 'Neo.selection.ListModel',
        /**
         * @member {String} ntype='selection-listmodel'
         * @protected
         */
        ntype: 'selection-listmodel'
    }

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownEscape(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownDown(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownEnter(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownLeft(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownRight(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownUp(data) {}

    /**
     * @param {Object} data
     */
    onListClick({ currentTarget }) {
        const {view} = this;

        if (!view.disableSelection) {
            const record = view.store.get(view.getItemRecordId(currentTarget));

            if (record) {
                this.select(record)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onListNavigate(data) {
        const
            {view}  = this,
            {store} = view;

        data.record      = store.getAt(Math.min(data.activeIndex, store.getCount()));
        view._focusIndex = store.indexOf(data.record); // silent update, no need to refocus

        view.fire('itemNavigate', data)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me         = this,
            {id, view} = me;

        view.addDomListeners([{
            click: me.onListClick,
            scope: me,

            // Should be `.${view.itemCls}:not(.neo-disabled,.neo-list-header)`
            // TODO parse delegate selectors
            delegate: path => {
                for (let i = 0, { length } = path; i < length; i++) {
                    const { cls } = path[i];

                    if (cls.includes(view.itemCls) && !cls.includes('neo-disabled') && !cls.includes('neo-list-header')) {
                        return i;
                    }
                }
            }
        }, {
            neonavigate : me.onListNavigate,
            scope       : me
        }]);

        view.keys?._keys.push(
            {fn: 'onKeyDownDown'   ,key: 'Down'   ,scope: id},
            {fn: 'onKeyDownEnter'  ,key: 'Enter'  ,scope: id},
            {fn: 'onKeyDownEscape' ,key: 'Escape' ,scope: id},
            {fn: 'onKeyDownLeft'   ,key: 'Left'   ,scope: id},
            {fn: 'onKeyDownRight'  ,key: 'Right'  ,scope: id},
            {fn: 'onKeyDownUp'     ,key: 'Up'     ,scope: id}
        )
    }

    /**
     * @param {Number} index
     */
    selectAt(index) {
        let view      = this.view,
            recordKey = view?.store.getKeyAt(index),
            itemId    = recordKey && view.getItemId(recordKey);

        if (itemId) {
            this.select(itemId)
        }
    }

    /**
     *
     */
    unregister() {
        let me   = this,
            id   = me.id,
            view = me.view;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown'   ,key: 'Down'   ,scope: id},
            {fn: 'onKeyDownEnter'  ,key: 'Enter'  ,scope: id},
            {fn: 'onKeyDownEscape' ,key: 'Escape' ,scope: id},
            {fn: 'onKeyDownLeft'   ,key: 'Left'   ,scope: id},
            {fn: 'onKeyDownRight'  ,key: 'Right'  ,scope: id},
            {fn: 'onKeyDownUp'     ,key: 'Up'     ,scope: id}
        ]);

        super.unregister()
    }
}

Neo.setupClass(ListModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListModel);


/***/ }),

/***/ "./src/selection/Model.mjs":
/*!*********************************!*\
  !*** ./src/selection/Model.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.selection.Model
 * @extends Neo.core.Base
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.selection.Model'
         * @protected
         */
        className: 'Neo.selection.Model',
        /**
         * @member {String} ntype='selection-model'
         * @protected
         */
        ntype: 'selection-model',
        /**
         * Placeholder for extended classes to add a custom css rule to this owner component
         * @member {String|null} cls=null
         * @protected
         */
        cls: null,
        /**
         * @member {Array} items_=null
         * @protected
         */
        items_: null,
        /**
         * @member {String} selectedCls='selected'
         */
        selectedCls: 'neo-selected',
        /**
         * @member {Boolean} singleSelect=true
         */
        singleSelect: true,
        /**
         * Internally saves the view id, but the getter will return the matching instance
         * @member {Object} view_=null
         * @protected
         */
        view_: null
    }

    /**
     * Gets triggered before getting the value of the items config
     * @param {Array|null} value
     * @returns {Array}
     */
    beforeGetItems(value) {
        if (!value) {
            this._items = value = [];
        }

        return value;
    }

    /**
     * Gets triggered before getting the value of the view config
     * @param {String} value
     * @returns {Neo.component.Base}
     */
    beforeGetView(value) {
        return Neo.getComponent(this._view);
    }

    /**
     * Gets triggered before setting the value of the view config
     * @returns {String} the view id
     */
    beforeSetView(value) {
        return value && value.id;
    }

    /**
     *
     */
    addDomListener() {}

    /**
     * @param {Object} item
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    deselect(item, silent, itemCollection=this.items, selectedCls) {
        // We hold vdom ids for now, so all incoming selections must be converted.
        item = item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item;

        if (itemCollection.includes(item)) {
            let me   = this,
                view = me.view,
                node = view.getVdomChild(item);

            if (node) {
                node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(node.cls || [], selectedCls || me.selectedCls);
                node['aria-selected'] = false;
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(itemCollection, item);

            if (!silent) {
                view.update();

                me.fire('selectionChange', {
                    selection : itemCollection
                });
            }
        }
        else if (!silent) {
            this.fire('noChange');
        }
    }

    /**
     * @param {Boolean} [silent] true to prevent a vdom update
     */
    deselectAll(silent) {
        let me    = this,
            items = [...me.items],
            view  = me.view;

        if (items.length) {
            items.forEach(item => {
                me.deselect(item, true);
            });

            if (!silent && items.length > 0) {
                view.update();
            }

            me.fire('selectionChange', {
                selection : this.items
            });
        }
        else if (!silent) {
            me.fire('noChange');
        }
    }

    /**
     *
     */
    destroy() {
        this.unregister();
        super.destroy();
    }

    /**
     * @returns {Array} this.items
     */
    getSelection() {
        return this.items;
    }

    /**
     * @returns {Boolean} true in case there is a selection
     */
    hasSelection() {
        return this.items.length > 0;
    }

    /**
     * @param {String} id
     * @returns {Boolean} true in case the item is selected
     */
    isSelected(id) {
        return this.items.includes(id);
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me  = this,
            cls = component.cls || [];

        if (me.cls && !cls.includes(me.cls)) {
            cls.push(me.cls);
            component.cls = cls;
        }

        me.view = component;
        me.addDomListener();
    }

    /**
     *
     */
    removeDomListeners() {
        let me           = this,
            component    = me.view,
            domListeners = [...component.domListeners];

        component.domListeners.forEach(listener => {
            if (listener.scope === me) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(domListeners, listener);
            }
        });

        component.domListeners = domListeners;
    }

    /**
     * @param {Object|Object[]|String[]} items
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    select(items, itemCollection=this.items, selectedCls) {
        let me     = this,
            {view} = me;

        // We hold vdom ids for now, so all incoming selections must be converted.
        items = (items = Array.isArray(items) ?
            items : [items]).map(item => item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item);

        if (!Neo.isEqual(itemCollection, items)) {
            if (me.singleSelect) {
                me.deselectAll(true)
            }

            items.forEach((node, i) => {
                node = view.getVdomChild(node);

                if (node) {
                    node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls || [], selectedCls || me.selectedCls);
                    node['aria-selected'] = true
                }
            });

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemCollection, items);

            !view.silentSelect && view.update();

            view.onSelect?.(items);

            me.fire('selectionChange', {
                selection: itemCollection
            })
        }
        else {
            me.fire('noChange')
        }
    }

    /**
     * @param {Object} item
     */
    toggleSelection(item) {
        let me = this;

        if (me.isSelected(item)) {
            me.deselect(item)
        } else {
            me.select(item)
        }
    }

    /**
     *
     */
    unregister() {
        let me  = this,
            cls = me.view.cls || [];

        if (me.cls && cls.includes(me.cls)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, me.cls);
            me.view.cls = cls;
        }

        me.deselectAll();

        me.removeDomListeners();
    }
}

Neo.setupClass(Model);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Model);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUNGO0FBQ0s7QUFDVDtBQUNBOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBUztBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx1REFBUTtBQUNwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xpc3QvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vTGlzdE1vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9Nb2RlbC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgTGlzdE1vZGVsICAgICAgIGZyb20gJy4uL3NlbGVjdGlvbi9MaXN0TW9kZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICBmcm9tICcuLi9kYXRhL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5saXN0LkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5saXN0LkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5saXN0LkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFuaW1hdGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdpbGwgZGVzdHJveSB0aGUgdXNlZCBjb2xsZWN0aW9uIC8gc3RvcmUgd2hlbiB0aGUgY29tcG9uZW50IGdldHMgZGVzdHJveWVkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9EZXN0cm95U3RvcmU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0Rlc3Ryb3lTdG9yZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWxpc3QnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgcmVjb3JkIGZpZWxkIHRvIG1ha2UgaXRlbXMgbm9uLWNsaWNrYWJsZSBhbmQgdmlzdWFsbHkgZ3JleWVkIG91dC5cbiAgICAgICAgICogVGhlIGZpZWxkIGV4cGVjdHMgdGhlIEJvb2xlYW4gdHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXNhYmxlZEZpZWxkPSdkaXNhYmxlZCdcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkRmllbGQ6ICdkaXNhYmxlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlU2VsZWN0aW9uXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZVNlbGVjdGlvbl86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXNwbGF5RmllbGQ9J25hbWUnXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwbGF5RmllbGQ6ICduYW1lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyYWdnYWJsZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnYWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS5saXN0LkRyYWdab25lfG51bGx9IGRyYWdab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcmFnWm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnWm9uZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBmb2N1c3NlZCBpdGVtIGluZGV4IGFuZCBhbGxvd3MgYmluZGluZ3MgYW5kIHByb2dyYW1tYXRpYyBjaGFuZ2VzLlxuICAgICAgICAgKiBZb3UgY2FuIGVpdGhlciBwYXNzIHRoZSBpbmRleCBvciB0aGUgcmVsYXRlZCByZWNvcmRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfE9iamVjdHxudWxsfSBmb2N1c0luZGV4Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBmb2N1c0luZGV4XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2Ugd2UgYXJlIHVzaW5nIGxpc3QgaXRlbSBoZWFkZXJzIGFuZCB3YW50IHRvIGJpbmQgbGlzdCBpdGVtIGluZGV4ZXMgdG8gZS5nLiBhIGNhcmQgbGF5b3V0XG4gICAgICAgICAqIGZvciBlLmcuIGEgc2lkZW5hdiwgdGhpcyBjb25maWcgY29tZXMgaW4gaGFuZHkuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVybGVzc1NlbGVjdGVkSW5kZXhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGlnaGxpZ2h0RmlsdGVyVmFsdWU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlnaGxpZ2h0RmlsdGVyVmFsdWU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGl0ZW1DbHM9J25lby1saXN0LWl0ZW0nXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtQ2xzOiAnbmVvLWxpc3QtaXRlbScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gaXRlbUhlaWdodF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUhlaWdodF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgbm9kZSAvIHRhZyBmb3IgZWFjaCBsaXN0IGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpdGVtVGFnTmFtZT0nbGknXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtVGFnTmFtZTogJ2xpJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpdGVtV2lkdGhfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1XaWR0aF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpdGVtc0ZvY3VzYWJsZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb25maWcgd2lsbCBnZXQgcGFzc2VkIHRvIHRoZSBuYXZpZ2F0b3IgbWFpbiB0aHJlYWQgYWRkb24uXG4gICAgICAgICAqIEUuZy4gZm9yIENvbWJvQm94ZXMsIHdoaWNoIHNoYWxsIHByZXNlcnZlIHRoZWlyIGZvY3Vzc2VkIGxpc3QgaXRlbSB3aGVuIGZpbHRlcmluZyB0aGUgc3RvcmUsIHVzZSB0cnVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBrZWVwRm9jdXNJbmRleD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAga2VlcEZvY3VzSW5kZXg6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbmZpZyB2YWx1ZXMgZm9yIE5lby5saXN0LnBsdWdpbi5BbmltYXRlXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcGx1Z2luQW5pbWF0ZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwbHVnaW5BbmltYXRlQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIHNlbGVjdGVkIGl0ZW0gaW5kZXggYW5kIGFsbG93cyBiaW5kaW5ncyBhbmQgcHJvZ3JhbW1hdGljIGNoYW5nZXNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHNlbGVjdGVkSW5kZXhfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkSW5kZXhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogRWl0aGVyIHBhc3MgYSBzZWxlY3Rpb24uTW9kZWwgbW9kdWxlLCBhbiBpbnN0YW5jZSBvciBhIGNvbmZpZyBvYmplY3RcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fE5lby5zZWxlY3Rpb24uTW9kZWx9IHNlbGVjdGlvbk1vZGVsXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25Nb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGluIGNhc2UgYSBzZWxlY3QgZXZlbnQgc2hvdWxkIG9ubHkgdXBkYXRlIF92ZG9tIChlLmcuIHdoZW4gdXNlZCBpbnNpZGUgYSBmb3JtLmZpZWxkLlNlbGVjdFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWxlbnRTZWxlY3Q9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudFNlbGVjdDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBzdG9yZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aWxsIGFkZCBhIGNoZWNrYm94IGluIGZyb250IG9mIGVhY2ggbGlzdCBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHN0YWNrZWRfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHVzZUNoZWNrQm94ZXNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyBjb25maWcgdG8gdHJ1ZSB3aWxsIHN3aXRjaCB0byBkbCwgZHQgJiBkZCB0YWdzIGluc3RlYWQgb2YgdXNpbmcgdWwgJiBsaS5cbiAgICAgICAgICogVXNlIHRoZSB7Qm9vbGVhbn0gbW9kZWwgZmllbGQgaXNIZWFkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZUhlYWRlcnNfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VIZWFkZXJzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VXcmFwcGVyTm9kZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHVzZVdyYXBwZXJOb2RlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAgICAgIHt0YWc6ICd1bCcsIGNuOiBbXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaXRlbVJvbGU9bnVsbFxuICAgICAqL1xuICAgIGl0ZW1Sb2xlID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0byBoZWxwIGNvbmZpZ3VyZSB0aGUgbmF2aWdhdGlvbi4gVXNlZCB0byBwYXNzIHRvIHtAbGluayBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3Ijc3Vic2NyaWJlfS5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG5hdmlnYXRvcj17fVxuICAgICAqL1xuICAgIG5hdmlnYXRvciA9IHt9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgdG8gZmFsc2UgaW4gY2FzZSB1c2VIZWFkZXJzIGlzIHNldCB0byB0cnVlXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2Nyb2xsSW50b1ZpZXdPbkZvY3VzPXRydWVcbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlld09uRm9jdXMgPSB0cnVlXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS51c2VIZWFkZXJzKSB7XG4gICAgICAgICAgICBtZS5zY3JvbGxJbnRvVmlld09uRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBjbGljazogbWUub25DbGljayxcbiAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYW5pbWF0ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFuaW1hdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIGltcG9ydCgnLi9wbHVnaW4vQW5pbWF0ZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGx1Z2lucyA9IG1lLnBsdWdpbnMgfHwgW107XG5cbiAgICAgICAgICAgIHBsdWdpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgOiAnYW5pbWF0ZScsXG4gICAgICAgICAgICAgICAgLi4ubWUucGx1Z2luQW5pbWF0ZUNvbmZpZ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnBsdWdpbnMgPSBwbHVnaW5zXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkaXNhYmxlU2VsZWN0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlzYWJsZVNlbGVjdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnZ2FibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvbGlzdC9EcmFnWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWU6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5kcmFnWm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmb2N1c0luZGV4IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZvY3VzSW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLk5hdmlnYXRvci5uYXZpZ2F0ZVRvKFttZS5nZXRIZWFkZXJsZXNzSW5kZXgodmFsdWUpLCBtZS5uYXZpZ2F0b3JdKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3IubmF2aWdhdGVUbyhbbWUuZ2V0SXRlbUlkKHZhbHVlW21lLmdldEtleVByb3BlcnR5KCldKSwgbWUubmF2aWdhdG9yXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGVhZGVybGVzc1NlbGVjdGVkSW5kZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGVhZGVybGVzc1NlbGVjdGVkSW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkSW5kZXggPSBtZS5zdG9yZS5nZXRDb3VudCgpID8gbWUuZ2V0U2VsZWN0ZWRJbmRleCh2YWx1ZSkgOiBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgbWUuc2VsZWN0ZWRJbmRleCA9IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBUZWFyIGRvd24gbmF2aWdhdGlvbiBiZWZvcmUgd2UgbG9zZSB0aGUgZWxlbWVudFxuICAgICAgICBpZiAoIXZhbHVlICYmIG1lLmhhc05hdmlnYXRvcikge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uTmF2aWdhdG9yLnVuc3Vic2NyaWJlKG1lLm5hdmlnYXRvcik7XG5cbiAgICAgICAgICAgIG1lLmhhc05hdmlnYXRvciAgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkSW5kZXggPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCBpdGVtIG5hdmlnYXRpb24gaW4gdGhlIGxpc3RcbiAgICAgICAgICAgIGlmICghbWUuaGFzTmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgbWUubmF2aWdhdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICBrZWVwRm9jdXNJbmRleDogbWUua2VlcEZvY3VzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICAgICAgOiBgLiR7bWUuaXRlbUNsc306bm90KC5uZW8tZGlzYWJsZWQsLm5lby1saXN0LWhlYWRlcilgLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCAgICAgIDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLm5hdmlnYXRvclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtZS5oYXNOYXZpZ2F0b3IgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLk5hdmlnYXRvci5zdWJzY3JpYmUobWUubmF2aWdhdG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGVkSW5kZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNlbGVjdGVkSW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbCA9IG1lLnNlbGVjdGlvbk1vZGVsO1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uc2VsZWN0QXQodmFsdWUpO1xuICAgICAgICAgICAgbWUuaGVhZGVybGVzc1NlbGVjdGVkSW5kZXggPSBtZS5nZXRIZWFkZXJsZXNzSW5kZXgodmFsdWUpXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgIG1lLmhlYWRlcmxlc3NTZWxlY3RlZEluZGV4ID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVkICYmIHZhbHVlLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgdmFsdWU/Lm9uKHtcbiAgICAgICAgICAgIGZpbHRlciAgICAgIDogJ29uU3RvcmVGaWx0ZXInLFxuICAgICAgICAgICAgbG9hZCAgICAgICAgOiAnb25TdG9yZUxvYWQnLFxuICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiAnb25TdG9yZVJlY29yZENoYW5nZScsXG4gICAgICAgICAgICBzb3J0ICAgICAgICA6ICdvblN0b3JlU29ydCcsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbHVlPy5nZXRDb3VudCgpID4gMCAmJiBtZS5vblN0b3JlTG9hZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VDaGVja0JveGVzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlQ2hlY2tCb3hlcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBtZS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby11c2UtY2hlY2tpY29ucycsICEhdmFsdWUpO1xuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUhlYWRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VIZWFkZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnZkb20udGFnID0gJ2RsJztcbiAgICAgICAgICAgIG1lLml0ZW1UYWdOYW1lID0gJ2RkJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VXcmFwcGVyTm9kZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZVdyYXBwZXJOb2RlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgICAgICAgID0gbWUuY2xzLFxuICAgICAgICAgICAgd3JhcHBlckNscyA9IG1lLndyYXBwZXJDbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tdXNlLXdyYXBwZXItbm9kZScpO1xuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKHdyYXBwZXJDbHMsICduZW8tbGlzdC13cmFwcGVyJyk7XG5cbiAgICAgICAgbWUud3JhcHBlckNscyA9IHdyYXBwZXJDbHM7XG4gICAgICAgIG1lLmNscyAgICAgICAgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5zZWxlY3Rpb24uTW9kZWx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBMaXN0TW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBTdG9yZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIGxpc3QgaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGxpc3QgaXRlbSB2ZG9tIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW0ocmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzICAgICAgICAgICAgPSBbbWUuaXRlbUNsc10sXG4gICAgICAgICAgICBoYXNJdGVtSGVpZ2h0ICA9IG1lLml0ZW1IZWlnaHQgIT09IG51bGwsXG4gICAgICAgICAgICBoYXNJdGVtV2lkdGggICA9IG1lLml0ZW1XaWR0aCAgIT09IG51bGwsXG4gICAgICAgICAgICBpc0hlYWRlciAgICAgICA9IG1lLnVzZUhlYWRlcnMgJiYgcmVjb3JkLmlzSGVhZGVyLFxuICAgICAgICAgICAgaXRlbUNvbnRlbnQgICAgPSBtZS5jcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSxcbiAgICAgICAgICAgIGl0ZW1JZCAgICAgICAgID0gbWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSksXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbCA9IG1lLnNlbGVjdGlvbk1vZGVsLFxuICAgICAgICAgICAgaXNTZWxlY3RlZCAgICAgPSAhbWUuZGlzYWJsZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb25Nb2RlbD8uaXNTZWxlY3RlZChpdGVtSWQpLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBpc0hlYWRlciAmJiBjbHMucHVzaCgnbmVvLWxpc3QtaGVhZGVyJyk7XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQpe1xuICAgICAgICAgICAgY2xzLnB1c2goc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRDbHMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLmNscykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgcmVjb3JkLmNscylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmRbbWUuZGlzYWJsZWRGaWVsZF0pIHtcbiAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZGlzYWJsZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgIGlkICA6IGl0ZW1JZCxcbiAgICAgICAgICAgIHRhZyA6IGlzSGVhZGVyID8gJ2R0JyA6IG1lLml0ZW1UYWdOYW1lLFxuICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnIDogaXNTZWxlY3RlZCxcbiAgICAgICAgICAgIGNsc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtZS5pdGVtc0ZvY3VzYWJsZSkge1xuICAgICAgICAgICAgaXRlbS50YWJJbmRleCA9IC0xXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLmhpZGRlbikge1xuICAgICAgICAgICAgaXRlbS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaXRlbVJvbGUpIHtcbiAgICAgICAgICAgIGl0ZW0ucm9sZSA9IG1lLml0ZW1Sb2xlXG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKE5lby50eXBlT2YoaXRlbUNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjYXNlIG51bGw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbiA9IGl0ZW1Db250ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdPYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCBhIG1lcmdlIGZvciBjdXN0b20gY2xzIHJ1bGVzXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1Db250ZW50LmNscykge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoaXRlbS5jbHMsIGl0ZW1Db250ZW50LmNscyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtQ29udGVudC5jbHNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW0sIGl0ZW1Db250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ1N0cmluZyc6IHtcbiAgICAgICAgICAgICAgICBpdGVtLmh0bWwgPSBpdGVtQ29udGVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJdGVtSGVpZ2h0IHx8IGhhc0l0ZW1XaWR0aCkge1xuICAgICAgICAgICAgaXRlbS5zdHlsZSA9IGl0ZW0uc3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIGlmIChoYXNJdGVtSGVpZ2h0ICYmICFpdGVtLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUuaGVpZ2h0ID0gYCR7bWUuaXRlbUhlaWdodH1weGBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0l0ZW1XaWR0aCAmJiAhaXRlbS5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUud2lkdGggPSBgJHttZS5pdGVtV2lkdGh9cHhgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtVGV4dCA9IHJlY29yZFttZS5kaXNwbGF5RmllbGRdLFxuICAgICAgICAgICAgZmlsdGVyO1xuXG4gICAgICAgIGlmIChtZS5oaWdobGlnaHRGaWx0ZXJWYWx1ZSkge1xuICAgICAgICAgICAgZmlsdGVyID0gbWUuc3RvcmUuZ2V0RmlsdGVyKG1lLmRpc3BsYXlGaWVsZCk7XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLnZhbHVlICE9PSBudWxsICYmIGZpbHRlci52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBpdGVtVGV4dCA9IGl0ZW1UZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChmaWx0ZXIudmFsdWUsICdnaScpLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwibmVvLWhpZ2hsaWdodC1zZWFyY2hcIj4nICsgbWF0Y2ggKyAnPC9zcGFuPidcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1UZXh0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcyhzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhlYWRlcmxlc3NTZWxlY3RlZEluZGV4ID0gbWUuaGVhZGVybGVzc1NlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgICAgICAgICAgICA9IG1lLmdldFZkb21Sb290KCksXG4gICAgICAgICAgICBsaXN0SXRlbTtcblxuICAgICAgICAvLyBpbiBjYXNlIHdlIHNldCBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCBiZWZvcmUgdGhlIHN0b3JlIHdhcyBsb2FkZWQsIHNlbGVjdGVkSW5kZXggY2FuIGJlIG51bGxcbiAgICAgICAgLy8gYW5kIHRoZSB3YW50ZWQgc2VsZWN0aW9uIGlzIG5vdCBpbml0aWFsbHkgdGhlcmVcbiAgICAgICAgaWYgKE5lby5pc051bWJlcihoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCkgJiYgIU5lby5pc051bWJlcihtZS5zZWxlY3RlZEluZGV4KSkge1xuICAgICAgICAgICAgbWUuYWZ0ZXJTZXRIZWFkZXJsZXNzU2VsZWN0ZWRJbmRleChoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCwgbnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKG1lLmFuaW1hdGUgJiYgIW1lLmdldFBsdWdpbignYW5pbWF0ZScpKSkge1xuICAgICAgICAgICAgdmRvbS5jbiA9IFtdO1xuXG4gICAgICAgICAgICBtZS5zdG9yZS5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtID0gbWUuY3JlYXRlSXRlbShpdGVtLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0gJiYgdmRvbS5jbi5wdXNoKGxpc3RJdGVtKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2NyZWF0ZUl0ZW1zJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5kZXN0cm95KCk7XG5cbiAgICAgICAgbWUuYXV0b0Rlc3Ryb3lTdG9yZSAmJiBtZS5zdG9yZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBmb2N1cygpIG9uIHRoZSB0b3AgbGV2ZWwgRE9NIG5vZGUgb2YgdGhpcyBjb21wb25lbnQgb3Igb24gYSBnaXZlbiBub2RlIHZpYSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqL1xuICAgIGZvY3VzKGlkKSB7XG4gICAgICAgIE5lby5tYWluLmFkZG9uLk5hdmlnYXRvci5uYXZpZ2F0ZVRvKFtpZCwgdGhpcy5uYXZpZ2F0b3JdKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gaW5kZXggZXhjbHVkaW5nIGxpc3QgaXRlbSBoZWFkZXJzIGludG8gdGhlIHJlYWwgc3RvcmUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVhZGVybGVzc1NlbGVjdGVkSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkSW5kZXgoaGVhZGVybGVzc1NlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgbGV0IGRlbHRhICAgPSAwLFxuICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICByZWNvcmRzID0gdGhpcy5zdG9yZS5pdGVtcyxcbiAgICAgICAgICAgIGxlbiAgICAgPSBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleDtcblxuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmRzW2ldLmlzSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsdGErKztcbiAgICAgICAgICAgICAgICBsZW4rK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcmxlc3NTZWxlY3RlZEluZGV4ICsgZGVsdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIGxpc3QgaXRlbSBleGNsdWRpbmcgaXRlbSBoZWFkZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJsZXNzSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgbGV0IGhlYWRlcmxlc3NJbmRleCA9IDAsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgcmVjb3JkcyAgICAgICAgID0gdGhpcy5zdG9yZS5pdGVtcztcblxuICAgICAgICBmb3IgKDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGlmICghcmVjb3Jkc1tpXS5pc0hlYWRlcikge1xuICAgICAgICAgICAgICAgIGhlYWRlcmxlc3NJbmRleCsrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVhZGVybGVzc0luZGV4XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG9iamVjdH0gcmVjb3JkT3JJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SXRlbUlkKHJlY29yZE9ySWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X18ke3JlY29yZE9ySWQuaXNSZWNvcmQgPyByZWNvcmRPcklkW3RoaXMuZ2V0S2V5UHJvcGVydHkoKV0gOiByZWNvcmRPcklkfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdm5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfSBpdGVtSWRcbiAgICAgKi9cbiAgICBnZXRJdGVtUmVjb3JkSWQodm5vZGVJZCkge1xuICAgICAgICBsZXQgaXRlbUlkICAgPSB2bm9kZUlkLnNwbGl0KCdfXycpWzFdLFxuICAgICAgICAgICAgbW9kZWwgICAgPSB0aGlzLnN0b3JlLm1vZGVsLFxuICAgICAgICAgICAga2V5RmllbGQgPSBtb2RlbD8uZ2V0RmllbGQobW9kZWwua2V5UHJvcGVydHkpLFxuICAgICAgICAgICAga2V5VHlwZSAgPSBrZXlGaWVsZD8udHlwZT8udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoa2V5VHlwZSA9PT0gJ2ludCcgfHwga2V5VHlwZSA9PT0gJ2ludGVnZXInKSB7XG4gICAgICAgICAgICBpdGVtSWQgPSBwYXJzZUludChpdGVtSWQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbUlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBjb2xsZWN0aW9ucyAmIHN0b3Jlc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0S2V5UHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmtleVByb3BlcnR5IHx8IHRoaXMuc3RvcmUubW9kZWwua2V5UHJvcGVydHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBpZiAoZGF0YS5wYXRoWzBdLmlkID09PSBtZS5pZCkge1xuICAgICAgICAgICAgbWUub25Db250YWluZXJDbGljayhkYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpdGVtIG9mIGRhdGEucGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNscy5pbmNsdWRlcyhtZS5pdGVtQ2xzKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vbkl0ZW1DbGljayhpdGVtLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsPy5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db250YWluZXJDbGljayhkYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29udGFpbmVyQ2xpY2sgZXZlbnQgZmlyZXMgd2hlbiBhIGNsaWNrIG9jY3VycyBvbiB0aGUgY29tcG9uZW50LCBidXQgbm90IG9uIGEgbGlzdCBpdGVtXG4gICAgICAgICAqIEBldmVudCBjb250YWluZXJDbGlja1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBjbHMgdGhlIGNsYXNzTGlzdCBvZiB0aGUgdGFyZ2V0IG5vZGUgKGNvbnZlcnRlZCB0byBhbiBhcnJheSlcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSB0YXJnZXQgZG9tIGlkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHBhdGggdGhlIGV2ZW50IHBhdGhcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnY29udGFpbmVyQ2xpY2snLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkl0ZW1DbGljayhub2RlLCBkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUuc3RvcmUuZ2V0KG1lLmdldEl0ZW1SZWNvcmRJZChub2RlLmlkKSk7XG5cbiAgICAgICAgLy8gcGFzcyB0aGUgcmVjb3JkIHRvIGNsYXNzIGV4dGVuc2lvbnNcbiAgICAgICAgZGF0YS5yZWNvcmQgPSByZWNvcmQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpdGVtQ2xpY2sgZXZlbnQgZmlyZXMgd2hlbiBhIGNsaWNrIG9jY3VycyBvbiBhIGxpc3QgaXRlbVxuICAgICAgICAgKiBAZXZlbnQgaXRlbUNsaWNrXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgcmVjb3JkIG1hdGNoaW5nIHRoZSBsaXN0IGl0ZW1cbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIG1lLmZpcmUoJ2l0ZW1DbGljaycsIHtcbiAgICAgICAgICAgIHJlY29yZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25TdG9yZUZpbHRlcigpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGxpc3RlbmVySWQ7XG5cbiAgICAgICAgaWYgKCFtZS5tb3VudGVkICYmIG1lLnJlbmRlcmluZykge1xuICAgICAgICAgICAgbGlzdGVuZXJJZCA9IG1lLm9uKCdtb3VudGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnVuKCdtb3VudGVkJywgbGlzdGVuZXJJZCk7XG4gICAgICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVJdGVtcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5pbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5kZXggPSBkYXRhLmluZGV4O1xuXG4gICAgICAgIC8vIGlnbm9yZSBjaGFuZ2VzIGZvciByZWNvcmRzIHdoaWNoIGhhdmUgbm90IGJlZW4gYWRkZWQgdG8gdGhlIGxpc3QgeWV0XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuW2luZGV4XSA9IG1lLmNyZWF0ZUl0ZW0oZGF0YS5yZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnByZXZpb3VzSXRlbXNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBkYXRhLnNjb3BlXG4gICAgICovXG4gICAgb25TdG9yZVNvcnQoZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaXRlbVxuICAgICAqL1xuICAgIHNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuZGlzYWJsZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gU2VsZWN0aW5nIGluZGV4XG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdEF0KGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWxlY3RpbmcgcmVjb3JkXG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdEF0KG1lLnN0b3JlLmluZGV4T2YoaXRlbSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKEJhc2UpO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlO1xuIiwiaW1wb3J0IE1vZGVsIGZyb20gJy4vTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5MaXN0TW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uTW9kZWxcbiAqL1xuY2xhc3MgTGlzdE1vZGVsIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5MaXN0TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uTGlzdE1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi1saXN0bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLWxpc3Rtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVzY2FwZShkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIHRvIGdldCBvdmVycmlkZGVuIGJ5IGNsYXNzIGV4dGVuc2lvbiBsaXN0IG1lbnUuTGlzdE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25Eb3duKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVudGVyKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkxlZnQoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBnZXQgb3ZlcnJpZGRlbiBieSBjbGFzcyBleHRlbnNpb24gbGlzdCBtZW51Lkxpc3RNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duUmlnaHQoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBnZXQgb3ZlcnJpZGRlbiBieSBjbGFzcyBleHRlbnNpb24gbGlzdCBtZW51Lkxpc3RNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duVXAoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25MaXN0Q2xpY2soeyBjdXJyZW50VGFyZ2V0IH0pIHtcbiAgICAgICAgY29uc3Qge3ZpZXd9ID0gdGhpcztcblxuICAgICAgICBpZiAoIXZpZXcuZGlzYWJsZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gdmlldy5zdG9yZS5nZXQodmlldy5nZXRJdGVtUmVjb3JkSWQoY3VycmVudFRhcmdldCkpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QocmVjb3JkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkxpc3ROYXZpZ2F0ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB7dmlld30gID0gdGhpcyxcbiAgICAgICAgICAgIHtzdG9yZX0gPSB2aWV3O1xuXG4gICAgICAgIGRhdGEucmVjb3JkICAgICAgPSBzdG9yZS5nZXRBdChNYXRoLm1pbihkYXRhLmFjdGl2ZUluZGV4LCBzdG9yZS5nZXRDb3VudCgpKSk7XG4gICAgICAgIHZpZXcuX2ZvY3VzSW5kZXggPSBzdG9yZS5pbmRleE9mKGRhdGEucmVjb3JkKTsgLy8gc2lsZW50IHVwZGF0ZSwgbm8gbmVlZCB0byByZWZvY3VzXG5cbiAgICAgICAgdmlldy5maXJlKCdpdGVtTmF2aWdhdGUnLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoY29tcG9uZW50KTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aWQsIHZpZXd9ID0gbWU7XG5cbiAgICAgICAgdmlldy5hZGREb21MaXN0ZW5lcnMoW3tcbiAgICAgICAgICAgIGNsaWNrOiBtZS5vbkxpc3RDbGljayxcbiAgICAgICAgICAgIHNjb3BlOiBtZSxcblxuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGAuJHt2aWV3Lml0ZW1DbHN9Om5vdCgubmVvLWRpc2FibGVkLC5uZW8tbGlzdC1oZWFkZXIpYFxuICAgICAgICAgICAgLy8gVE9ETyBwYXJzZSBkZWxlZ2F0ZSBzZWxlY3RvcnNcbiAgICAgICAgICAgIGRlbGVnYXRlOiBwYXRoID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgeyBsZW5ndGggfSA9IHBhdGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNscyB9ID0gcGF0aFtpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xzLmluY2x1ZGVzKHZpZXcuaXRlbUNscykgJiYgIWNscy5pbmNsdWRlcygnbmVvLWRpc2FibGVkJykgJiYgIWNscy5pbmNsdWRlcygnbmVvLWxpc3QtaGVhZGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuZW9uYXZpZ2F0ZSA6IG1lLm9uTGlzdE5hdmlnYXRlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgdmlldy5rZXlzPy5fa2V5cy5wdXNoKFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicgICAsa2V5OiAnRG93bicgICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkVudGVyJyAgLGtleTogJ0VudGVyJyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25Fc2NhcGUnICxrZXk6ICdFc2NhcGUnICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICAsa2V5OiAnTGVmdCcgICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAgLGtleTogJ1JpZ2h0JyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25VcCcgICAgICxrZXk6ICdVcCcgICAgICxzY29wZTogaWR9XG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKi9cbiAgICBzZWxlY3RBdChpbmRleCkge1xuICAgICAgICBsZXQgdmlldyAgICAgID0gdGhpcy52aWV3LFxuICAgICAgICAgICAgcmVjb3JkS2V5ID0gdmlldz8uc3RvcmUuZ2V0S2V5QXQoaW5kZXgpLFxuICAgICAgICAgICAgaXRlbUlkICAgID0gcmVjb3JkS2V5ICYmIHZpZXcuZ2V0SXRlbUlkKHJlY29yZEtleSk7XG5cbiAgICAgICAgaWYgKGl0ZW1JZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QoaXRlbUlkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgID0gbWUuaWQsXG4gICAgICAgICAgICB2aWV3ID0gbWUudmlldztcblxuICAgICAgICB2aWV3LmtleXM/LnJlbW92ZUtleXMoW1xuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicgICAsa2V5OiAnRG93bicgICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkVudGVyJyAgLGtleTogJ0VudGVyJyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25Fc2NhcGUnICxrZXk6ICdFc2NhcGUnICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICAsa2V5OiAnTGVmdCcgICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAgLGtleTogJ1JpZ2h0JyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25VcCcgICAgICxrZXk6ICdVcCcgICAgICxzY29wZTogaWR9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoTGlzdE1vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgTGlzdE1vZGVsO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBNb2RlbCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLW1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi1tb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGFjZWhvbGRlciBmb3IgZXh0ZW5kZWQgY2xhc3NlcyB0byBhZGQgYSBjdXN0b20gY3NzIHJ1bGUgdG8gdGhpcyBvd25lciBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNscz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBpdGVtc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNlbGVjdGVkQ2xzPSdzZWxlY3RlZCdcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkQ2xzOiAnbmVvLXNlbGVjdGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZVNlbGVjdD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGVTZWxlY3Q6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbGx5IHNhdmVzIHRoZSB2aWV3IGlkLCBidXQgdGhlIGdldHRlciB3aWxsIHJldHVybiB0aGUgbWF0Y2hpbmcgaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2aWV3Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZpZXdfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYmVmb3JlIGdldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSBpdGVtcyBjb25maWdcbiAgICAgKiBAcGFyYW0ge0FycmF5fG51bGx9IHZhbHVlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGJlZm9yZUdldEl0ZW1zKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gdmFsdWUgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIHZpZXcgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRWaWV3KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuX3ZpZXcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJlZm9yZSBzZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgdmlldyBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgdmlldyBpZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFZpZXcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkRG9tTGlzdGVuZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnRdIHRydWUgdG8gcHJldmVudCBhIHZkb20gdXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0ZWRDbHNdXG4gICAgICovXG4gICAgZGVzZWxlY3QoaXRlbSwgc2lsZW50LCBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zLCBzZWxlY3RlZENscykge1xuICAgICAgICAvLyBXZSBob2xkIHZkb20gaWRzIGZvciBub3csIHNvIGFsbCBpbmNvbWluZyBzZWxlY3Rpb25zIG11c3QgYmUgY29udmVydGVkLlxuICAgICAgICBpdGVtID0gaXRlbS5pc1JlY29yZCA/IHZpZXcuZ2V0SXRlbUlkKGl0ZW0pIDogTmVvLmlzT2JqZWN0KGl0ZW0pID8gaXRlbS5pZCA6IGl0ZW07XG5cbiAgICAgICAgaWYgKGl0ZW1Db2xsZWN0aW9uLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmlldyA9IG1lLnZpZXcsXG4gICAgICAgICAgICAgICAgbm9kZSA9IHZpZXcuZ2V0VmRvbUNoaWxkKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2xzID0gTmVvQXJyYXkucmVtb3ZlKG5vZGUuY2xzIHx8IFtdLCBzZWxlY3RlZENscyB8fCBtZS5zZWxlY3RlZENscyk7XG4gICAgICAgICAgICAgICAgbm9kZVsnYXJpYS1zZWxlY3RlZCddID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShpdGVtQ29sbGVjdGlvbiwgaXRlbSk7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uIDogaXRlbUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ25vQ2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnRdIHRydWUgdG8gcHJldmVudCBhIHZkb20gdXBkYXRlXG4gICAgICovXG4gICAgZGVzZWxlY3RBbGwoc2lsZW50KSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyA9IFsuLi5tZS5pdGVtc10sXG4gICAgICAgICAgICB2aWV3ICA9IG1lLnZpZXc7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdChpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXNpbGVudCAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA6IHRoaXMuaXRlbXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ25vQ2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcigpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fSB0aGlzLml0ZW1zXG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZXJlIGlzIGEgc2VsZWN0aW9uXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmluY2x1ZGVzKGlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gY29tcG9uZW50LmNscyB8fCBbXTtcblxuICAgICAgICBpZiAobWUuY2xzICYmICFjbHMuaW5jbHVkZXMobWUuY2xzKSkge1xuICAgICAgICAgICAgY2xzLnB1c2gobWUuY2xzKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5jbHMgPSBjbHM7XG4gICAgICAgIH1cblxuICAgICAgICBtZS52aWV3ID0gY29tcG9uZW50O1xuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlRG9tTGlzdGVuZXJzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCAgICA9IG1lLnZpZXcsXG4gICAgICAgICAgICBkb21MaXN0ZW5lcnMgPSBbLi4uY29tcG9uZW50LmRvbUxpc3RlbmVyc107XG5cbiAgICAgICAgY29tcG9uZW50LmRvbUxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5zY29wZSA9PT0gbWUpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoZG9tTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudC5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W118U3RyaW5nW119IGl0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0ZWRDbHNdXG4gICAgICovXG4gICAgc2VsZWN0KGl0ZW1zLCBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zLCBzZWxlY3RlZENscykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lO1xuXG4gICAgICAgIC8vIFdlIGhvbGQgdmRvbSBpZHMgZm9yIG5vdywgc28gYWxsIGluY29taW5nIHNlbGVjdGlvbnMgbXVzdCBiZSBjb252ZXJ0ZWQuXG4gICAgICAgIGl0ZW1zID0gKGl0ZW1zID0gQXJyYXkuaXNBcnJheShpdGVtcykgP1xuICAgICAgICAgICAgaXRlbXMgOiBbaXRlbXNdKS5tYXAoaXRlbSA9PiBpdGVtLmlzUmVjb3JkID8gdmlldy5nZXRJdGVtSWQoaXRlbSkgOiBOZW8uaXNPYmplY3QoaXRlbSkgPyBpdGVtLmlkIDogaXRlbSk7XG5cbiAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChpdGVtQ29sbGVjdGlvbiwgaXRlbXMpKSB7XG4gICAgICAgICAgICBpZiAobWUuc2luZ2xlU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwodHJ1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB2aWV3LmdldFZkb21DaGlsZChub2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xzID0gTmVvQXJyYXkuYWRkKG5vZGUuY2xzIHx8IFtdLCBzZWxlY3RlZENscyB8fCBtZS5zZWxlY3RlZENscyk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVbJ2FyaWEtc2VsZWN0ZWQnXSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGl0ZW1Db2xsZWN0aW9uLCBpdGVtcyk7XG5cbiAgICAgICAgICAgICF2aWV3LnNpbGVudFNlbGVjdCAmJiB2aWV3LnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICB2aWV3Lm9uU2VsZWN0Py4oaXRlbXMpO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdzZWxlY3Rpb25DaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBpdGVtQ29sbGVjdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ25vQ2hhbmdlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICovXG4gICAgdG9nZ2xlU2VsZWN0aW9uKGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICAgICAgbWUuZGVzZWxlY3QoaXRlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdChpdGVtKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLnZpZXcuY2xzIHx8IFtdO1xuXG4gICAgICAgIGlmIChtZS5jbHMgJiYgY2xzLmluY2x1ZGVzKG1lLmNscykpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIG1lLmNscyk7XG4gICAgICAgICAgICBtZS52aWV3LmNscyA9IGNscztcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRlc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgbWUucmVtb3ZlRG9tTGlzdGVuZXJzKCk7XG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGVsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9