"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_table_Container_mjs"],{

/***/ "./src/selection/table/RowModel.mjs":
/*!******************************************!*\
  !*** ./src/selection/table/RowModel.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Model.mjs */ "./src/selection/Model.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");



/**
 * @class Neo.selection.table.RowModel
 * @extends Neo.selection.Model
 */
class RowModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.table.RowModel'
         * @protected
         */
        className: 'Neo.selection.table.RowModel',
        /**
         * @member {String} ntype='selection-table-rowmodel'
         * @protected
         */
        ntype: 'selection-table-rowmodel',
        /**
         * @member {String} cls='selection-rowmodel'
         * @protected
         */
        cls: 'neo-selection-rowmodel'
    }

    /**
     *
     */
    addDomListener() {
        let me     = this,
            {view} = me;

        view.addDomListeners({
            click   : me.onRowClick,
            delegate: '.neo-table-row',
            scope   : me
        })
    }

    /**
     * Finds the matching table row for a given row index
     * @param {Number} index row index
     * @returns {String|null} The table row node id
     */
    getRowId(index) {
        if (index < 0 || this.view.store.getCount() < index) {
            return null
        }

        return this.view.vdom.cn[0].cn[1].cn[index].id
    }

    /**
     * Finds the matching table row for a given event path
     * @param {Object} path The event path
     * @returns {Object|null} The node containing the table row class or null
     * @protected
     */
    static getRowNode(path) {
        let i    = 0,
            len  = path.length,
            node = null;

        for (; i < len; i++) {
            if (path[i].cls.includes('neo-table-row')) {
                node = path[i]
            }
        }

        return node
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        this.onNavKeyRow(data, 1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        this.onNavKeyRow(data, -1)
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKeyRow(data, step) {
        let me           = this,
            node         = RowModel.getRowNode(data.path),
            {view}       = me,
            {store}      = view,
            vdomNode     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].findVdomChild(view.vdom, node.id),
            newIndex     = (vdomNode.index + step) % store.getCount(),
            {parentNode} = vdomNode,
            id;

        while (newIndex < 0) {
            newIndex += store.getCount()
        }

        id = parentNode.cn[newIndex].id;

        if (id) {
            me.select(id);
            view.focus(id);

            view.fire('select', {
                record: store.getAt(newIndex)
            })
        }
    }

    /**
     * @param {Object} data
     */
    onRowClick(data) {
        let me     = this,
            node   = RowModel.getRowNode(data.path),
            id     = node?.id,
            {view} = me,
            isSelected, record;

        if (id) {
            me.toggleSelection(id);

            isSelected = me.isSelected(id);
            record     = view.store.getAt(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].findVdomChild(view.vdom, id).index);

            !isSelected && view.onDeselect?.(record);

            view.fire(isSelected ? 'select' : 'deselect', {
                record
            })
        }
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let {id, view} = this;

        view.keys?._keys.push(
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        )
    }

    /**
     *
     */
    unregister() {
        let {id, view} = this;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        ]);

        super.unregister()
    }
}

Neo.setupClass(RowModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RowModel);


/***/ }),

/***/ "./src/table/Container.mjs":
/*!*********************************!*\
  !*** ./src/table/Container.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Css_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Css.mjs */ "./src/util/Css.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_table_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/table/RowModel.mjs */ "./src/selection/table/RowModel.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _View_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./View.mjs */ "./src/table/View.mjs");
/* harmony import */ var _header_export_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./header/_export.mjs */ "./src/table/header/_export.mjs");









/**
 * @class Neo.table.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.table.Container'
         * @protected
         */
        className: 'Neo.table.Container',
        /**
         * @member {String} ntype='table-container'
         * @protected
         */
        ntype: 'table-container',
        /**
         * todo: testing config, remove when Stores are ready
         * @member {Number} amountRows=20
         */
        amountRows: 20,
        /**
         * @member {String[]} baseCls=['neo-table-container']
         */
        baseCls: ['neo-table-container'],
        /**
         * Default configs for each column
         * @member {Object} columnDefaults=null
         */
        columnDefaults: null,
        /**
         * todo: testing config, remove when Stores are ready
         * @member {Boolean} createRandomData=false
         */
        createRandomData: false,
        /**
         * @member {Object[]} columns_=[]
         */
        columns_: [],
        /**
         * Configs for Neo.table.header.Toolbar
         * @member {Object|null} [headerToolbarConfig=null]
         */
        headerToolbarConfig: null,
        /**
         * @member {String|null} headerToolbarId_=null
         */
        headerToolbarId_: null,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * @member {String} layout='base'
         */
        layout: 'base',
        /**
         * @member {Boolean} scrollbarsCssApplied=false
         * @protected
         */
        scrollbarsCssApplied: false,
        /**
         * @member {Neo.selection.Model} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * @member {Boolean} showHeaderFilters_=false
         */
        showHeaderFilters_: false,
        /**
         * @member {Boolean} sortable_=true
         */
        sortable_: true,
        /**
         * @member {Neo.data.Store} store_=null
         */
        store_: null,
        /**
         * todo: only works for chrome & safari -> add a check
         * @member {Boolean} useCustomScrollbars_=true
         */
        useCustomScrollbars_: true,
        /**
         * Configs for Neo.table.View
         * @member {Object|null} [viewConfig=null]
         */
        viewConfig: null,
        /**
         * @member {String|null} viewId_=null
         * @protected
         */
        viewId_: null,
        /**
         * @member {Array|null} items=null
         * @protected
         */
        items: null,
        /**
         * @member {Object} _vdom={cls: ['neo-table-wrapper'],cn : [{tag: 'table',cn : []}]}
         */
        _vdom:
        {cls: ['neo-table-wrapper'], cn: [
            {tag: 'table', cn: []}
        ]}
    }

    /**
     * Convenience method to access the Neo.table.header.Toolbar
     * @returns {Neo.table.header.Toolbar|null}
     */
    get headerToolbar() {
        return Neo.getComponent(this.headerToolbarId) || Neo.get(this.headerToolbarId)
    }

    /**
     * Convenience method to access the Neo.table.View
     * @returns {Neo.table.View|null}
     */
    get view() {
        return Neo.getComponent(this.viewId) || Neo.get(this.viewId)
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.headerToolbarId = Neo.getId('table-header-toolbar');
        me.viewId          = Neo.getId('table-view');

        me.items = [{
            module           : _header_export_mjs__WEBPACK_IMPORTED_MODULE_7__.Toolbar,
            id               : me.headerToolbarId,
            showHeaderFilters: me.showHeaderFilters,
            sortable         : me.sortable,
            ...me.headerToolbarConfig
        }, {
            module         : _View_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
            containerId    : me.id,
            id             : me.viewId,
            store          : me.store,
            useRowRecordIds: !me.createRandomData,
            ...me.viewConfig
        }];

        me.vdom.id = me.getWrapperId();

        me.createColumns(me.columns)
    }

    /**
     * Triggered after the columns config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetColumns(value, oldValue) {
        if (Array.isArray(oldValue) && oldValue.length > 0) {
            let me              = this,
                {headerToolbar} = me;

            if (headerToolbar) {
                headerToolbar.items = value;
                headerToolbar.createItems()
            }

            me.view?.createViewData(me.store.items)
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.rendered && value.register(this)
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.showHeaderFilters = value
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.sortable = value
        }
    }

    /**
     * Triggered after the useCustomScrollbars config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseCustomScrollbars(value, oldValue) {
        if (value === true) {
            this.vdom.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(this.vdom.cls, ['neo-use-custom-scrollbar'])
        }
    }

    /**
     * @protected
     */
    applyCustomScrollbarsCss() {
        let me       = this,
            id       = me.getWrapperId(),
            cssRules = [];

        if (me.dockLeftMargin) {
            cssRules.push('#' + id + '::-webkit-scrollbar-track:horizontal {margin-left: ' + me.dockLeftMargin + 'px;}')
        }

        if (me.dockRightMargin) {
            cssRules.push('#' + id + '::-webkit-scrollbar-track:horizontal {margin-right: ' + me.dockRightMargin + 'px;}')
        }
        if (cssRules.length > 0) {
            _util_Css_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].insertRules(me.appName, cssRules)
        }

        me.scrollbarsCssApplied = true
    }

    /**
     * Triggered before the columns config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    beforeSetColumns(value, oldValue) {
        if (this.configsApplied) {
            return this.createColumns(value)
        }

        return value
    }

    /**
     * Triggered before the headerToolbarId config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetHeaderToolbarId(value, oldValue) {
        return value || oldValue
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _selection_table_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    beforeSetStore(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me = this,

            listeners = {
                filter      : me.onStoreFilter,
                load        : me.onStoreLoad,
                recordChange: me.onStoreRecordChange,
                scope       : me
            };

            if (value instanceof _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]) {
                value.on(listeners);
                value.getCount() > 0 && me.onStoreLoad(value.items)
            } else {
                value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], {
                    listeners
                })
            }

            // in case we dynamically change the store, the view needs to get the new reference
            if (me.view) {
                me.view.store = value
            }
        }

        return value
    }

    /**
     * Triggered before the viewId config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetViewId(value, oldValue) {
        return value || oldValue
    }

    /**
     * In case you want to update multiple existing records in parallel,
     * using this method is faster than updating each record one by one.
     * At least until we introduce row based vdom updates.
     * @param {Object[]} records
     */
    bulkUpdateRecords(records) {
        let {store, view} = this,
            {keyProperty} = store;

        if (view) {
            view.silentVdomUpdate = true;

            records.forEach(item => {
                store.get(item[keyProperty])?.set(item)
            });

            view.silentVdomUpdate = false;

            view.update()
        }
    }

    /**
     * @param {Object[]} columns
     * @returns {*}
     */
    createColumns(columns) {
        let me             = this,
            columnDefaults = me.columnDefaults,
            sorters        = me.store?.sorters,
            renderer;

        if (!columns || !columns.length) {
            Neo.logError('Attempting to create a table.Container without defined columns', me.id);
        }

        columns.forEach(column => {
            renderer = column.renderer;

            columnDefaults && Neo.assignDefaults(column, columnDefaults);

            if (column.dock && !column.width) {
                Neo.logError('Attempting to create a docked column without a defined width', column, me.id);
            }

            if (renderer && Neo.isString(renderer) && me[renderer]) {
                column.renderer = me[renderer]
            }

            if (sorters?.[0]) {
                if (column.dataField === sorters[0].property) {
                    column.isSorted = sorters[0].direction
                }
            }

            column.listeners = {
                sort : me.onSortColumn,
                scope: me
            }
        });

        me.items[0].items = columns;

        return columns
    }

    /**
     * @param {Number} countRows
     */
    createRandomViewData(countRows) {
        this.loadData(countRows)
    }

    /**
     * @param {Array} inputData
     */
    createViewData(inputData) {
        let me      = this,
            {items} = me;

        items[1].createViewData(inputData); // todo: save a reference to the view & headerContainer

        if (me.useCustomScrollbars && me.scrollbarsCssApplied === false) {
            me.applyCustomScrollbarsCss();
        }

        me.items = items
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @returns {Object[]} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @returns {String}
     */
    getWrapperId() {
        return `${this.id}__wrapper`
    }

    /**
     * @param {Number} countRows
     */
    loadData(countRows) {
        let me           = this,
            columns      = me.items[0].items,
            countColumns = columns.length;

        Neo.manager.Store.createRandomData([countColumns, countRows]).then(data => {
            me.createViewData(data)
        })
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.selectionModel?.register(me);

        if (me.createRandomData) {
            // todo: if mounting apply after mount
            me.timeout(50).then(() => {
                me.createRandomViewData(me.amountRows)
            })
        }
    }

    /**
     * @param {Object} opts
     * @param {String} opts.direction
     * @param {String} opts.property
     * @protected
     */
    onSortColumn(opts) {
        let me = this;

        me.store.sort(opts);
        me.removeSortingCss(opts.property);
        me.onStoreLoad(me.store.items)
    }

    /**
     *
     */
    onStoreFilter() {
        this.onStoreLoad(this.store.items)
    }

    /**
     * @param {Object[]} data
     * @protected
     */
    onStoreLoad(data) {
        let me = this;

        if (me.rendered) {
            me.createViewData(data);

            if (me.store.sorters.length < 1) {
                me.removeSortingCss()
            }
        } else {
            me.on('rendered', () => {
                me.timeout(50).then(() => {
                    me.createViewData(data)
                })
            }, me, {once: true})
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {String} opts.field The name of the field which got changed
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {*} opts.oldValue
     * @param {Object} opts.record
     * @param {*} opts.value
     */
    onStoreRecordChange(opts) {
        this.view.onStoreRecordChange(opts)
    }

    /**
     * @param {String} dataField
     * @protected
     */
    removeSortingCss(dataField) {
        this.items[0].items.forEach(column => {
            if (column.dataField !== dataField) {
                column.removeSortingCss()
            }
        })
    }
}

Neo.setupClass(Container);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Container);


/***/ }),

/***/ "./src/table/View.mjs":
/*!****************************!*\
  !*** ./src/table/View.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");



/**
 * @class Neo.table.View
 * @extends Neo.component.Base
 */
class View extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.table.View'
         * @protected
         */
        className: 'Neo.table.View',
        /**
         * @member {String} ntype='table-view'
         * @protected
         */
        ntype: 'table-view',
        /**
         * @member {String[]} baseCls=['neo-table-view']
         */
        baseCls: ['neo-table-view'],
        /**
         * Define which model field contains the value of colspan definitions
         * @member {String} colspanField='colspan'
         */
        colspanField: 'colspan',
        /**
         * @member {String|null} containerId=null
         * @protected
         */
        containerId: null,
        /**
         * @member {Object} recordVnodeMap={}
         */
        recordVnodeMap: {},
        /**
         * @member {Neo.data.Store|null} store=null
         */
        store: null,
        /**
         * @member {Boolean} useRowRecordIds=true
         */
        useRowRecordIds: true,
        /**
         * @member {Object} _vdom={tag: 'tbody', cn : []}
         */
        _vdom:
        {tag: 'tbody', cn: []}
    }

    /**
     * @param {Object} data
     * @param {String} [data.cellId]
     * @param {Object} data.column
     * @param {Object} data.record
     * @param {Number} data.index
     * @param {Neo.table.Container} data.tableContainer
     * @returns {Object}
     */
    applyRendererOutput(data) {
        let {cellId, column, record, index, tableContainer} = data,
            me          = this,
            cellCls     = ['neo-table-cell'],
            colspan     = record[me.colspanField],
            {dataField} = column,
            fieldValue  = record[dataField],
            hasStore    = tableContainer.store?.model, // todo: remove as soon as all tables use stores (examples table)
            {vdom}      = me,
            cellConfig, rendererOutput;

        if (fieldValue === null || fieldValue === undefined) {
            fieldValue = ''
        }

        rendererOutput = column.renderer.call(column.rendererScope || tableContainer, {
            column,
            dataField,
            index,
            record,
            tableContainer,
            value: fieldValue
        });

        switch (Neo.typeOf(rendererOutput)) {
            case 'Object': {
                if (rendererOutput.html) {
                    rendererOutput.cls && cellCls.push(...rendererOutput.cls);
                } else {
                    rendererOutput = [rendererOutput];
                }
                break
            }
            case 'Number':
            case 'String': {
                rendererOutput = {
                    cls : cellCls,
                    html: rendererOutput?.toString()
                };
                break
            }
        }

        if (rendererOutput === null || rendererOutput === undefined) {
            rendererOutput = ''
        }

        if (column.cellAlign !== 'left') {
            cellCls.push('neo-' + column.cellAlign)
        }

        if (!cellId) {
            // todo: remove the else part as soon as all tables use stores (examples table)
            if (hasStore) {
                cellId = me.getCellId(record, column.dataField)
            } else {
                cellId = vdom.cn[index]?.cn[me.getColumn(column.dataField, true)]?.id || Neo.getId('td')
            }
        }

        cellConfig = {
            tag     : 'td',
            id      : cellId,
            cls     : cellCls,
            style   : rendererOutput.style || {},
            tabIndex: '-1'
        };

        if (colspan && Object.keys(colspan).includes(dataField)) {
            cellConfig.colspan = colspan[dataField]
        }

        if (Neo.typeOf(rendererOutput) === 'Object') {
            cellConfig.innerHTML = rendererOutput.html  || ''
        } else {
            cellConfig.cn = rendererOutput
        }

        return cellConfig
    }

    /**
     * @param {Object[]} inputData
     */
    createViewData(inputData) {
        let me             = this,
            amountRows     = inputData.length,
            tableContainer = me.parent,
            columns        = tableContainer.items[0].items,
            colCount       = columns.length,
            data           = [],
            i              = 0,
            {vdom}         = me,
            config, colspan, colspanKeys, column, dockLeftMargin, dockRightMargin, id, index, j, record, selectedRows, trCls;

        if (tableContainer.selectionModel.ntype === 'selection-table-rowmodel') {
            selectedRows = tableContainer.selectionModel.items || [];
        }

        for (; i < amountRows; i++) {
            record      = inputData[i];
            colspan     = record[me.colspanField];
            colspanKeys = colspan && Object.keys(colspan);
            id          = me.getRowId(record, i);

            me.recordVnodeMap[id] = i;

            trCls = me.getTrClass(record, i);

            if (selectedRows?.includes(id)) {
                trCls.push('neo-selected');

                Neo.getComponent(me.containerId).fire('select', {
                    record
                })
            }

            data.push({
                tag     : 'tr',
                id,
                cls     : trCls,
                cn      : [],
                tabIndex: '-1'
            });

            dockLeftMargin  = 0;
            dockRightMargin = 0;

            for (j=0; j < colCount; j++) {
                column = columns[j];
                config = me.applyRendererOutput({column, record, index: i, tableContainer});

                if (column.dock) {
                    config.cls = ['neo-locked', ...config.cls || []];

                    if (column.dock === 'left') {
                        config.style.left = dockLeftMargin + 'px';
                        dockLeftMargin += (column.width + 1) // todo: borders fix
                    }
                }

                if (column.flex) {
                    config.style.width = '100%'
                }

                data[i].cn.push(config);

                if (colspanKeys?.includes(column.dataField)) {
                    j += (colspan[column.dataField] - 1)
                }
            }

            for (j=0; j < colCount; j++) {
                index  = colCount - j -1;
                column = columns[index];

                if (column.dock === 'right') {
                    data[i].cn[index].style.right = dockRightMargin + 'px';
                    dockRightMargin += (column.width + 1) // todo: borders fix
                }

                if (colspanKeys?.includes(column.dataField)) {
                    j += (colspan[column.dataField] - 1)
                }
            }
        }

        vdom.cn = data;

        Object.assign(tableContainer, {dockLeftMargin, dockRightMargin});

        me.promiseUpdate().then(() => {
            if (selectedRows?.length > 0) {
                // this logic only works for selection.table.RowModel
                Neo.main.DomAccess.scrollToTableRow({appName: me.appName, id: selectedRows[0]})
            }
        })
    }

    /**
     * @param args
     */
    destroy(...args) {
        this.store = null;
        super.destroy(...args)
    }

    /**
     * @param {Object} record
     * @param {String} dataField
     * @returns {String}
     */
    getCellId(record, dataField) {
        return this.id + '__' + record[this.store.keyProperty] + '__' + dataField
    }

    /**
     * Get a table column or column index by a given field name
     * @param {String} field
     * @param {Boolean} returnIndex=false
     * @returns {Object|Number|null}
     */
    getColumn(field, returnIndex=false) {
        let container = this.parent,
            columns   = container.items[0].items, // todo: we need a shortcut for accessing the header toolbar
            i         = 0,
            len       = columns.length,
            column;

        for (; i < len; i++) {
            column = columns[i];

            if (column.dataField === field) {
                return returnIndex ? i : column
            }
        }

        return null
    }

    /**
     * Get the matching record by passing a row id, a cell id or an id inside a table cell.
     * @param {String} nodeId
     * @returns {Object|null}
     */
    getRecord(nodeId) {
        let me     = this,
            record = me.getRecordByRowId(nodeId),
            node, parentNodes;

        if (record) {
            return record;
        }

        parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParentNodes(me.vdom, nodeId);

        for (node of parentNodes) {
            record = me.getRecordByRowId(node.id);

            if (record) {
                return record
            }
        }

        return null
    }

    /**
     * @param {String} rowId
     * @returns {Object}
     */
    getRecordByRowId(rowId) {
        return this.store.getAt(this.recordVnodeMap[rowId])
    }

    /**
     * @param {Object} record
     * @param {Number} [index]
     * @returns {String}
     */
    getRowId(record, index) {
        let me      = this,
            {store} = me;

        if (me.useRowRecordIds) {
            return `${me.id}__tr__${record[store.keyProperty]}`
        } else {
            index = Neo.isNumber(index) ? index : store.indexOf(record);
            return me.vdom.cn[index]?.id || Neo.getId('tr')
        }
    }

    /**
     * Override this method to apply custom CSS rules to table rows
     * @param {Object} record
     * @param {Number} rowIndex
     * @returns {String[]}
     */
    getTrClass(record, rowIndex) {
        return ['neo-table-row']
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onStoreRecordChange(opts) {
        let me             = this,
            fieldNames     = opts.fields.map(field => field.name),
            needsUpdate    = false,
            tableContainer = me.parent,
            {vdom}         = me,
            cellId, cellNode, column, index, scope;

        if (fieldNames.includes(me.colspanField)) {
            // we should narrow it down to only update the current row
            me.createViewData(me.store.items)
        } else {
            opts.fields.forEach(field => {
                cellId   = me.getCellId(opts.record, field.name);
                cellNode = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].findVdomChild(vdom, cellId);

                // the vdom might not exist yet => nothing to do in this case
                if (cellNode?.vdom) {
                    column      = me.getColumn(field.name);
                    index       = cellNode.index;
                    needsUpdate = true;
                    scope       = column.rendererScope || tableContainer;

                    cellNode.parentNode.cn[index] = me.applyRendererOutput({cellId, column, record: opts.record, index, tableContainer})
                }
            })
        }

        needsUpdate && me.update()
    }
}

Neo.setupClass(View);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);


/***/ }),

/***/ "./src/table/header/Button.mjs":
/*!*************************************!*\
  !*** ./src/table/header/Button.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");




/**
 * @class Neo.table.header.Button
 * @extends Neo.button.Base
 */
class Button extends _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} cellAlignValues: ['left','center','right']
     * @protected
     * @static
     */
    static cellAlignValues = ['left', 'center', 'right']

    static config = {
        /**
         * @member {String} className='Neo.table.header.Button'
         * @protected
         */
        className: 'Neo.table.header.Button',
        /**
         * @member {String} ntype='table-header-button'
         * @protected
         */
        ntype: 'table-header-button',
        /**
         * @member {String[]} baseCls=['neo-table-header-button']
         */
        baseCls: ['neo-table-header-button'],
        /**
         * Alignment of the matching table cells. Valid values are left, center, right
         * @member {String} cellAlign_='left'
         */
        cellAlign_: 'left',
        /**
         * @member {String|null} dataField=null
         */
        dataField: null,
        /**
         * Sort direction when clicking on an unsorted button
         * @member {String} defaultSortDirection='ASC'
         */
        defaultSortDirection: 'ASC',
        /**
         * @member {Boolean} draggable_=true
         */
        draggable_: true,
        /**
         * @member {Object} editorConfig=null
         */
        editorConfig: null,
        /**
         * @member {Object} filterConfig=null
         */
        filterConfig: null,
        /**
         * @member {Neo.form.field.Base|null} filterField=null
         * @protected
         */
        filterField: null,
        /**
         * @member {String} iconCls='fa fa-arrow-circle-up'
         */
        iconCls: 'fa fa-arrow-circle-up',
        /**
         * @member {String} iconPosition='right'
         */
        iconPosition: 'right',
        /**
         * 'ASC', 'DESC' or null
         * @member {String|null} isSorted_=null
         * @protected
         */
        isSorted_: null,
        /**
         * Scope to execute the column renderer.
         * Defaults to the matching table.Container
         * @member {Neo.core.Base|null} rendererScope=null
         */
        rendererScope: null,
        /**
         * @member {Boolean} showHeaderFilter_=false
         */
        showHeaderFilter_: false,
        /**
         * @member {Boolean} sortable_=true
         */
        sortable_: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'th', cn: [
            {tag: 'button', cn: [
                {tag: 'span', cls: ['neo-button-glyph']},
                {tag: 'span', cls: ['neo-button-text']},
                {tag: 'span', cls: ['neo-button-badge']},
                {tag: 'span', cls: ['neo-button-ripple-wrapper'], cn: [
                    {tag: 'span', cls: ['neo-button-ripple']}
                ]}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.draggable && me.addDomListeners({
            dragend  : me.onDragEnd,
            dragenter: me.onDragEnter,
            dragleave: me.onDragLeave,
            dragover : me.onDragOver,
            dragstart: me.onDragStart,
            drop     : me.onDrop,
            scope    : me
        })
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value === true) {
            me.getVdomRoot().draggable = true
        } else {
            delete me.getVdomRoot().draggable
        }

        me.update()
    }

    /**
     * Triggered after the isSorted config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetIsSorted(value, oldValue) {
        let me        = this,
            {cls}     = me,
            container = me.up('table-container');

        switch(value) {
            case null:
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');
                break
            case 'ASC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-desc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-asc');
                break
            case 'DESC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-asc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-desc');
                break
        }

        me.cls = cls;

        // testing check until all example tables have a store
        if (!container || !container.store) {
            return
        }

        me.mounted && me.fire('sort', {
            direction: value,
            property : me.dataField
        })
    }

    /**
     * Triggered after the showHeaderFilter config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilter(value, oldValue) {
        let me = this;

        if (value) {
            if (!me.filterField) {
                me.filterField = Neo.create({
                    module   : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                    appName  : me.appName,
                    flag     : 'filter-field',
                    hideLabel: true,
                    parentId : me.id,

                    listeners: {
                        change        : me.changeFilterValue,
                        operatorChange: me.changeFilterOperator,
                        scope         : me
                    },

                    style: {
                        marginLeft : '.5em',
                        marginRight: '.5em'
                    },
                    ...me.editorConfig
                });

                me.vdom.cn.push(me.filterField.vdom)
            } else {
                delete me.filterField.vdom.removeDom
            }
        } else if (me.filterField) {
            me.filterField.vdom.removeDom = true
        }

        me.update()
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
     afterSetSortable(value, oldValue) {
        let me    = this,
            {cls} = me;

        if (value === true) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');

            me.addDomListeners({
                click: me.onButtonClick,
                scope: me
            })
        } else {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

            me.removeDomListeners({
                click: me.onButtonClick,
                scope: me
            })
        }

        me.cls = cls;
        me.update()
    }

    /**
     * Triggered before the cellAlign config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetCellAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'cellAlign', 'cellAlignValues');
    }

    /**
     *
     */
    destroy(...args) {
        this.filterField?.destroy();

        super.destroy(...args)
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @protected
     */
    onButtonClick() {
        let me = this,
            map;

        if (me.defaultSortDirection === 'DESC') {
            map = {
                ASC : null,
                DESC: 'ASC',
                null: 'DESC'
            }
        } else {
            map = {
                ASC : 'DESC',
                DESC: null,
                null: 'ASC'
            }
        }

        me.isSorted = map[me.isSorted + '']
    }

    /**
     * @protected
     */
    onDragEnd() {
        let me      = this,
            {style} = me;

        delete style.opacity;
        me.style = style
    }

    /**
     * @protected
     */
    onDragEnter() {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-drag-over');
        me.cls = cls
    }

    /**
     * @protected
     */
    onDragLeave() {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-drag-over');
        me.cls = cls
    }

    /**
     * @param {Object} event
     */
    onDragOver(event) {
        //console.log('onDragOver', event);
    }

    /**
     * @protected
     */
    onDragStart() {
        let me      = this,
            {style} = me;

        style.opacity = 0.4;
        me.style = style
    }

    /**
     * @param {Object} data
     */
    onDrop(data) {
        let me             = this,
            headerToolbar  = me.parent,
            {style}        = me,
            tableContainer = headerToolbar.parent;

        me.onDragLeave();
        headerToolbar.switchItems(me.id, data.srcId);
        tableContainer.createViewData(tableContainer.store.data);

        style.opacity = 1;
        me.style = style
    }

    /**
     * @param {Object} data
     */
    changeFilterOperator(data) {
        let me             = this,
            tableContainer = me.up('table-container'),
            store          = tableContainer?.store,
            operator       = data.value,
            filter, filters;

        if (store) {
            filter = store.getFilter(me.dataField);

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator,
                    value   : null,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.operator = operator
            }
        }
    }

    /**
     * @param {Object} data
     */
    changeFilterValue(data) {
        let me             = this,
            tableContainer = me.up('table-container'),
            store          = tableContainer?.store,
            {value}        = data,
            field, filter, filters, model;

        if (store) {
            filter = store.getFilter(me.dataField);
            model  = store.model;
            field  = model && model.getField(me.dataField);

            if (value && field.type.toLowerCase() === 'date') {
                value = new Date(value)
            }

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator: 'like',
                    value,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.value = value
            }
        }
    }

    /**
     * @protected
     */
    removeSortingCss() {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

        me.cls       = cls;
        me._isSorted = null
    }

    /**
     * @param {Object} data
     * @param {String} data.dataField
     * @param {Number} data.index
     * @param {Object} data.record
     * @param {Number|String} data.value
     * @returns {*}
     */
    renderer(data) {
        return data.value
    }
}

Neo.setupClass(Button);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Button);


/***/ }),

/***/ "./src/table/header/Toolbar.mjs":
/*!**************************************!*\
  !*** ./src/table/header/Toolbar.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.table.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.table.header.Toolbar'
         * @protected
         */
        className: 'Neo.table.header.Toolbar',
        /**
         * @member {String} ntype='table-header-toolbar'
         * @protected
         */
        ntype: 'table-header-toolbar',
        /**
         * @member {String[]} baseCls=['table-header-toolbar']
         */
        baseCls: ['table-header-toolbar'],
        /**
         * @member {String} layout='base'
         */
        layout: 'base',
        /**
         * @member {Object} itemDefaults={ntype : 'table-header-button'}
         */
        itemDefaults: {
            ntype : 'table-header-button'
        },
        /**
         * @member {Boolean} showHeaderFilters_=false
         */
        showHeaderFilters_: false,
        /**
         * @member {Boolean} sortable=true
         */
        sortable: true,
        /**
         * @member {Object} _vdom={tag:'thead',cn:[{tag:'tr',cn:[]}]}
         */
        _vdom:
        {tag: 'thead', cn: [
            {tag: 'tr', cn: []}
        ]}
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    showHeaderFilter: value
                })
            });

            me.update()
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
     afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    sortable: value
                })
            });

            me.update()
        }
    }

    /**
     *
     */
    createItems() {
        let me = this;

        me.itemDefaults.showHeaderFilter = me.showHeaderFilters;

        super.createItems();

        let dockLeftWidth  = 0,
            dockRightWidth = 0,
            {items}        = me,
            len            = items.length,
            style;

        items.forEach((item, index) => {
            style = item.wrapperStyle;

            // todo: only add px if number
            if (item.maxWidth) {style.maxWidth = item.maxWidth + 'px'}
            if (item.minWidth) {style.minWidth = item.minWidth + 'px'}
            if (item.width)    {style.width    = item.width    + 'px'}

            if (item.dock) {
                item.vdom.cls = ['neo-locked'];

                if (item.dock === 'left') {
                    style.left = dockLeftWidth + 'px'
                }

                dockLeftWidth += (item.width + 1) // todo: borders fix
            } else {
                item.vdom.cls = [] // remove the button cls from the th tag
            }

            item.sortable = me.sortable;
            item.wrapperStyle = style;

            // inverse loop direction
            item = items[len - index -1];

            if (item.dock === 'right') {
                style = item.wrapperStyle;
                style.right = dockRightWidth + 'px';

                item.wrapperStyle = style;

                dockRightWidth += (item.width + 1) // todo: borders fix
            }
        });

        me.update()
    }

    /**
     * @param {String} dock
     * @returns {String} layoutConfig
     * @override
     */
    getLayoutConfig(dock) {
        return 'base'
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }
}

Neo.setupClass(Toolbar);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Toolbar);


/***/ }),

/***/ "./src/table/header/_export.mjs":
/*!**************************************!*\
  !*** ./src/table/header/_export.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* reexport safe */ _Button_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Toolbar: () => (/* reexport safe */ _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _Button_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.mjs */ "./src/table/header/Button.mjs");
/* harmony import */ var _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Toolbar.mjs */ "./src/table/header/Toolbar.mjs");





/***/ }),

/***/ "./src/util/Css.mjs":
/*!**************************!*\
  !*** ./src/util/Css.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Css
 * @extends Neo.core.Base
 */
class Css extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Css'
         * @protected
         */
        className: 'Neo.util.Css'
    }

    /**
     * Pass the selectorText of the rules which you want to remove
     * @param {String} appName
     * @param {String[]|String} rules
     */
    static deleteRules(appName, rules) {
        if (!Array.isArray(rules)) {
            rules = [rules]
        }

        Neo.main.addon.Stylesheet.deleteCssRules({appName, rules})
    }

    /**
     * @param {String} appName
     * @param {String[]|String} rules
     */
    static insertRules(appName, rules) {
        if (!Array.isArray(rules)) {
            rules = [rules]
        }

        Neo.main.addon.Stylesheet.insertCssRules({appName, rules})
    }
}

Neo.setupClass(Css);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Css);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNPOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBSztBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7QUFDekIsMkJBQTJCLHNEQUFRO0FBQ25DO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1B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O0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsZUFBZTtBQUNqRTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxlQUFlO0FBQ2pFO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsR0FBRyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vdGFibGUvUm93TW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFibGUvQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3RhYmxlL1ZpZXcubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFibGUvaGVhZGVyL0J1dHRvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90YWJsZS9oZWFkZXIvVG9vbGJhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90YWJsZS9oZWFkZXIvX2V4cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0Nzcy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1vZGVsICAgIGZyb20gJy4uL01vZGVsLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24udGFibGUuUm93TW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uTW9kZWxcbiAqL1xuY2xhc3MgUm93TW9kZWwgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLnRhYmxlLlJvd01vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLnRhYmxlLlJvd01vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi10YWJsZS1yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tdGFibGUtcm93bW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbHM9J3NlbGVjdGlvbi1yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiAnbmVvLXNlbGVjdGlvbi1yb3dtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lO1xuXG4gICAgICAgIHZpZXcuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGNsaWNrICAgOiBtZS5vblJvd0NsaWNrLFxuICAgICAgICAgICAgZGVsZWdhdGU6ICcubmVvLXRhYmxlLXJvdycsXG4gICAgICAgICAgICBzY29wZSAgIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWF0Y2hpbmcgdGFibGUgcm93IGZvciBhIGdpdmVuIHJvdyBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCByb3cgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFRoZSB0YWJsZSByb3cgbm9kZSBpZFxuICAgICAqL1xuICAgIGdldFJvd0lkKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy52aWV3LnN0b3JlLmdldENvdW50KCkgPCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcudmRvbS5jblswXS5jblsxXS5jbltpbmRleF0uaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWF0Y2hpbmcgdGFibGUgcm93IGZvciBhIGdpdmVuIGV2ZW50IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF0aCBUaGUgZXZlbnQgcGF0aFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIG5vZGUgY29udGFpbmluZyB0aGUgdGFibGUgcm93IGNsYXNzIG9yIG51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvd05vZGUocGF0aCkge1xuICAgICAgICBsZXQgaSAgICA9IDAsXG4gICAgICAgICAgICBsZW4gID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBub2RlID0gbnVsbDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jbHMuaW5jbHVkZXMoJ25lby10YWJsZS1yb3cnKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRG93bihkYXRhKSB7XG4gICAgICAgIHRoaXMub25OYXZLZXlSb3coZGF0YSwgMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blVwKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbk5hdktleVJvdyhkYXRhLCAtMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgb25OYXZLZXlSb3coZGF0YSwgc3RlcCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgICAgICAgICA9IFJvd01vZGVsLmdldFJvd05vZGUoZGF0YS5wYXRoKSxcbiAgICAgICAgICAgIHt2aWV3fSAgICAgICA9IG1lLFxuICAgICAgICAgICAge3N0b3JlfSAgICAgID0gdmlldyxcbiAgICAgICAgICAgIHZkb21Ob2RlICAgICA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQodmlldy52ZG9tLCBub2RlLmlkKSxcbiAgICAgICAgICAgIG5ld0luZGV4ICAgICA9ICh2ZG9tTm9kZS5pbmRleCArIHN0ZXApICUgc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIHtwYXJlbnROb2RlfSA9IHZkb21Ob2RlLFxuICAgICAgICAgICAgaWQ7XG5cbiAgICAgICAgd2hpbGUgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgbmV3SW5kZXggKz0gc3RvcmUuZ2V0Q291bnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWQgPSBwYXJlbnROb2RlLmNuW25ld0luZGV4XS5pZDtcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdChpZCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKGlkKTtcblxuICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgcmVjb3JkOiBzdG9yZS5nZXRBdChuZXdJbmRleClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUm93Q2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgICA9IFJvd01vZGVsLmdldFJvd05vZGUoZGF0YS5wYXRoKSxcbiAgICAgICAgICAgIGlkICAgICA9IG5vZGU/LmlkLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICBpc1NlbGVjdGVkLCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBtZS50b2dnbGVTZWxlY3Rpb24oaWQpO1xuXG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gbWUuaXNTZWxlY3RlZChpZCk7XG4gICAgICAgICAgICByZWNvcmQgICAgID0gdmlldy5zdG9yZS5nZXRBdChWRG9tVXRpbC5maW5kVmRvbUNoaWxkKHZpZXcudmRvbSwgaWQpLmluZGV4KTtcblxuICAgICAgICAgICAgIWlzU2VsZWN0ZWQgJiYgdmlldy5vbkRlc2VsZWN0Py4ocmVjb3JkKTtcblxuICAgICAgICAgICAgdmlldy5maXJlKGlzU2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICdkZXNlbGVjdCcsIHtcbiAgICAgICAgICAgICAgICByZWNvcmRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKGNvbXBvbmVudCk7XG5cbiAgICAgICAgbGV0IHtpZCwgdmlld30gPSB0aGlzO1xuXG4gICAgICAgIHZpZXcua2V5cz8uX2tleXMucHVzaChcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nLCBrZXk6ICdEb3duJywgc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJywgICBrZXk6ICdVcCcsICAgc2NvcGU6IGlkfVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQge2lkLCB2aWV3fSA9IHRoaXM7XG5cbiAgICAgICAgdmlldy5rZXlzPy5yZW1vdmVLZXlzKFtcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nLCBrZXk6ICdEb3duJywgc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJywgICBrZXk6ICdVcCcsICAgc2NvcGU6IGlkfVxuICAgICAgICBdKTtcblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKFJvd01vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgUm93TW9kZWw7XG4iLCJpbXBvcnQgQmFzZUNvbnRhaW5lciAgIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDc3NVdGlsICAgICAgICAgZnJvbSAnLi4vdXRpbC9Dc3MubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFJvd01vZGVsICAgICAgICBmcm9tICcuLi9zZWxlY3Rpb24vdGFibGUvUm93TW9kZWwubWpzJztcbmltcG9ydCBTdG9yZSAgICAgICAgICAgZnJvbSAnLi4vZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFZpZXcgICAgICAgICAgICBmcm9tICcuL1ZpZXcubWpzJztcbmltcG9ydCAqIGFzIGhlYWRlciAgICAgZnJvbSAnLi9oZWFkZXIvX2V4cG9ydC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFibGUuQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udGFibGUuQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFibGUuQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RhYmxlLWNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0YWJsZS1jb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogdG9kbzogdGVzdGluZyBjb25maWcsIHJlbW92ZSB3aGVuIFN0b3JlcyBhcmUgcmVhZHlcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhbW91bnRSb3dzPTIwXG4gICAgICAgICAqL1xuICAgICAgICBhbW91bnRSb3dzOiAyMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRhYmxlLWNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10YWJsZS1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgY29uZmlncyBmb3IgZWFjaCBjb2x1bW5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjb2x1bW5EZWZhdWx0cz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5EZWZhdWx0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvZG86IHRlc3RpbmcgY29uZmlnLCByZW1vdmUgd2hlbiBTdG9yZXMgYXJlIHJlYWR5XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNyZWF0ZVJhbmRvbURhdGE9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVJhbmRvbURhdGE6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGNvbHVtbnNfPVtdXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5zXzogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWdzIGZvciBOZW8udGFibGUuaGVhZGVyLlRvb2xiYXJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IFtoZWFkZXJUb29sYmFyQ29uZmlnPW51bGxdXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJUb29sYmFyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGhlYWRlclRvb2xiYXJJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyVG9vbGJhcklkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgdXNlZCBrZXlzIGZvciB0aGUgc2VsZWN0aW9uIG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0ga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAga2V5czoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxheW91dD0nYmFzZSdcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogJ2Jhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2Nyb2xsYmFyc0Nzc0FwcGxpZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsYmFyc0Nzc0FwcGxpZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gc2VsZWN0aW9uTW9kZWxfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dIZWFkZXJGaWx0ZXJzXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0hlYWRlckZpbHRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZX0gc3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvZG86IG9ubHkgd29ya3MgZm9yIGNocm9tZSAmIHNhZmFyaSAtPiBhZGQgYSBjaGVja1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VDdXN0b21TY3JvbGxiYXJzXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VDdXN0b21TY3JvbGxiYXJzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3MgZm9yIE5lby50YWJsZS5WaWV3XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBbdmlld0NvbmZpZz1udWxsXVxuICAgICAgICAgKi9cbiAgICAgICAgdmlld0NvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB2aWV3SWRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdmlld0lkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGl0ZW1zPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXtjbHM6IFsnbmVvLXRhYmxlLXdyYXBwZXInXSxjbiA6IFt7dGFnOiAndGFibGUnLGNuIDogW119XX1cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y2xzOiBbJ25lby10YWJsZS13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICB7dGFnOiAndGFibGUnLCBjbjogW119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFjY2VzcyB0aGUgTmVvLnRhYmxlLmhlYWRlci5Ub29sYmFyXG4gICAgICogQHJldHVybnMge05lby50YWJsZS5oZWFkZXIuVG9vbGJhcnxudWxsfVxuICAgICAqL1xuICAgIGdldCBoZWFkZXJUb29sYmFyKCkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLmhlYWRlclRvb2xiYXJJZCkgfHwgTmVvLmdldCh0aGlzLmhlYWRlclRvb2xiYXJJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWNjZXNzIHRoZSBOZW8udGFibGUuVmlld1xuICAgICAqIEByZXR1cm5zIHtOZW8udGFibGUuVmlld3xudWxsfVxuICAgICAqL1xuICAgIGdldCB2aWV3KCkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLnZpZXdJZCkgfHwgTmVvLmdldCh0aGlzLnZpZXdJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmhlYWRlclRvb2xiYXJJZCA9IE5lby5nZXRJZCgndGFibGUtaGVhZGVyLXRvb2xiYXInKTtcbiAgICAgICAgbWUudmlld0lkICAgICAgICAgID0gTmVvLmdldElkKCd0YWJsZS12aWV3Jyk7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBbe1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICA6IGhlYWRlci5Ub29sYmFyLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgICA6IG1lLmhlYWRlclRvb2xiYXJJZCxcbiAgICAgICAgICAgIHNob3dIZWFkZXJGaWx0ZXJzOiBtZS5zaG93SGVhZGVyRmlsdGVycyxcbiAgICAgICAgICAgIHNvcnRhYmxlICAgICAgICAgOiBtZS5zb3J0YWJsZSxcbiAgICAgICAgICAgIC4uLm1lLmhlYWRlclRvb2xiYXJDb25maWdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBWaWV3LFxuICAgICAgICAgICAgY29udGFpbmVySWQgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgIDogbWUudmlld0lkLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICAgOiBtZS5zdG9yZSxcbiAgICAgICAgICAgIHVzZVJvd1JlY29yZElkczogIW1lLmNyZWF0ZVJhbmRvbURhdGEsXG4gICAgICAgICAgICAuLi5tZS52aWV3Q29uZmlnXG4gICAgICAgIH1dO1xuXG4gICAgICAgIG1lLnZkb20uaWQgPSBtZS5nZXRXcmFwcGVySWQoKTtcblxuICAgICAgICBtZS5jcmVhdGVDb2x1bW5zKG1lLmNvbHVtbnMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjb2x1bW5zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29sdW1ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2xkVmFsdWUpICYmIG9sZFZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtoZWFkZXJUb29sYmFyfSA9IG1lO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVyVG9vbGJhcikge1xuICAgICAgICAgICAgICAgIGhlYWRlclRvb2xiYXIuaXRlbXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBoZWFkZXJUb29sYmFyLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUudmlldz8uY3JlYXRlVmlld0RhdGEobWUuc3RvcmUuaXRlbXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgJiYgdmFsdWUucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dIZWFkZXJGaWx0ZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0hlYWRlckZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclRvb2xiYXIuc2hvd0hlYWRlckZpbHRlcnMgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJUb29sYmFyLnNvcnRhYmxlID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlQ3VzdG9tU2Nyb2xsYmFycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUN1c3RvbVNjcm9sbGJhcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy52ZG9tLmNscyA9IE5lb0FycmF5LnVuaW9uKHRoaXMudmRvbS5jbHMsIFsnbmVvLXVzZS1jdXN0b20tc2Nyb2xsYmFyJ10pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXBwbHlDdXN0b21TY3JvbGxiYXJzQ3NzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICAgICAgPSBtZS5nZXRXcmFwcGVySWQoKSxcbiAgICAgICAgICAgIGNzc1J1bGVzID0gW107XG5cbiAgICAgICAgaWYgKG1lLmRvY2tMZWZ0TWFyZ2luKSB7XG4gICAgICAgICAgICBjc3NSdWxlcy5wdXNoKCcjJyArIGlkICsgJzo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2s6aG9yaXpvbnRhbCB7bWFyZ2luLWxlZnQ6ICcgKyBtZS5kb2NrTGVmdE1hcmdpbiArICdweDt9JylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5kb2NrUmlnaHRNYXJnaW4pIHtcbiAgICAgICAgICAgIGNzc1J1bGVzLnB1c2goJyMnICsgaWQgKyAnOjotd2Via2l0LXNjcm9sbGJhci10cmFjazpob3Jpem9udGFsIHttYXJnaW4tcmlnaHQ6ICcgKyBtZS5kb2NrUmlnaHRNYXJnaW4gKyAncHg7fScpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNzc1J1bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIENzc1V0aWwuaW5zZXJ0UnVsZXMobWUuYXBwTmFtZSwgY3NzUnVsZXMpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5zY3JvbGxiYXJzQ3NzQXBwbGllZCA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjb2x1bW5zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWdzQXBwbGllZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1ucyh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGhlYWRlclRvb2xiYXJJZCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRIZWFkZXJUb29sYmFySWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBvbGRWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgUm93TW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgIGZpbHRlciAgICAgIDogbWUub25TdG9yZUZpbHRlcixcbiAgICAgICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uU3RvcmVMb2FkLFxuICAgICAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25TdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdG9yZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLm9uKGxpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgdmFsdWUuZ2V0Q291bnQoKSA+IDAgJiYgbWUub25TdG9yZUxvYWQodmFsdWUuaXRlbXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBTdG9yZSwge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlIGR5bmFtaWNhbGx5IGNoYW5nZSB0aGUgc3RvcmUsIHRoZSB2aWV3IG5lZWRzIHRvIGdldCB0aGUgbmV3IHJlZmVyZW5jZVxuICAgICAgICAgICAgaWYgKG1lLnZpZXcpIHtcbiAgICAgICAgICAgICAgICBtZS52aWV3LnN0b3JlID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZpZXdJZCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWaWV3SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBvbGRWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgeW91IHdhbnQgdG8gdXBkYXRlIG11bHRpcGxlIGV4aXN0aW5nIHJlY29yZHMgaW4gcGFyYWxsZWwsXG4gICAgICogdXNpbmcgdGhpcyBtZXRob2QgaXMgZmFzdGVyIHRoYW4gdXBkYXRpbmcgZWFjaCByZWNvcmQgb25lIGJ5IG9uZS5cbiAgICAgKiBBdCBsZWFzdCB1bnRpbCB3ZSBpbnRyb2R1Y2Ugcm93IGJhc2VkIHZkb20gdXBkYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSByZWNvcmRzXG4gICAgICovXG4gICAgYnVsa1VwZGF0ZVJlY29yZHMocmVjb3Jkcykge1xuICAgICAgICBsZXQge3N0b3JlLCB2aWV3fSA9IHRoaXMsXG4gICAgICAgICAgICB7a2V5UHJvcGVydHl9ID0gc3RvcmU7XG5cbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcuc2lsZW50VmRvbVVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXQoaXRlbVtrZXlQcm9wZXJ0eV0pPy5zZXQoaXRlbSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2aWV3LnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmlldy51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gY29sdW1uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNyZWF0ZUNvbHVtbnMoY29sdW1ucykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29sdW1uRGVmYXVsdHMgPSBtZS5jb2x1bW5EZWZhdWx0cyxcbiAgICAgICAgICAgIHNvcnRlcnMgICAgICAgID0gbWUuc3RvcmU/LnNvcnRlcnMsXG4gICAgICAgICAgICByZW5kZXJlcjtcblxuICAgICAgICBpZiAoIWNvbHVtbnMgfHwgIWNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ0F0dGVtcHRpbmcgdG8gY3JlYXRlIGEgdGFibGUuQ29udGFpbmVyIHdpdGhvdXQgZGVmaW5lZCBjb2x1bW5zJywgbWUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICByZW5kZXJlciA9IGNvbHVtbi5yZW5kZXJlcjtcblxuICAgICAgICAgICAgY29sdW1uRGVmYXVsdHMgJiYgTmVvLmFzc2lnbkRlZmF1bHRzKGNvbHVtbiwgY29sdW1uRGVmYXVsdHMpO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uLmRvY2sgJiYgIWNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgIE5lby5sb2dFcnJvcignQXR0ZW1wdGluZyB0byBjcmVhdGUgYSBkb2NrZWQgY29sdW1uIHdpdGhvdXQgYSBkZWZpbmVkIHdpZHRoJywgY29sdW1uLCBtZS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJlciAmJiBOZW8uaXNTdHJpbmcocmVuZGVyZXIpICYmIG1lW3JlbmRlcmVyXSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5yZW5kZXJlciA9IG1lW3JlbmRlcmVyXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc29ydGVycz8uWzBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRlcnNbMF0ucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmlzU29ydGVkID0gc29ydGVyc1swXS5kaXJlY3Rpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbHVtbi5saXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICAgICAgc29ydCA6IG1lLm9uU29ydENvbHVtbixcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaXRlbXNbMF0uaXRlbXMgPSBjb2x1bW5zO1xuXG4gICAgICAgIHJldHVybiBjb2x1bW5zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50Um93c1xuICAgICAqL1xuICAgIGNyZWF0ZVJhbmRvbVZpZXdEYXRhKGNvdW50Um93cykge1xuICAgICAgICB0aGlzLmxvYWREYXRhKGNvdW50Um93cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3RGF0YShpbnB1dERhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1zfSA9IG1lO1xuXG4gICAgICAgIGl0ZW1zWzFdLmNyZWF0ZVZpZXdEYXRhKGlucHV0RGF0YSk7IC8vIHRvZG86IHNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHZpZXcgJiBoZWFkZXJDb250YWluZXJcblxuICAgICAgICBpZiAobWUudXNlQ3VzdG9tU2Nyb2xsYmFycyAmJiBtZS5zY3JvbGxiYXJzQ3NzQXBwbGllZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1lLmFwcGx5Q3VzdG9tU2Nyb2xsYmFyc0NzcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXRlbXMgPSBpdGVtc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBUaGUgbmV3IHZkb20gaXRlbXMgcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21JdGVtc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnZkb20uVk5vZGV9XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRXcmFwcGVySWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fd3JhcHBlcmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291bnRSb3dzXG4gICAgICovXG4gICAgbG9hZERhdGEoY291bnRSb3dzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29sdW1ucyAgICAgID0gbWUuaXRlbXNbMF0uaXRlbXMsXG4gICAgICAgICAgICBjb3VudENvbHVtbnMgPSBjb2x1bW5zLmxlbmd0aDtcblxuICAgICAgICBOZW8ubWFuYWdlci5TdG9yZS5jcmVhdGVSYW5kb21EYXRhKFtjb3VudENvbHVtbnMsIGNvdW50Um93c10pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBtZS5jcmVhdGVWaWV3RGF0YShkYXRhKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnJlZ2lzdGVyKG1lKTtcblxuICAgICAgICBpZiAobWUuY3JlYXRlUmFuZG9tRGF0YSkge1xuICAgICAgICAgICAgLy8gdG9kbzogaWYgbW91bnRpbmcgYXBwbHkgYWZ0ZXIgbW91bnRcbiAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZVJhbmRvbVZpZXdEYXRhKG1lLmFtb3VudFJvd3MpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5kaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5wcm9wZXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNvcnRDb2x1bW4ob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnN0b3JlLnNvcnQob3B0cyk7XG4gICAgICAgIG1lLnJlbW92ZVNvcnRpbmdDc3Mob3B0cy5wcm9wZXJ0eSk7XG4gICAgICAgIG1lLm9uU3RvcmVMb2FkKG1lLnN0b3JlLml0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25TdG9yZUZpbHRlcigpIHtcbiAgICAgICAgdGhpcy5vblN0b3JlTG9hZCh0aGlzLnN0b3JlLml0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5yZW5kZXJlZCkge1xuICAgICAgICAgICAgbWUuY3JlYXRlVmlld0RhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChtZS5zdG9yZS5zb3J0ZXJzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICBtZS5yZW1vdmVTb3J0aW5nQ3NzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLm9uKCdyZW5kZXJlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlVmlld0RhdGEoZGF0YSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhIHJlY29yZCBmaWVsZC5cbiAgICAgKiBFLmcuIG15UmVjb3JkLmZvbyA9ICdiYXInO1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHdoaWNoIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gb3B0cy5tb2RlbCBUaGUgbW9kZWwgaW5zdGFuY2Ugb2YgdGhlIGNoYW5nZWQgcmVjb3JkXG4gICAgICogQHBhcmFtIHsqfSBvcHRzLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucmVjb3JkXG4gICAgICogQHBhcmFtIHsqfSBvcHRzLnZhbHVlXG4gICAgICovXG4gICAgb25TdG9yZVJlY29yZENoYW5nZShvcHRzKSB7XG4gICAgICAgIHRoaXMudmlldy5vblN0b3JlUmVjb3JkQ2hhbmdlKG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVTb3J0aW5nQ3NzKGRhdGFGaWVsZCkge1xuICAgICAgICB0aGlzLml0ZW1zWzBdLml0ZW1zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZGF0YUZpZWxkICE9PSBkYXRhRmllbGQpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4ucmVtb3ZlU29ydGluZ0NzcygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhDb250YWluZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFibGUuVmlld1xuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIFZpZXcgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYmxlLlZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50YWJsZS5WaWV3JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RhYmxlLXZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGFibGUtdmlldycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10YWJsZS12aWV3J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRhYmxlLXZpZXcnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSB3aGljaCBtb2RlbCBmaWVsZCBjb250YWlucyB0aGUgdmFsdWUgb2YgY29sc3BhbiBkZWZpbml0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbHNwYW5GaWVsZD0nY29sc3BhbidcbiAgICAgICAgICovXG4gICAgICAgIGNvbHNwYW5GaWVsZDogJ2NvbHNwYW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbnRhaW5lcklkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlY29yZFZub2RlTWFwPXt9XG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmRWbm9kZU1hcDoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBzdG9yZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVJvd1JlY29yZElkcz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VSb3dSZWNvcmRJZHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt0YWc6ICd0Ym9keScsIGNuIDogW119XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ3Rib2R5JywgY246IFtdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmNlbGxJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5jb2x1bW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5pbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLnRhYmxlLkNvbnRhaW5lcn0gZGF0YS50YWJsZUNvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXBwbHlSZW5kZXJlck91dHB1dChkYXRhKSB7XG4gICAgICAgIGxldCB7Y2VsbElkLCBjb2x1bW4sIHJlY29yZCwgaW5kZXgsIHRhYmxlQ29udGFpbmVyfSA9IGRhdGEsXG4gICAgICAgICAgICBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjZWxsQ2xzICAgICA9IFsnbmVvLXRhYmxlLWNlbGwnXSxcbiAgICAgICAgICAgIGNvbHNwYW4gICAgID0gcmVjb3JkW21lLmNvbHNwYW5GaWVsZF0sXG4gICAgICAgICAgICB7ZGF0YUZpZWxkfSA9IGNvbHVtbixcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgID0gcmVjb3JkW2RhdGFGaWVsZF0sXG4gICAgICAgICAgICBoYXNTdG9yZSAgICA9IHRhYmxlQ29udGFpbmVyLnN0b3JlPy5tb2RlbCwgLy8gdG9kbzogcmVtb3ZlIGFzIHNvb24gYXMgYWxsIHRhYmxlcyB1c2Ugc3RvcmVzIChleGFtcGxlcyB0YWJsZSlcbiAgICAgICAgICAgIHt2ZG9tfSAgICAgID0gbWUsXG4gICAgICAgICAgICBjZWxsQ29uZmlnLCByZW5kZXJlck91dHB1dDtcblxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gbnVsbCB8fCBmaWVsZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSBjb2x1bW4ucmVuZGVyZXIuY2FsbChjb2x1bW4ucmVuZGVyZXJTY29wZSB8fCB0YWJsZUNvbnRhaW5lciwge1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgZGF0YUZpZWxkLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICB0YWJsZUNvbnRhaW5lcixcbiAgICAgICAgICAgIHZhbHVlOiBmaWVsZFZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN3aXRjaCAoTmVvLnR5cGVPZihyZW5kZXJlck91dHB1dCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6IHtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXJPdXRwdXQuaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlck91dHB1dC5jbHMgJiYgY2VsbENscy5wdXNoKC4uLnJlbmRlcmVyT3V0cHV0LmNscyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSBbcmVuZGVyZXJPdXRwdXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ1N0cmluZyc6IHtcbiAgICAgICAgICAgICAgICByZW5kZXJlck91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2xzIDogY2VsbENscyxcbiAgICAgICAgICAgICAgICAgICAgaHRtbDogcmVuZGVyZXJPdXRwdXQ/LnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyZXJPdXRwdXQgPT09IG51bGwgfHwgcmVuZGVyZXJPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHVtbi5jZWxsQWxpZ24gIT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgY2VsbENscy5wdXNoKCduZW8tJyArIGNvbHVtbi5jZWxsQWxpZ24pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNlbGxJZCkge1xuICAgICAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoZSBlbHNlIHBhcnQgYXMgc29vbiBhcyBhbGwgdGFibGVzIHVzZSBzdG9yZXMgKGV4YW1wbGVzIHRhYmxlKVxuICAgICAgICAgICAgaWYgKGhhc1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgY2VsbElkID0gbWUuZ2V0Q2VsbElkKHJlY29yZCwgY29sdW1uLmRhdGFGaWVsZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbElkID0gdmRvbS5jbltpbmRleF0/LmNuW21lLmdldENvbHVtbihjb2x1bW4uZGF0YUZpZWxkLCB0cnVlKV0/LmlkIHx8IE5lby5nZXRJZCgndGQnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2VsbENvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZyAgICAgOiAndGQnLFxuICAgICAgICAgICAgaWQgICAgICA6IGNlbGxJZCxcbiAgICAgICAgICAgIGNscyAgICAgOiBjZWxsQ2xzLFxuICAgICAgICAgICAgc3R5bGUgICA6IHJlbmRlcmVyT3V0cHV0LnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgdGFiSW5kZXg6ICctMSdcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29sc3BhbiAmJiBPYmplY3Qua2V5cyhjb2xzcGFuKS5pbmNsdWRlcyhkYXRhRmllbGQpKSB7XG4gICAgICAgICAgICBjZWxsQ29uZmlnLmNvbHNwYW4gPSBjb2xzcGFuW2RhdGFGaWVsZF1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8udHlwZU9mKHJlbmRlcmVyT3V0cHV0KSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIGNlbGxDb25maWcuaW5uZXJIVE1MID0gcmVuZGVyZXJPdXRwdXQuaHRtbCAgfHwgJydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxDb25maWcuY24gPSByZW5kZXJlck91dHB1dFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGxDb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3RGF0YShpbnB1dERhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFtb3VudFJvd3MgICAgID0gaW5wdXREYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHRhYmxlQ29udGFpbmVyID0gbWUucGFyZW50LFxuICAgICAgICAgICAgY29sdW1ucyAgICAgICAgPSB0YWJsZUNvbnRhaW5lci5pdGVtc1swXS5pdGVtcyxcbiAgICAgICAgICAgIGNvbENvdW50ICAgICAgID0gY29sdW1ucy5sZW5ndGgsXG4gICAgICAgICAgICBkYXRhICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAge3Zkb219ICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIGNvbmZpZywgY29sc3BhbiwgY29sc3BhbktleXMsIGNvbHVtbiwgZG9ja0xlZnRNYXJnaW4sIGRvY2tSaWdodE1hcmdpbiwgaWQsIGluZGV4LCBqLCByZWNvcmQsIHNlbGVjdGVkUm93cywgdHJDbHM7XG5cbiAgICAgICAgaWYgKHRhYmxlQ29udGFpbmVyLnNlbGVjdGlvbk1vZGVsLm50eXBlID09PSAnc2VsZWN0aW9uLXRhYmxlLXJvd21vZGVsJykge1xuICAgICAgICAgICAgc2VsZWN0ZWRSb3dzID0gdGFibGVDb250YWluZXIuc2VsZWN0aW9uTW9kZWwuaXRlbXMgfHwgW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGFtb3VudFJvd3M7IGkrKykge1xuICAgICAgICAgICAgcmVjb3JkICAgICAgPSBpbnB1dERhdGFbaV07XG4gICAgICAgICAgICBjb2xzcGFuICAgICA9IHJlY29yZFttZS5jb2xzcGFuRmllbGRdO1xuICAgICAgICAgICAgY29sc3BhbktleXMgPSBjb2xzcGFuICYmIE9iamVjdC5rZXlzKGNvbHNwYW4pO1xuICAgICAgICAgICAgaWQgICAgICAgICAgPSBtZS5nZXRSb3dJZChyZWNvcmQsIGkpO1xuXG4gICAgICAgICAgICBtZS5yZWNvcmRWbm9kZU1hcFtpZF0gPSBpO1xuXG4gICAgICAgICAgICB0ckNscyA9IG1lLmdldFRyQ2xhc3MocmVjb3JkLCBpKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkUm93cz8uaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgdHJDbHMucHVzaCgnbmVvLXNlbGVjdGVkJyk7XG5cbiAgICAgICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KG1lLmNvbnRhaW5lcklkKS5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFnICAgICA6ICd0cicsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgY2xzICAgICA6IHRyQ2xzLFxuICAgICAgICAgICAgICAgIGNuICAgICAgOiBbXSxcbiAgICAgICAgICAgICAgICB0YWJJbmRleDogJy0xJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRvY2tMZWZ0TWFyZ2luICA9IDA7XG4gICAgICAgICAgICBkb2NrUmlnaHRNYXJnaW4gPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGo9MDsgaiA8IGNvbENvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2pdO1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lLmFwcGx5UmVuZGVyZXJPdXRwdXQoe2NvbHVtbiwgcmVjb3JkLCBpbmRleDogaSwgdGFibGVDb250YWluZXJ9KTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uZG9jaykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuY2xzID0gWyduZW8tbG9ja2VkJywgLi4uY29uZmlnLmNscyB8fCBbXV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kb2NrID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdHlsZS5sZWZ0ID0gZG9ja0xlZnRNYXJnaW4gKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9ja0xlZnRNYXJnaW4gKz0gKGNvbHVtbi53aWR0aCArIDEpIC8vIHRvZG86IGJvcmRlcnMgZml4XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmZsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YVtpXS5jbi5wdXNoKGNvbmZpZyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sc3BhbktleXM/LmluY2x1ZGVzKGNvbHVtbi5kYXRhRmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gKGNvbHNwYW5bY29sdW1uLmRhdGFGaWVsZF0gLSAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChqPTA7IGogPCBjb2xDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggID0gY29sQ291bnQgLSBqIC0xO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kb2NrID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0uY25baW5kZXhdLnN0eWxlLnJpZ2h0ID0gZG9ja1JpZ2h0TWFyZ2luICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgZG9ja1JpZ2h0TWFyZ2luICs9IChjb2x1bW4ud2lkdGggKyAxKSAvLyB0b2RvOiBib3JkZXJzIGZpeFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2xzcGFuS2V5cz8uaW5jbHVkZXMoY29sdW1uLmRhdGFGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAoY29sc3Bhbltjb2x1bW4uZGF0YUZpZWxkXSAtIDEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmRvbS5jbiA9IGRhdGE7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YWJsZUNvbnRhaW5lciwge2RvY2tMZWZ0TWFyZ2luLCBkb2NrUmlnaHRNYXJnaW59KTtcblxuICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRSb3dzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBsb2dpYyBvbmx5IHdvcmtzIGZvciBzZWxlY3Rpb24udGFibGUuUm93TW9kZWxcbiAgICAgICAgICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc2Nyb2xsVG9UYWJsZVJvdyh7YXBwTmFtZTogbWUuYXBwTmFtZSwgaWQ6IHNlbGVjdGVkUm93c1swXX0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG51bGw7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2VsbElkKHJlY29yZCwgZGF0YUZpZWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJ19fJyArIHJlY29yZFt0aGlzLnN0b3JlLmtleVByb3BlcnR5XSArICdfXycgKyBkYXRhRmllbGRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSB0YWJsZSBjb2x1bW4gb3IgY29sdW1uIGluZGV4IGJ5IGEgZ2l2ZW4gZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuSW5kZXg9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE51bWJlcnxudWxsfVxuICAgICAqL1xuICAgIGdldENvbHVtbihmaWVsZCwgcmV0dXJuSW5kZXg9ZmFsc2UpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMucGFyZW50LFxuICAgICAgICAgICAgY29sdW1ucyAgID0gY29udGFpbmVyLml0ZW1zWzBdLml0ZW1zLCAvLyB0b2RvOiB3ZSBuZWVkIGEgc2hvcnRjdXQgZm9yIGFjY2Vzc2luZyB0aGUgaGVhZGVyIHRvb2xiYXJcbiAgICAgICAgICAgIGkgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgPSBjb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgICAgIGNvbHVtbjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uLmRhdGFGaWVsZCA9PT0gZmllbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuSW5kZXggPyBpIDogY29sdW1uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWF0Y2hpbmcgcmVjb3JkIGJ5IHBhc3NpbmcgYSByb3cgaWQsIGEgY2VsbCBpZCBvciBhbiBpZCBpbnNpZGUgYSB0YWJsZSBjZWxsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0UmVjb3JkKG5vZGVJZCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmdldFJlY29yZEJ5Um93SWQobm9kZUlkKSxcbiAgICAgICAgICAgIG5vZGUsIHBhcmVudE5vZGVzO1xuXG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnROb2RlcyA9IFZEb21VdGlsLmdldFBhcmVudE5vZGVzKG1lLnZkb20sIG5vZGVJZCk7XG5cbiAgICAgICAgZm9yIChub2RlIG9mIHBhcmVudE5vZGVzKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBtZS5nZXRSZWNvcmRCeVJvd0lkKG5vZGUuaWQpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm93SWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJlY29yZEJ5Um93SWQocm93SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0QXQodGhpcy5yZWNvcmRWbm9kZU1hcFtyb3dJZF0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRSb3dJZChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzdG9yZX0gPSBtZTtcblxuICAgICAgICBpZiAobWUudXNlUm93UmVjb3JkSWRzKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bWUuaWR9X190cl9fJHtyZWNvcmRbc3RvcmUua2V5UHJvcGVydHldfWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gTmVvLmlzTnVtYmVyKGluZGV4KSA/IGluZGV4IDogc3RvcmUuaW5kZXhPZihyZWNvcmQpO1xuICAgICAgICAgICAgcmV0dXJuIG1lLnZkb20uY25baW5kZXhdPy5pZCB8fCBOZW8uZ2V0SWQoJ3RyJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGN1c3RvbSBDU1MgcnVsZXMgdG8gdGFibGUgcm93c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcm93SW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0VHJDbGFzcyhyZWNvcmQsIHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiBbJ25lby10YWJsZS1yb3cnXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhIHJlY29yZCBmaWVsZC5cbiAgICAgKiBFLmcuIG15UmVjb3JkLmZvbyA9ICdiYXInO1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb3B0cy5maWVsZHMgRWFjaCBmaWVsZCBvYmplY3QgY29udGFpbnMgdGhlIGtleXM6IG5hbWUsIG9sZFZhbHVlLCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG9wdHMubW9kZWwgVGhlIG1vZGVsIGluc3RhbmNlIG9mIHRoZSBjaGFuZ2VkIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnJlY29yZFxuICAgICAqL1xuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2Uob3B0cykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmllbGROYW1lcyAgICAgPSBvcHRzLmZpZWxkcy5tYXAoZmllbGQgPT4gZmllbGQubmFtZSksXG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdGFibGVDb250YWluZXIgPSBtZS5wYXJlbnQsXG4gICAgICAgICAgICB7dmRvbX0gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgY2VsbElkLCBjZWxsTm9kZSwgY29sdW1uLCBpbmRleCwgc2NvcGU7XG5cbiAgICAgICAgaWYgKGZpZWxkTmFtZXMuaW5jbHVkZXMobWUuY29sc3BhbkZpZWxkKSkge1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIG5hcnJvdyBpdCBkb3duIHRvIG9ubHkgdXBkYXRlIHRoZSBjdXJyZW50IHJvd1xuICAgICAgICAgICAgbWUuY3JlYXRlVmlld0RhdGEobWUuc3RvcmUuaXRlbXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICBjZWxsSWQgICA9IG1lLmdldENlbGxJZChvcHRzLnJlY29yZCwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgY2VsbE5vZGUgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKHZkb20sIGNlbGxJZCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgdmRvbSBtaWdodCBub3QgZXhpc3QgeWV0ID0+IG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgaWYgKGNlbGxOb2RlPy52ZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiAgICAgID0gbWUuZ2V0Q29sdW1uKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAgICAgICA9IGNlbGxOb2RlLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlICAgICAgID0gY29sdW1uLnJlbmRlcmVyU2NvcGUgfHwgdGFibGVDb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgY2VsbE5vZGUucGFyZW50Tm9kZS5jbltpbmRleF0gPSBtZS5hcHBseVJlbmRlcmVyT3V0cHV0KHtjZWxsSWQsIGNvbHVtbiwgcmVjb3JkOiBvcHRzLnJlY29yZCwgaW5kZXgsIHRhYmxlQ29udGFpbmVyfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmVlZHNVcGRhdGUgJiYgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBWaWV3O1xuIiwiaW1wb3J0IEJhc2VCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUZXh0RmllbGQgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFibGUuaGVhZGVyLkJ1dHRvblxuICogQGV4dGVuZHMgTmVvLmJ1dHRvbi5CYXNlXG4gKi9cbmNsYXNzIEJ1dHRvbiBleHRlbmRzIEJhc2VCdXR0b24ge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgYWxpZ25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2VsbEFsaWduVmFsdWVzOiBbJ2xlZnQnLCdjZW50ZXInLCdyaWdodCddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2VsbEFsaWduVmFsdWVzID0gWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50YWJsZS5oZWFkZXIuQnV0dG9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFibGUuaGVhZGVyLkJ1dHRvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWJsZS1oZWFkZXItYnV0dG9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RhYmxlLWhlYWRlci1idXR0b24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdGFibGUtaGVhZGVyLWJ1dHRvbiddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10YWJsZS1oZWFkZXItYnV0dG9uJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlnbm1lbnQgb2YgdGhlIG1hdGNoaW5nIHRhYmxlIGNlbGxzLiBWYWxpZCB2YWx1ZXMgYXJlIGxlZnQsIGNlbnRlciwgcmlnaHRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjZWxsQWxpZ25fPSdsZWZ0J1xuICAgICAgICAgKi9cbiAgICAgICAgY2VsbEFsaWduXzogJ2xlZnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRhdGFGaWVsZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0IGRpcmVjdGlvbiB3aGVuIGNsaWNraW5nIG9uIGFuIHVuc29ydGVkIGJ1dHRvblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRlZmF1bHRTb3J0RGlyZWN0aW9uPSdBU0MnXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0U29ydERpcmVjdGlvbjogJ0FTQycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnZ2FibGVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnYWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGVkaXRvckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0b3JDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGZpbHRlckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZm9ybS5maWVsZC5CYXNlfG51bGx9IGZpbHRlckZpZWxkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGljb25DbHM9J2ZhIGZhLWFycm93LWNpcmNsZS11cCdcbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6ICdmYSBmYS1hcnJvdy1jaXJjbGUtdXAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpY29uUG9zaXRpb249J3JpZ2h0J1xuICAgICAgICAgKi9cbiAgICAgICAgaWNvblBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogJ0FTQycsICdERVNDJyBvciBudWxsXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpc1NvcnRlZF89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1NvcnRlZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY29wZSB0byBleGVjdXRlIHRoZSBjb2x1bW4gcmVuZGVyZXIuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHRoZSBtYXRjaGluZyB0YWJsZS5Db250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvcmUuQmFzZXxudWxsfSByZW5kZXJlclNjb3BlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyU2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93SGVhZGVyRmlsdGVyXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0hlYWRlckZpbHRlcl86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc29ydGFibGVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAndGgnLCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ2J1dHRvbicsIGNuOiBbXG4gICAgICAgICAgICAgICAge3RhZzogJ3NwYW4nLCBjbHM6IFsnbmVvLWJ1dHRvbi1nbHlwaCddfSxcbiAgICAgICAgICAgICAgICB7dGFnOiAnc3BhbicsIGNsczogWyduZW8tYnV0dG9uLXRleHQnXX0sXG4gICAgICAgICAgICAgICAge3RhZzogJ3NwYW4nLCBjbHM6IFsnbmVvLWJ1dHRvbi1iYWRnZSddfSxcbiAgICAgICAgICAgICAgICB7dGFnOiAnc3BhbicsIGNsczogWyduZW8tYnV0dG9uLXJpcHBsZS13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1idXR0b24tcmlwcGxlJ119XG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kcmFnZ2FibGUgJiYgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGRyYWdlbmQgIDogbWUub25EcmFnRW5kLFxuICAgICAgICAgICAgZHJhZ2VudGVyOiBtZS5vbkRyYWdFbnRlcixcbiAgICAgICAgICAgIGRyYWdsZWF2ZTogbWUub25EcmFnTGVhdmUsXG4gICAgICAgICAgICBkcmFnb3ZlciA6IG1lLm9uRHJhZ092ZXIsXG4gICAgICAgICAgICBkcmFnc3RhcnQ6IG1lLm9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgZHJvcCAgICAgOiBtZS5vbkRyb3AsXG4gICAgICAgICAgICBzY29wZSAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnZ2FibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZS5nZXRWZG9tUm9vdCgpLmRyYWdnYWJsZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5nZXRWZG9tUm9vdCgpLmRyYWdnYWJsZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlzU29ydGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1NvcnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgPSBtZSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG1lLnVwKCd0YWJsZS1jb250YWluZXInKTtcblxuICAgICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FTQyc6XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWRlc2MnKTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1zb3J0LWFzYycpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdERVNDJzpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtYXNjJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1kZXNjJyk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICAvLyB0ZXN0aW5nIGNoZWNrIHVudGlsIGFsbCBleGFtcGxlIHRhYmxlcyBoYXZlIGEgc3RvcmVcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5zdG9yZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5tb3VudGVkICYmIG1lLmZpcmUoJ3NvcnQnLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IHZhbHVlLFxuICAgICAgICAgICAgcHJvcGVydHkgOiBtZS5kYXRhRmllbGRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dIZWFkZXJGaWx0ZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93SGVhZGVyRmlsdGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFtZS5maWx0ZXJGaWVsZCkge1xuICAgICAgICAgICAgICAgIG1lLmZpbHRlckZpZWxkID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgICAgIDogJ2ZpbHRlci1maWVsZCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5pZCxcblxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSAgICAgICAgOiBtZS5jaGFuZ2VGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yQ2hhbmdlOiBtZS5jaGFuZ2VGaWx0ZXJPcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlICAgICAgICAgOiBtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0IDogJy41ZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICcuNWVtJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5lZGl0b3JDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLnZkb20uY24ucHVzaChtZS5maWx0ZXJGaWVsZC52ZG9tKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWUuZmlsdGVyRmllbGQudmRvbS5yZW1vdmVEb21cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZS5maWx0ZXJGaWVsZCkge1xuICAgICAgICAgICAgbWUuZmlsdGVyRmllbGQudmRvbS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuXG4gICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgIGNsaWNrOiBtZS5vbkJ1dHRvbkNsaWNrLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcblxuICAgICAgICAgICAgbWUucmVtb3ZlRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgICAgICBjbGljazogbWUub25CdXR0b25DbGljayxcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2VsbEFsaWduIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2VsbEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnY2VsbEFsaWduJywgJ2NlbGxBbGlnblZhbHVlcycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyRmllbGQ/LmRlc3Ryb3koKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2ZG9tIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZub2RlUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdmRvbSByb290XG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZub2RlIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZkb21Sb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2bm9kZSByb290XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uQnV0dG9uQ2xpY2soKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBtYXA7XG5cbiAgICAgICAgaWYgKG1lLmRlZmF1bHRTb3J0RGlyZWN0aW9uID09PSAnREVTQycpIHtcbiAgICAgICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgICAgICBBU0MgOiBudWxsLFxuICAgICAgICAgICAgICAgIERFU0M6ICdBU0MnLFxuICAgICAgICAgICAgICAgIG51bGw6ICdERVNDJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgICAgIEFTQyA6ICdERVNDJyxcbiAgICAgICAgICAgICAgICBERVNDOiBudWxsLFxuICAgICAgICAgICAgICAgIG51bGw6ICdBU0MnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc1NvcnRlZCA9IG1hcFttZS5pc1NvcnRlZCArICcnXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzdHlsZX0gPSBtZTtcblxuICAgICAgICBkZWxldGUgc3R5bGUub3BhY2l0eTtcbiAgICAgICAgbWUuc3R5bGUgPSBzdHlsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRyYWdFbnRlcigpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1kcmFnLW92ZXInKTtcbiAgICAgICAgbWUuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRHJhZ0xlYXZlKCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZTtcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLWRyYWctb3ZlcicpO1xuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ29uRHJhZ092ZXInLCBldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c3R5bGV9ID0gbWU7XG5cbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuNDtcbiAgICAgICAgbWUuc3R5bGUgPSBzdHlsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Ecm9wKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhlYWRlclRvb2xiYXIgID0gbWUucGFyZW50LFxuICAgICAgICAgICAge3N0eWxlfSAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIHRhYmxlQ29udGFpbmVyID0gaGVhZGVyVG9vbGJhci5wYXJlbnQ7XG5cbiAgICAgICAgbWUub25EcmFnTGVhdmUoKTtcbiAgICAgICAgaGVhZGVyVG9vbGJhci5zd2l0Y2hJdGVtcyhtZS5pZCwgZGF0YS5zcmNJZCk7XG4gICAgICAgIHRhYmxlQ29udGFpbmVyLmNyZWF0ZVZpZXdEYXRhKHRhYmxlQ29udGFpbmVyLnN0b3JlLmRhdGEpO1xuXG4gICAgICAgIHN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBtZS5zdHlsZSA9IHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjaGFuZ2VGaWx0ZXJPcGVyYXRvcihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0YWJsZUNvbnRhaW5lciA9IG1lLnVwKCd0YWJsZS1jb250YWluZXInKSxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICAgID0gdGFibGVDb250YWluZXI/LnN0b3JlLFxuICAgICAgICAgICAgb3BlcmF0b3IgICAgICAgPSBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgZmlsdGVyLCBmaWx0ZXJzO1xuXG4gICAgICAgIGlmIChzdG9yZSkge1xuICAgICAgICAgICAgZmlsdGVyID0gc3RvcmUuZ2V0RmlsdGVyKG1lLmRhdGFGaWVsZCk7XG5cbiAgICAgICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IHN0b3JlLmZpbHRlcnM7XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogbWUuZGF0YUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmZpbHRlckNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc3RvcmUuZmlsdGVycyA9IGZpbHRlcnNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLm9wZXJhdG9yID0gb3BlcmF0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgY2hhbmdlRmlsdGVyVmFsdWUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdGFibGVDb250YWluZXIgPSBtZS51cCgndGFibGUtY29udGFpbmVyJyksXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgICA9IHRhYmxlQ29udGFpbmVyPy5zdG9yZSxcbiAgICAgICAgICAgIHt2YWx1ZX0gICAgICAgID0gZGF0YSxcbiAgICAgICAgICAgIGZpZWxkLCBmaWx0ZXIsIGZpbHRlcnMsIG1vZGVsO1xuXG4gICAgICAgIGlmIChzdG9yZSkge1xuICAgICAgICAgICAgZmlsdGVyID0gc3RvcmUuZ2V0RmlsdGVyKG1lLmRhdGFGaWVsZCk7XG4gICAgICAgICAgICBtb2RlbCAgPSBzdG9yZS5tb2RlbDtcbiAgICAgICAgICAgIGZpZWxkICA9IG1vZGVsICYmIG1vZGVsLmdldEZpZWxkKG1lLmRhdGFGaWVsZCk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBmaWVsZC50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IHN0b3JlLmZpbHRlcnM7XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogbWUuZGF0YUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ2xpa2UnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZmlsdGVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdG9yZS5maWx0ZXJzID0gZmlsdGVyc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZVNvcnRpbmdDc3MoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcblxuICAgICAgICBtZS5jbHMgICAgICAgPSBjbHM7XG4gICAgICAgIG1lLl9pc1NvcnRlZCA9IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmRhdGFGaWVsZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBkYXRhLnZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgcmVuZGVyZXIoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS52YWx1ZVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoQnV0dG9uKTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xuIiwiaW1wb3J0IEJhc2VUb29sYmFyIGZyb20gJy4uLy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFibGUuaGVhZGVyLlRvb2xiYXJcbiAqIEBleHRlbmRzIE5lby50b29sYmFyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIEJhc2VUb29sYmFyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50YWJsZS5oZWFkZXIuVG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYmxlLmhlYWRlci5Ub29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RhYmxlLWhlYWRlci10b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RhYmxlLWhlYWRlci10b29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsndGFibGUtaGVhZGVyLXRvb2xiYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyd0YWJsZS1oZWFkZXItdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsYXlvdXQ9J2Jhc2UnXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6ICdiYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtudHlwZSA6ICd0YWJsZS1oZWFkZXItYnV0dG9uJ31cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGUgOiAndGFibGUtaGVhZGVyLWJ1dHRvbidcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dIZWFkZXJGaWx0ZXJzXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0hlYWRlckZpbHRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17dGFnOid0aGVhZCcsY246W3t0YWc6J3RyJyxjbjpbXX1dfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICd0aGVhZCcsIGNuOiBbXG4gICAgICAgICAgICB7dGFnOiAndHInLCBjbjogW119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93SGVhZGVyRmlsdGVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dIZWFkZXJGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnNldFNpbGVudCh7XG4gICAgICAgICAgICAgICAgICAgIHNob3dIZWFkZXJGaWx0ZXI6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICAgYWZ0ZXJTZXRTb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLml0ZW1EZWZhdWx0cy5zaG93SGVhZGVyRmlsdGVyID0gbWUuc2hvd0hlYWRlckZpbHRlcnM7XG5cbiAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKTtcblxuICAgICAgICBsZXQgZG9ja0xlZnRXaWR0aCAgPSAwLFxuICAgICAgICAgICAgZG9ja1JpZ2h0V2lkdGggPSAwLFxuICAgICAgICAgICAge2l0ZW1zfSAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgc3R5bGU7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHN0eWxlID0gaXRlbS53cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgIC8vIHRvZG86IG9ubHkgYWRkIHB4IGlmIG51bWJlclxuICAgICAgICAgICAgaWYgKGl0ZW0ubWF4V2lkdGgpIHtzdHlsZS5tYXhXaWR0aCA9IGl0ZW0ubWF4V2lkdGggKyAncHgnfVxuICAgICAgICAgICAgaWYgKGl0ZW0ubWluV2lkdGgpIHtzdHlsZS5taW5XaWR0aCA9IGl0ZW0ubWluV2lkdGggKyAncHgnfVxuICAgICAgICAgICAgaWYgKGl0ZW0ud2lkdGgpICAgIHtzdHlsZS53aWR0aCAgICA9IGl0ZW0ud2lkdGggICAgKyAncHgnfVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5kb2NrKSB7XG4gICAgICAgICAgICAgICAgaXRlbS52ZG9tLmNscyA9IFsnbmVvLWxvY2tlZCddO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZG9jayA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBkb2NrTGVmdFdpZHRoICsgJ3B4J1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvY2tMZWZ0V2lkdGggKz0gKGl0ZW0ud2lkdGggKyAxKSAvLyB0b2RvOiBib3JkZXJzIGZpeFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLnZkb20uY2xzID0gW10gLy8gcmVtb3ZlIHRoZSBidXR0b24gY2xzIGZyb20gdGhlIHRoIHRhZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLnNvcnRhYmxlID0gbWUuc29ydGFibGU7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgICAgICAvLyBpbnZlcnNlIGxvb3AgZGlyZWN0aW9uXG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbbGVuIC0gaW5kZXggLTFdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5kb2NrID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZTtcbiAgICAgICAgICAgICAgICBzdHlsZS5yaWdodCA9IGRvY2tSaWdodFdpZHRoICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gc3R5bGU7XG5cbiAgICAgICAgICAgICAgICBkb2NrUmlnaHRXaWR0aCArPSAoaXRlbS53aWR0aCArIDEpIC8vIHRvZG86IGJvcmRlcnMgZml4XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRvY2tcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBsYXlvdXRDb25maWdcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBnZXRMYXlvdXRDb25maWcoZG9jaykge1xuICAgICAgICByZXR1cm4gJ2Jhc2UnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2ZG9tIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZub2RlUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdmRvbSByb290XG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZub2RlIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZkb21Sb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2bm9kZSByb290XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzBdXG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhUb29sYmFyKTtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJhcjtcbiIsImltcG9ydCBCdXR0b24gIGZyb20gJy4vQnV0dG9uLm1qcyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuL1Rvb2xiYXIubWpzJztcblxuZXhwb3J0IHtCdXR0b24sIFRvb2xiYXJ9OyIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5Dc3NcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQ3NzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5Dc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLkNzcydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzIHRoZSBzZWxlY3RvclRleHQgb2YgdGhlIHJ1bGVzIHdoaWNoIHlvdSB3YW50IHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IHJ1bGVzXG4gICAgICovXG4gICAgc3RhdGljIGRlbGV0ZVJ1bGVzKGFwcE5hbWUsIHJ1bGVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShydWxlcykpIHtcbiAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzXVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldC5kZWxldGVDc3NSdWxlcyh7YXBwTmFtZSwgcnVsZXN9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IHJ1bGVzXG4gICAgICovXG4gICAgc3RhdGljIGluc2VydFJ1bGVzKGFwcE5hbWUsIHJ1bGVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShydWxlcykpIHtcbiAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzXVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldC5pbnNlcnRDc3NSdWxlcyh7YXBwTmFtZSwgcnVsZXN9KVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoQ3NzKTtcblxuZXhwb3J0IGRlZmF1bHQgQ3NzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9