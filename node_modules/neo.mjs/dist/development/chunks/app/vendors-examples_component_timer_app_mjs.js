"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_component_timer_app_mjs"],{

/***/ "./examples/component/timer/MainContainer.mjs":
/*!****************************************************!*\
  !*** ./examples/component/timer/MainContainer.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/form/field/Color.mjs */ "./src/form/field/Color.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _src_component_Timer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/component/Timer.mjs */ "./src/component/Timer.mjs");






/**
 * @class Neo.examples.component.timer.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className: 'Neo.examples.component.timer.MainContainer',
    }

    createConfigurationComponents() {
        let me = this;

        return [{
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            labelText: 'dimensions',
            listeners: {change: me.onConfigChange.bind(me, 'dimensions')},
            value    : '8rem'
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: false,
            labelText: 'colorStart',
            listeners: {change: me.onConfigChange.bind(me, 'colorStart')},
            value    : '#8a9b0f'
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: false,
            labelText: 'colorEnd',
            listeners: {change: me.onConfigChange.bind(me, 'colorEnd')},
            value    : '#940a3d'
        }]
    }

    createExampleComponent() {
        return Neo.create({
            module: _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            style : {
                overflow : 'auto',
                maxHeight: '100%'
            },
            items : [{
                html: '<h1>Configurable</h1>',
                style: {textAlign: 'center'}
            }, {
                module    : _src_component_Timer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                duration  : '20s',
                flag      : 'timer-component',
                dimensions: '8rem'
            }]
        })
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        const timer = this.down({flag: 'timer-component'});

        timer[config] = opts.value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./examples/component/timer/app.mjs":
/*!******************************************!*\
  !*** ./examples/component/timer/app.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/timer/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.timer'
});



/***/ }),

/***/ "./src/component/Timer.mjs":
/*!*********************************!*\
  !*** ./src/component/Timer.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.component.Timer
 * @extends Neo.component.Base
 */
class Timer extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Timer'
         * @protected
         */
        className: 'Neo.component.Timer',
        /**
         * @member {String} ntype='timer'
         * @protected
         */
        ntype: 'timer',
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=['timer']
         */
        baseCls: ['neo-timer'],
        /**
         * End color of the circle. If not set, it uses the css default
         * @member {Number|String} colorEnd_=null
         */
        colorEnd_: null,
        /**
         * Start color of the circle. If not set, it uses the css default
         * @member {Number|String} colorStart_=null
         */
        colorStart_: null,
        /**
         * Start time. This might be '5m', '30s' or milliseconds as number
         * @member {Number|String} duration_='5m'
         */
        duration_: '10m',
        /**
         * Defines height and min-width. This can be a number in px or a string.
         * @member {Number|String} dimensions_='6rem'
         */
        dimensions_: '8em',
        /**
         * Helper to keep running smooth at minimum cost
         * @member {Object}      timer={}
         * @member {Number|null} timer.currentSecond =null // run only once per second
         * @member {Number|null} timer.intervalId    =null // setInterval id
         * @member {Boolean}     timer.running       =false// keeps track if timer/entry is up
         * @member {Number|null} timer.startTime     =null // calc the current progress
         */
        timer: {
            currentSecond: null,
            intervalId   : null,
            running      : false,
            startTime    : null
        },
        /**
         * The vdom markup for this component.
         * @member {Object} vdom={}
         */
        vdom:
        {cn: [
            {cls: 'countdown', cn: [
                {tag: 'svg', cls: 'clock', viewBox: '-50 -50 100 100', strokeWidth: '10', cn: [
                    {tag: 'circle', r: 45},
                    {tag: 'circle', r: 45, pathLength: 1}
                ]},
                {cls: ['flip-card'], cn : [
                    {cls: 'flip-card-inner enter-mask', cn : [
                        {cls: 'flip-card-front', cn : [
                            {tag: 'input', cls: 'enter-time'},
                            {tag: 'button',cls: 'fa fa-play'}
                        ]},
                        {cls: 'flip-card-back', cn : [
                            {cls: 'runner', html: '00:00'}
                        ]}
                    ]}
                ]}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click   : me.onTimerClick,   delegate: 'flip-card-back'},
            {click   : me.onTimerClick,   delegate: 'fa fa-play'},
            {input   : me.onTimerInput,   delegate: 'enter-time'},
            {focusout: me.onTimerInput,   delegate: 'enter-time'},
            {keydown : me.onFieldKeyDown, delegate: 'enter-time'}
        ])
    }

    /**
     * Triggered after the dimensions config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetDimensions(value, oldValue) {
        if (typeof value === 'number') {
            value = value + 'px'
        }

        this.updateProperties({dimensions: value})
    }

    /**
     * Triggered after the colorStart config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetColorStart(value, oldValue) {
        value && this.updateProperties({colorStart: value})
    }

    /**
     * Triggered after the colorEnd config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetColorEnd(value, oldValue) {
        value && this.updateProperties({colorEnd: value})
    }

    /**
     * Triggered before the duration config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetDuration(value, oldValue) {
        let me = this,
            durationType;

        me.updateInputField(value)

        if (Neo.isString(value)) {
            durationType = value.at(-1);

            if (durationType === 'm') {
                value = value.split('m')[0] * 60 * 1000
            } else if (durationType === 's') {
                value = value.split('s')[0] * 1000
            }
        }

        me.updateProperties({full: value});

        return value
    }

    /**
     * Check if Enter was pressed
     * @param {Object} data
     */
    onFieldKeyDown(data) {
        let me = this;

        if (data.key === 'Enter') {
            me.duration = me.timer.entry;
            me.onTimerClick()
        }
    }

    /**
     * Click on Play or Timer
     */
    onTimerClick() {
        let me = this;

        // If the timer is running, stop and clear it
        if (me.timer.intervalId) {
            me.toggleTimer(false);
            me.resetTimer()
        } else {
            // prepare
            me.timer.startTime = new Date().getTime();

            me.timer.intervalId = setInterval(function () {
                const startTime = me.timer.startTime,
                      curTime   = new Date().getTime(),
                      totalTime = me.duration,
                      endTime   = startTime + totalTime;

                if (curTime > endTime) {
                    me.toggleTimer(false);
                    me.resetTimer()
                } else {
                    const milliseconds = endTime - curTime,
                          secondsLeft  = Math.floor(milliseconds / 1000);
                    let secondsNow = secondsLeft % 60,
                        minutesNow = Math.floor(secondsLeft / 60)

                    // Ensure this does not run 10 times a second
                    if (secondsNow !== me.timer.currentSecond) {
                        me.timer.currentSecond = secondsNow;

                        secondsNow = secondsNow.toString().padStart(2, '0');
                        minutesNow = minutesNow.toString().padStart(2, '0');

                        me.updateTimer(`${minutesNow}:${secondsNow}`);
                        me.updateProperties({current: milliseconds});
                        me.toggleTimer(true)
                    }
                }
            }, 100)
        }
    }

    /**
     * On change event of the textfield
     * @param {Object} data
     */
    onTimerInput(data) {
        let me = this;

        if (data.value) {
            me.timer.entry = data.value
        } else {
            me.duration = me.timer.entry
        }
    }

    /**
     * Reset the properties, timer and remove Interval
     */
    resetTimer() {
        let me = this;

        me.updateProperties({current: ''});
        me.updateTimer('00:00');

        clearInterval(me.timer.intervalId);
        delete me.timer.intervalId
    }

    /**
     * Flip over the timer face
     * @param {Boolean} doShow
     */
    toggleTimer(doShow) {
        if(this.running === doShow) return;

        let me       = this,
            flipCard = me.vdom.cn[0].cn[1];

        me.running = doShow;

        flipCard.cls = flipCard.cls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][doShow ? 'add' : 'remove'](flipCard.cls, 'turn');
        me.update()
    }

    /**
     * Write to the input field
     * @param {String} value
     */
    updateInputField(value) {
        let me         = this,
            inputField = me.vdom.cn[0].cn[1].cn[0].cn[0].cn[0];

        inputField.value = value;
    }

    /**
     * Update the timer, typically once per second
     * @param {String} value
     */
    updateTimer(value) {
        let me    = this,
            timer = me.vdom.cn[0].cn[1].cn[0].cn[1].cn[0];

        timer.innerHTML = value;
        me.update()
    }

    /**
     * Update the css properties
     * - current amount of seconds left
     * - full amount of time
     * - size of the timer
     * @param {Object} properties
     */
    updateProperties(properties) {
        let {style} = this;

        if (properties.current !== undefined) {
            style['--neo-timer-current'] = `${properties.current}!important`
        }
        if (properties.full !== undefined) {
            style['--neo-timer-full'] = `${properties.full}!important`
        }
        if (properties.colorEnd !== undefined) {
            style['--timer-color-end'] = `${properties.colorEnd}!important`
        }
        if (properties.colorStart !== undefined) {
            style['--timer-color-start'] = `${properties.colorStart}!important`
        }
        if (properties.dimensions !== undefined) {
            style['--timer-dimension'] = `${properties.dimensions}!important`
        }

        this.style = style
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Timer));


/***/ }),

/***/ "./src/form/field/Color.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.ComboBox
 */
class Color extends _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-combobox','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-combobox', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getInputWrapperId()});

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getColorIndicatorId()})?.vdom,
            {list, record} = me,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor();
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]))
        } else {
            selectionModel?.deselectAll(true)
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter)
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me                  = this,
            {inputValue, value} = me;

        return value ? me.colorFormatter(me, value) : me.forceSelection ? null : inputValue
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let {list} = this,
            index  = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem()
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let {list} = this;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ }),

/***/ "./src/list/Color.mjs":
/*!****************************!*\
  !*** ./src/list/Color.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.list.Color
 * @extends Neo.list.Base
 */
class Color extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Color'
         * @protected
         */
        className: 'Neo.list.Color',
        /**
         * @member {String} ntype='colorlist'
         * @protected
         */
        ntype: 'colorlist',
        /**
         * @member {String[]} baseCls=['neo-color-list','neo-list']
         */
        baseCls: ['neo-color-list', 'neo-list'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField]
    }

    /**
     * form.field.Color needs to trigger a silent vdom update
     * @member {Boolean} silentSelectUpdate=false
     * @protected
     */
    silentSelectUpdate = false

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me         = this,
            id         = record[me.store.keyProperty],
            isSelected = me.selectionModel.isSelected(me.getItemId(id));

        return [{
            tag  : 'i',
            cls  : ['neo-icon', 'fas', `fa-${isSelected ? 'check-' : ''}square`],
            id   : me.getListItemIconId(id),
            style: {
                color: me.colorFormatter(me, record)
            }
        }, {
            vtype: 'text',
            html : record[me.displayField],
            id   : me.getListItemVtextId(id)
        }]
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemIconId(recordId) {
        return `${this.id}__icon__${recordId}`
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemVtextId(recordId) {
        return `${this.id}__vtext__${recordId}`
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        let me = this;

        me.createItems(me.silentSelectUpdate);

        !me.silentSelect && me.focus(items[0])
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90aW1lcl9hcHBfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNBO0FBQ0U7QUFDRDtBQUNBOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBcUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZ0VBQVM7QUFDaEM7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFO0FBQ0EsU0FBUztBQUNULHVCQUF1QixpRUFBVTtBQUNqQztBQUNBO0FBQ0Esd0JBQXdCLGlEQUFpRDtBQUN6RTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsaUVBQVU7QUFDakM7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBK0M7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2IsNEJBQTRCLGdFQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRUc7O0FBRXpDO0FBQ1AsY0FBYywwREFBYTtBQUMzQjtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xrQztBQUNPOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFD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QUNBLGtCQUFrQixRQUFRLFdBQVcsU0FBUztBQUM5Qzs7QUFFQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NvbXBvbmVudC90aW1lci9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY29tcG9uZW50L3RpbWVyL2FwcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvVGltZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9Db2xvci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9saXN0L0NvbG9yLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29uZmlndXJhdGlvblZpZXdwb3J0IGZyb20gJy4uLy4uL0NvbmZpZ3VyYXRpb25WaWV3cG9ydC5tanMnO1xuaW1wb3J0IENvbnRhaW5lciAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBDb2xvckZpZWxkICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2Zvcm0vZmllbGQvQ29sb3IubWpzJztcbmltcG9ydCBUZXh0RmllbGQgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuaW1wb3J0IFRpbWVyICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29tcG9uZW50L1RpbWVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy5jb21wb25lbnQudGltZXIuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmV4YW1wbGVzLkNvbmZpZ3VyYXRpb25WaWV3cG9ydFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgQ29uZmlndXJhdGlvblZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZXhhbXBsZXMuY29tcG9uZW50LnRpbWVyLk1haW5Db250YWluZXInLFxuICAgIH1cblxuICAgIGNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnRzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBUZXh0RmllbGQsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2RpbWVuc2lvbnMnKX0sXG4gICAgICAgICAgICB2YWx1ZSAgICA6ICc4cmVtJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IENvbG9yRmllbGQsXG4gICAgICAgICAgICBjbGVhcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnY29sb3JTdGFydCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdjb2xvclN0YXJ0Jyl9LFxuICAgICAgICAgICAgdmFsdWUgICAgOiAnIzhhOWIwZidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDb2xvckZpZWxkLFxuICAgICAgICAgICAgY2xlYXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ2NvbG9yRW5kJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2NvbG9yRW5kJyl9LFxuICAgICAgICAgICAgdmFsdWUgICAgOiAnIzk0MGEzZCdcbiAgICAgICAgfV1cbiAgICB9XG5cbiAgICBjcmVhdGVFeGFtcGxlQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtb2R1bGU6IENvbnRhaW5lcixcbiAgICAgICAgICAgIHN0eWxlIDoge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93IDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbXMgOiBbe1xuICAgICAgICAgICAgICAgIGh0bWw6ICc8aDE+Q29uZmlndXJhYmxlPC9oMT4nLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7dGV4dEFsaWduOiAnY2VudGVyJ31cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgOiBUaW1lcixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiAgOiAnMjBzJyxcbiAgICAgICAgICAgICAgICBmbGFnICAgICAgOiAndGltZXItY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiAnOHJlbSdcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgb25Db25maWdDaGFuZ2UoY29uZmlnLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy5kb3duKHtmbGFnOiAndGltZXItY29tcG9uZW50J30pO1xuXG4gICAgICAgIHRpbWVyW2NvbmZpZ10gPSBvcHRzLnZhbHVlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyKTtcbiIsImltcG9ydCBNYWluQ29udGFpbmVyIGZyb20gJy4vTWFpbkNvbnRhaW5lci5tanMnO1xuXG5leHBvcnQgY29uc3Qgb25TdGFydCA9ICgpID0+IE5lby5hcHAoe1xuICAgIG1haW5WaWV3OiBNYWluQ29udGFpbmVyLFxuICAgIG5hbWUgICAgOiAnTmVvLmV4YW1wbGVzLmNvbXBvbmVudC50aW1lcidcbn0pO1xuXG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuVGltZXJcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBUaW1lciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LlRpbWVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LlRpbWVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RpbWVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RpbWVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBzZWxlY3RvcnMgdG8gYXBwbHkgdG8gdGhlIHJvb3QgbGV2ZWwgbm9kZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ3RpbWVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRpbWVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmQgY29sb3Igb2YgdGhlIGNpcmNsZS4gSWYgbm90IHNldCwgaXQgdXNlcyB0aGUgY3NzIGRlZmF1bHRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ30gY29sb3JFbmRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRW5kXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IGNvbG9yIG9mIHRoZSBjaXJjbGUuIElmIG5vdCBzZXQsIGl0IHVzZXMgdGhlIGNzcyBkZWZhdWx0XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IGNvbG9yU3RhcnRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yU3RhcnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgdGltZS4gVGhpcyBtaWdodCBiZSAnNW0nLCAnMzBzJyBvciBtaWxsaXNlY29uZHMgYXMgbnVtYmVyXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IGR1cmF0aW9uXz0nNW0nXG4gICAgICAgICAqL1xuICAgICAgICBkdXJhdGlvbl86ICcxMG0nLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBoZWlnaHQgYW5kIG1pbi13aWR0aC4gVGhpcyBjYW4gYmUgYSBudW1iZXIgaW4gcHggb3IgYSBzdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IGRpbWVuc2lvbnNfPSc2cmVtJ1xuICAgICAgICAgKi9cbiAgICAgICAgZGltZW5zaW9uc186ICc4ZW0nLFxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHRvIGtlZXAgcnVubmluZyBzbW9vdGggYXQgbWluaW11bSBjb3N0XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gICAgICB0aW1lcj17fVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gdGltZXIuY3VycmVudFNlY29uZCA9bnVsbCAvLyBydW4gb25seSBvbmNlIHBlciBzZWNvbmRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRpbWVyLmludGVydmFsSWQgICAgPW51bGwgLy8gc2V0SW50ZXJ2YWwgaWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gICAgIHRpbWVyLnJ1bm5pbmcgICAgICAgPWZhbHNlLy8ga2VlcHMgdHJhY2sgaWYgdGltZXIvZW50cnkgaXMgdXBcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRpbWVyLnN0YXJ0VGltZSAgICAgPW51bGwgLy8gY2FsYyB0aGUgY3VycmVudCBwcm9ncmVzc1xuICAgICAgICAgKi9cbiAgICAgICAgdGltZXI6IHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWNvbmQ6IG51bGwsXG4gICAgICAgICAgICBpbnRlcnZhbElkICAgOiBudWxsLFxuICAgICAgICAgICAgcnVubmluZyAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBzdGFydFRpbWUgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmRvbSBtYXJrdXAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209e31cbiAgICAgICAgICovXG4gICAgICAgIHZkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge2NsczogJ2NvdW50ZG93bicsIGNuOiBbXG4gICAgICAgICAgICAgICAge3RhZzogJ3N2ZycsIGNsczogJ2Nsb2NrJywgdmlld0JveDogJy01MCAtNTAgMTAwIDEwMCcsIHN0cm9rZVdpZHRoOiAnMTAnLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7dGFnOiAnY2lyY2xlJywgcjogNDV9LFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiAnY2lyY2xlJywgcjogNDUsIHBhdGhMZW5ndGg6IDF9XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NsczogWydmbGlwLWNhcmQnXSwgY24gOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6ICdmbGlwLWNhcmQtaW5uZXIgZW50ZXItbWFzaycsIGNuIDogW1xuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogJ2ZsaXAtY2FyZC1mcm9udCcsIGNuIDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0YWc6ICdpbnB1dCcsIGNsczogJ2VudGVyLXRpbWUnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGFnOiAnYnV0dG9uJyxjbHM6ICdmYSBmYS1wbGF5J31cbiAgICAgICAgICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogJ2ZsaXAtY2FyZC1iYWNrJywgY24gOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogJ3J1bm5lcicsIGh0bWw6ICcwMDowMCd9XG4gICAgICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgIHtjbGljayAgIDogbWUub25UaW1lckNsaWNrLCAgIGRlbGVnYXRlOiAnZmxpcC1jYXJkLWJhY2snfSxcbiAgICAgICAgICAgIHtjbGljayAgIDogbWUub25UaW1lckNsaWNrLCAgIGRlbGVnYXRlOiAnZmEgZmEtcGxheSd9LFxuICAgICAgICAgICAge2lucHV0ICAgOiBtZS5vblRpbWVySW5wdXQsICAgZGVsZWdhdGU6ICdlbnRlci10aW1lJ30sXG4gICAgICAgICAgICB7Zm9jdXNvdXQ6IG1lLm9uVGltZXJJbnB1dCwgICBkZWxlZ2F0ZTogJ2VudGVyLXRpbWUnfSxcbiAgICAgICAgICAgIHtrZXlkb3duIDogbWUub25GaWVsZEtleURvd24sIGRlbGVnYXRlOiAnZW50ZXItdGltZSd9XG4gICAgICAgIF0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkaW1lbnNpb25zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGltZW5zaW9ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAncHgnXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoe2RpbWVuc2lvbnM6IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbG9yU3RhcnQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbG9yU3RhcnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMudXBkYXRlUHJvcGVydGllcyh7Y29sb3JTdGFydDogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29sb3JFbmQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbG9yRW5kKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoe2NvbG9yRW5kOiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZHVyYXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREdXJhdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGR1cmF0aW9uVHlwZTtcblxuICAgICAgICBtZS51cGRhdGVJbnB1dEZpZWxkKHZhbHVlKVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBkdXJhdGlvblR5cGUgPSB2YWx1ZS5hdCgtMSk7XG5cbiAgICAgICAgICAgIGlmIChkdXJhdGlvblR5cGUgPT09ICdtJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJ20nKVswXSAqIDYwICogMTAwMFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvblR5cGUgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJ3MnKVswXSAqIDEwMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZVByb3BlcnRpZXMoe2Z1bGw6IHZhbHVlfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgRW50ZXIgd2FzIHByZXNzZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRmllbGRLZXlEb3duKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgIG1lLmR1cmF0aW9uID0gbWUudGltZXIuZW50cnk7XG4gICAgICAgICAgICBtZS5vblRpbWVyQ2xpY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xpY2sgb24gUGxheSBvciBUaW1lclxuICAgICAqL1xuICAgIG9uVGltZXJDbGljaygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBJZiB0aGUgdGltZXIgaXMgcnVubmluZywgc3RvcCBhbmQgY2xlYXIgaXRcbiAgICAgICAgaWYgKG1lLnRpbWVyLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIG1lLnRvZ2dsZVRpbWVyKGZhbHNlKTtcbiAgICAgICAgICAgIG1lLnJlc2V0VGltZXIoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcHJlcGFyZVxuICAgICAgICAgICAgbWUudGltZXIuc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgIG1lLnRpbWVyLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbWUudGltZXIuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGN1clRpbWUgICA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVGltZSA9IG1lLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgICA9IHN0YXJ0VGltZSArIHRvdGFsVGltZTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJUaW1lID4gZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS50b2dnbGVUaW1lcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlc2V0VGltZXIoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IGVuZFRpbWUgLSBjdXJUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzTGVmdCAgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Vjb25kc05vdyA9IHNlY29uZHNMZWZ0ICUgNjAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzTm93ID0gTWF0aC5mbG9vcihzZWNvbmRzTGVmdCAvIDYwKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGRvZXMgbm90IHJ1biAxMCB0aW1lcyBhIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kc05vdyAhPT0gbWUudGltZXIuY3VycmVudFNlY29uZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudGltZXIuY3VycmVudFNlY29uZCA9IHNlY29uZHNOb3c7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHNOb3cgPSBzZWNvbmRzTm93LnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXNOb3cgPSBtaW51dGVzTm93LnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlVGltZXIoYCR7bWludXRlc05vd306JHtzZWNvbmRzTm93fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlUHJvcGVydGllcyh7Y3VycmVudDogbWlsbGlzZWNvbmRzfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS50b2dnbGVUaW1lcih0cnVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT24gY2hhbmdlIGV2ZW50IG9mIHRoZSB0ZXh0ZmllbGRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uVGltZXJJbnB1dChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEudmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnRpbWVyLmVudHJ5ID0gZGF0YS52YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuZHVyYXRpb24gPSBtZS50aW1lci5lbnRyeVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHByb3BlcnRpZXMsIHRpbWVyIGFuZCByZW1vdmUgSW50ZXJ2YWxcbiAgICAgKi9cbiAgICByZXNldFRpbWVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnVwZGF0ZVByb3BlcnRpZXMoe2N1cnJlbnQ6ICcnfSk7XG4gICAgICAgIG1lLnVwZGF0ZVRpbWVyKCcwMDowMCcpO1xuXG4gICAgICAgIGNsZWFySW50ZXJ2YWwobWUudGltZXIuaW50ZXJ2YWxJZCk7XG4gICAgICAgIGRlbGV0ZSBtZS50aW1lci5pbnRlcnZhbElkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxpcCBvdmVyIHRoZSB0aW1lciBmYWNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkb1Nob3dcbiAgICAgKi9cbiAgICB0b2dnbGVUaW1lcihkb1Nob3cpIHtcbiAgICAgICAgaWYodGhpcy5ydW5uaW5nID09PSBkb1Nob3cpIHJldHVybjtcblxuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmxpcENhcmQgPSBtZS52ZG9tLmNuWzBdLmNuWzFdO1xuXG4gICAgICAgIG1lLnJ1bm5pbmcgPSBkb1Nob3c7XG5cbiAgICAgICAgZmxpcENhcmQuY2xzID0gZmxpcENhcmQuY2xzIHx8IFtdO1xuXG4gICAgICAgIE5lb0FycmF5W2RvU2hvdyA/ICdhZGQnIDogJ3JlbW92ZSddKGZsaXBDYXJkLmNscywgJ3R1cm4nKTtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGVJbnB1dEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0RmllbGQgPSBtZS52ZG9tLmNuWzBdLmNuWzFdLmNuWzBdLmNuWzBdLmNuWzBdO1xuXG4gICAgICAgIGlucHV0RmllbGQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHRpbWVyLCB0eXBpY2FsbHkgb25jZSBwZXIgc2Vjb25kXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlVGltZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRpbWVyID0gbWUudmRvbS5jblswXS5jblsxXS5jblswXS5jblsxXS5jblswXTtcblxuICAgICAgICB0aW1lci5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgICogLSBjdXJyZW50IGFtb3VudCBvZiBzZWNvbmRzIGxlZnRcbiAgICAgKiAtIGZ1bGwgYW1vdW50IG9mIHRpbWVcbiAgICAgKiAtIHNpemUgb2YgdGhlIHRpbWVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHtzdHlsZX0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVbJy0tbmVvLXRpbWVyLWN1cnJlbnQnXSA9IGAke3Byb3BlcnRpZXMuY3VycmVudH0haW1wb3J0YW50YFxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmZ1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVbJy0tbmVvLXRpbWVyLWZ1bGwnXSA9IGAke3Byb3BlcnRpZXMuZnVsbH0haW1wb3J0YW50YFxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNvbG9yRW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLXRpbWVyLWNvbG9yLWVuZCddID0gYCR7cHJvcGVydGllcy5jb2xvckVuZH0haW1wb3J0YW50YFxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNvbG9yU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVbJy0tdGltZXItY29sb3Itc3RhcnQnXSA9IGAke3Byb3BlcnRpZXMuY29sb3JTdGFydH0haW1wb3J0YW50YFxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmRpbWVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVbJy0tdGltZXItZGltZW5zaW9uJ10gPSBgJHtwcm9wZXJ0aWVzLmRpbWVuc2lvbnN9IWltcG9ydGFudGBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGltZXIpO1xuIiwiaW1wb3J0IENvbG9yTGlzdCBmcm9tICcuLi8uLi9saXN0L0NvbG9yLm1qcydcbmltcG9ydCBDb21ib0JveCAgZnJvbSAnLi9Db21ib0JveC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLkNvbWJvQm94XG4gKi9cbmNsYXNzIENvbG9yIGV4dGVuZHMgQ29tYm9Cb3gge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQ29sb3InXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLkNvbG9yJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbG9yZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29sb3JmaWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jb2xvcmZpZWxkJywnbmVvLWNvbWJvYm94JywnbmVvLXBpY2tlcmZpZWxkJywnbmVvLXRleHRmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb2xvcmZpZWxkJywgJ25lby1jb21ib2JveCcsICduZW8tcGlja2VyZmllbGQnLCAnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEuTW9kZWwgZmllbGQgd2hpY2ggY29udGFpbnMgdGhlIGNvbG9yIHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY29sb3JGaWVsZD0nbmFtZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmllbGQ6ICduYW1lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIHRoZSBmb3JtYXR0ZXIgdG8gYXBwbHkgYSBjdXN0b20gYmFja2dyb3VuZC1jb2xvciBzdHlsaW5nLlxuICAgICAgICAgKiBFLmcuIHVzaW5nIENTUyB2YXJzIGZvciBkaWZmZXJlbnQgdGhlbWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBjb2xvckZpZWxkPShzY29wZSxkYXRhKT0+ZGF0YVtzY29wZS5jb2xvckZpZWxkXVxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGb3JtYXR0ZXI6IChzY29wZSxkYXRhKSA9PiBkYXRhW3Njb3BlLmNvbG9yRmllbGRdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxpc3RDb25maWdcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb25maWc6IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgIDogQ29sb3JMaXN0LFxuICAgICAgICAgICAgY29sb3JGaWVsZCAgICAgICAgOiAnQGNvbmZpZzpjb2xvckZpZWxkJyxcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0dGVyICAgIDogJ0Bjb25maWc6Y29sb3JGb3JtYXR0ZXInLFxuICAgICAgICAgICAgc2lsZW50U2VsZWN0VXBkYXRlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0V3JhcHBlciA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQobWUudmRvbSwge2lkOiBtZS5nZXRJbnB1dFdyYXBwZXJJZCgpfSk7XG5cbiAgICAgICAgaW5wdXRXcmFwcGVyLnZkb20uY24udW5zaGlmdCh7XG4gICAgICAgICAgICBjbHMgIDogJ25lby1jb2xvcicsXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0Q29sb3JJbmRpY2F0b3JJZCgpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG1lLmdldENvbG9yKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50RmlsdGVyPWZhbHNlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgcHJldmVudEZpbHRlcj1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29sb3JJbmRpY2F0b3IgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG1lLnZkb20sIHtpZDogbWUuZ2V0Q29sb3JJbmRpY2F0b3JJZCgpfSk/LnZkb20sXG4gICAgICAgICAgICB7bGlzdCwgcmVjb3JkfSA9IG1lLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwgPSBtZS5saXN0Py5zZWxlY3Rpb25Nb2RlbDtcblxuICAgICAgICBpZiAoY29sb3JJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGNvbG9ySW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1lLmdldENvbG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uc2VsZWN0KGxpc3QuZ2V0SXRlbUlkKHJlY29yZFttZS5zdG9yZS5rZXlQcm9wZXJ0eV0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LmRlc2VsZWN0QWxsKHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgc3VwZXIgY2FsbCB3aWxsIHRyaWdnZXIgdGhlIHZkb20gdXBkYXRlXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBwcmV2ZW50RmlsdGVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29sb3IoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpbnB1dFZhbHVlLCB2YWx1ZX0gPSBtZTtcblxuICAgICAgICByZXR1cm4gdmFsdWUgPyBtZS5jb2xvckZvcm1hdHRlcihtZSwgdmFsdWUpIDogbWUuZm9yY2VTZWxlY3Rpb24gPyBudWxsIDogaW5wdXRWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29sb3JJbmRpY2F0b3JJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19jb2xvci1pbmRpY2F0b3JgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UG9zdExhc3RJdGVtKCkge1xuICAgICAgICBsZXQge2xpc3R9ID0gdGhpcyxcbiAgICAgICAgICAgIGluZGV4ICA9IGxpc3Quc3RvcmUuZ2V0Q291bnQoKSAtIDE7XG5cbiAgICAgICAgbGlzdC52ZG9tLmNuW2luZGV4XSA9IGxpc3QuY3JlYXRlSXRlbShsaXN0LnN0b3JlLmdldEF0KGluZGV4KSwgaW5kZXgpO1xuXG4gICAgICAgIHN1cGVyLm9uU2VsZWN0UG9zdExhc3RJdGVtKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TZWxlY3RQcmVGaXJzdEl0ZW0oKSB7XG4gICAgICAgIGxldCB7bGlzdH0gPSB0aGlzO1xuXG4gICAgICAgIGxpc3QudmRvbS5jblswXSA9IGxpc3QuY3JlYXRlSXRlbShsaXN0LnN0b3JlLmdldEF0KDApLCAwKTtcblxuICAgICAgICBzdXBlci5vblNlbGVjdFByZUZpcnN0SXRlbSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb2xvcik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxpc3QuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqL1xuY2xhc3MgQ29sb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5saXN0LkNvbG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGlzdC5Db2xvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb2xvcmxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29sb3JsaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvbG9yLWxpc3QnLCduZW8tbGlzdCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb2xvci1saXN0JywgJ25lby1saXN0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YS5Nb2RlbCBmaWVsZCB3aGljaCBjb250YWlucyB0aGUgY29sb3IgdmFsdWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb2xvckZpZWxkPSduYW1lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgdGhlIGZvcm1hdHRlciB0byBhcHBseSBhIGN1c3RvbSBiYWNrZ3JvdW5kLWNvbG9yIHN0eWxpbmcuXG4gICAgICAgICAqIEUuZy4gdXNpbmcgQ1NTIHZhcnMgZm9yIGRpZmZlcmVudCB0aGVtZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGNvbG9yRmllbGQ9KHNjb3BlLGRhdGEpPT5kYXRhW3Njb3BlLmNvbG9yRmllbGRdXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZvcm1hdHRlcjogKHNjb3BlLGRhdGEpID0+IGRhdGFbc2NvcGUuY29sb3JGaWVsZF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmb3JtLmZpZWxkLkNvbG9yIG5lZWRzIHRvIHRyaWdnZXIgYSBzaWxlbnQgdmRvbSB1cGRhdGVcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWxlbnRTZWxlY3RVcGRhdGU9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2lsZW50U2VsZWN0VXBkYXRlID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgICAgICAgPSByZWNvcmRbbWUuc3RvcmUua2V5UHJvcGVydHldLFxuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IG1lLnNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQobWUuZ2V0SXRlbUlkKGlkKSk7XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICB0YWcgIDogJ2knLFxuICAgICAgICAgICAgY2xzICA6IFsnbmVvLWljb24nLCAnZmFzJywgYGZhLSR7aXNTZWxlY3RlZCA/ICdjaGVjay0nIDogJyd9c3F1YXJlYF0sXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0TGlzdEl0ZW1JY29uSWQoaWQpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbWUuY29sb3JGb3JtYXR0ZXIobWUsIHJlY29yZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdnR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGh0bWwgOiByZWNvcmRbbWUuZGlzcGxheUZpZWxkXSxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRMaXN0SXRlbVZ0ZXh0SWQoaWQpXG4gICAgICAgIH1dXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TGlzdEl0ZW1JY29uSWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pY29uX18ke3JlY29yZElkfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRMaXN0SXRlbVZ0ZXh0SWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X192dGV4dF9fJHtyZWNvcmRJZH1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zKG1lLnNpbGVudFNlbGVjdFVwZGF0ZSk7XG5cbiAgICAgICAgIW1lLnNpbGVudFNlbGVjdCAmJiBtZS5mb2N1cyhpdGVtc1swXSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbG9yKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==