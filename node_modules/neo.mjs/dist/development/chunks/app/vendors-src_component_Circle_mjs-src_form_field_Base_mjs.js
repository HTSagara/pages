"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_Circle_mjs-src_form_field_Base_mjs"],{

/***/ "./src/component/Circle.mjs":
/*!**********************************!*\
  !*** ./src/component/Circle.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _selection_CircleModel_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection/CircleModel.mjs */ "./src/selection/CircleModel.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







let DragZone;

/**
 * @class Neo.component.Circle
 * @extends Neo.component.Base
 */
class Circle extends _Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Circle'
         * @protected
         */
        className: 'Neo.component.Circle',
        /**
         * @member {String} ntype='circle'
         * @protected
         */
        ntype: 'circle',
        /**
         * Will get set inside the ctor to avoid issues inside the webpack builds
         * @member {String|null} backsideIconPath=Neo.config.resourcesPath + 'images/circle/'
         */
        backsideIconPath: null,
        /**
         * @member {String[]} baseCls=['neo-circle-component']
         */
        baseCls: ['neo-circle-component'],
        /**
         * @member {Boolean} circleCenterHasTransitionCls=true
         * @protected
         */
        circleCenterHasTransitionCls: true,
        /**
         * @member {Boolean} collapsed=true
         */
        collapsed: true,
        /**
         * @member {Boolean} draggable_=true
         */
        draggable_: true,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys={}
         */
        keys: {},
        /**
         * @member {Number} innerRadius_=100
         */
        innerRadius_: 100,
        /**
         * @member {Boolean} isFlipped=false
         */
        isFlipped: false,
        /**
         * Will get set inside the ctor to avoid issues inside the webpack builds
         * @member {String} itemImagePath=Neo.config.resourcesPath + 'examples/images/'
         */
        itemImagePath: null,
        /**
         * @member {Number} itemSize_=60
         */
        itemSize_: 60,
        /**
         * @member {Number} maxItems_=12
         */
        maxItems_: 12,
        /**
         * The amount in px which the outerRadius is bigger than the innerRadius
         * @member {Number} outerRadiusDelta_=10
         */
        outerRadiusDelta_: 10,
        /**
         * @member {Number} rotateX_=0
         */
        rotateX_: 0,
        /**
         * @member {Number} rotateY_=0
         */
        rotateY_: 0,
        /**
         * @member {Number} rotateZ_=0
         */
        rotateZ_: 0,
        /**
         * @member {Number} rotationIndex_=0
         */
        rotationIndex_: 0,
        /**
         * @member {Neo.selection.Model|null} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * @member {Neo.collection.Base|null} store_=null
         */
        store_: null,
        /**
         * @member {String} title_='Circle 1'
         */
        title_: 'Circle 1',
        /**
         * The url for the store to load the data
         * @member {String} url_='../resources/examples/data/circles/group1.json'
         */
        url_: '../../resources/examples/data/circles/group1.json',
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tabIndex: -1, cn: [
            {cls: ['neo-circle-center'], style: {}, cn: [
                {cls: ['neo-circle-front'], cn: [
                    {cls: ['neo-circle'], style: {}, cn: [
                        {cls: ['neo-count-items']},
                        {cls: ['neo-circle-name']}
                    ]},
                    {cls: ['neo-outer-circle'], style: {}}
                ]},
                {cls: ['neo-circle-back'], cn: []}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        Neo.main.DomEvents.registerPreventDefaultTargets({
            name: 'contextmenu',
            cls : ['neo-circle', 'neo-circle-back']
        });

        let me = this;

        if (!me.backsideIconPath) {
            me.backsideIconPath = Neo.config.resourcesPath + 'images/circle/';
        }

        if (!me.itemImagePath) {
            me.itemImagePath = Neo.config.resourcesPath + 'examples/';
        }

        me.addDomListeners([{
            mouseenter: me.expand,
            mouseleave: me.collapse,
            scope     : me
        }, {
            contextmenu: me.onContextMenu,
            delegate   : 'neo-circle-back',
            scope      : me
        }, {
            click   : me.onBacksideIconClick,
            delegate: 'neo-backside-icon',
            scope   : me
        }, {
            mouseenter: me.expandItem,
            mouseleave: me.collapseItem,
            delegate  : 'neo-circle-item',
            scope     : me
        }, {
            contextmenu: me.onContextMenu,
            wheel      : me.onMouseWheel,
            delegate   : 'neo-circle',
            scope      : me
        }]);

        me.store = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            keyProperty: 'id'
        });

        // silent updates
        me.createBacksideItems(true);
        me.updateInnerCircle(true);
        me.updateOuterCircle(true);
        me.updateTitle(true);

        me.update();
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me           = this,
            domListeners = [];

        value && __webpack_require__.e(/*! import() */ "vendors-src_draggable_DragZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs")).then(module => {
            DragZone = module.default;

            if (!me.dragListenersAdded) {
                domListeners.push(
                    {'drag:end'  : me.onDragEnd,   scope: me, delegate: 'neo-circle-item'},
                    {'drag:start': me.onDragStart, scope: me, delegate: 'neo-circle-item'}
                );

                me.addDomListeners(domListeners);
                me.dragListenersAdded = true;
            }
        });
    }

    /**
     * Triggered after the innerRadius config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInnerRadius(value, oldValue) {
        if (oldValue) {
            let me = this;

            me.updateItemPositions(true);
            me.updateInnerCircle(true);
            me.updateOuterCircle(false);
        }
    }

    /**
     * Triggered after the maxItems config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMaxItems(value, oldValue) {
        if (oldValue && this.rendered) {
            let me      = this,
                frontEl = me.getFrontEl();

            if (value < oldValue) {
                if (me.collapsed) {
                    frontEl.cn.splice(value + 2);
                } else {
                    me.updateItemOpacity(0, true, value);

                    setTimeout(() => {
                        frontEl.cn.splice(value + 2);
                        me.update();
                    }, 300);
                }

                me.updateItemPositions(true);
                me.update();
            } else {
                me.createItems(oldValue, true);
                me.updateItemPositions(true);

                me.promiseVdomUpdate().then(() => {
                    if (!me.collapsed) {
                        me.updateItemOpacity(1, true, oldValue);
                        me.update();
                    }
                });
            }
        }
    }

    /**
     * Triggered after the itemSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetItemSize(value, oldValue) {
        let me = this;

        if (oldValue && me.rendered) {
            !me.collapsed && me.updateOuterCircle(true);
            me.updateItemPositions();
        }
    }

    /**
     * Triggered after the rotateX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateX(value, oldValue) {
        oldValue && this.rendered && this.rotate();
    }

    /**
     * Triggered after the rotateY config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateY(value, oldValue) {
        oldValue && this.rendered && this.rotate();
    }

    /**
     * Triggered after the rotateZ config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateZ(value, oldValue) {
        oldValue && this.rendered && this.rotate();
    }

    /**
     * Triggered after the rotationIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotationIndex(value, oldValue) {
        if (Neo.isNumber(oldValue)) {
            console.log('afterSetRotationIndex', value);
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.rendered && value.register(this);
    }

    /**
     * Triggered after the title config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTitle(value, oldValue) {
        oldValue && this.updateTitle();
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue && oldValue.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_CircleModel_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }

    /**
     * @returns {Object[]}
     */
    calculateItemPositions() {
        let me        = this,
            angle     = 360 / me.maxItems,
            circlePos = [],
            itemSize  = me.itemSize,
            radius    = me.innerRadius + itemSize / 2 + 4,
            i         = 0,
            len       = me.maxItems,
            nr;

        for (; i < len; i++) {
            nr = (angle * i + 180) * Math.PI / 180;

            circlePos.push({
                left: -Math.round(radius * Math.sin(nr)) - itemSize / 2,
                top :  Math.round(radius * Math.cos(nr)) - itemSize / 2
            });
        }

        return circlePos;
    }

    /**
     *
     */
    collapse() {
        let me = this;

        if (!me.collapsed) {
            me.collapsed = true;
            me.updateOuterCircle(true);
            me.updateItemOpacity(0, false);
        }
    }

    /**
     * @param {Object} data
     */
    collapseItem(data) {
        let me    = this,
            item  = me.getItemEl(data.path[0].id),
            style = item.cn[0].style;

        delete style.marginLeft;
        delete style.marginTop;
        delete style.zIndex;

        style.height = me.itemSize + 'px';
        style.width  = me.itemSize + 'px';

        me.update();
    }

    /**
     * @param {Boolean} silent=false
     */
    createBacksideItems(silent=false) {
        let me         = this,
            backEl     = me.getBackEl(),
            itemCls    = ['neo-flip', 'neo-pencil', 'neo-trash'],
            itemFile   = ['flip.png', 'pencil.png', 'trash.png'],
            countItems = 3,
            i          = 0,
            vdom       = me.vdom;

        backEl.cn.push(
            {cls: ['neo-count-items']},
            {cls: ['neo-circle-name']}
        );

        for (; i < countItems; i++) {
            backEl.cn.push({
                tag: 'img',
                cls: ['neo-backside-icon', itemCls[i]],
                src: me.backsideIconPath + itemFile[i]
            });
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Number} startIndex=0
     * @param {Boolean} silent=false
     */
    createItems(startIndex=0, silent=false) {
        let me            = this,
            frontEl       = me.getFrontEl(),
            itemCls       = ['neo-circle-item'],
            itemPositions = me.calculateItemPositions(),
            itemSize      = me.itemSize,
            countItems    = Math.min(me.store.getCount(), me.maxItems),
            i             = startIndex,
            vdom          = me.vdom;

        me.draggable && itemCls.push('neo-draggable');

        for (; i < countItems; i++) {
            frontEl.cn.push({
                id      : me.getItemId(i),
                cls     : itemCls,
                tabIndex: -1,
                style: {
                    height: itemSize              + 'px',
                    left  : itemPositions[i].left + 'px',
                    top   : itemPositions[i].top  + 'px',
                    width : itemSize              + 'px'
                },
                cn: [{
                    tag  : 'img',
                    cls  : ['neo-circle-item-image'],
                    src  : me.itemImagePath + me.store.getAt(i).image,
                    style: {
                        height: itemSize + 'px',
                        width : itemSize + 'px'
                    }
                }]
            });
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Object} data
     */
    expand(data) {
        let me = this;

        if (me.collapsed) {
            me.collapsed = false;
            me.updateOuterCircle(true);
            me.updateItemOpacity(1, false);
        }
    }

    /**
     * @param {Object} data
     */
    expandItem(data) {
        let me   = this,
            item = me.getItemEl(data.path[0].id);

        item.cn[0].style = {
            height    : (me.itemSize + 20) + 'px',
            marginLeft: -10 + 'px',
            marginTop : -10 + 'px',
            width     : (me.itemSize + 20) + 'px',
            zIndex    : 40
        };

        me.update();
    }

    flipCircle() {
        let me = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][me.isFlipped ? 'remove': 'add'](me.vdom.cn[0].cls, 'neo-flipped');

        me.isFlipped = !me.isFlipped;
        me.update();
    }

    /**
     *
     */
    getBackEl() {
        return this.vdom.cn[0].cn[1];
    }

    /**
     *
     */
    getFrontEl() {
        return this.vdom.cn[0].cn[0];
    }

    /**
     *
     */
    getInnerCircle() {
        return this.vdom.cn[0].cn[0].cn[0];
    }

    /**
     * @param {String} itemId
     * @returns {Object}
     */
    getItemEl(itemId) {
        let item = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(this.getFrontEl(), itemId);

        return item?.vdom;
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getItemId(index) {
        let store = this.store;

        return this.id + '__' + store.getAt(index)[store.keyProperty];
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId   = vnodeId.split('__').pop(),
            model    = this.store.model,
            keyField = model?.getField(model.keyProperty);

        if (keyField?.type.toLowerCase() === 'number') {
            itemId = parseInt(itemId);
        }

        return itemId;
    }

    /**
     *
     */
    getOuterCircle() {
        return this.vdom.cn[0].cn[0].cn[1];
    }

    /**
     *
     */
    loadData() {
        let me = this;

        // todo: use a real store, not defined here for the examples
        Neo.Xhr.promiseJson({
            insideNeo: true,
            url      : me.url
        }).then(data => {
            me.store.items = data.json.data;

            setTimeout(() => {
                me.updateTitle();
                me.createItems();
            }, 100);
        }).catch(err => {
            console.log('Error for Neo.Xhr.request', err, me.id);
        });
    }

    /**
     * @param {Object} data
     */
    onBacksideIconClick(data) {
        let me  = this,
            cls = data.path[0].cls;

             if (cls.includes('neo-flip'))   {me.flipCircle();}
        else if (cls.includes('neo-pencil')) {console.log('edit circle');}
        else if (cls.includes('neo-trash'))  {console.log('delete circle');}
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.selectionModel?.register(me);
        me.loadData();
    }

    /**
     * @param {Object} data
     */
    onContextMenu(data) {
        this.flipCircle();
    }

    /**
     * @param data
     */
    onDragEnd(data) {
        console.log('onDragEnd', data);
    }

    /**
     * @param data
     */
    onDragStart(data) {
        console.log('onDragStart', data);

        let me           = this,
            wrapperStyle = me.wrapperStyle || {};

        me.isDragging = true;

        if (!me.dragZone) {
            me.dragZone = Neo.create({
                module         : DragZone,
                appName        : me.appName,
                bodyCursorStyle: 'move !important',
                dragElement    : me.vdom,
                dragProxyConfig: {vdom: me.getProxyVdom()},
                owner          : me,
                useProxyWrapper: false,
                ...me.dragZoneConfig
            });
        }

        me.dragZone.dragStart(data);

        wrapperStyle.opacity = 0.7;

        me.wrapperStyle = wrapperStyle;
    }

    /**
     * @param {Object} data
     */
    onMouseWheel(data) {
        let me        = this,
            deltaY    = data.deltaY,
            itemAngle = 360 / me.maxItems,
            maxAngle  = Math.max(0, (me.store.getCount() - me.maxItems) * itemAngle),
            rotateZ   = me.rotateZ;

        if (deltaY >  1 || deltaY < -1) {
            rotateZ += deltaY;
        }

        if (rotateZ < 0) {
            rotateZ = 0;
        } else if (rotateZ > maxAngle) {
            rotateZ = maxAngle;
        }

        if (!(me.rotateZ === 0 && rotateZ === 0) && !(me.rotateZ === maxAngle && rotateZ === maxAngle)) {
            me.rotateZ       = rotateZ;
            me.rotationIndex = Math.floor(rotateZ / itemAngle);

            me.rotate();
        }
    }

    /**
     *
     */
    rotate() {
        let me             = this,
            circleCenterEl = me.vdom.cn[0],
            transform = [
                `rotateX(${me.rotateX}deg)`,
                `rotateY(${me.rotateY}deg)`,
                `rotateZ(${me.rotateZ}deg)`
            ].join(' ');

        if (me.circleCenterHasTransitionCls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(circleCenterEl.cls, 'no-transition');

            me.circleCenterHasTransitionCls = false;

            me.promiseVdomUpdate().then(() => {
                me.updateItemAngle(true);
                circleCenterEl.style.transform = transform;
                me.update();
            });
        } else {
            me.updateItemAngle(true);
            circleCenterEl.style.transform = transform;
            me.update();
        }
    }

    /**
     * @param {Boolean} silent=false
     */
    updateInnerCircle(silent=false) {
        let me           = this,
            innerCircle  = me.getInnerCircle(),
            innerRadius  = me.innerRadius,
            innerSize    = innerRadius * 2,
            vdom         = me.vdom;

        Object.assign(innerCircle.style, {
            height: innerSize + 'px',
            left  : '-' + innerRadius + 'px',
            top   : '-' + innerRadius + 'px',
            width : innerSize + 'px'
        });

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateItemAngle(silent=false) {
        let me      = this,
            frontEl = me.getFrontEl(),
            vdom    = me.vdom,
            i       = 2,
            len     = frontEl.cn.length;

        for (; i < len; i++) {
            frontEl.cn[i].style.transform = 'rotateZ(' + (-me.rotateZ) + 'deg)';
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Number} value
     * @param {Boolean} silent=false
     * @param {Number} startIndex=0
     */
    updateItemOpacity(value, silent=false, startIndex=0) {
        let me      = this,
            i       = startIndex + 2,
            frontEl = me.getFrontEl(),
            len     = frontEl.cn.length,
            vdom    = me.vdom;

        for (; i < len; i++) {
            frontEl.cn[i].style.opacity = value;
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateItemPositions(silent=false) {
        let me            = this,
            frontEl       = me.getFrontEl(),
            itemPositions = me.calculateItemPositions(),
            itemSize      = me.itemSize,
            vdom          = me.vdom,
            i             = 2,
            len           = Math.min(frontEl.cn.length, itemPositions.length + 2);

        for (; i < len; i++) {
            Object.assign(frontEl.cn[i].style, {
                height: itemSize                + 'px',
                left  : itemPositions[i-2].left + 'px',
                top   : itemPositions[i-2].top  + 'px',
                width : itemSize                + 'px'
            });

            Object.assign(frontEl.cn[i].cn[0].style, {
                height: itemSize + 'px',
                width : itemSize + 'px'
            });
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateOuterCircle(silent=false) {
        let me           = this,
            itemSize = me.itemSize,
            outerCircle  = me.getOuterCircle(),
            outerRadius  = me.innerRadius + me.outerRadiusDelta,
            outerSize    = me.collapsed ? outerRadius * 2 : (outerRadius + itemSize) * 2,
            vdom         = me.vdom,
            opts;

        if (me.collapsed) {
            opts = {
                height: outerSize + 'px',
                left  : '-' + outerRadius + 'px',
                top   : '-' + outerRadius + 'px',
                width : outerSize + 'px'
            };
        } else {
            opts = {
                height: outerSize + 'px',
                left  : '-' + (outerRadius + itemSize) + 'px',
                top   : '-' + (outerRadius + itemSize) + 'px',
                width : outerSize + 'px'
            };
        }

        Object.assign(outerCircle.style, opts);

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateTitle(silent=false) {
        let me          = this,
            innerCircle = me.getInnerCircle(),
            vdom        = me.vdom;

        innerCircle.cn[0].html = me.store?.getCount() || 0;
        innerCircle.cn[1].html = me.title;

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }
}

Neo.applyClassConfig(Circle);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Circle);


/***/ }),

/***/ "./src/form/field/Base.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         */
        formGroup_: null,
        /**
         * @member {String|null} name_=null
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {
        if (oldValue !== undefined) {
            this.fireChangeEvent(value, oldValue)
        }
    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString;
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value;
        } else {
            delete me.getInputEl()[key];
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        let me            = this,
            FormContainer = Neo.form?.Container;

        me.fire('change', {
            component: me,
            oldValue,
            value
        });

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldChange', {
                        component: me,
                        oldValue,
                        value
                    })
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getValue() {
        return this.value;
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true;
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave?.(data);

        let me            = this,
            FormContainer = Neo.form?.Container;

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', {
                        ...data,
                        component: me
                    })
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.value = value;
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true;
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

Neo.applyClassConfig(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/selection/CircleModel.mjs":
/*!***************************************!*\
  !*** ./src/selection/CircleModel.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");


/**
 * @class Neo.selection.CircleModel
 * @extends Neo.selection.Model
 */
class CircleModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.CircleModel'
         * @protected
         */
        className: 'Neo.selection.CircleModel',
        /**
         * @member {String} ntype='selection-circlemodel'
         * @protected
         */
        ntype: 'selection-circlemodel'
    }

    /**
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        this.onNavKey(data, -1);
    }

    /**
     * @param {Object} data
     */
    onKeyDownRight(data) {
        this.onNavKey(data, 1);
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        let me       = this,
            item     = data.path[0],
            view     = me.view,
            store    = view.store,
            maxIndex = Math.min(store.getCount(), view.maxItems) - 1,
            index, itemId, recordId;

        if (item.cls.includes('neo-circle-item')) {
            recordId = parseInt(view.getItemRecordId(item.id));
            index    = store.indexOf(recordId) + step;

                 if (index < 0)        {index = maxIndex;}
            else if (index > maxIndex) {index = 0;}
        } else {
            index = 0;
        }

        itemId = view.getItemId(index);

        me.select(itemId);
        view.focus(itemId);
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me   = this,
            id   = me.id,
            view = me.view;

        if (view.keys) {
            view.keys._keys.push(
                {fn: 'onKeyDownLeft'  ,key: 'Down'  ,scope: id},
                {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
                {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
                {fn: 'onKeyDownRight' ,key: 'Up'    ,scope: id}
            );
        }
    }

    /**
     *
     */
    unregister() {
        let me   = this,
            id   = me.id,
            view = me.view;

        if (view.keys) {
            view.keys.removeKeys([
                {fn: 'onKeyDownLeft'  ,key: 'Down'  ,scope: id},
                {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
                {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
                {fn: 'onKeyDownRight' ,key: 'Up'    ,scope: id}
            ]);
        }

        super.unregister();
    }
}

Neo.applyClassConfig(CircleModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleModel);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfQ2lyY2xlX21qcy1zcmNfZm9ybV9maWVsZF9CYXNlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ0s7QUFDTjtBQUNaO0FBQ087QUFDRDs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQVM7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFB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UUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4QyxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDO0FBQy9ELGlCQUFpQiw4Q0FBOEM7QUFDL0QsaUJBQWlCLDhDQUE4QztBQUMvRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDO0FBQy9ELGlCQUFpQiw4Q0FBOEM7QUFDL0QsaUJBQWlCLDhDQUE4QztBQUMvRCxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsV0FBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvQ2lyY2xlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vQ2lyY2xlTW9kZWwubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENpcmNsZU1vZGVsICAgICBmcm9tICcuLi9zZWxlY3Rpb24vQ2lyY2xlTW9kZWwubWpzJztcbmltcG9ydCBDb2xsZWN0aW9uICAgICAgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuXG5sZXQgRHJhZ1pvbmU7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQ2lyY2xlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuQ2lyY2xlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkNpcmNsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjaXJjbGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2lyY2xlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgZ2V0IHNldCBpbnNpZGUgdGhlIGN0b3IgdG8gYXZvaWQgaXNzdWVzIGluc2lkZSB0aGUgd2VicGFjayBidWlsZHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGJhY2tzaWRlSWNvblBhdGg9TmVvLmNvbmZpZy5yZXNvdXJjZXNQYXRoICsgJ2ltYWdlcy9jaXJjbGUvJ1xuICAgICAgICAgKi9cbiAgICAgICAgYmFja3NpZGVJY29uUGF0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNpcmNsZS1jb21wb25lbnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2lyY2xlLWNvbXBvbmVudCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2lyY2xlQ2VudGVySGFzVHJhbnNpdGlvbkNscz10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNpcmNsZUNlbnRlckhhc1RyYW5zaXRpb25DbHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjb2xsYXBzZWQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ2dhYmxlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzPXt9XG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaW5uZXJSYWRpdXNfPTEwMFxuICAgICAgICAgKi9cbiAgICAgICAgaW5uZXJSYWRpdXNfOiAxMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0ZsaXBwZWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzRmxpcHBlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGdldCBzZXQgaW5zaWRlIHRoZSBjdG9yIHRvIGF2b2lkIGlzc3VlcyBpbnNpZGUgdGhlIHdlYnBhY2sgYnVpbGRzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaXRlbUltYWdlUGF0aD1OZW8uY29uZmlnLnJlc291cmNlc1BhdGggKyAnZXhhbXBsZXMvaW1hZ2VzLydcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1JbWFnZVBhdGg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGl0ZW1TaXplXz02MFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVNpemVfOiA2MCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4SXRlbXNfPTEyXG4gICAgICAgICAqL1xuICAgICAgICBtYXhJdGVtc186IDEyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBpbiBweCB3aGljaCB0aGUgb3V0ZXJSYWRpdXMgaXMgYmlnZ2VyIHRoYW4gdGhlIGlubmVyUmFkaXVzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gb3V0ZXJSYWRpdXNEZWx0YV89MTBcbiAgICAgICAgICovXG4gICAgICAgIG91dGVyUmFkaXVzRGVsdGFfOiAxMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm90YXRlWF89MFxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlWF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvdGF0ZVlfPTBcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZVlfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3RhdGVaXz0wXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVaXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm90YXRpb25JbmRleF89MFxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRpb25JbmRleF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uc2VsZWN0aW9uLk1vZGVsfG51bGx9IHNlbGVjdGlvbk1vZGVsXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25Nb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IHN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRpdGxlXz0nQ2lyY2xlIDEnXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZV86ICdDaXJjbGUgMScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXJsIGZvciB0aGUgc3RvcmUgdG8gbG9hZCB0aGUgZGF0YVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHVybF89Jy4uL3Jlc291cmNlcy9leGFtcGxlcy9kYXRhL2NpcmNsZXMvZ3JvdXAxLmpzb24nXG4gICAgICAgICAqL1xuICAgICAgICB1cmxfOiAnLi4vLi4vcmVzb3VyY2VzL2V4YW1wbGVzL2RhdGEvY2lyY2xlcy9ncm91cDEuanNvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhYkluZGV4OiAtMSwgY246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNpcmNsZS1jZW50ZXInXSwgc3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNpcmNsZS1mcm9udCddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1jaXJjbGUnXSwgc3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tY291bnQtaXRlbXMnXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1jaXJjbGUtbmFtZSddfVxuICAgICAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tb3V0ZXItY2lyY2xlJ10sIHN0eWxlOiB7fX1cbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1jaXJjbGUtYmFjayddLCBjbjogW119XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIE5lby5tYWluLkRvbUV2ZW50cy5yZWdpc3RlclByZXZlbnREZWZhdWx0VGFyZ2V0cyh7XG4gICAgICAgICAgICBuYW1lOiAnY29udGV4dG1lbnUnLFxuICAgICAgICAgICAgY2xzIDogWyduZW8tY2lyY2xlJywgJ25lby1jaXJjbGUtYmFjayddXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5iYWNrc2lkZUljb25QYXRoKSB7XG4gICAgICAgICAgICBtZS5iYWNrc2lkZUljb25QYXRoID0gTmVvLmNvbmZpZy5yZXNvdXJjZXNQYXRoICsgJ2ltYWdlcy9jaXJjbGUvJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUuaXRlbUltYWdlUGF0aCkge1xuICAgICAgICAgICAgbWUuaXRlbUltYWdlUGF0aCA9IE5lby5jb25maWcucmVzb3VyY2VzUGF0aCArICdleGFtcGxlcy8nO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFt7XG4gICAgICAgICAgICBtb3VzZWVudGVyOiBtZS5leHBhbmQsXG4gICAgICAgICAgICBtb3VzZWxlYXZlOiBtZS5jb2xsYXBzZSxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbnRleHRtZW51OiBtZS5vbkNvbnRleHRNZW51LFxuICAgICAgICAgICAgZGVsZWdhdGUgICA6ICduZW8tY2lyY2xlLWJhY2snLFxuICAgICAgICAgICAgc2NvcGUgICAgICA6IG1lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNsaWNrICAgOiBtZS5vbkJhY2tzaWRlSWNvbkNsaWNrLFxuICAgICAgICAgICAgZGVsZWdhdGU6ICduZW8tYmFja3NpZGUtaWNvbicsXG4gICAgICAgICAgICBzY29wZSAgIDogbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW91c2VlbnRlcjogbWUuZXhwYW5kSXRlbSxcbiAgICAgICAgICAgIG1vdXNlbGVhdmU6IG1lLmNvbGxhcHNlSXRlbSxcbiAgICAgICAgICAgIGRlbGVnYXRlICA6ICduZW8tY2lyY2xlLWl0ZW0nLFxuICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY29udGV4dG1lbnU6IG1lLm9uQ29udGV4dE1lbnUsXG4gICAgICAgICAgICB3aGVlbCAgICAgIDogbWUub25Nb3VzZVdoZWVsLFxuICAgICAgICAgICAgZGVsZWdhdGUgICA6ICduZW8tY2lyY2xlJyxcbiAgICAgICAgICAgIHNjb3BlICAgICAgOiBtZVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgbWUuc3RvcmUgPSBOZW8uY3JlYXRlKENvbGxlY3Rpb24sIHtcbiAgICAgICAgICAgIGtleVByb3BlcnR5OiAnaWQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNpbGVudCB1cGRhdGVzXG4gICAgICAgIG1lLmNyZWF0ZUJhY2tzaWRlSXRlbXModHJ1ZSk7XG4gICAgICAgIG1lLnVwZGF0ZUlubmVyQ2lyY2xlKHRydWUpO1xuICAgICAgICBtZS51cGRhdGVPdXRlckNpcmNsZSh0cnVlKTtcbiAgICAgICAgbWUudXBkYXRlVGl0bGUodHJ1ZSk7XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnZ2FibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgdmFsdWUgJiYgaW1wb3J0KCcuLi9kcmFnZ2FibGUvRHJhZ1pvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgRHJhZ1pvbmUgPSBtb2R1bGUuZGVmYXVsdDtcblxuICAgICAgICAgICAgaWYgKCFtZS5kcmFnTGlzdGVuZXJzQWRkZWQpIHtcbiAgICAgICAgICAgICAgICBkb21MaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25EcmFnRW5kLCAgIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICduZW8tY2lyY2xlLWl0ZW0nfSxcbiAgICAgICAgICAgICAgICAgICAgeydkcmFnOnN0YXJ0JzogbWUub25EcmFnU3RhcnQsIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICduZW8tY2lyY2xlLWl0ZW0nfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoZG9tTGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICBtZS5kcmFnTGlzdGVuZXJzQWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlubmVyUmFkaXVzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElubmVyUmFkaXVzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1Qb3NpdGlvbnModHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVJbm5lckNpcmNsZSh0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZU91dGVyQ2lyY2xlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWF4SXRlbXMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWF4SXRlbXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAmJiB0aGlzLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZnJvbnRFbCA9IG1lLmdldEZyb250RWwoKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb250RWwuY24uc3BsaWNlKHZhbHVlICsgMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlSXRlbU9wYWNpdHkoMCwgdHJ1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbnRFbC5jbi5zcGxpY2UodmFsdWUgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1Qb3NpdGlvbnModHJ1ZSk7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKG9sZFZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVJdGVtUG9zaXRpb25zKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVZkb21VcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1PcGFjaXR5KDEsIHRydWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGl0ZW1TaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEl0ZW1TaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAmJiBtZS5yZW5kZXJlZCkge1xuICAgICAgICAgICAgIW1lLmNvbGxhcHNlZCAmJiBtZS51cGRhdGVPdXRlckNpcmNsZSh0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1Qb3NpdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRlWCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGVYKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnJlbmRlcmVkICYmIHRoaXMucm90YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3RhdGVZIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvdGF0ZVkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5yb3RhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJvdGF0ZVogY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um90YXRlWih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnJvdGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRpb25JbmRleCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGlvbkluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FmdGVyU2V0Um90YXRpb25JbmRleCcsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCAmJiB2YWx1ZS5yZWdpc3Rlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRpdGxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRpdGxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnVwZGF0ZVRpdGxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgb2xkVmFsdWUuZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIENpcmNsZU1vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgY2FsY3VsYXRlSXRlbVBvc2l0aW9ucygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhbmdsZSAgICAgPSAzNjAgLyBtZS5tYXhJdGVtcyxcbiAgICAgICAgICAgIGNpcmNsZVBvcyA9IFtdLFxuICAgICAgICAgICAgaXRlbVNpemUgID0gbWUuaXRlbVNpemUsXG4gICAgICAgICAgICByYWRpdXMgICAgPSBtZS5pbm5lclJhZGl1cyArIGl0ZW1TaXplIC8gMiArIDQsXG4gICAgICAgICAgICBpICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgID0gbWUubWF4SXRlbXMsXG4gICAgICAgICAgICBucjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuciA9IChhbmdsZSAqIGkgKyAxODApICogTWF0aC5QSSAvIDE4MDtcblxuICAgICAgICAgICAgY2lyY2xlUG9zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxlZnQ6IC1NYXRoLnJvdW5kKHJhZGl1cyAqIE1hdGguc2luKG5yKSkgLSBpdGVtU2l6ZSAvIDIsXG4gICAgICAgICAgICAgICAgdG9wIDogIE1hdGgucm91bmQocmFkaXVzICogTWF0aC5jb3MobnIpKSAtIGl0ZW1TaXplIC8gMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2lyY2xlUG9zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY29sbGFwc2UoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIG1lLmNvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgICAgICBtZS51cGRhdGVPdXRlckNpcmNsZSh0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1PcGFjaXR5KDAsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgY29sbGFwc2VJdGVtKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gID0gbWUuZ2V0SXRlbUVsKGRhdGEucGF0aFswXS5pZCksXG4gICAgICAgICAgICBzdHlsZSA9IGl0ZW0uY25bMF0uc3R5bGU7XG5cbiAgICAgICAgZGVsZXRlIHN0eWxlLm1hcmdpbkxlZnQ7XG4gICAgICAgIGRlbGV0ZSBzdHlsZS5tYXJnaW5Ub3A7XG4gICAgICAgIGRlbGV0ZSBzdHlsZS56SW5kZXg7XG5cbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gbWUuaXRlbVNpemUgKyAncHgnO1xuICAgICAgICBzdHlsZS53aWR0aCAgPSBtZS5pdGVtU2l6ZSArICdweCc7XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjcmVhdGVCYWNrc2lkZUl0ZW1zKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBiYWNrRWwgICAgID0gbWUuZ2V0QmFja0VsKCksXG4gICAgICAgICAgICBpdGVtQ2xzICAgID0gWyduZW8tZmxpcCcsICduZW8tcGVuY2lsJywgJ25lby10cmFzaCddLFxuICAgICAgICAgICAgaXRlbUZpbGUgICA9IFsnZmxpcC5wbmcnLCAncGVuY2lsLnBuZycsICd0cmFzaC5wbmcnXSxcbiAgICAgICAgICAgIGNvdW50SXRlbXMgPSAzLFxuICAgICAgICAgICAgaSAgICAgICAgICA9IDAsXG4gICAgICAgICAgICB2ZG9tICAgICAgID0gbWUudmRvbTtcblxuICAgICAgICBiYWNrRWwuY24ucHVzaChcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNvdW50LWl0ZW1zJ119LFxuICAgICAgICAgICAge2NsczogWyduZW8tY2lyY2xlLW5hbWUnXX1cbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKDsgaSA8IGNvdW50SXRlbXM7IGkrKykge1xuICAgICAgICAgICAgYmFja0VsLmNuLnB1c2goe1xuICAgICAgICAgICAgICAgIHRhZzogJ2ltZycsXG4gICAgICAgICAgICAgICAgY2xzOiBbJ25lby1iYWNrc2lkZS1pY29uJywgaXRlbUNsc1tpXV0sXG4gICAgICAgICAgICAgICAgc3JjOiBtZS5iYWNrc2lkZUljb25QYXRoICsgaXRlbUZpbGVbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSB2ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4PTBcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKHN0YXJ0SW5kZXg9MCwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZyb250RWwgICAgICAgPSBtZS5nZXRGcm9udEVsKCksXG4gICAgICAgICAgICBpdGVtQ2xzICAgICAgID0gWyduZW8tY2lyY2xlLWl0ZW0nXSxcbiAgICAgICAgICAgIGl0ZW1Qb3NpdGlvbnMgPSBtZS5jYWxjdWxhdGVJdGVtUG9zaXRpb25zKCksXG4gICAgICAgICAgICBpdGVtU2l6ZSAgICAgID0gbWUuaXRlbVNpemUsXG4gICAgICAgICAgICBjb3VudEl0ZW1zICAgID0gTWF0aC5taW4obWUuc3RvcmUuZ2V0Q291bnQoKSwgbWUubWF4SXRlbXMpLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICA9IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgID0gbWUudmRvbTtcblxuICAgICAgICBtZS5kcmFnZ2FibGUgJiYgaXRlbUNscy5wdXNoKCduZW8tZHJhZ2dhYmxlJyk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBjb3VudEl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgIGZyb250RWwuY24ucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmdldEl0ZW1JZChpKSxcbiAgICAgICAgICAgICAgICBjbHMgICAgIDogaXRlbUNscyxcbiAgICAgICAgICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtU2l6ZSAgICAgICAgICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICA6IGl0ZW1Qb3NpdGlvbnNbaV0ubGVmdCArICdweCcsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgIDogaXRlbVBvc2l0aW9uc1tpXS50b3AgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBpdGVtU2l6ZSAgICAgICAgICAgICAgKyAncHgnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbjogW3tcbiAgICAgICAgICAgICAgICAgICAgdGFnICA6ICdpbWcnLFxuICAgICAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tY2lyY2xlLWl0ZW0taW1hZ2UnXSxcbiAgICAgICAgICAgICAgICAgICAgc3JjICA6IG1lLml0ZW1JbWFnZVBhdGggKyBtZS5zdG9yZS5nZXRBdChpKS5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemUgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBpdGVtU2l6ZSArICdweCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGV4cGFuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgbWUuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBtZS51cGRhdGVPdXRlckNpcmNsZSh0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1PcGFjaXR5KDEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZXhwYW5kSXRlbShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5nZXRJdGVtRWwoZGF0YS5wYXRoWzBdLmlkKTtcblxuICAgICAgICBpdGVtLmNuWzBdLnN0eWxlID0ge1xuICAgICAgICAgICAgaGVpZ2h0ICAgIDogKG1lLml0ZW1TaXplICsgMjApICsgJ3B4JyxcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IC0xMCArICdweCcsXG4gICAgICAgICAgICBtYXJnaW5Ub3AgOiAtMTAgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGggICAgIDogKG1lLml0ZW1TaXplICsgMjApICsgJ3B4JyxcbiAgICAgICAgICAgIHpJbmRleCAgICA6IDQwXG4gICAgICAgIH07XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZmxpcENpcmNsZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBOZW9BcnJheVttZS5pc0ZsaXBwZWQgPyAncmVtb3ZlJzogJ2FkZCddKG1lLnZkb20uY25bMF0uY2xzLCAnbmVvLWZsaXBwZWQnKTtcblxuICAgICAgICBtZS5pc0ZsaXBwZWQgPSAhbWUuaXNGbGlwcGVkO1xuICAgICAgICBtZS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldEJhY2tFbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXS5jblsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldEZyb250RWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRJbm5lckNpcmNsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXS5jblswXS5jblswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRJdGVtRWwoaXRlbUlkKSB7XG4gICAgICAgIGxldCBpdGVtID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZCh0aGlzLmdldEZyb250RWwoKSwgaXRlbUlkKTtcblxuICAgICAgICByZXR1cm4gaXRlbT8udmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEl0ZW1JZChpbmRleCkge1xuICAgICAgICBsZXQgc3RvcmUgPSB0aGlzLnN0b3JlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJ19fJyArIHN0b3JlLmdldEF0KGluZGV4KVtzdG9yZS5rZXlQcm9wZXJ0eV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcn0gaXRlbUlkXG4gICAgICovXG4gICAgZ2V0SXRlbVJlY29yZElkKHZub2RlSWQpIHtcbiAgICAgICAgbGV0IGl0ZW1JZCAgID0gdm5vZGVJZC5zcGxpdCgnX18nKS5wb3AoKSxcbiAgICAgICAgICAgIG1vZGVsICAgID0gdGhpcy5zdG9yZS5tb2RlbCxcbiAgICAgICAgICAgIGtleUZpZWxkID0gbW9kZWw/LmdldEZpZWxkKG1vZGVsLmtleVByb3BlcnR5KTtcblxuICAgICAgICBpZiAoa2V5RmllbGQ/LnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGl0ZW1JZCA9IHBhcnNlSW50KGl0ZW1JZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbUlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0T3V0ZXJDaXJjbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF0uY25bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBsb2FkRGF0YSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvOiB1c2UgYSByZWFsIHN0b3JlLCBub3QgZGVmaW5lZCBoZXJlIGZvciB0aGUgZXhhbXBsZXNcbiAgICAgICAgTmVvLlhoci5wcm9taXNlSnNvbih7XG4gICAgICAgICAgICBpbnNpZGVOZW86IHRydWUsXG4gICAgICAgICAgICB1cmwgICAgICA6IG1lLnVybFxuICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgbWUuc3RvcmUuaXRlbXMgPSBkYXRhLmpzb24uZGF0YTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlVGl0bGUoKTtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVJdGVtcygpO1xuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBmb3IgTmVvLlhoci5yZXF1ZXN0JywgZXJyLCBtZS5pZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25CYWNrc2lkZUljb25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gZGF0YS5wYXRoWzBdLmNscztcblxuICAgICAgICAgICAgIGlmIChjbHMuaW5jbHVkZXMoJ25lby1mbGlwJykpICAge21lLmZsaXBDaXJjbGUoKTt9XG4gICAgICAgIGVsc2UgaWYgKGNscy5pbmNsdWRlcygnbmVvLXBlbmNpbCcpKSB7Y29uc29sZS5sb2coJ2VkaXQgY2lyY2xlJyk7fVxuICAgICAgICBlbHNlIGlmIChjbHMuaW5jbHVkZXMoJ25lby10cmFzaCcpKSAge2NvbnNvbGUubG9nKCdkZWxldGUgY2lyY2xlJyk7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnJlZ2lzdGVyKG1lKTtcbiAgICAgICAgbWUubG9hZERhdGEoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29udGV4dE1lbnUoZGF0YSkge1xuICAgICAgICB0aGlzLmZsaXBDaXJjbGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkRyYWdFbmQnLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uRHJhZ1N0YXJ0JywgZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSBtZS53cmFwcGVyU3R5bGUgfHwge307XG5cbiAgICAgICAgbWUuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICA6IERyYWdab25lLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBib2R5Q3Vyc29yU3R5bGU6ICdtb3ZlICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgIDogbWUudmRvbSxcbiAgICAgICAgICAgICAgICBkcmFnUHJveHlDb25maWc6IHt2ZG9tOiBtZS5nZXRQcm94eVZkb20oKX0sXG4gICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICB1c2VQcm94eVdyYXBwZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC4uLm1lLmRyYWdab25lQ29uZmlnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRyYWdab25lLmRyYWdTdGFydChkYXRhKTtcblxuICAgICAgICB3cmFwcGVyU3R5bGUub3BhY2l0eSA9IDAuNztcblxuICAgICAgICBtZS53cmFwcGVyU3R5bGUgPSB3cmFwcGVyU3R5bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlV2hlZWwoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRlbHRhWSAgICA9IGRhdGEuZGVsdGFZLFxuICAgICAgICAgICAgaXRlbUFuZ2xlID0gMzYwIC8gbWUubWF4SXRlbXMsXG4gICAgICAgICAgICBtYXhBbmdsZSAgPSBNYXRoLm1heCgwLCAobWUuc3RvcmUuZ2V0Q291bnQoKSAtIG1lLm1heEl0ZW1zKSAqIGl0ZW1BbmdsZSksXG4gICAgICAgICAgICByb3RhdGVaICAgPSBtZS5yb3RhdGVaO1xuXG4gICAgICAgIGlmIChkZWx0YVkgPiAgMSB8fCBkZWx0YVkgPCAtMSkge1xuICAgICAgICAgICAgcm90YXRlWiArPSBkZWx0YVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRlWiA8IDApIHtcbiAgICAgICAgICAgIHJvdGF0ZVogPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHJvdGF0ZVogPiBtYXhBbmdsZSkge1xuICAgICAgICAgICAgcm90YXRlWiA9IG1heEFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEobWUucm90YXRlWiA9PT0gMCAmJiByb3RhdGVaID09PSAwKSAmJiAhKG1lLnJvdGF0ZVogPT09IG1heEFuZ2xlICYmIHJvdGF0ZVogPT09IG1heEFuZ2xlKSkge1xuICAgICAgICAgICAgbWUucm90YXRlWiAgICAgICA9IHJvdGF0ZVo7XG4gICAgICAgICAgICBtZS5yb3RhdGlvbkluZGV4ID0gTWF0aC5mbG9vcihyb3RhdGVaIC8gaXRlbUFuZ2xlKTtcblxuICAgICAgICAgICAgbWUucm90YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJvdGF0ZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNpcmNsZUNlbnRlckVsID0gbWUudmRvbS5jblswXSxcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IFtcbiAgICAgICAgICAgICAgICBgcm90YXRlWCgke21lLnJvdGF0ZVh9ZGVnKWAsXG4gICAgICAgICAgICAgICAgYHJvdGF0ZVkoJHttZS5yb3RhdGVZfWRlZylgLFxuICAgICAgICAgICAgICAgIGByb3RhdGVaKCR7bWUucm90YXRlWn1kZWcpYFxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG5cbiAgICAgICAgaWYgKG1lLmNpcmNsZUNlbnRlckhhc1RyYW5zaXRpb25DbHMpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjaXJjbGVDZW50ZXJFbC5jbHMsICduby10cmFuc2l0aW9uJyk7XG5cbiAgICAgICAgICAgIG1lLmNpcmNsZUNlbnRlckhhc1RyYW5zaXRpb25DbHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgbWUucHJvbWlzZVZkb21VcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVJdGVtQW5nbGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2lyY2xlQ2VudGVyRWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS51cGRhdGVJdGVtQW5nbGUodHJ1ZSk7XG4gICAgICAgICAgICBjaXJjbGVDZW50ZXJFbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICBtZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlSW5uZXJDaXJjbGUoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5uZXJDaXJjbGUgID0gbWUuZ2V0SW5uZXJDaXJjbGUoKSxcbiAgICAgICAgICAgIGlubmVyUmFkaXVzICA9IG1lLmlubmVyUmFkaXVzLFxuICAgICAgICAgICAgaW5uZXJTaXplICAgID0gaW5uZXJSYWRpdXMgKiAyLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgID0gbWUudmRvbTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGlubmVyQ2lyY2xlLnN0eWxlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IGlubmVyU2l6ZSArICdweCcsXG4gICAgICAgICAgICBsZWZ0ICA6ICctJyArIGlubmVyUmFkaXVzICsgJ3B4JyxcbiAgICAgICAgICAgIHRvcCAgIDogJy0nICsgaW5uZXJSYWRpdXMgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGggOiBpbm5lclNpemUgKyAncHgnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIHVwZGF0ZUl0ZW1BbmdsZShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZnJvbnRFbCA9IG1lLmdldEZyb250RWwoKSxcbiAgICAgICAgICAgIHZkb20gICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgaSAgICAgICA9IDIsXG4gICAgICAgICAgICBsZW4gICAgID0gZnJvbnRFbC5jbi5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZnJvbnRFbC5jbltpXS5zdHlsZS50cmFuc2Zvcm0gPSAncm90YXRlWignICsgKC1tZS5yb3RhdGVaKSArICdkZWcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4PTBcbiAgICAgKi9cbiAgICB1cGRhdGVJdGVtT3BhY2l0eSh2YWx1ZSwgc2lsZW50PWZhbHNlLCBzdGFydEluZGV4PTApIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaSAgICAgICA9IHN0YXJ0SW5kZXggKyAyLFxuICAgICAgICAgICAgZnJvbnRFbCA9IG1lLmdldEZyb250RWwoKSxcbiAgICAgICAgICAgIGxlbiAgICAgPSBmcm9udEVsLmNuLmxlbmd0aCxcbiAgICAgICAgICAgIHZkb20gICAgPSBtZS52ZG9tO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZyb250RWwuY25baV0uc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSB2ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlSXRlbVBvc2l0aW9ucyhzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZnJvbnRFbCAgICAgICA9IG1lLmdldEZyb250RWwoKSxcbiAgICAgICAgICAgIGl0ZW1Qb3NpdGlvbnMgPSBtZS5jYWxjdWxhdGVJdGVtUG9zaXRpb25zKCksXG4gICAgICAgICAgICBpdGVtU2l6ZSAgICAgID0gbWUuaXRlbVNpemUsXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgPSAyLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICA9IE1hdGgubWluKGZyb250RWwuY24ubGVuZ3RoLCBpdGVtUG9zaXRpb25zLmxlbmd0aCArIDIpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZnJvbnRFbC5jbltpXS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemUgICAgICAgICAgICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIGxlZnQgIDogaXRlbVBvc2l0aW9uc1tpLTJdLmxlZnQgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcCAgIDogaXRlbVBvc2l0aW9uc1tpLTJdLnRvcCAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbVNpemUgICAgICAgICAgICAgICAgKyAncHgnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihmcm9udEVsLmNuW2ldLmNuWzBdLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtU2l6ZSArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggOiBpdGVtU2l6ZSArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSB2ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlT3V0ZXJDaXJjbGUoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbVNpemUgPSBtZS5pdGVtU2l6ZSxcbiAgICAgICAgICAgIG91dGVyQ2lyY2xlICA9IG1lLmdldE91dGVyQ2lyY2xlKCksXG4gICAgICAgICAgICBvdXRlclJhZGl1cyAgPSBtZS5pbm5lclJhZGl1cyArIG1lLm91dGVyUmFkaXVzRGVsdGEsXG4gICAgICAgICAgICBvdXRlclNpemUgICAgPSBtZS5jb2xsYXBzZWQgPyBvdXRlclJhZGl1cyAqIDIgOiAob3V0ZXJSYWRpdXMgKyBpdGVtU2l6ZSkgKiAyLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIG9wdHM7XG5cbiAgICAgICAgaWYgKG1lLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG91dGVyU2l6ZSArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiAnLScgKyBvdXRlclJhZGl1cyArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wICAgOiAnLScgKyBvdXRlclJhZGl1cyArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggOiBvdXRlclNpemUgKyAncHgnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG91dGVyU2l6ZSArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiAnLScgKyAob3V0ZXJSYWRpdXMgKyBpdGVtU2l6ZSkgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcCAgIDogJy0nICsgKG91dGVyUmFkaXVzICsgaXRlbVNpemUpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IG91dGVyU2l6ZSArICdweCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG91dGVyQ2lyY2xlLnN0eWxlLCBvcHRzKTtcblxuICAgICAgICBtZVtzaWxlbnQgPyAnX3Zkb20nIDogJ3Zkb20nXSA9IHZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICB1cGRhdGVUaXRsZShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlubmVyQ2lyY2xlID0gbWUuZ2V0SW5uZXJDaXJjbGUoKSxcbiAgICAgICAgICAgIHZkb20gICAgICAgID0gbWUudmRvbTtcblxuICAgICAgICBpbm5lckNpcmNsZS5jblswXS5odG1sID0gbWUuc3RvcmU/LmdldENvdW50KCkgfHwgMDtcbiAgICAgICAgaW5uZXJDaXJjbGUuY25bMV0uaHRtbCA9IG1lLnRpdGxlO1xuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENpcmNsZSk7XG5cbmV4cG9ydCBkZWZhdWx0IENpcmNsZTtcbiIsImltcG9ydCBDb21wb25lbnQgICAgICAgIGZyb20gJy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGZvcm0gZmllbGRzXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdiYXNlZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnYmFzZWZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcm0gZ3JvdXBzIGNhbiBnZXQgc2V0IG9uIGFueSBwYXJlbnQgY29tcG9uZW50IGxldmVsLlxuICAgICAgICAgKiBBbiBhbHRlcm5hdGl2ZSB3YXkgZm9yIHVzaW5nIGRvdHMgaW4gZmllbGQgbmFtZXMuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBmb3JtR3JvdXBfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGZvcm1Hcm91cF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gbmFtZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOZW8gaXRzZWxmIGRvZXMgbm90IG5lZWQgZmllbGQgbmFtZXMgdG8gZ2V0IG1hcHBlZCB0byB0aGUgRE9NIChpbnB1dCBub2RlcyksXG4gICAgICAgICAqIGV4Y2VwdCBmb3IgQ2hlY2tCb3hlcyAmIFJhZGlvcyB0byB3b3JrLiBJdCBjYW4gYmUgdXNlZnVsIGZvciB0ZXN0aW5nIHRvb2xzXG4gICAgICAgICAqICYgYWNjZXNzaWJpbGl0eSB0aG91Z2gsIHNvIHRoZSBkZWZhdWx0IGdvdCBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgICogRmVlbCBmcmVlIHRvIGNoYW5nZSBpdCB0byBmYWxzZSB0byBrZWVwIHRoZSBET00gbWluaW1hbC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyTmFtZV89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyTmFtZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBjYXNlIHJlbmRlck5hbWUgaXMgc2V0IHRvIHRydWUsIHlvdSBjYW4gb3B0aW9uYWxseSByZW5kZXIgdGhlIGNvbWJpbmF0aW9uXG4gICAgICAgICAqIG9mIGFsbCBmb3JtR3JvdXAocykgJiB0aGUgZmllbGQgbmFtZSBpbnRvIHRoZSBET00gPT4gaW5wdXQgbm9kZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJQYXRoPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlclBhdGg6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHsqfSB2YWx1ZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgY2FjaGUgZm9yIGZvcm1Hcm91cHMgb2YgYWxsIHBhcmVudCBsZXZlbHNcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZm9ybUdyb3VwU3RyaW5nPW51bGxcbiAgICAgKi9cbiAgICBmb3JtR3JvdXBTdHJpbmcgPSBudWxsXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgY2FjaGUgZm9yIGZvcm1Hcm91cChzKSBhbmQgdGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcGF0aD1udWxsXG4gICAgICovXG4gICAgcGF0aCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbmFtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXROYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnJlbmRlck5hbWUgJiYgbWUuY2hhbmdlSW5wdXRFbEtleSgnbmFtZScsIG1lLnJlbmRlclBhdGggPyBtZS5nZXRQYXRoKCkgOiB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZm9ybUdyb3VwIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBwYXJlbnRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldEZvcm1Hcm91cCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JvdXAgPSBbXSxcbiAgICAgICAgICAgIHJldHVyblZhbHVlO1xuXG4gICAgICAgIGlmIChtZS5mb3JtR3JvdXBTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5mb3JtR3JvdXBTdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAmJiBncm91cC5wdXNoKHZhbHVlKTtcblxuICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgIHBhcmVudC5mb3JtR3JvdXAgJiYgZ3JvdXAudW5zaGlmdChwYXJlbnQuZm9ybUdyb3VwKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm5WYWx1ZSA9IGdyb3VwLmpvaW4oJy4nKTtcblxuICAgICAgICBtZS5mb3JtR3JvdXBTdHJpbmcgPSByZXR1cm5WYWx1ZTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIGlucHV0RWwgdmRvbSBvYmplY3QgYXR0cmlidXRlIG9yIHJlbW92ZXMgaXQgaW4gY2FzZSBpdCBoYXMgbm8gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ8T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgY2hhbmdlSW5wdXRFbEtleShrZXksIHZhbHVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgfHwgTmVvLmlzQm9vbGVhbih2YWx1ZSkgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIG1lLmdldElucHV0RWwoKVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbWUuZ2V0SW5wdXRFbCgpW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBmaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyO1xuXG4gICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogbWUsXG4gICAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEZvcm1Db250YWluZXIgJiYgcGFyZW50IGluc3RhbmNlb2YgRm9ybUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZmlyZSgnZmllbGRDaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IG1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0SW5wdXRFbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBmaWVsZCBmb3JtR3JvdXAocykgJiBuYW1lXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwYXRoO1xuXG4gICAgICAgIGlmICghbWUucGF0aCkge1xuICAgICAgICAgICAgcGF0aCA9IG1lLmZvcm1Hcm91cCA/IG1lLmZvcm1Hcm91cC5zcGxpdCgnLicpIDogW107XG5cbiAgICAgICAgICAgIG1lLm5hbWUgJiYgcGF0aC5wdXNoKG1lLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUucGF0aCA9IHBhdGguam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5wYXRoKSB7XG4gICAgICAgICAgICBtZS5wYXRoID0gJ25vbmUnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUucGF0aCA9PT0gJ25vbmUnID8gbnVsbDogbWUucGF0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICBzdXBlci5vbkZvY3VzTGVhdmU/LihkYXRhKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBGb3JtQ29udGFpbmVyID0gTmVvLmZvcm0/LkNvbnRhaW5lcjtcblxuICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZpcmUoJ2ZpZWxkRm9jdXNMZWF2ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IG1lXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZmllbGQgdG8gYSBuZXcgdmFsdWUgb3IgbnVsbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWU9bnVsbFxuICAgICAqL1xuICAgIHJlc2V0KHZhbHVlPW51bGwpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY2xpZW50LXNpZGUgZmllbGQgZXJyb3JzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2xpZW50LXNpZGUgZXJyb3JzXG4gICAgICovXG4gICAgdmFsaWRhdGUoc2lsZW50PXRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBjaGFuZ2UgZXZlbnQgZmlyZXMgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAqIEBldmVudCBjaGFuZ2VcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQmFzZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U7XG4iLCJpbXBvcnQgTW9kZWwgZnJvbSAnLi9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLkNpcmNsZU1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uc2VsZWN0aW9uLk1vZGVsXG4gKi9cbmNsYXNzIENpcmNsZU1vZGVsIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5DaXJjbGVNb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5DaXJjbGVNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tY2lyY2xlbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLWNpcmNsZW1vZGVsJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duTGVmdChkYXRhKSB7XG4gICAgICAgIHRoaXMub25OYXZLZXkoZGF0YSwgLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duUmlnaHQoZGF0YSkge1xuICAgICAgICB0aGlzLm9uTmF2S2V5KGRhdGEsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBvbk5hdktleShkYXRhLCBzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtICAgICA9IGRhdGEucGF0aFswXSxcbiAgICAgICAgICAgIHZpZXcgICAgID0gbWUudmlldyxcbiAgICAgICAgICAgIHN0b3JlICAgID0gdmlldy5zdG9yZSxcbiAgICAgICAgICAgIG1heEluZGV4ID0gTWF0aC5taW4oc3RvcmUuZ2V0Q291bnQoKSwgdmlldy5tYXhJdGVtcykgLSAxLFxuICAgICAgICAgICAgaW5kZXgsIGl0ZW1JZCwgcmVjb3JkSWQ7XG5cbiAgICAgICAgaWYgKGl0ZW0uY2xzLmluY2x1ZGVzKCduZW8tY2lyY2xlLWl0ZW0nKSkge1xuICAgICAgICAgICAgcmVjb3JkSWQgPSBwYXJzZUludCh2aWV3LmdldEl0ZW1SZWNvcmRJZChpdGVtLmlkKSk7XG4gICAgICAgICAgICBpbmRleCAgICA9IHN0b3JlLmluZGV4T2YocmVjb3JkSWQpICsgc3RlcDtcblxuICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSAgICAgICAge2luZGV4ID0gbWF4SW5kZXg7fVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPiBtYXhJbmRleCkge2luZGV4ID0gMDt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtSWQgPSB2aWV3LmdldEl0ZW1JZChpbmRleCk7XG5cbiAgICAgICAgbWUuc2VsZWN0KGl0ZW1JZCk7XG4gICAgICAgIHZpZXcuZm9jdXMoaXRlbUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKGNvbXBvbmVudCk7XG5cbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICA9IG1lLmlkLFxuICAgICAgICAgICAgdmlldyA9IG1lLnZpZXc7XG5cbiAgICAgICAgaWYgKHZpZXcua2V5cykge1xuICAgICAgICAgICAgdmlldy5rZXlzLl9rZXlzLnB1c2goXG4gICAgICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICxrZXk6ICdEb3duJyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICxrZXk6ICdMZWZ0JyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICxrZXk6ICdSaWdodCcgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICxrZXk6ICdVcCcgICAgLHNjb3BlOiBpZH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgPSBtZS5pZCxcbiAgICAgICAgICAgIHZpZXcgPSBtZS52aWV3O1xuXG4gICAgICAgIGlmICh2aWV3LmtleXMpIHtcbiAgICAgICAgICAgIHZpZXcua2V5cy5yZW1vdmVLZXlzKFtcbiAgICAgICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgLGtleTogJ0Rvd24nICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgLGtleTogJ0xlZnQnICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgLGtleTogJ1JpZ2h0JyAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgLGtleTogJ1VwJyAgICAsc2NvcGU6IGlkfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKCk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDaXJjbGVNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IENpcmNsZU1vZGVsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9