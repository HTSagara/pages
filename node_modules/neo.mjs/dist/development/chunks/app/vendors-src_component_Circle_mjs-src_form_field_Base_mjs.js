"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_Circle_mjs-src_form_field_Base_mjs"],{

/***/ "./src/component/Circle.mjs":
/*!**********************************!*\
  !*** ./src/component/Circle.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _selection_CircleModel_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection/CircleModel.mjs */ "./src/selection/CircleModel.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







let DragZone;

/**
 * @class Neo.component.Circle
 * @extends Neo.component.Base
 */
class Circle extends _Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Circle'
         * @protected
         */
        className: 'Neo.component.Circle',
        /**
         * @member {String} ntype='circle'
         * @protected
         */
        ntype: 'circle',
        /**
         * Will get set inside the ctor to avoid issues inside the webpack builds
         * @member {String|null} backsideIconPath=Neo.config.resourcesPath + 'images/circle/'
         */
        backsideIconPath: null,
        /**
         * @member {String[]} baseCls=['neo-circle-component']
         */
        baseCls: ['neo-circle-component'],
        /**
         * @member {Boolean} circleCenterHasTransitionCls=true
         * @protected
         */
        circleCenterHasTransitionCls: true,
        /**
         * @member {Boolean} collapsed=true
         */
        collapsed: true,
        /**
         * @member {Boolean} draggable_=true
         */
        draggable_: true,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys={}
         */
        keys: {},
        /**
         * @member {Number} innerRadius_=100
         */
        innerRadius_: 100,
        /**
         * @member {Boolean} isFlipped=false
         */
        isFlipped: false,
        /**
         * Will get set inside the ctor to avoid issues inside the webpack builds
         * @member {String} itemImagePath=Neo.config.resourcesPath + 'examples/images/'
         */
        itemImagePath: null,
        /**
         * @member {Number} itemSize_=60
         */
        itemSize_: 60,
        /**
         * @member {Number} maxItems_=12
         */
        maxItems_: 12,
        /**
         * The amount in px which the outerRadius is bigger than the innerRadius
         * @member {Number} outerRadiusDelta_=10
         */
        outerRadiusDelta_: 10,
        /**
         * @member {Number} rotateX_=0
         */
        rotateX_: 0,
        /**
         * @member {Number} rotateY_=0
         */
        rotateY_: 0,
        /**
         * @member {Number} rotateZ_=0
         */
        rotateZ_: 0,
        /**
         * @member {Number} rotationIndex_=0
         */
        rotationIndex_: 0,
        /**
         * @member {Neo.selection.Model|null} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * @member {Neo.collection.Base|null} store_=null
         */
        store_: null,
        /**
         * @member {String} title_='Circle 1'
         */
        title_: 'Circle 1',
        /**
         * The url for the store to load the data
         * @member {String} url_='../resources/examples/data/circles/group1.json'
         */
        url_: '../../resources/examples/data/circles/group1.json',
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tabIndex: -1, cn: [
            {cls: ['neo-circle-center'], style: {}, cn: [
                {cls: ['neo-circle-front'], cn: [
                    {cls: ['neo-circle'], style: {}, cn: [
                        {cls: ['neo-count-items']},
                        {cls: ['neo-circle-name']}
                    ]},
                    {cls: ['neo-outer-circle'], style: {}}
                ]},
                {cls: ['neo-circle-back'], cn: []}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        Neo.main.DomEvents.registerPreventDefaultTargets({
            name: 'contextmenu',
            cls : ['neo-circle', 'neo-circle-back']
        });

        let me = this;

        if (!me.backsideIconPath) {
            me.backsideIconPath = Neo.config.resourcesPath + 'images/circle/';
        }

        if (!me.itemImagePath) {
            me.itemImagePath = Neo.config.resourcesPath + 'examples/';
        }

        me.addDomListeners([{
            mouseenter: me.expand,
            mouseleave: me.collapse,
            scope     : me
        }, {
            contextmenu: me.onContextMenu,
            delegate   : 'neo-circle-back',
            scope      : me
        }, {
            click   : me.onBacksideIconClick,
            delegate: 'neo-backside-icon',
            scope   : me
        }, {
            mouseenter: me.expandItem,
            mouseleave: me.collapseItem,
            delegate  : 'neo-circle-item',
            scope     : me
        }, {
            contextmenu: me.onContextMenu,
            wheel      : me.onMouseWheel,
            delegate   : 'neo-circle',
            scope      : me
        }]);

        me.store = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            keyProperty: 'id'
        });

        // silent updates
        me.createBacksideItems(true);
        me.updateInnerCircle(true);
        me.updateOuterCircle(true);
        me.updateTitle(true);

        me.update();
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me           = this,
            domListeners = [];

        value && __webpack_require__.e(/*! import() */ "vendors-src_draggable_DragZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs")).then(module => {
            DragZone = module.default;

            if (!me.dragListenersAdded) {
                domListeners.push(
                    {'drag:end'  : me.onDragEnd,   scope: me, delegate: 'neo-circle-item'},
                    {'drag:start': me.onDragStart, scope: me, delegate: 'neo-circle-item'}
                );

                me.addDomListeners(domListeners);
                me.dragListenersAdded = true;
            }
        });
    }

    /**
     * Triggered after the innerRadius config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInnerRadius(value, oldValue) {
        if (oldValue) {
            let me = this;

            me.updateItemPositions(true);
            me.updateInnerCircle(true);
            me.updateOuterCircle(false);
        }
    }

    /**
     * Triggered after the maxItems config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMaxItems(value, oldValue) {
        if (oldValue && this.rendered) {
            let me      = this,
                frontEl = me.getFrontEl();

            if (value < oldValue) {
                if (me.collapsed) {
                    frontEl.cn.splice(value + 2);
                } else {
                    me.updateItemOpacity(0, true, value);

                    setTimeout(() => {
                        frontEl.cn.splice(value + 2);
                        me.update();
                    }, 300);
                }

                me.updateItemPositions(true);
                me.update();
            } else {
                me.createItems(oldValue, true);
                me.updateItemPositions(true);

                me.promiseUpdate().then(() => {
                    if (!me.collapsed) {
                        me.updateItemOpacity(1, true, oldValue);
                        me.update();
                    }
                });
            }
        }
    }

    /**
     * Triggered after the itemSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetItemSize(value, oldValue) {
        let me = this;

        if (oldValue && me.rendered) {
            !me.collapsed && me.updateOuterCircle(true);
            me.updateItemPositions();
        }
    }

    /**
     * Triggered after the rotateX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateX(value, oldValue) {
        oldValue && this.rendered && this.rotate();
    }

    /**
     * Triggered after the rotateY config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateY(value, oldValue) {
        oldValue && this.rendered && this.rotate();
    }

    /**
     * Triggered after the rotateZ config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateZ(value, oldValue) {
        oldValue && this.rendered && this.rotate();
    }

    /**
     * Triggered after the rotationIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotationIndex(value, oldValue) {
        if (Neo.isNumber(oldValue)) {
            console.log('afterSetRotationIndex', value);
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.rendered && value.register(this);
    }

    /**
     * Triggered after the title config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTitle(value, oldValue) {
        oldValue && this.updateTitle();
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue && oldValue.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_CircleModel_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }

    /**
     * @returns {Object[]}
     */
    calculateItemPositions() {
        let me        = this,
            angle     = 360 / me.maxItems,
            circlePos = [],
            itemSize  = me.itemSize,
            radius    = me.innerRadius + itemSize / 2 + 4,
            i         = 0,
            len       = me.maxItems,
            nr;

        for (; i < len; i++) {
            nr = (angle * i + 180) * Math.PI / 180;

            circlePos.push({
                left: -Math.round(radius * Math.sin(nr)) - itemSize / 2,
                top :  Math.round(radius * Math.cos(nr)) - itemSize / 2
            });
        }

        return circlePos;
    }

    /**
     *
     */
    collapse() {
        let me = this;

        if (!me.collapsed) {
            me.collapsed = true;
            me.updateOuterCircle(true);
            me.updateItemOpacity(0, false);
        }
    }

    /**
     * @param {Object} data
     */
    collapseItem(data) {
        let me    = this,
            item  = me.getItemEl(data.path[0].id),
            style = item.cn[0].style;

        delete style.marginLeft;
        delete style.marginTop;
        delete style.zIndex;

        style.height = me.itemSize + 'px';
        style.width  = me.itemSize + 'px';

        me.update();
    }

    /**
     * @param {Boolean} silent=false
     */
    createBacksideItems(silent=false) {
        let me         = this,
            backEl     = me.getBackEl(),
            itemCls    = ['neo-flip', 'neo-pencil', 'neo-trash'],
            itemFile   = ['flip.png', 'pencil.png', 'trash.png'],
            countItems = 3,
            i          = 0,
            vdom       = me.vdom;

        backEl.cn.push(
            {cls: ['neo-count-items']},
            {cls: ['neo-circle-name']}
        );

        for (; i < countItems; i++) {
            backEl.cn.push({
                tag: 'img',
                cls: ['neo-backside-icon', itemCls[i]],
                src: me.backsideIconPath + itemFile[i]
            });
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Number} startIndex=0
     * @param {Boolean} silent=false
     */
    createItems(startIndex=0, silent=false) {
        let me            = this,
            frontEl       = me.getFrontEl(),
            itemCls       = ['neo-circle-item'],
            itemPositions = me.calculateItemPositions(),
            itemSize      = me.itemSize,
            countItems    = Math.min(me.store.getCount(), me.maxItems),
            i             = startIndex,
            vdom          = me.vdom;

        me.draggable && itemCls.push('neo-draggable');

        for (; i < countItems; i++) {
            frontEl.cn.push({
                id      : me.getItemId(i),
                cls     : itemCls,
                tabIndex: -1,
                style: {
                    height: itemSize              + 'px',
                    left  : itemPositions[i].left + 'px',
                    top   : itemPositions[i].top  + 'px',
                    width : itemSize              + 'px'
                },
                cn: [{
                    tag  : 'img',
                    cls  : ['neo-circle-item-image'],
                    src  : me.itemImagePath + me.store.getAt(i).image,
                    style: {
                        height: itemSize + 'px',
                        width : itemSize + 'px'
                    }
                }]
            });
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Object} data
     */
    expand(data) {
        let me = this;

        if (me.collapsed) {
            me.collapsed = false;
            me.updateOuterCircle(true);
            me.updateItemOpacity(1, false);
        }
    }

    /**
     * @param {Object} data
     */
    expandItem(data) {
        let me   = this,
            item = me.getItemEl(data.path[0].id);

        item.cn[0].style = {
            height    : (me.itemSize + 20) + 'px',
            marginLeft: -10 + 'px',
            marginTop : -10 + 'px',
            width     : (me.itemSize + 20) + 'px',
            zIndex    : 40
        };

        me.update();
    }

    flipCircle() {
        let me = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][me.isFlipped ? 'remove': 'add'](me.vdom.cn[0].cls, 'neo-flipped');

        me.isFlipped = !me.isFlipped;
        me.update();
    }

    /**
     *
     */
    getBackEl() {
        return this.vdom.cn[0].cn[1];
    }

    /**
     *
     */
    getFrontEl() {
        return this.vdom.cn[0].cn[0];
    }

    /**
     *
     */
    getInnerCircle() {
        return this.vdom.cn[0].cn[0].cn[0];
    }

    /**
     * @param {String} itemId
     * @returns {Object}
     */
    getItemEl(itemId) {
        let item = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(this.getFrontEl(), itemId);

        return item?.vdom;
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getItemId(index) {
        let store = this.store;

        return this.id + '__' + store.getAt(index)[store.keyProperty];
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId   = vnodeId.split('__').pop(),
            model    = this.store.model,
            keyField = model?.getField(model.keyProperty);

        if (keyField?.type.toLowerCase() === 'number') {
            itemId = parseInt(itemId);
        }

        return itemId;
    }

    /**
     *
     */
    getOuterCircle() {
        return this.vdom.cn[0].cn[0].cn[1];
    }

    /**
     *
     */
    loadData() {
        let me = this;

        // todo: use a real store, not defined here for the examples
        Neo.Xhr.promiseJson({
            insideNeo: true,
            url      : me.url
        }).then(data => {
            me.store.items = data.json.data;

            setTimeout(() => {
                me.updateTitle();
                me.createItems();
            }, 100);
        }).catch(err => {
            console.log('Error for Neo.Xhr.request', err, me.id);
        });
    }

    /**
     * @param {Object} data
     */
    onBacksideIconClick(data) {
        let me  = this,
            cls = data.path[0].cls;

             if (cls.includes('neo-flip'))   {me.flipCircle();}
        else if (cls.includes('neo-pencil')) {console.log('edit circle');}
        else if (cls.includes('neo-trash'))  {console.log('delete circle');}
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.selectionModel?.register(me);
        me.loadData();
    }

    /**
     * @param {Object} data
     */
    onContextMenu(data) {
        this.flipCircle();
    }

    /**
     * @param data
     */
    onDragEnd(data) {
        console.log('onDragEnd', data);
    }

    /**
     * @param data
     */
    onDragStart(data) {
        console.log('onDragStart', data);

        let me           = this,
            wrapperStyle = me.wrapperStyle || {};

        me.isDragging = true;

        if (!me.dragZone) {
            me.dragZone = Neo.create({
                module         : DragZone,
                appName        : me.appName,
                bodyCursorStyle: 'move !important',
                dragElement    : me.vdom,
                dragProxyConfig: {vdom: me.getProxyVdom()},
                owner          : me,
                useProxyWrapper: false,
                ...me.dragZoneConfig
            });
        }

        me.dragZone.dragStart(data);

        wrapperStyle.opacity = 0.7;

        me.wrapperStyle = wrapperStyle;
    }

    /**
     * @param {Object} data
     */
    onMouseWheel(data) {
        let me        = this,
            deltaY    = data.deltaY,
            itemAngle = 360 / me.maxItems,
            maxAngle  = Math.max(0, (me.store.getCount() - me.maxItems) * itemAngle),
            rotateZ   = me.rotateZ;

        if (deltaY >  1 || deltaY < -1) {
            rotateZ += deltaY;
        }

        if (rotateZ < 0) {
            rotateZ = 0;
        } else if (rotateZ > maxAngle) {
            rotateZ = maxAngle;
        }

        if (!(me.rotateZ === 0 && rotateZ === 0) && !(me.rotateZ === maxAngle && rotateZ === maxAngle)) {
            me.rotateZ       = rotateZ;
            me.rotationIndex = Math.floor(rotateZ / itemAngle);

            me.rotate();
        }
    }

    /**
     *
     */
    rotate() {
        let me             = this,
            circleCenterEl = me.vdom.cn[0],
            transform = [
                `rotateX(${me.rotateX}deg)`,
                `rotateY(${me.rotateY}deg)`,
                `rotateZ(${me.rotateZ}deg)`
            ].join(' ');

        if (me.circleCenterHasTransitionCls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(circleCenterEl.cls, 'no-transition');

            me.circleCenterHasTransitionCls = false;

            me.promiseUpdate().then(() => {
                me.updateItemAngle(true);
                circleCenterEl.style.transform = transform;
                me.update();
            });
        } else {
            me.updateItemAngle(true);
            circleCenterEl.style.transform = transform;
            me.update();
        }
    }

    /**
     * @param {Boolean} silent=false
     */
    updateInnerCircle(silent=false) {
        let me           = this,
            innerCircle  = me.getInnerCircle(),
            innerRadius  = me.innerRadius,
            innerSize    = innerRadius * 2,
            vdom         = me.vdom;

        Object.assign(innerCircle.style, {
            height: innerSize + 'px',
            left  : '-' + innerRadius + 'px',
            top   : '-' + innerRadius + 'px',
            width : innerSize + 'px'
        });

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateItemAngle(silent=false) {
        let me      = this,
            frontEl = me.getFrontEl(),
            vdom    = me.vdom,
            i       = 2,
            len     = frontEl.cn.length;

        for (; i < len; i++) {
            frontEl.cn[i].style.transform = 'rotateZ(' + (-me.rotateZ) + 'deg)';
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Number} value
     * @param {Boolean} silent=false
     * @param {Number} startIndex=0
     */
    updateItemOpacity(value, silent=false, startIndex=0) {
        let me      = this,
            i       = startIndex + 2,
            frontEl = me.getFrontEl(),
            len     = frontEl.cn.length,
            vdom    = me.vdom;

        for (; i < len; i++) {
            frontEl.cn[i].style.opacity = value;
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateItemPositions(silent=false) {
        let me            = this,
            frontEl       = me.getFrontEl(),
            itemPositions = me.calculateItemPositions(),
            itemSize      = me.itemSize,
            vdom          = me.vdom,
            i             = 2,
            len           = Math.min(frontEl.cn.length, itemPositions.length + 2);

        for (; i < len; i++) {
            Object.assign(frontEl.cn[i].style, {
                height: itemSize                + 'px',
                left  : itemPositions[i-2].left + 'px',
                top   : itemPositions[i-2].top  + 'px',
                width : itemSize                + 'px'
            });

            Object.assign(frontEl.cn[i].cn[0].style, {
                height: itemSize + 'px',
                width : itemSize + 'px'
            });
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateOuterCircle(silent=false) {
        let me           = this,
            itemSize = me.itemSize,
            outerCircle  = me.getOuterCircle(),
            outerRadius  = me.innerRadius + me.outerRadiusDelta,
            outerSize    = me.collapsed ? outerRadius * 2 : (outerRadius + itemSize) * 2,
            vdom         = me.vdom,
            opts;

        if (me.collapsed) {
            opts = {
                height: outerSize + 'px',
                left  : '-' + outerRadius + 'px',
                top   : '-' + outerRadius + 'px',
                width : outerSize + 'px'
            };
        } else {
            opts = {
                height: outerSize + 'px',
                left  : '-' + (outerRadius + itemSize) + 'px',
                top   : '-' + (outerRadius + itemSize) + 'px',
                width : outerSize + 'px'
            };
        }

        Object.assign(outerCircle.style, opts);

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateTitle(silent=false) {
        let me          = this,
            innerCircle = me.getInnerCircle(),
            vdom        = me.vdom;

        innerCircle.cn[0].html = me.store?.getCount() || 0;
        innerCircle.cn[1].html = me.title;

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }
}

Neo.applyClassConfig(Circle);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Circle);


/***/ }),

/***/ "./src/form/field/Base.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        fireChangeEvent    : {type: 'debounce', timer: 1000},
        fireUserChangeEvent: {type: 'debounce', timer: 1000}
    }

    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         */
        formGroup_: null,
        /**
         * @member {String|null} name_=null
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.getInputEl().role = value;
        this.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {
        oldValue !== undefined && this.fireChangeEvent(value, oldValue)
    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString;
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value;
        } else {
            delete me.getInputEl()[key];
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*}      value
     * @param {*}      oldValue
     * @param {String} eventName
     */
    doFireChangeEvent(value, oldValue, eventName) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            formEvent     = 'field' + Neo.capitalize(eventName),
            opts          = {component: me, oldValue, value};

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        me.fire(eventName, opts);

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire(formEvent, opts)
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'change')
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireUserChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'userChange')
    }

    /**
     * Forms in neo can be nested. This method will return the closest parent which is a form.Container or null.
     * @returns {Neo.form.Container|null}
     */
    getClosestForm() {
        let me            = this,
            FormContainer = Neo.form?.Container,
            parent;

        for (parent of _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me)) {
            if (FormContainer && parent instanceof FormContainer) {
                return parent
            }
        }

        return null
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        // fields could have formGroups, but no name.
        // returning the namespace can confuse form.Container.adjustTreeLeaves(),
        // since namespaces could be considered as field instances.
        if (!me.name) {
            return null
        }

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getValue() {
        return this.value;
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true;
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave?.(data);

        let me            = this,
            FormContainer = Neo.form?.Container,
            opts          = {...data, component: me, value: me.getValue()};

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', opts)
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.value = value;
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true;
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

Neo.applyClassConfig(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/selection/CircleModel.mjs":
/*!***************************************!*\
  !*** ./src/selection/CircleModel.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");


/**
 * @class Neo.selection.CircleModel
 * @extends Neo.selection.Model
 */
class CircleModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.CircleModel'
         * @protected
         */
        className: 'Neo.selection.CircleModel',
        /**
         * @member {String} ntype='selection-circlemodel'
         * @protected
         */
        ntype: 'selection-circlemodel'
    }

    /**
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        this.onNavKey(data, -1);
    }

    /**
     * @param {Object} data
     */
    onKeyDownRight(data) {
        this.onNavKey(data, 1);
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        let me       = this,
            item     = data.path[0],
            view     = me.view,
            store    = view.store,
            maxIndex = Math.min(store.getCount(), view.maxItems) - 1,
            index, itemId, recordId;

        if (item.cls.includes('neo-circle-item')) {
            recordId = parseInt(view.getItemRecordId(item.id));
            index    = store.indexOf(recordId) + step;

                 if (index < 0)        {index = maxIndex;}
            else if (index > maxIndex) {index = 0;}
        } else {
            index = 0;
        }

        itemId = view.getItemId(index);

        me.select(itemId);
        view.focus(itemId);
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me   = this,
            id   = me.id,
            view = me.view;

        view.keys?._keys.push(
            {fn: 'onKeyDownLeft'  ,key: 'Down'  ,scope: id},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Up'    ,scope: id}
        );
    }

    /**
     *
     */
    unregister() {
        let me   = this,
            id   = me.id,
            view = me.view;

        view.keys?.removeKeys([
            {fn: 'onKeyDownLeft'  ,key: 'Down'  ,scope: id},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Up'    ,scope: id}
        ]);

        super.unregister();
    }
}

Neo.applyClassConfig(CircleModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleModel);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfQ2lyY2xlX21qcy1zcmNfZm9ybV9maWVsZF9CYXNlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ0s7QUFDTjtBQUNaO0FBQ087QUFDRDs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQVM7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFB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QUFFQTs7QUFFQSxpRUFBZSxXQUFXLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9DaXJjbGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9DaXJjbGVNb2RlbC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ2lyY2xlTW9kZWwgICAgIGZyb20gJy4uL3NlbGVjdGlvbi9DaXJjbGVNb2RlbC5tanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gICAgICBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnQgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbmxldCBEcmFnWm9uZTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5DaXJjbGVcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5DaXJjbGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuQ2lyY2xlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NpcmNsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgc2V0IGluc2lkZSB0aGUgY3RvciB0byBhdm9pZCBpc3N1ZXMgaW5zaWRlIHRoZSB3ZWJwYWNrIGJ1aWxkc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYmFja3NpZGVJY29uUGF0aD1OZW8uY29uZmlnLnJlc291cmNlc1BhdGggKyAnaW1hZ2VzL2NpcmNsZS8nXG4gICAgICAgICAqL1xuICAgICAgICBiYWNrc2lkZUljb25QYXRoOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2lyY2xlLWNvbXBvbmVudCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jaXJjbGUtY29tcG9uZW50J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjaXJjbGVDZW50ZXJIYXNUcmFuc2l0aW9uQ2xzPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2lyY2xlQ2VudGVySGFzVHJhbnNpdGlvbkNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNvbGxhcHNlZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnZ2FibGVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnYWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHVzZWQga2V5cyBmb3IgdGhlIHNlbGVjdGlvbiBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGtleXM9e31cbiAgICAgICAgICovXG4gICAgICAgIGtleXM6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBpbm5lclJhZGl1c189MTAwXG4gICAgICAgICAqL1xuICAgICAgICBpbm5lclJhZGl1c186IDEwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzRmxpcHBlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNGbGlwcGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgZ2V0IHNldCBpbnNpZGUgdGhlIGN0b3IgdG8gYXZvaWQgaXNzdWVzIGluc2lkZSB0aGUgd2VicGFjayBidWlsZHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpdGVtSW1hZ2VQYXRoPU5lby5jb25maWcucmVzb3VyY2VzUGF0aCArICdleGFtcGxlcy9pbWFnZXMvJ1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUltYWdlUGF0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaXRlbVNpemVfPTYwXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtU2l6ZV86IDYwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhJdGVtc189MTJcbiAgICAgICAgICovXG4gICAgICAgIG1heEl0ZW1zXzogMTIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IGluIHB4IHdoaWNoIHRoZSBvdXRlclJhZGl1cyBpcyBiaWdnZXIgdGhhbiB0aGUgaW5uZXJSYWRpdXNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBvdXRlclJhZGl1c0RlbHRhXz0xMFxuICAgICAgICAgKi9cbiAgICAgICAgb3V0ZXJSYWRpdXNEZWx0YV86IDEwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3RhdGVYXz0wXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVYXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm90YXRlWV89MFxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlWV86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvdGF0ZVpfPTBcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZVpfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3RhdGlvbkluZGV4Xz0wXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGlvbkluZGV4XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5zZWxlY3Rpb24uTW9kZWx8bnVsbH0gc2VsZWN0aW9uTW9kZWxfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb2xsZWN0aW9uLkJhc2V8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGl0bGVfPSdDaXJjbGUgMSdcbiAgICAgICAgICovXG4gICAgICAgIHRpdGxlXzogJ0NpcmNsZSAxJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cmwgZm9yIHRoZSBzdG9yZSB0byBsb2FkIHRoZSBkYXRhXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdXJsXz0nLi4vcmVzb3VyY2VzL2V4YW1wbGVzL2RhdGEvY2lyY2xlcy9ncm91cDEuanNvbidcbiAgICAgICAgICovXG4gICAgICAgIHVybF86ICcuLi8uLi9yZXNvdXJjZXMvZXhhbXBsZXMvZGF0YS9jaXJjbGVzL2dyb3VwMS5qc29uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFiSW5kZXg6IC0xLCBjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tY2lyY2xlLWNlbnRlciddLCBzdHlsZToge30sIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tY2lyY2xlLWZyb250J10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNpcmNsZSddLCBzdHlsZToge30sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1jb3VudC1pdGVtcyddfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNpcmNsZS1uYW1lJ119XG4gICAgICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1vdXRlci1jaXJjbGUnXSwgc3R5bGU6IHt9fVxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNpcmNsZS1iYWNrJ10sIGNuOiBbXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgTmVvLm1haW4uRG9tRXZlbnRzLnJlZ2lzdGVyUHJldmVudERlZmF1bHRUYXJnZXRzKHtcbiAgICAgICAgICAgIG5hbWU6ICdjb250ZXh0bWVudScsXG4gICAgICAgICAgICBjbHMgOiBbJ25lby1jaXJjbGUnLCAnbmVvLWNpcmNsZS1iYWNrJ11cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmJhY2tzaWRlSWNvblBhdGgpIHtcbiAgICAgICAgICAgIG1lLmJhY2tzaWRlSWNvblBhdGggPSBOZW8uY29uZmlnLnJlc291cmNlc1BhdGggKyAnaW1hZ2VzL2NpcmNsZS8nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5pdGVtSW1hZ2VQYXRoKSB7XG4gICAgICAgICAgICBtZS5pdGVtSW1hZ2VQYXRoID0gTmVvLmNvbmZpZy5yZXNvdXJjZXNQYXRoICsgJ2V4YW1wbGVzLyc7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tcbiAgICAgICAgICAgIG1vdXNlZW50ZXI6IG1lLmV4cGFuZCxcbiAgICAgICAgICAgIG1vdXNlbGVhdmU6IG1lLmNvbGxhcHNlLFxuICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY29udGV4dG1lbnU6IG1lLm9uQ29udGV4dE1lbnUsXG4gICAgICAgICAgICBkZWxlZ2F0ZSAgIDogJ25lby1jaXJjbGUtYmFjaycsXG4gICAgICAgICAgICBzY29wZSAgICAgIDogbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2xpY2sgICA6IG1lLm9uQmFja3NpZGVJY29uQ2xpY2ssXG4gICAgICAgICAgICBkZWxlZ2F0ZTogJ25lby1iYWNrc2lkZS1pY29uJyxcbiAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb3VzZWVudGVyOiBtZS5leHBhbmRJdGVtLFxuICAgICAgICAgICAgbW91c2VsZWF2ZTogbWUuY29sbGFwc2VJdGVtLFxuICAgICAgICAgICAgZGVsZWdhdGUgIDogJ25lby1jaXJjbGUtaXRlbScsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb250ZXh0bWVudTogbWUub25Db250ZXh0TWVudSxcbiAgICAgICAgICAgIHdoZWVsICAgICAgOiBtZS5vbk1vdXNlV2hlZWwsXG4gICAgICAgICAgICBkZWxlZ2F0ZSAgIDogJ25lby1jaXJjbGUnLFxuICAgICAgICAgICAgc2NvcGUgICAgICA6IG1lXG4gICAgICAgIH1dKTtcblxuICAgICAgICBtZS5zdG9yZSA9IE5lby5jcmVhdGUoQ29sbGVjdGlvbiwge1xuICAgICAgICAgICAga2V5UHJvcGVydHk6ICdpZCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2lsZW50IHVwZGF0ZXNcbiAgICAgICAgbWUuY3JlYXRlQmFja3NpZGVJdGVtcyh0cnVlKTtcbiAgICAgICAgbWUudXBkYXRlSW5uZXJDaXJjbGUodHJ1ZSk7XG4gICAgICAgIG1lLnVwZGF0ZU91dGVyQ2lyY2xlKHRydWUpO1xuICAgICAgICBtZS51cGRhdGVUaXRsZSh0cnVlKTtcblxuICAgICAgICBtZS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyYWdnYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkb21MaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICB2YWx1ZSAmJiBpbXBvcnQoJy4uL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBEcmFnWm9uZSA9IG1vZHVsZS5kZWZhdWx0O1xuXG4gICAgICAgICAgICBpZiAoIW1lLmRyYWdMaXN0ZW5lcnNBZGRlZCkge1xuICAgICAgICAgICAgICAgIGRvbUxpc3RlbmVycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkRyYWdFbmQsICAgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJ25lby1jaXJjbGUtaXRlbSd9LFxuICAgICAgICAgICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkRyYWdTdGFydCwgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJ25lby1jaXJjbGUtaXRlbSd9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhkb21MaXN0ZW5lcnMpO1xuICAgICAgICAgICAgICAgIG1lLmRyYWdMaXN0ZW5lcnNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW5uZXJSYWRpdXMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW5uZXJSYWRpdXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUudXBkYXRlSXRlbVBvc2l0aW9ucyh0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUlubmVyQ2lyY2xlKHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlT3V0ZXJDaXJjbGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXhJdGVtcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhJdGVtcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICYmIHRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBmcm9udEVsID0gbWUuZ2V0RnJvbnRFbCgpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChtZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbnRFbC5jbi5zcGxpY2UodmFsdWUgKyAyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVJdGVtT3BhY2l0eSgwLCB0cnVlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9udEVsLmNuLnNwbGljZSh2YWx1ZSArIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUudXBkYXRlSXRlbVBvc2l0aW9ucyh0cnVlKTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMob2xkVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1Qb3NpdGlvbnModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVJdGVtT3BhY2l0eSgxLCB0cnVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpdGVtU2l6ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJdGVtU2l6ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUgJiYgbWUucmVuZGVyZWQpIHtcbiAgICAgICAgICAgICFtZS5jb2xsYXBzZWQgJiYgbWUudXBkYXRlT3V0ZXJDaXJjbGUodHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVJdGVtUG9zaXRpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJvdGF0ZVggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um90YXRlWCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnJvdGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRlWSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGVZKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnJlbmRlcmVkICYmIHRoaXMucm90YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3RhdGVaIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvdGF0ZVoodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5yb3RhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJvdGF0aW9uSW5kZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um90YXRpb25JbmRleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc051bWJlcihvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZnRlclNldFJvdGF0aW9uSW5kZXgnLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgJiYgdmFsdWUucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aXRsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaXRsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgdGhpcy51cGRhdGVUaXRsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIG9sZFZhbHVlLmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBDaXJjbGVNb2RlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUl0ZW1Qb3NpdGlvbnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYW5nbGUgICAgID0gMzYwIC8gbWUubWF4SXRlbXMsXG4gICAgICAgICAgICBjaXJjbGVQb3MgPSBbXSxcbiAgICAgICAgICAgIGl0ZW1TaXplICA9IG1lLml0ZW1TaXplLFxuICAgICAgICAgICAgcmFkaXVzICAgID0gbWUuaW5uZXJSYWRpdXMgKyBpdGVtU2l6ZSAvIDIgKyA0LFxuICAgICAgICAgICAgaSAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICA9IG1lLm1heEl0ZW1zLFxuICAgICAgICAgICAgbnI7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbnIgPSAoYW5nbGUgKiBpICsgMTgwKSAqIE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgICAgIGNpcmNsZVBvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAtTWF0aC5yb3VuZChyYWRpdXMgKiBNYXRoLnNpbihucikpIC0gaXRlbVNpemUgLyAyLFxuICAgICAgICAgICAgICAgIHRvcCA6ICBNYXRoLnJvdW5kKHJhZGl1cyAqIE1hdGguY29zKG5yKSkgLSBpdGVtU2l6ZSAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNpcmNsZVBvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbGxhcHNlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBtZS5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgbWUudXBkYXRlT3V0ZXJDaXJjbGUodHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVJdGVtT3BhY2l0eSgwLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNvbGxhcHNlSXRlbShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtICA9IG1lLmdldEl0ZW1FbChkYXRhLnBhdGhbMF0uaWQpLFxuICAgICAgICAgICAgc3R5bGUgPSBpdGVtLmNuWzBdLnN0eWxlO1xuXG4gICAgICAgIGRlbGV0ZSBzdHlsZS5tYXJnaW5MZWZ0O1xuICAgICAgICBkZWxldGUgc3R5bGUubWFyZ2luVG9wO1xuICAgICAgICBkZWxldGUgc3R5bGUuekluZGV4O1xuXG4gICAgICAgIHN0eWxlLmhlaWdodCA9IG1lLml0ZW1TaXplICsgJ3B4JztcbiAgICAgICAgc3R5bGUud2lkdGggID0gbWUuaXRlbVNpemUgKyAncHgnO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgY3JlYXRlQmFja3NpZGVJdGVtcyhzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYmFja0VsICAgICA9IG1lLmdldEJhY2tFbCgpLFxuICAgICAgICAgICAgaXRlbUNscyAgICA9IFsnbmVvLWZsaXAnLCAnbmVvLXBlbmNpbCcsICduZW8tdHJhc2gnXSxcbiAgICAgICAgICAgIGl0ZW1GaWxlICAgPSBbJ2ZsaXAucG5nJywgJ3BlbmNpbC5wbmcnLCAndHJhc2gucG5nJ10sXG4gICAgICAgICAgICBjb3VudEl0ZW1zID0gMyxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgdmRvbSAgICAgICA9IG1lLnZkb207XG5cbiAgICAgICAgYmFja0VsLmNuLnB1c2goXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1jb3VudC1pdGVtcyddfSxcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNpcmNsZS1uYW1lJ119XG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBjb3VudEl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgIGJhY2tFbC5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YWc6ICdpbWcnLFxuICAgICAgICAgICAgICAgIGNsczogWyduZW8tYmFja3NpZGUtaWNvbicsIGl0ZW1DbHNbaV1dLFxuICAgICAgICAgICAgICAgIHNyYzogbWUuYmFja3NpZGVJY29uUGF0aCArIGl0ZW1GaWxlW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRleD0wXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcyhzdGFydEluZGV4PTAsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBmcm9udEVsICAgICAgID0gbWUuZ2V0RnJvbnRFbCgpLFxuICAgICAgICAgICAgaXRlbUNscyAgICAgICA9IFsnbmVvLWNpcmNsZS1pdGVtJ10sXG4gICAgICAgICAgICBpdGVtUG9zaXRpb25zID0gbWUuY2FsY3VsYXRlSXRlbVBvc2l0aW9ucygpLFxuICAgICAgICAgICAgaXRlbVNpemUgICAgICA9IG1lLml0ZW1TaXplLFxuICAgICAgICAgICAgY291bnRJdGVtcyAgICA9IE1hdGgubWluKG1lLnN0b3JlLmdldENvdW50KCksIG1lLm1heEl0ZW1zKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgPSBzdGFydEluZGV4LFxuICAgICAgICAgICAgdmRvbSAgICAgICAgICA9IG1lLnZkb207XG5cbiAgICAgICAgbWUuZHJhZ2dhYmxlICYmIGl0ZW1DbHMucHVzaCgnbmVvLWRyYWdnYWJsZScpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgY291bnRJdGVtczsgaSsrKSB7XG4gICAgICAgICAgICBmcm9udEVsLmNuLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkICAgICAgOiBtZS5nZXRJdGVtSWQoaSksXG4gICAgICAgICAgICAgICAgY2xzICAgICA6IGl0ZW1DbHMsXG4gICAgICAgICAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemUgICAgICAgICAgICAgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgOiBpdGVtUG9zaXRpb25zW2ldLmxlZnQgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICB0b3AgICA6IGl0ZW1Qb3NpdGlvbnNbaV0udG9wICArICdweCcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbVNpemUgICAgICAgICAgICAgICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgIHRhZyAgOiAnaW1nJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLWNpcmNsZS1pdGVtLWltYWdlJ10sXG4gICAgICAgICAgICAgICAgICAgIHNyYyAgOiBtZS5pdGVtSW1hZ2VQYXRoICsgbWUuc3RvcmUuZ2V0QXQoaSkuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW1TaXplICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbVNpemUgKyAncHgnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZVtzaWxlbnQgPyAnX3Zkb20nIDogJ3Zkb20nXSA9IHZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBleHBhbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIG1lLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbWUudXBkYXRlT3V0ZXJDaXJjbGUodHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVJdGVtT3BhY2l0eSgxLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGV4cGFuZEl0ZW0oZGF0YSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gbWUuZ2V0SXRlbUVsKGRhdGEucGF0aFswXS5pZCk7XG5cbiAgICAgICAgaXRlbS5jblswXS5zdHlsZSA9IHtcbiAgICAgICAgICAgIGhlaWdodCAgICA6IChtZS5pdGVtU2l6ZSArIDIwKSArICdweCcsXG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiAtMTAgKyAncHgnLFxuICAgICAgICAgICAgbWFyZ2luVG9wIDogLTEwICsgJ3B4JyxcbiAgICAgICAgICAgIHdpZHRoICAgICA6IChtZS5pdGVtU2l6ZSArIDIwKSArICdweCcsXG4gICAgICAgICAgICB6SW5kZXggICAgOiA0MFxuICAgICAgICB9O1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGZsaXBDaXJjbGUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvQXJyYXlbbWUuaXNGbGlwcGVkID8gJ3JlbW92ZSc6ICdhZGQnXShtZS52ZG9tLmNuWzBdLmNscywgJ25lby1mbGlwcGVkJyk7XG5cbiAgICAgICAgbWUuaXNGbGlwcGVkID0gIW1lLmlzRmxpcHBlZDtcbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRCYWNrRWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRGcm9udEVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0SW5uZXJDaXJjbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF0uY25bMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0SXRlbUVsKGl0ZW1JZCkge1xuICAgICAgICBsZXQgaXRlbSA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQodGhpcy5nZXRGcm9udEVsKCksIGl0ZW1JZCk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0/LnZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJdGVtSWQoaW5kZXgpIHtcbiAgICAgICAgbGV0IHN0b3JlID0gdGhpcy5zdG9yZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pZCArICdfXycgKyBzdG9yZS5nZXRBdChpbmRleClbc3RvcmUua2V5UHJvcGVydHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2bm9kZUlkXG4gICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9IGl0ZW1JZFxuICAgICAqL1xuICAgIGdldEl0ZW1SZWNvcmRJZCh2bm9kZUlkKSB7XG4gICAgICAgIGxldCBpdGVtSWQgICA9IHZub2RlSWQuc3BsaXQoJ19fJykucG9wKCksXG4gICAgICAgICAgICBtb2RlbCAgICA9IHRoaXMuc3RvcmUubW9kZWwsXG4gICAgICAgICAgICBrZXlGaWVsZCA9IG1vZGVsPy5nZXRGaWVsZChtb2RlbC5rZXlQcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGtleUZpZWxkPy50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpdGVtSWQgPSBwYXJzZUludChpdGVtSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1JZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldE91dGVyQ2lyY2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzBdLmNuWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbG9hZERhdGEoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gdG9kbzogdXNlIGEgcmVhbCBzdG9yZSwgbm90IGRlZmluZWQgaGVyZSBmb3IgdGhlIGV4YW1wbGVzXG4gICAgICAgIE5lby5YaHIucHJvbWlzZUpzb24oe1xuICAgICAgICAgICAgaW5zaWRlTmVvOiB0cnVlLFxuICAgICAgICAgICAgdXJsICAgICAgOiBtZS51cmxcbiAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIG1lLnN0b3JlLml0ZW1zID0gZGF0YS5qc29uLmRhdGE7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZVRpdGxlKCk7XG4gICAgICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMoKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgZm9yIE5lby5YaHIucmVxdWVzdCcsIGVyciwgbWUuaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQmFja3NpZGVJY29uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IGRhdGEucGF0aFswXS5jbHM7XG5cbiAgICAgICAgICAgICBpZiAoY2xzLmluY2x1ZGVzKCduZW8tZmxpcCcpKSAgIHttZS5mbGlwQ2lyY2xlKCk7fVxuICAgICAgICBlbHNlIGlmIChjbHMuaW5jbHVkZXMoJ25lby1wZW5jaWwnKSkge2NvbnNvbGUubG9nKCdlZGl0IGNpcmNsZScpO31cbiAgICAgICAgZWxzZSBpZiAoY2xzLmluY2x1ZGVzKCduZW8tdHJhc2gnKSkgIHtjb25zb2xlLmxvZygnZGVsZXRlIGNpcmNsZScpO31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5yZWdpc3RlcihtZSk7XG4gICAgICAgIG1lLmxvYWREYXRhKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbnRleHRNZW51KGRhdGEpIHtcbiAgICAgICAgdGhpcy5mbGlwQ2lyY2xlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZygnb25EcmFnRW5kJywgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkRyYWdTdGFydCcsIGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgd3JhcHBlclN0eWxlID0gbWUud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgIG1lLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIGlmICghbWUuZHJhZ1pvbmUpIHtcbiAgICAgICAgICAgIG1lLmRyYWdab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBEcmFnWm9uZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgYm9keUN1cnNvclN0eWxlOiAnbW92ZSAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCAgICA6IG1lLnZkb20sXG4gICAgICAgICAgICAgICAgZHJhZ1Byb3h5Q29uZmlnOiB7dmRvbTogbWUuZ2V0UHJveHlWZG9tKCl9LFxuICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgdXNlUHJveHlXcmFwcGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAuLi5tZS5kcmFnWm9uZUNvbmZpZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5kcmFnWm9uZS5kcmFnU3RhcnQoZGF0YSk7XG5cbiAgICAgICAgd3JhcHBlclN0eWxlLm9wYWNpdHkgPSAwLjc7XG5cbiAgICAgICAgbWUud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZVdoZWVsKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkZWx0YVkgICAgPSBkYXRhLmRlbHRhWSxcbiAgICAgICAgICAgIGl0ZW1BbmdsZSA9IDM2MCAvIG1lLm1heEl0ZW1zLFxuICAgICAgICAgICAgbWF4QW5nbGUgID0gTWF0aC5tYXgoMCwgKG1lLnN0b3JlLmdldENvdW50KCkgLSBtZS5tYXhJdGVtcykgKiBpdGVtQW5nbGUpLFxuICAgICAgICAgICAgcm90YXRlWiAgID0gbWUucm90YXRlWjtcblxuICAgICAgICBpZiAoZGVsdGFZID4gIDEgfHwgZGVsdGFZIDwgLTEpIHtcbiAgICAgICAgICAgIHJvdGF0ZVogKz0gZGVsdGFZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdGF0ZVogPCAwKSB7XG4gICAgICAgICAgICByb3RhdGVaID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChyb3RhdGVaID4gbWF4QW5nbGUpIHtcbiAgICAgICAgICAgIHJvdGF0ZVogPSBtYXhBbmdsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKG1lLnJvdGF0ZVogPT09IDAgJiYgcm90YXRlWiA9PT0gMCkgJiYgIShtZS5yb3RhdGVaID09PSBtYXhBbmdsZSAmJiByb3RhdGVaID09PSBtYXhBbmdsZSkpIHtcbiAgICAgICAgICAgIG1lLnJvdGF0ZVogICAgICAgPSByb3RhdGVaO1xuICAgICAgICAgICAgbWUucm90YXRpb25JbmRleCA9IE1hdGguZmxvb3Iocm90YXRlWiAvIGl0ZW1BbmdsZSk7XG5cbiAgICAgICAgICAgIG1lLnJvdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByb3RhdGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjaXJjbGVDZW50ZXJFbCA9IG1lLnZkb20uY25bMF0sXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBbXG4gICAgICAgICAgICAgICAgYHJvdGF0ZVgoJHttZS5yb3RhdGVYfWRlZylgLFxuICAgICAgICAgICAgICAgIGByb3RhdGVZKCR7bWUucm90YXRlWX1kZWcpYCxcbiAgICAgICAgICAgICAgICBgcm90YXRlWigke21lLnJvdGF0ZVp9ZGVnKWBcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuXG4gICAgICAgIGlmIChtZS5jaXJjbGVDZW50ZXJIYXNUcmFuc2l0aW9uQ2xzKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2lyY2xlQ2VudGVyRWwuY2xzLCAnbm8tdHJhbnNpdGlvbicpO1xuXG4gICAgICAgICAgICBtZS5jaXJjbGVDZW50ZXJIYXNUcmFuc2l0aW9uQ2xzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIG1lLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVJdGVtQW5nbGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2lyY2xlQ2VudGVyRWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS51cGRhdGVJdGVtQW5nbGUodHJ1ZSk7XG4gICAgICAgICAgICBjaXJjbGVDZW50ZXJFbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICBtZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlSW5uZXJDaXJjbGUoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5uZXJDaXJjbGUgID0gbWUuZ2V0SW5uZXJDaXJjbGUoKSxcbiAgICAgICAgICAgIGlubmVyUmFkaXVzICA9IG1lLmlubmVyUmFkaXVzLFxuICAgICAgICAgICAgaW5uZXJTaXplICAgID0gaW5uZXJSYWRpdXMgKiAyLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgID0gbWUudmRvbTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGlubmVyQ2lyY2xlLnN0eWxlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IGlubmVyU2l6ZSArICdweCcsXG4gICAgICAgICAgICBsZWZ0ICA6ICctJyArIGlubmVyUmFkaXVzICsgJ3B4JyxcbiAgICAgICAgICAgIHRvcCAgIDogJy0nICsgaW5uZXJSYWRpdXMgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGggOiBpbm5lclNpemUgKyAncHgnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIHVwZGF0ZUl0ZW1BbmdsZShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZnJvbnRFbCA9IG1lLmdldEZyb250RWwoKSxcbiAgICAgICAgICAgIHZkb20gICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgaSAgICAgICA9IDIsXG4gICAgICAgICAgICBsZW4gICAgID0gZnJvbnRFbC5jbi5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZnJvbnRFbC5jbltpXS5zdHlsZS50cmFuc2Zvcm0gPSAncm90YXRlWignICsgKC1tZS5yb3RhdGVaKSArICdkZWcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4PTBcbiAgICAgKi9cbiAgICB1cGRhdGVJdGVtT3BhY2l0eSh2YWx1ZSwgc2lsZW50PWZhbHNlLCBzdGFydEluZGV4PTApIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaSAgICAgICA9IHN0YXJ0SW5kZXggKyAyLFxuICAgICAgICAgICAgZnJvbnRFbCA9IG1lLmdldEZyb250RWwoKSxcbiAgICAgICAgICAgIGxlbiAgICAgPSBmcm9udEVsLmNuLmxlbmd0aCxcbiAgICAgICAgICAgIHZkb20gICAgPSBtZS52ZG9tO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZyb250RWwuY25baV0uc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSB2ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlSXRlbVBvc2l0aW9ucyhzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZnJvbnRFbCAgICAgICA9IG1lLmdldEZyb250RWwoKSxcbiAgICAgICAgICAgIGl0ZW1Qb3NpdGlvbnMgPSBtZS5jYWxjdWxhdGVJdGVtUG9zaXRpb25zKCksXG4gICAgICAgICAgICBpdGVtU2l6ZSAgICAgID0gbWUuaXRlbVNpemUsXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgPSAyLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICA9IE1hdGgubWluKGZyb250RWwuY24ubGVuZ3RoLCBpdGVtUG9zaXRpb25zLmxlbmd0aCArIDIpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZnJvbnRFbC5jbltpXS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemUgICAgICAgICAgICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIGxlZnQgIDogaXRlbVBvc2l0aW9uc1tpLTJdLmxlZnQgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcCAgIDogaXRlbVBvc2l0aW9uc1tpLTJdLnRvcCAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbVNpemUgICAgICAgICAgICAgICAgKyAncHgnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihmcm9udEVsLmNuW2ldLmNuWzBdLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtU2l6ZSArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggOiBpdGVtU2l6ZSArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSB2ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlT3V0ZXJDaXJjbGUoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbVNpemUgPSBtZS5pdGVtU2l6ZSxcbiAgICAgICAgICAgIG91dGVyQ2lyY2xlICA9IG1lLmdldE91dGVyQ2lyY2xlKCksXG4gICAgICAgICAgICBvdXRlclJhZGl1cyAgPSBtZS5pbm5lclJhZGl1cyArIG1lLm91dGVyUmFkaXVzRGVsdGEsXG4gICAgICAgICAgICBvdXRlclNpemUgICAgPSBtZS5jb2xsYXBzZWQgPyBvdXRlclJhZGl1cyAqIDIgOiAob3V0ZXJSYWRpdXMgKyBpdGVtU2l6ZSkgKiAyLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIG9wdHM7XG5cbiAgICAgICAgaWYgKG1lLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG91dGVyU2l6ZSArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiAnLScgKyBvdXRlclJhZGl1cyArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wICAgOiAnLScgKyBvdXRlclJhZGl1cyArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggOiBvdXRlclNpemUgKyAncHgnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG91dGVyU2l6ZSArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiAnLScgKyAob3V0ZXJSYWRpdXMgKyBpdGVtU2l6ZSkgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcCAgIDogJy0nICsgKG91dGVyUmFkaXVzICsgaXRlbVNpemUpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IG91dGVyU2l6ZSArICdweCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG91dGVyQ2lyY2xlLnN0eWxlLCBvcHRzKTtcblxuICAgICAgICBtZVtzaWxlbnQgPyAnX3Zkb20nIDogJ3Zkb20nXSA9IHZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICB1cGRhdGVUaXRsZShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlubmVyQ2lyY2xlID0gbWUuZ2V0SW5uZXJDaXJjbGUoKSxcbiAgICAgICAgICAgIHZkb20gICAgICAgID0gbWUudmRvbTtcblxuICAgICAgICBpbm5lckNpcmNsZS5jblswXS5odG1sID0gbWUuc3RvcmU/LmdldENvdW50KCkgfHwgMDtcbiAgICAgICAgaW5uZXJDaXJjbGUuY25bMV0uaHRtbCA9IG1lLnRpdGxlO1xuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENpcmNsZSk7XG5cbmV4cG9ydCBkZWZhdWx0IENpcmNsZTtcbiIsImltcG9ydCBDb21wb25lbnQgICAgICAgIGZyb20gJy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGZvcm0gZmllbGRzXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVsYXlhYmxlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsYXlhYmxlID0ge1xuICAgICAgICBmaXJlQ2hhbmdlRXZlbnQgICAgOiB7dHlwZTogJ2RlYm91bmNlJywgdGltZXI6IDEwMDB9LFxuICAgICAgICBmaXJlVXNlckNoYW5nZUV2ZW50OiB7dHlwZTogJ2RlYm91bmNlJywgdGltZXI6IDEwMDB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Jhc2VmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdiYXNlZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybSBncm91cHMgY2FuIGdldCBzZXQgb24gYW55IHBhcmVudCBjb21wb25lbnQgbGV2ZWwuXG4gICAgICAgICAqIEFuIGFsdGVybmF0aXZlIHdheSBmb3IgdXNpbmcgZG90cyBpbiBmaWVsZCBuYW1lcy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybUdyb3VwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBuYW1lXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5lbyBpdHNlbGYgZG9lcyBub3QgbmVlZCBmaWVsZCBuYW1lcyB0byBnZXQgbWFwcGVkIHRvIHRoZSBET00gKGlucHV0IG5vZGVzKSxcbiAgICAgICAgICogZXhjZXB0IGZvciBDaGVja0JveGVzICYgUmFkaW9zIHRvIHdvcmsuIEl0IGNhbiBiZSB1c2VmdWwgZm9yIHRlc3RpbmcgdG9vbHNcbiAgICAgICAgICogJiBhY2Nlc3NpYmlsaXR5IHRob3VnaCwgc28gdGhlIGRlZmF1bHQgZ290IHNldCB0byB0cnVlLlxuICAgICAgICAgKiBGZWVsIGZyZWUgdG8gY2hhbmdlIGl0IHRvIGZhbHNlIHRvIGtlZXAgdGhlIERPTSBtaW5pbWFsLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJOYW1lXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJOYW1lXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2UgcmVuZGVyTmFtZSBpcyBzZXQgdG8gdHJ1ZSwgeW91IGNhbiBvcHRpb25hbGx5IHJlbmRlciB0aGUgY29tYmluYXRpb25cbiAgICAgICAgICogb2YgYWxsIGZvcm1Hcm91cChzKSAmIHRoZSBmaWVsZCBuYW1lIGludG8gdGhlIERPTSA9PiBpbnB1dCBub2RlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlclBhdGg9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyUGF0aDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIgeyp9IHZhbHVlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwcyBvZiBhbGwgcGFyZW50IGxldmVsc1xuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBmb3JtR3JvdXBTdHJpbmc9bnVsbFxuICAgICAqL1xuICAgIGZvcm1Hcm91cFN0cmluZyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwKHMpIGFuZCB0aGUgZmllbGQgbmFtZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBwYXRoPW51bGxcbiAgICAgKi9cbiAgICBwYXRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUucmVuZGVyTmFtZSAmJiBtZS5jaGFuZ2VJbnB1dEVsS2V5KCduYW1lJywgbWUucmVuZGVyUGF0aCA/IG1lLmdldFBhdGgoKSA6IHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm9sZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um9sZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRJbnB1dEVsKCkucm9sZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGZvcm1Hcm91cCBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gcGFyZW50c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRGb3JtR3JvdXAodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGdyb3VwID0gW10sXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICBpZiAobWUuZm9ybUdyb3VwU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuZm9ybUdyb3VwU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgJiYgZ3JvdXAucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICBwYXJlbnQuZm9ybUdyb3VwICYmIGdyb3VwLnVuc2hpZnQocGFyZW50LmZvcm1Hcm91cClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuVmFsdWUgPSBncm91cC5qb2luKCcuJyk7XG5cbiAgICAgICAgbWUuZm9ybUdyb3VwU3RyaW5nID0gcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBpbnB1dEVsIHZkb20gb2JqZWN0IGF0dHJpYnV0ZSBvciByZW1vdmVzIGl0IGluIGNhc2UgaXQgaGFzIG5vIHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfE9iamVjdHxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIGNoYW5nZUlucHV0RWxLZXkoa2V5LCB2YWx1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlIHx8IE5lby5pc0Jvb2xlYW4odmFsdWUpIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBtZS5nZXRJbnB1dEVsKClba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG1lLmdldElucHV0RWwoKVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7Kn0gICAgICB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gICAgICBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKi9cbiAgICBkb0ZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUsIGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBGb3JtQ29udGFpbmVyID0gTmVvLmZvcm0/LkNvbnRhaW5lcixcbiAgICAgICAgICAgIGZvcm1FdmVudCAgICAgPSAnZmllbGQnICsgTmVvLmNhcGl0YWxpemUoZXZlbnROYW1lKSxcbiAgICAgICAgICAgIG9wdHMgICAgICAgICAgPSB7Y29tcG9uZW50OiBtZSwgb2xkVmFsdWUsIHZhbHVlfTtcblxuICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24obWUuZ2V0R3JvdXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9wdHMuZ3JvdXBWYWx1ZSA9IG1lLmdldEdyb3VwVmFsdWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZShldmVudE5hbWUsIG9wdHMpO1xuXG4gICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEZvcm1Db250YWluZXIgJiYgcGFyZW50IGluc3RhbmNlb2YgRm9ybUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZmlyZShmb3JtRXZlbnQsIG9wdHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRvRmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSwgJ2NoYW5nZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBmaXJlVXNlckNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRvRmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSwgJ3VzZXJDaGFuZ2UnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1zIGluIG5lbyBjYW4gYmUgbmVzdGVkLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBwYXJlbnQgd2hpY2ggaXMgYSBmb3JtLkNvbnRhaW5lciBvciBudWxsLlxuICAgICAqIEByZXR1cm5zIHtOZW8uZm9ybS5Db250YWluZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDbG9zZXN0Rm9ybSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgICAgZm9yIChwYXJlbnQgb2YgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKSkge1xuICAgICAgICAgICAgaWYgKEZvcm1Db250YWluZXIgJiYgcGFyZW50IGluc3RhbmNlb2YgRm9ybUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldElucHV0RWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgZmllbGQgZm9ybUdyb3VwKHMpICYgbmFtZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcGF0aDtcblxuICAgICAgICAvLyBmaWVsZHMgY291bGQgaGF2ZSBmb3JtR3JvdXBzLCBidXQgbm8gbmFtZS5cbiAgICAgICAgLy8gcmV0dXJuaW5nIHRoZSBuYW1lc3BhY2UgY2FuIGNvbmZ1c2UgZm9ybS5Db250YWluZXIuYWRqdXN0VHJlZUxlYXZlcygpLFxuICAgICAgICAvLyBzaW5jZSBuYW1lc3BhY2VzIGNvdWxkIGJlIGNvbnNpZGVyZWQgYXMgZmllbGQgaW5zdGFuY2VzLlxuICAgICAgICBpZiAoIW1lLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggPSBtZS5mb3JtR3JvdXAgPyBtZS5mb3JtR3JvdXAuc3BsaXQoJy4nKSA6IFtdO1xuXG4gICAgICAgICAgICBtZS5uYW1lICYmIHBhdGgucHVzaChtZS5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnBhdGggPSBwYXRoLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUucGF0aCkge1xuICAgICAgICAgICAgbWUucGF0aCA9ICdub25lJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLnBhdGggPT09ICdub25lJyA/IG51bGw6IG1lLnBhdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlPy4oZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICBvcHRzICAgICAgICAgID0gey4uLmRhdGEsIGNvbXBvbmVudDogbWUsIHZhbHVlOiBtZS5nZXRWYWx1ZSgpfTtcblxuICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24obWUuZ2V0R3JvdXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9wdHMuZ3JvdXBWYWx1ZSA9IG1lLmdldEdyb3VwVmFsdWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5zdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5maXJlKCdmaWVsZEZvY3VzTGVhdmUnLCBvcHRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGZpZWxkIHRvIGEgbmV3IHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlPW51bGxcbiAgICAgKi9cbiAgICByZXNldCh2YWx1ZT1udWxsKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGNsaWVudC1zaWRlIGZpZWxkIGVycm9yc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PXRydWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNsaWVudC1zaWRlIGVycm9yc1xuICAgICAqL1xuICAgIHZhbGlkYXRlKHNpbGVudD10cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgY2hhbmdlIGV2ZW50IGZpcmVzIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gKiBAZXZlbnQgY2hhbmdlXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKEJhc2UpO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlO1xuIiwiaW1wb3J0IE1vZGVsIGZyb20gJy4vTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5DaXJjbGVNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICovXG5jbGFzcyBDaXJjbGVNb2RlbCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uQ2lyY2xlTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uQ2lyY2xlTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLWNpcmNsZW1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi1jaXJjbGVtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkxlZnQoZGF0YSkge1xuICAgICAgICB0aGlzLm9uTmF2S2V5KGRhdGEsIC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blJpZ2h0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbk5hdktleShkYXRhLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgb25OYXZLZXkoZGF0YSwgc3RlcCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSAgICAgPSBkYXRhLnBhdGhbMF0sXG4gICAgICAgICAgICB2aWV3ICAgICA9IG1lLnZpZXcsXG4gICAgICAgICAgICBzdG9yZSAgICA9IHZpZXcuc3RvcmUsXG4gICAgICAgICAgICBtYXhJbmRleCA9IE1hdGgubWluKHN0b3JlLmdldENvdW50KCksIHZpZXcubWF4SXRlbXMpIC0gMSxcbiAgICAgICAgICAgIGluZGV4LCBpdGVtSWQsIHJlY29yZElkO1xuXG4gICAgICAgIGlmIChpdGVtLmNscy5pbmNsdWRlcygnbmVvLWNpcmNsZS1pdGVtJykpIHtcbiAgICAgICAgICAgIHJlY29yZElkID0gcGFyc2VJbnQodmlldy5nZXRJdGVtUmVjb3JkSWQoaXRlbS5pZCkpO1xuICAgICAgICAgICAgaW5kZXggICAgPSBzdG9yZS5pbmRleE9mKHJlY29yZElkKSArIHN0ZXA7XG5cbiAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkgICAgICAgIHtpbmRleCA9IG1heEluZGV4O31cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtpbmRleCA9IDA7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbUlkID0gdmlldy5nZXRJdGVtSWQoaW5kZXgpO1xuXG4gICAgICAgIG1lLnNlbGVjdChpdGVtSWQpO1xuICAgICAgICB2aWV3LmZvY3VzKGl0ZW1JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBzdXBlci5yZWdpc3Rlcihjb21wb25lbnQpO1xuXG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgPSBtZS5pZCxcbiAgICAgICAgICAgIHZpZXcgPSBtZS52aWV3O1xuXG4gICAgICAgIHZpZXcua2V5cz8uX2tleXMucHVzaChcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkxlZnQnICAsa2V5OiAnRG93bicgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICxrZXk6ICdMZWZ0JyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgLGtleTogJ1JpZ2h0JyAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAsa2V5OiAnVXAnICAgICxzY29wZTogaWR9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgID0gbWUuaWQsXG4gICAgICAgICAgICB2aWV3ID0gbWUudmlldztcblxuICAgICAgICB2aWV3LmtleXM/LnJlbW92ZUtleXMoW1xuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICxrZXk6ICdEb3duJyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgLGtleTogJ0xlZnQnICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAsa2V5OiAnUmlnaHQnICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICxrZXk6ICdVcCcgICAgLHNjb3BlOiBpZH1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgc3VwZXIudW5yZWdpc3RlcigpO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ2lyY2xlTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBDaXJjbGVNb2RlbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==