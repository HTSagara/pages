"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_container_Viewport_mjs-src_model_Component_mjs"],{

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport']
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName: this.appName,
            cls    : ['neo-body-viewport']
        })
    }
}

Neo.applyClassConfig(Viewport);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Viewport);


/***/ }),

/***/ "./src/model/Component.mjs":
/*!*********************************!*\
  !*** ./src/model/Component.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");





const dataVariableRegex = /data((?!(\.[a-z_]\w*\(\)))\.[a-z_]\w*)+/gi,
      variableNameRegex = /^\w*/;

/**
 * An optional component (view) model for adding bindings to configs
 * @class Neo.model.Component
 * @extends Neo.core.Base
 */
class Component extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.model.Component'
         * @protected
         */
        className: 'Neo.model.Component',
        /**
         * @member {String} ntype='component-model'
         * @protected
         */
        ntype: 'component-model',
        /**
         * @member {Object|null} bindings_=null
         * @protected
         */
        bindings_: null,
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Object|null} data_=null
         */
        data_: null,
        /**
         * @member {Neo.model.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object|null} stores_=null
         */
        stores_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        Neo.currentWorker.isUsingViewModels = true;
        super.construct(config);
        this.bindings = {};
    }

    /**
     * Adds a given key/value combination on this model level.
     * The method is used by setData() & setDataAtSameLevel()
     * in case the  data property does not exist yet.
     * @param {String} key
     * @param {*} value
     * @private
     */
    addDataProperty(key, value) {
        let me = this,
            data, scope;

        Neo.ns(key, true, me.data);

        data  = me.getDataScope(key);
        scope = data.scope;

        scope[data.key] = value;

        me.createDataProperties(me.data, 'data');
    }

    /**
     * Triggered after the data config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        value && this.createDataProperties(value, 'data');
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return value || {};
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.model.Component|null} value
     * @param {Neo.model.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value ? value : this.getParent();
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        let controller = this.component.getController();

        value && Object.entries(value).forEach(([key, storeValue]) => {
            controller?.parseConfig(storeValue);
            value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(storeValue);
        });

        return value;
    }

    /**
     * @param {Function} formatter
     * @param {Object} [data=null] optionally pass this.getHierarchyData() for performance reasons
     * @returns {String}
     */
    callFormatter(formatter, data=null) {
        if (!data) {
            data = this.getHierarchyData();
        }

        return formatter.call(this, data);
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} key
     * @param {String} value
     * @param {String} formatter
     */
    createBinding(componentId, key, value, formatter) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            bindingScope, parentModel;

        if (scope?.hasOwnProperty(keyLeaf)) {
            bindingScope = Neo.ns(`${key}.${componentId}`, true, me.bindings);
            bindingScope[value] = formatter;
        } else {
            parentModel = me.getParent();

            if (parentModel) {
                parentModel.createBinding(componentId, key, value, formatter);
            } else {
                console.error('No model.Component found with the specified data property', componentId, keyLeaf, value);
            }
        }
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} formatter
     * @param {String} value
     */
    createBindingByFormatter(componentId, formatter, value) {
        let me            = this,
            formatterVars = me.getFormatterVariables(formatter);

        formatterVars.forEach(key => {
            me.createBinding(componentId, key, value, formatter);
        });
    }

    /**
     * @param {Neo.component.Base} component
     */
    createBindings(component) {
        Object.entries(component.bind).forEach(([key, value]) => {
            if (Neo.isObject(value)) {
                value = value.value;
            }

            if (!this.isStoreValue(value)) {
                this.createBindingByFormatter(component.id, value, key);
            }
        });
    }

    /**
     * @param {Object} config
     * @param {String} path
     */
    createDataProperties(config, path) {
        let me   = this,
            root = Neo.ns(path, false, me),
            descriptor, keyValue, newPath;

        Object.entries(config).forEach(([key, value]) => {
            if (!key.startsWith('_')) {
                descriptor = Object.getOwnPropertyDescriptor(root, key);
                newPath    = `${path}.${key}`

                if (!(typeof descriptor === 'object' && typeof descriptor.set === 'function')) {
                    keyValue = config[key];
                    me.createDataProperty(key, newPath, root);
                    root[key] = keyValue;
                }

                if (Neo.isObject(value)) {
                    me.createDataProperties(config[key], newPath);
                }
            }
        });
    }

    /**
     * @param {String} key
     * @param {String} path
     * @param {Object} [root=this.data]
     */
    createDataProperty(key, path, root=this.data) {
        let me = this;

        if (path?.startsWith('data.')) {
            path = path.substring(5);
        }

        Object.defineProperty(root, key, {
            get() {
                return root['_' + key];
            },

            set(value) {
                let _key     = `_${key}`,
                    oldValue = root[_key];

                if (!root[_key]) {
                    Object.defineProperty(root, _key, {
                        enumerable: false,
                        value,
                        writable  : true
                    });
                } else {
                    root[_key] = value;
                }

                if (!Neo.isEqual(value, oldValue)) {
                    me.onDataPropertyChange(path ? path : key, value, oldValue);
                }
            }
        });
    }

    /**
     * Convenience shortcut
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        return this.component.getController(ntype);
    }

    /**
     * Access the closest data property inside the VM parent chain.
     * @param {String} key
     * @param {Neo.model.Component} [originModel=this] for internal usage only
     * @returns {*} value
     */
    getData(key, originModel=this) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            parentModel;

        if (scope?.hasOwnProperty(keyLeaf)) {
            return scope[keyLeaf];
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`data property '${key}' does not exist.`, originModel);
        }

        return parentModel.getData(key, originModel);
    }

    /**
     * Helper method to get the scope for a nested data property via Neo.ns() if needed.
     *
     * Example: passing the value 'foo.bar.baz' will return the bar object as the scope
     * and 'baz' as the key.
     * @param key
     * @returns {Object}
     */
    getDataScope(key) {
        let me      = this,
            keyLeaf = key,
            data    = me.data;

        if (key.includes('.')) {
            key     = key.split('.');
            keyLeaf = key.pop();
            data    = Neo.ns(key.join('.'), false, data);
        }

        return {
            key  : keyLeaf,
            scope: data
        };
    }

    /**
     * Extracts data variables from a given formatter string
     * @param {String} value
     */
    getFormatterVariables(value) {
        if (Neo.isFunction(value)) {
            value = value.toString();
        }

        if (Neo.config.environment === 'dist/production') {
            // see: https://github.com/neomjs/neo/issues/2371
            // inside dist/prod the formatter:
            // data => DateUtil.convertToyyyymmdd(data.currentDate)
            // will get minified to:
            // e=>s.Z.convertToyyyymmdd(e.currentDate)
            // the new strategy: find the first variable name => "e"
            // replace it with "data":
            // data=>s.Z.convertToyyyymmdd(data.currentDate)
            // from there we can use the dev mode regex again.

            let dataName       = value.match(variableNameRegex)[0],
                variableRegExp = new RegExp(`(^|[^\\w.])(${dataName})(?!\\w)`, 'g');

            value = value.replace(variableRegExp, '$1data');
        }

        let dataVars = value.match(dataVariableRegex) || [],
            result   = [];

        dataVars.forEach(variable => {
            // remove the "data." at the start
            variable = variable.substr(5);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(result, variable);
        });

        result.sort();

        return result;
    }

    /**
     * Returns the merged data
     * @param {Object} data=this.getPlainData()
     * @returns {Object} data
     */
    getHierarchyData(data=this.getPlainData()) {
        let me     = this,
            parent = me.getParent();

        if (parent) {
            return {
                ...parent.getHierarchyData(data),
                ...me.getPlainData()
            };
        }

        return me.getPlainData();
    }

    /**
     * Returns a plain version of this.data.
     * This excludes the property getters & setters.
     * @param {Object} [data=this.data]
     * @returns {Object}
     */
    getPlainData(data=this.data) {
        let plainData = {};

        Object.entries(data).forEach(([key, value]) => {
            if (Neo.typeOf(value) === 'Object') {
                plainData[key] = this.getPlainData(value);
            } else {
                plainData[key] = value;
            }
        });

        return plainData;
    }

    /**
     * Get the closest model inside the components parent tree
     * @returns {Neo.model.Component|null}
     */
    getParent() {
        let me = this,
            parentComponent, parentId;

        if (me.parent) {
            return me.parent;
        }

        parentId        = me.component.parentId;
        parentComponent = parentId && Neo.getComponent(parentId);

        return parentComponent?.getModel() || null;
    }

    /**
     * Access the closest store inside the VM parent chain.
     * @param {String} key
     * @param {Neo.model.Component} [originModel=this] for internal usage only
     * @returns {*} value
     */
    getStore(key, originModel=this) {
        let me     = this,
            stores = me.stores,
            parentModel;

        if (stores?.hasOwnProperty(key)) {
            return stores[key];
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`store '${key}' not found inside this model or parents.`, originModel);
        }

        return parentModel.getStore(key, originModel);
    }

    /**
     * Internal method to avoid code redundancy.
     * Use setData() or setDataAtSameLevel() instead.
     *
     * Passing an originModel param will try to set each key on the closest property match
     * inside the parent model chain => setData()
     * Not passing it will set all values on the model where the method gets called => setDataAtSameLevel()
     * @param {Object|String} key
     * @param {*} value
     * @param {Neo.model.Component} [originModel]
     * @protected
     */
    internalSetData(key, value, originModel) {
        let me = this,
            data, keyLeaf, parentModel, scope;

        if (Neo.isObject(key)) {
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originModel);
            });
        } else {
            data    = me.getDataScope(key);
            scope   = data.scope;
            keyLeaf = data.key;

            if (scope?.hasOwnProperty(keyLeaf)) {
                scope[keyLeaf] = value;
            } else {
                if (originModel) {
                    parentModel = me.getParent();

                    if (parentModel) {
                        parentModel.internalSetData(key, value, originModel);
                    } else {
                        originModel.addDataProperty(key, value);
                    }
                } else {
                    me.addDataProperty(key, value);
                }
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return Neo.isString(value) && value.startsWith('stores.');
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(config, preventOriginalConfig) {
        if (config.data) {
            config.data = Neo.merge(Neo.clone(this.constructor.config.data, true) || {}, config.data);
        }

        return super.mergeConfig(config, preventOriginalConfig);
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        let me      = this,
            binding = me.bindings && Neo.ns(key, false, me.bindings),
            component, config, hierarchyData, model;

        if (binding) {
            hierarchyData = {};

            Object.entries(binding).forEach(([componentId, configObject]) => {
                component = Neo.getComponent(componentId) || Neo.get(componentId); // timing issue: the cmp might not be registered inside manager.Component yet
                config    = {};
                model     = component.getModel();

                if (!hierarchyData[model.id]) {
                    hierarchyData[model.id] = model.getHierarchyData();
                }

                Object.entries(configObject).forEach(([configField, formatter]) => {
                    // we can not call me.callFormatter(), since a data property inside a parent model
                    // could have changed which is relying on data properties inside a closer model
                    config[configField] = model.callFormatter(formatter, hierarchyData[model.id]);
                });

                component?.set(config);
            });
        }

        me.fire('dataPropertyChange', {
            key,
            id: me.id,
            oldValue,
            value
        });
    }

    /**
     * This method will assign binding values at the earliest possible point inside the component lifecycle.
     * It can not store bindings though, since child component ids most likely do not exist yet.
     * @param {Neo.component.Base} [component=this.component]
     */
    parseConfig(component=this.component) {
        let me     = this,
            config = {};

        if (component.bind) {
            me.createBindings(component);

            Object.entries(component.bind).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    value.key = me.getFormatterVariables(value.value)[0];
                    value = value.value;
                }

                if (me.isStoreValue(value)) {
                    me.resolveStore(component, key, value.substring(7)); // remove the "stores." at the start
                } else {
                    config[key] = me.callFormatter(value);
                }
            });

            component.set(config);
        }
    }

    /**
     * Removes all bindings for a given component id inside this model
     * as well as inside all parent models.
     * @param {String} componentId
     */
    removeBindings(componentId) {
        let me          = this,
            parentModel = me.getParent();

        Object.entries(me.bindings).forEach(([dataProperty, binding]) => {
            delete binding[componentId];
        });

        parentModel?.removeBindings(componentId);
    }

    /**
     * @param {Neo.component.Base} component
     * @param {String} configName
     * @param {String} storeName
     */
    resolveStore(component, configName, storeName) {
        component[configName] = this.getStore(storeName);
    }

    /**
     * The method will assign all values to the closest model where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     * @param {Object|String} key
     * @param {*} value
     */
    setData(key, value) {
        this.internalSetData(key, value, this);
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent models.
     * @param {Object|String} key
     * @param {*} value
     */
    setDataAtSameLevel(key, value) {
        this.internalSetData(key, value);
    }
}

Neo.applyClassConfig(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb250YWluZXJfVmlld3BvcnRfbWpzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBUztBQUNoQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFFBQVEsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEdUI7QUFDTztBQUNOO0FBQ0s7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBSTtBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNB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QUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekUsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsU0FBUyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbW9kZWwvQ29tcG9uZW50Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5WaWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5WaWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd2aWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd2aWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgJ25lby1ib2R5LXZpZXdwb3J0JyB0byB0aGUgZG9jdW1lbnQuYm9keVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhcHBseUJvZHlDbHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlCb2R5Q2xzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzdW1pbmcgdGhhdCBhIFZpZXdwb3J0IGlzIHRoZSB0b3AgbGV2ZWwgdmlldyBvZiB5b3VyIGFwcCwgYW5kIHlvdSB3YW50IHRvIG1vdW50IGl0IHJpZ2h0IGF3YXkuXG4gICAgICAgICAqIENvdWxkIGJlIHdpdGhvdXQgYW55IGl0ZW1zLiBVc2UgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdmlld3BvcnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdmlld3BvcnQnXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIHRoaXMuYXBwbHlCb2R5Q2xzICYmIE5lby5tYWluLkRvbUFjY2Vzcy5hcHBseUJvZHlDbHMoe1xuICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5hcHBOYW1lLFxuICAgICAgICAgICAgY2xzICAgIDogWyduZW8tYm9keS12aWV3cG9ydCddXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhWaWV3cG9ydCk7XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0O1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG5jb25zdCBkYXRhVmFyaWFibGVSZWdleCA9IC9kYXRhKCg/IShcXC5bYS16X11cXHcqXFwoXFwpKSlcXC5bYS16X11cXHcqKSsvZ2ksXG4gICAgICB2YXJpYWJsZU5hbWVSZWdleCA9IC9eXFx3Ki87XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgY29tcG9uZW50ICh2aWV3KSBtb2RlbCBmb3IgYWRkaW5nIGJpbmRpbmdzIHRvIGNvbmZpZ3NcbiAqIEBjbGFzcyBOZW8ubW9kZWwuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tb2RlbC5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tb2RlbC5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LW1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1tb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gYmluZGluZ3NfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZGluZ3NfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkYXRhXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5tb2RlbC5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHN0b3Jlc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVzXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLmlzVXNpbmdWaWV3TW9kZWxzID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZ2l2ZW4ga2V5L3ZhbHVlIGNvbWJpbmF0aW9uIG9uIHRoaXMgbW9kZWwgbGV2ZWwuXG4gICAgICogVGhlIG1ldGhvZCBpcyB1c2VkIGJ5IHNldERhdGEoKSAmIHNldERhdGFBdFNhbWVMZXZlbCgpXG4gICAgICogaW4gY2FzZSB0aGUgIGRhdGEgcHJvcGVydHkgZG9lcyBub3QgZXhpc3QgeWV0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSwgc2NvcGU7XG5cbiAgICAgICAgTmVvLm5zKGtleSwgdHJ1ZSwgbWUuZGF0YSk7XG5cbiAgICAgICAgZGF0YSAgPSBtZS5nZXREYXRhU2NvcGUoa2V5KTtcbiAgICAgICAgc2NvcGUgPSBkYXRhLnNjb3BlO1xuXG4gICAgICAgIHNjb3BlW2RhdGEua2V5XSA9IHZhbHVlO1xuXG4gICAgICAgIG1lLmNyZWF0ZURhdGFQcm9wZXJ0aWVzKG1lLmRhdGEsICdkYXRhJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXRhIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREYXRhKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLmNyZWF0ZURhdGFQcm9wZXJ0aWVzKHZhbHVlLCAnZGF0YScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZGF0YSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RGF0YSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5tb2RlbC5Db21wb25lbnR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5tb2RlbC5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGFyZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSA6IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmVzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmVzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY29udHJvbGxlciA9IHRoaXMuY29tcG9uZW50LmdldENvbnRyb2xsZXIoKTtcblxuICAgICAgICB2YWx1ZSAmJiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgc3RvcmVWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXI/LnBhcnNlQ29uZmlnKHN0b3JlVmFsdWUpO1xuICAgICAgICAgICAgdmFsdWVba2V5XSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZShzdG9yZVZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZvcm1hdHRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YT1udWxsXSBvcHRpb25hbGx5IHBhc3MgdGhpcy5nZXRIaWVyYXJjaHlEYXRhKCkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNhbGxGb3JtYXR0ZXIoZm9ybWF0dGVyLCBkYXRhPW51bGwpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5nZXRIaWVyYXJjaHlEYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmNhbGwodGhpcywgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGJpbmRpbmcgaW4gY2FzZSBhIG1hdGNoaW5nIGRhdGEgcHJvcGVydHkgZG9lcyBleGlzdC5cbiAgICAgKiBPdGhlcndpc2UgaXQgd2lsbCB1c2UgdGhlIGNsb3Nlc3QgbW9kZWwgd2l0aCBhIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0dGVyXG4gICAgICovXG4gICAgY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwga2V5LCB2YWx1ZSwgZm9ybWF0dGVyKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgICAgPSBtZS5nZXREYXRhU2NvcGUoa2V5KSxcbiAgICAgICAgICAgIHNjb3BlICAgPSBkYXRhLnNjb3BlLFxuICAgICAgICAgICAga2V5TGVhZiA9IGRhdGEua2V5LFxuICAgICAgICAgICAgYmluZGluZ1Njb3BlLCBwYXJlbnRNb2RlbDtcblxuICAgICAgICBpZiAoc2NvcGU/Lmhhc093blByb3BlcnR5KGtleUxlYWYpKSB7XG4gICAgICAgICAgICBiaW5kaW5nU2NvcGUgPSBOZW8ubnMoYCR7a2V5fS4ke2NvbXBvbmVudElkfWAsIHRydWUsIG1lLmJpbmRpbmdzKTtcbiAgICAgICAgICAgIGJpbmRpbmdTY29wZVt2YWx1ZV0gPSBmb3JtYXR0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRNb2RlbC5jcmVhdGVCaW5kaW5nKGNvbXBvbmVudElkLCBrZXksIHZhbHVlLCBmb3JtYXR0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBtb2RlbC5Db21wb25lbnQgZm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgcHJvcGVydHknLCBjb21wb25lbnRJZCwga2V5TGVhZiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGJpbmRpbmcgaW4gY2FzZSBhIG1hdGNoaW5nIGRhdGEgcHJvcGVydHkgZG9lcyBleGlzdC5cbiAgICAgKiBPdGhlcndpc2UgaXQgd2lsbCB1c2UgdGhlIGNsb3Nlc3QgbW9kZWwgd2l0aCBhIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXR0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5nQnlGb3JtYXR0ZXIoY29tcG9uZW50SWQsIGZvcm1hdHRlciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZm9ybWF0dGVyVmFycyA9IG1lLmdldEZvcm1hdHRlclZhcmlhYmxlcyhmb3JtYXR0ZXIpO1xuXG4gICAgICAgIGZvcm1hdHRlclZhcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbWUuY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwga2V5LCB2YWx1ZSwgZm9ybWF0dGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmdzKGNvbXBvbmVudCkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhjb21wb25lbnQuYmluZCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1N0b3JlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCaW5kaW5nQnlGb3JtYXR0ZXIoY29tcG9uZW50LmlkLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICovXG4gICAgY3JlYXRlRGF0YVByb3BlcnRpZXMoY29uZmlnLCBwYXRoKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHJvb3QgPSBOZW8ubnMocGF0aCwgZmFsc2UsIG1lKSxcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsIGtleVZhbHVlLCBuZXdQYXRoO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWtleS5zdGFydHNXaXRoKCdfJykpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyb290LCBrZXkpO1xuICAgICAgICAgICAgICAgIG5ld1BhdGggICAgPSBgJHtwYXRofS4ke2tleX1gXG5cbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlWYWx1ZSA9IGNvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVEYXRhUHJvcGVydHkoa2V5LCBuZXdQYXRoLCByb290KTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFtrZXldID0ga2V5VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlRGF0YVByb3BlcnRpZXMoY29uZmlnW2tleV0sIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtyb290PXRoaXMuZGF0YV1cbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhUHJvcGVydHkoa2V5LCBwYXRoLCByb290PXRoaXMuZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChwYXRoPy5zdGFydHNXaXRoKCdkYXRhLicpKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoNSk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocm9vdCwga2V5LCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RbJ18nICsga2V5XTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBfa2V5ICAgICA9IGBfJHtrZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByb290W19rZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyb290W19rZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb290LCBfa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGUgIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb290W19rZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm9uRGF0YVByb3BlcnR5Q2hhbmdlKHBhdGggPyBwYXRoIDoga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyKG50eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRDb250cm9sbGVyKG50eXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdGhlIGNsb3Nlc3QgZGF0YSBwcm9wZXJ0eSBpbnNpZGUgdGhlIFZNIHBhcmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtOZW8ubW9kZWwuQ29tcG9uZW50fSBbb3JpZ2luTW9kZWw9dGhpc10gZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXREYXRhKGtleSwgb3JpZ2luTW9kZWw9dGhpcykge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhICAgID0gbWUuZ2V0RGF0YVNjb3BlKGtleSksXG4gICAgICAgICAgICBzY29wZSAgID0gZGF0YS5zY29wZSxcbiAgICAgICAgICAgIGtleUxlYWYgPSBkYXRhLmtleSxcbiAgICAgICAgICAgIHBhcmVudE1vZGVsO1xuXG4gICAgICAgIGlmIChzY29wZT8uaGFzT3duUHJvcGVydHkoa2V5TGVhZikpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZVtrZXlMZWFmXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE1vZGVsID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKCFwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgZGF0YSBwcm9wZXJ0eSAnJHtrZXl9JyBkb2VzIG5vdCBleGlzdC5gLCBvcmlnaW5Nb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50TW9kZWwuZ2V0RGF0YShrZXksIG9yaWdpbk1vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGdldCB0aGUgc2NvcGUgZm9yIGEgbmVzdGVkIGRhdGEgcHJvcGVydHkgdmlhIE5lby5ucygpIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6IHBhc3NpbmcgdGhlIHZhbHVlICdmb28uYmFyLmJheicgd2lsbCByZXR1cm4gdGhlIGJhciBvYmplY3QgYXMgdGhlIHNjb3BlXG4gICAgICogYW5kICdiYXonIGFzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RGF0YVNjb3BlKGtleSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBrZXlMZWFmID0ga2V5LFxuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmRhdGE7XG5cbiAgICAgICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBrZXkgICAgID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBrZXlMZWFmID0ga2V5LnBvcCgpO1xuICAgICAgICAgICAgZGF0YSAgICA9IE5lby5ucyhrZXkuam9pbignLicpLCBmYWxzZSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5ICA6IGtleUxlYWYsXG4gICAgICAgICAgICBzY29wZTogZGF0YVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGRhdGEgdmFyaWFibGVzIGZyb20gYSBnaXZlbiBmb3JtYXR0ZXIgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0dGVyVmFyaWFibGVzKHZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uY29uZmlnLmVudmlyb25tZW50ID09PSAnZGlzdC9wcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjM3MVxuICAgICAgICAgICAgLy8gaW5zaWRlIGRpc3QvcHJvZCB0aGUgZm9ybWF0dGVyOlxuICAgICAgICAgICAgLy8gZGF0YSA9PiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRhLmN1cnJlbnREYXRlKVxuICAgICAgICAgICAgLy8gd2lsbCBnZXQgbWluaWZpZWQgdG86XG4gICAgICAgICAgICAvLyBlPT5zLlouY29udmVydFRveXl5eW1tZGQoZS5jdXJyZW50RGF0ZSlcbiAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RyYXRlZ3k6IGZpbmQgdGhlIGZpcnN0IHZhcmlhYmxlIG5hbWUgPT4gXCJlXCJcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgaXQgd2l0aCBcImRhdGFcIjpcbiAgICAgICAgICAgIC8vIGRhdGE9PnMuWi5jb252ZXJ0VG95eXl5bW1kZChkYXRhLmN1cnJlbnREYXRlKVxuICAgICAgICAgICAgLy8gZnJvbSB0aGVyZSB3ZSBjYW4gdXNlIHRoZSBkZXYgbW9kZSByZWdleCBhZ2Fpbi5cblxuICAgICAgICAgICAgbGV0IGRhdGFOYW1lICAgICAgID0gdmFsdWUubWF0Y2godmFyaWFibGVOYW1lUmVnZXgpWzBdLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlUmVnRXhwID0gbmV3IFJlZ0V4cChgKF58W15cXFxcdy5dKSgke2RhdGFOYW1lfSkoPyFcXFxcdylgLCAnZycpO1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UodmFyaWFibGVSZWdFeHAsICckMWRhdGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhVmFycyA9IHZhbHVlLm1hdGNoKGRhdGFWYXJpYWJsZVJlZ2V4KSB8fCBbXSxcbiAgICAgICAgICAgIHJlc3VsdCAgID0gW107XG5cbiAgICAgICAgZGF0YVZhcnMuZm9yRWFjaCh2YXJpYWJsZSA9PiB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIFwiZGF0YS5cIiBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUuc3Vic3RyKDUpO1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKHJlc3VsdCwgdmFyaWFibGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHQuc29ydCgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVyZ2VkIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YT10aGlzLmdldFBsYWluRGF0YSgpXG4gICAgICogQHJldHVybnMge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGdldEhpZXJhcmNoeURhdGEoZGF0YT10aGlzLmdldFBsYWluRGF0YSgpKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcGFyZW50ID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5wYXJlbnQuZ2V0SGllcmFyY2h5RGF0YShkYXRhKSxcbiAgICAgICAgICAgICAgICAuLi5tZS5nZXRQbGFpbkRhdGEoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5nZXRQbGFpbkRhdGEoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGxhaW4gdmVyc2lvbiBvZiB0aGlzLmRhdGEuXG4gICAgICogVGhpcyBleGNsdWRlcyB0aGUgcHJvcGVydHkgZ2V0dGVycyAmIHNldHRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhPXRoaXMuZGF0YV1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFBsYWluRGF0YShkYXRhPXRoaXMuZGF0YSkge1xuICAgICAgICBsZXQgcGxhaW5EYXRhID0ge307XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcGxhaW5EYXRhW2tleV0gPSB0aGlzLmdldFBsYWluRGF0YSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWluRGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwbGFpbkRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IG1vZGVsIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8ubW9kZWwuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRJZDtcblxuICAgICAgICBpZiAobWUucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50SWQgICAgICAgID0gbWUuY29tcG9uZW50LnBhcmVudElkO1xuICAgICAgICBwYXJlbnRDb21wb25lbnQgPSBwYXJlbnRJZCAmJiBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkKTtcblxuICAgICAgICByZXR1cm4gcGFyZW50Q29tcG9uZW50Py5nZXRNb2RlbCgpIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjZXNzIHRoZSBjbG9zZXN0IHN0b3JlIGluc2lkZSB0aGUgVk0gcGFyZW50IGNoYWluLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge05lby5tb2RlbC5Db21wb25lbnR9IFtvcmlnaW5Nb2RlbD10aGlzXSBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAqIEByZXR1cm5zIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldFN0b3JlKGtleSwgb3JpZ2luTW9kZWw9dGhpcykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0b3JlcyA9IG1lLnN0b3JlcyxcbiAgICAgICAgICAgIHBhcmVudE1vZGVsO1xuXG4gICAgICAgIGlmIChzdG9yZXM/Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZXNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE1vZGVsID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKCFwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgc3RvcmUgJyR7a2V5fScgbm90IGZvdW5kIGluc2lkZSB0aGlzIG1vZGVsIG9yIHBhcmVudHMuYCwgb3JpZ2luTW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudE1vZGVsLmdldFN0b3JlKGtleSwgb3JpZ2luTW9kZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBhdm9pZCBjb2RlIHJlZHVuZGFuY3kuXG4gICAgICogVXNlIHNldERhdGEoKSBvciBzZXREYXRhQXRTYW1lTGV2ZWwoKSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogUGFzc2luZyBhbiBvcmlnaW5Nb2RlbCBwYXJhbSB3aWxsIHRyeSB0byBzZXQgZWFjaCBrZXkgb24gdGhlIGNsb3Nlc3QgcHJvcGVydHkgbWF0Y2hcbiAgICAgKiBpbnNpZGUgdGhlIHBhcmVudCBtb2RlbCBjaGFpbiA9PiBzZXREYXRhKClcbiAgICAgKiBOb3QgcGFzc2luZyBpdCB3aWxsIHNldCBhbGwgdmFsdWVzIG9uIHRoZSBtb2RlbCB3aGVyZSB0aGUgbWV0aG9kIGdldHMgY2FsbGVkID0+IHNldERhdGFBdFNhbWVMZXZlbCgpXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8ubW9kZWwuQ29tcG9uZW50fSBbb3JpZ2luTW9kZWxdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCBvcmlnaW5Nb2RlbCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSwga2V5TGVhZiwgcGFyZW50TW9kZWwsIHNjb3BlO1xuXG4gICAgICAgIGlmIChOZW8uaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoa2V5KS5mb3JFYWNoKChbZGF0YUtleSwgZGF0YVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmludGVybmFsU2V0RGF0YShkYXRhS2V5LCBkYXRhVmFsdWUsIG9yaWdpbk1vZGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmdldERhdGFTY29wZShrZXkpO1xuICAgICAgICAgICAgc2NvcGUgICA9IGRhdGEuc2NvcGU7XG4gICAgICAgICAgICBrZXlMZWFmID0gZGF0YS5rZXk7XG5cbiAgICAgICAgICAgIGlmIChzY29wZT8uaGFzT3duUHJvcGVydHkoa2V5TGVhZikpIHtcbiAgICAgICAgICAgICAgICBzY29wZVtrZXlMZWFmXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE1vZGVsLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCBvcmlnaW5Nb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5Nb2RlbC5hZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5hZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY29udmVuaWVuY2UgbWV0aG9kIHRvIGNoZWNrIGlmIGEgYmluZGluZyB2YWx1ZSBpcyBzdXBwb3NlZCB0byBtYXRjaCBhIHN0b3JlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdG9yZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLnN0YXJ0c1dpdGgoJ3N0b3Jlcy4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIG9yZGVyIGNvbmZpZ3MgYXJlIGFwcGxpZWQgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gTmVvLm1lcmdlKE5lby5jbG9uZSh0aGlzLmNvbnN0cnVjdG9yLmNvbmZpZy5kYXRhLCB0cnVlKSB8fCB7fSwgY29uZmlnLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLm1lcmdlQ29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkRhdGFQcm9wZXJ0eUNoYW5nZShrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBiaW5kaW5nID0gbWUuYmluZGluZ3MgJiYgTmVvLm5zKGtleSwgZmFsc2UsIG1lLmJpbmRpbmdzKSxcbiAgICAgICAgICAgIGNvbXBvbmVudCwgY29uZmlnLCBoaWVyYXJjaHlEYXRhLCBtb2RlbDtcblxuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgaGllcmFyY2h5RGF0YSA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhiaW5kaW5nKS5mb3JFYWNoKChbY29tcG9uZW50SWQsIGNvbmZpZ09iamVjdF0pID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGNvbXBvbmVudElkKSB8fCBOZW8uZ2V0KGNvbXBvbmVudElkKTsgLy8gdGltaW5nIGlzc3VlOiB0aGUgY21wIG1pZ2h0IG5vdCBiZSByZWdpc3RlcmVkIGluc2lkZSBtYW5hZ2VyLkNvbXBvbmVudCB5ZXRcbiAgICAgICAgICAgICAgICBjb25maWcgICAgPSB7fTtcbiAgICAgICAgICAgICAgICBtb2RlbCAgICAgPSBjb21wb25lbnQuZ2V0TW9kZWwoKTtcblxuICAgICAgICAgICAgICAgIGlmICghaGllcmFyY2h5RGF0YVttb2RlbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGllcmFyY2h5RGF0YVttb2RlbC5pZF0gPSBtb2RlbC5nZXRIaWVyYXJjaHlEYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnT2JqZWN0KS5mb3JFYWNoKChbY29uZmlnRmllbGQsIGZvcm1hdHRlcl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIG5vdCBjYWxsIG1lLmNhbGxGb3JtYXR0ZXIoKSwgc2luY2UgYSBkYXRhIHByb3BlcnR5IGluc2lkZSBhIHBhcmVudCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBoYXZlIGNoYW5nZWQgd2hpY2ggaXMgcmVseWluZyBvbiBkYXRhIHByb3BlcnRpZXMgaW5zaWRlIGEgY2xvc2VyIG1vZGVsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tjb25maWdGaWVsZF0gPSBtb2RlbC5jYWxsRm9ybWF0dGVyKGZvcm1hdHRlciwgaGllcmFyY2h5RGF0YVttb2RlbC5pZF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Py5zZXQoY29uZmlnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZSgnZGF0YVByb3BlcnR5Q2hhbmdlJywge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgaWQ6IG1lLmlkLFxuICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFzc2lnbiBiaW5kaW5nIHZhbHVlcyBhdCB0aGUgZWFybGllc3QgcG9zc2libGUgcG9pbnQgaW5zaWRlIHRoZSBjb21wb25lbnQgbGlmZWN5Y2xlLlxuICAgICAqIEl0IGNhbiBub3Qgc3RvcmUgYmluZGluZ3MgdGhvdWdoLCBzaW5jZSBjaGlsZCBjb21wb25lbnQgaWRzIG1vc3QgbGlrZWx5IGRvIG5vdCBleGlzdCB5ZXQuXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IFtjb21wb25lbnQ9dGhpcy5jb21wb25lbnRdXG4gICAgICovXG4gICAgcGFyc2VDb25maWcoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5iaW5kKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVCaW5kaW5ncyhjb21wb25lbnQpO1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb21wb25lbnQuYmluZCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUua2V5ID0gbWUuZ2V0Rm9ybWF0dGVyVmFyaWFibGVzKHZhbHVlLnZhbHVlKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWUuaXNTdG9yZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5yZXNvbHZlU3RvcmUoY29tcG9uZW50LCBrZXksIHZhbHVlLnN1YnN0cmluZyg3KSk7IC8vIHJlbW92ZSB0aGUgXCJzdG9yZXMuXCIgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2tleV0gPSBtZS5jYWxsRm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29tcG9uZW50LnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgYmluZGluZ3MgZm9yIGEgZ2l2ZW4gY29tcG9uZW50IGlkIGluc2lkZSB0aGlzIG1vZGVsXG4gICAgICogYXMgd2VsbCBhcyBpbnNpZGUgYWxsIHBhcmVudCBtb2RlbHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICovXG4gICAgcmVtb3ZlQmluZGluZ3MoY29tcG9uZW50SWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudE1vZGVsID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWUuYmluZGluZ3MpLmZvckVhY2goKFtkYXRhUHJvcGVydHksIGJpbmRpbmddKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgYmluZGluZ1tjb21wb25lbnRJZF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBhcmVudE1vZGVsPy5yZW1vdmVCaW5kaW5ncyhjb21wb25lbnRJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWdOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlTmFtZVxuICAgICAqL1xuICAgIHJlc29sdmVTdG9yZShjb21wb25lbnQsIGNvbmZpZ05hbWUsIHN0b3JlTmFtZSkge1xuICAgICAgICBjb21wb25lbnRbY29uZmlnTmFtZV0gPSB0aGlzLmdldFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB3aWxsIGFzc2lnbiBhbGwgdmFsdWVzIHRvIHRoZSBjbG9zZXN0IG1vZGVsIHdoZXJlIGl0IGZpbmRzIGFuIGV4aXN0aW5nIGtleS5cbiAgICAgKiBJbiBjYXNlIG5vIG1hdGNoIGlzIGZvdW5kIGluc2lkZSB0aGUgcGFyZW50IGNoYWluLCBhIG5ldyBkYXRhIHByb3BlcnR5IHdpbGwgZ2V0IGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXREYXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIGluc3RlYWQgb2Ygc2V0RGF0YSgpIGluIGNhc2UgeW91IHdhbnQgdG8gZW5mb3JjZVxuICAgICAqIHNldHRpbmcgYWxsIGtleXMgb24gdGhpcyBpbnN0YW5jZSBpbnN0ZWFkIG9mIGxvb2tpbmcgZm9yIG1hdGNoZXMgaW5zaWRlIHBhcmVudCBtb2RlbHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc2V0RGF0YUF0U2FtZUxldmVsKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=