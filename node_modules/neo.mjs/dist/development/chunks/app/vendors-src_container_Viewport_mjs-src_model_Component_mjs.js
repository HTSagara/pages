"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_container_Viewport_mjs-src_model_Component_mjs"],{

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport']
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName: this.appName,
            cls    : ['neo-body-viewport']
        })
    }
}

Neo.applyClassConfig(Viewport);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Viewport);


/***/ }),

/***/ "./src/model/Component.mjs":
/*!*********************************!*\
  !*** ./src/model/Component.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");





const dataVariableRegex = /data((?!(\.[a-z_]\w*\(\)))\.[a-z_]\w*)+/gi,
      variableNameRegex = /^\w*/;

/**
 * An optional component (view) model for adding bindings to configs
 * @class Neo.model.Component
 * @extends Neo.core.Base
 */
class Component extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.model.Component'
         * @protected
         */
        className: 'Neo.model.Component',
        /**
         * @member {String} ntype='component-model'
         * @protected
         */
        ntype: 'component-model',
        /**
         * @member {Object|null} bindings_=null
         * @protected
         */
        bindings_: null,
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Object|null} data_=null
         */
        data_: null,
        /**
         * @member {Object|null} formulas_=null
         *
         * @example
         *     data: {
         *         a: 1,
         *         b: 2
         *     }
         *     formulas: {
         *         aPlusB: {
         *             bind: {
         *                 foo: 'a',
         *                 bar: 'b'
         *             },
         *             get(data) {
         *                 return data.foo + data.bar
         *             }
         *         }
         *     }
         */
        formulas_: null,
        /**
         * @member {Neo.model.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object|null} stores_=null
         */
        stores_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        Neo.currentWorker.isUsingViewModels = true;
        super.construct(config);
        this.bindings = {}
    }

    /**
     * Adds a given key/value combination on this model level.
     * The method is used by setData() & setDataAtSameLevel()
     * in case the  data property does not exist yet.
     * @param {String} key
     * @param {*} value
     * @private
     */
    addDataProperty(key, value) {
        let me = this,
            data, scope;

        Neo.ns(key, true, me.data);

        data = me.getDataScope(key);
        scope = data.scope;

        scope[data.key] = value;

        me.createDataProperties(me.data, 'data')
    }

    /**
     * Triggered after the data config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        value && this.createDataProperties(value, 'data')
    }

    /**
     * Triggered after the formulas config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetFormulas(value, oldValue) {
        value && this.resolveFormulas(null)
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return value || {}
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.model.Component|null} value
     * @param {Neo.model.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value ? value : this.getParent()
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        let controller = this.component.getController();

        value && Object.entries(value).forEach(([key, storeValue]) => {
            controller?.parseConfig(storeValue);
            value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(storeValue)
        });

        return value
    }

    /**
     * @param {Function} formatter
     * @param {Object} data=null optionally pass this.getHierarchyData() for performance reasons
     * @returns {String}
     */
    callFormatter(formatter, data=null) {
        if (!data) {
            data = this.getHierarchyData()
        }

        return formatter.call(this, data)
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} key
     * @param {String} value
     * @param {String} formatter
     */
    createBinding(componentId, key, value, formatter) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            bindingScope, parentModel;

        if (scope?.hasOwnProperty(keyLeaf)) {
            bindingScope = Neo.ns(`${key}.${componentId}`, true, me.bindings);
            bindingScope[value] = formatter
        } else {
            parentModel = me.getParent();

            if (parentModel) {
                parentModel.createBinding(componentId, key, value, formatter)
            } else {
                console.error('No model.Component found with the specified data property', componentId, keyLeaf, value)
            }
        }
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise, it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} formatter
     * @param {String} value
     */
    createBindingByFormatter(componentId, formatter, value) {
        let me            = this,
            formatterVars = me.getFormatterVariables(formatter);

        formatterVars.forEach(key => {
            me.createBinding(componentId, key, value, formatter)
        })
    }

    /**
     * @param {Neo.component.Base} component
     */
    createBindings(component) {
        Object.entries(component.bind).forEach(([key, value]) => {
            if (Neo.isObject(value)) {
                value = value.value
            }

            if (!this.isStoreValue(value)) {
                this.createBindingByFormatter(component.id, value, key)
            }
        })
    }

    /**
     * @param {Object} config
     * @param {String} path
     */
    createDataProperties(config, path) {
        let me   = this,
            root = Neo.ns(path, false, me),
            descriptor, keyValue, newPath;

        Object.entries(config).forEach(([key, value]) => {
            if (!key.startsWith('_')) {
                descriptor = Object.getOwnPropertyDescriptor(root, key);
                newPath    = `${path}.${key}`

                if (!(typeof descriptor === 'object' && typeof descriptor.set === 'function')) {
                    keyValue = config[key];
                    me.createDataProperty(key, newPath, root);
                    root[key] = keyValue
                }

                if (Neo.isObject(value)) {
                    me.createDataProperties(config[key], newPath)
                }
            }
        })
    }

    /**
     * @param {String} key
     * @param {String} path
     * @param {Object} root=this.data
     */
    createDataProperty(key, path, root=this.data) {
        let me = this;

        if (path?.startsWith('data.')) {
            path = path.substring(5)
        }

        Object.defineProperty(root, key, {
            get() {
                return root['_' + key]
            },

            set(value) {
                let _key     = `_${key}`,
                    oldValue = root[_key];

                if (!root[_key]) {
                    Object.defineProperty(root, _key, {
                        enumerable: false,
                        value,
                        writable  : true
                    })
                } else {
                    root[_key] = value
                }

                if (!Neo.isEqual(value, oldValue)) {
                    me.onDataPropertyChange(path ? path : key, value, oldValue)
                }
            }
        })
    }

    /**
     * Convenience shortcut
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        return this.component.getController(ntype)
    }

    /**
     * Access the closest data property inside the VM parent chain.
     * @param {String} key
     * @param {Neo.model.Component} originModel=this for internal usage only
     * @returns {*} value
     */
    getData(key, originModel=this) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            parentModel;

        if (scope?.hasOwnProperty(keyLeaf)) {
            return scope[keyLeaf]
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`data property '${key}' does not exist.`, originModel)
        }

        return parentModel.getData(key, originModel)
    }

    /**
     * Helper method to get the scope for a nested data property via Neo.ns() if needed.
     *
     * Example: passing the value 'foo.bar.baz' will return the bar object as the scope
     * and 'baz' as the key.
     * @param key
     * @returns {Object}
     */
    getDataScope(key) {
        let me      = this,
            keyLeaf = key,
            data    = me.data;

        if (key.includes('.')) {
            key     = key.split('.');
            keyLeaf = key.pop();
            data    = Neo.ns(key.join('.'), false, data)
        }

        return {
            key  : keyLeaf,
            scope: data
        }
    }

    /**
     * Extracts data variables from a given formatter string
     * @param {String} value
     */
    getFormatterVariables(value) {
        if (Neo.isFunction(value)) {
            value = value.toString()
        }

        if (Neo.config.environment === 'dist/production') {
            // see: https://github.com/neomjs/neo/issues/2371
            // inside dist/prod the formatter:
            // data => DateUtil.convertToyyyymmdd(data.currentDate)
            // will get minified to:
            // e=>s.Z.convertToyyyymmdd(e.currentDate)
            // the new strategy: find the first variable name => "e"
            // replace it with "data":
            // data=>s.Z.convertToyyyymmdd(data.currentDate)
            // from there we can use the dev mode regex again.

            let dataName       = value.match(variableNameRegex)[0],
                variableRegExp = new RegExp(`(^|[^\\w.])(${dataName})(?!\\w)`, 'g');

            value = value.replace(variableRegExp, '$1data')
        }

        let dataVars = value.match(dataVariableRegex) || [],
            result   = [];

        dataVars.forEach(variable => {
            // remove the "data." at the start
            variable = variable.substr(5);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(result, variable)
        });

        result.sort();

        return result
    }

    /**
     * Returns the merged data
     * @param {Object} data=this.getPlainData()
     * @returns {Object} data
     */
    getHierarchyData(data=this.getPlainData()) {
        let me     = this,
            parent = me.getParent();

        if (parent) {
            return {
                ...parent.getHierarchyData(data),
                ...me.getPlainData()
            }
        }

        return me.getPlainData()
    }

    /**
     * Returns a plain version of this.data.
     * This excludes the property getters & setters.
     * @param {Object} data=this.data
     * @returns {Object}
     */
    getPlainData(data=this.data) {
        let plainData = {};

        Object.entries(data).forEach(([key, value]) => {
            if (Neo.typeOf(value) === 'Object') {
                plainData[key] = this.getPlainData(value)
            } else {
                plainData[key] = value
            }
        });

        return plainData
    }

    /**
     * Get the closest model inside the components parent tree
     * @returns {Neo.model.Component|null}
     */
    getParent() {
        let me = this,
            parentComponent, parentId;

        if (me.parent) {
            return me.parent
        }

        parentId = me.component.parentId;
        parentComponent = parentId && Neo.getComponent(parentId);

        return parentComponent?.getModel() || null
    }

    /**
     * Access the closest store inside the VM parent chain.
     * @param {String} key
     * @param {Neo.model.Component} originModel=this for internal usage only
     * @returns {*} value
     */
    getStore(key, originModel=this) {
        let me     = this,
            stores = me.stores,
            parentModel;

        if (stores?.hasOwnProperty(key)) {
            return stores[key]
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`store '${key}' not found inside this model or parents.`, originModel)
        }

        return parentModel.getStore(key, originModel)
    }

    /**
     * Internal method to avoid code redundancy.
     * Use setData() or setDataAtSameLevel() instead.
     *
     * Passing an originModel param will try to set each key on the closest property match
     * inside the parent model chain => setData()
     * Not passing it will set all values on the model where the method gets called => setDataAtSameLevel()
     * @param {Object|String} key
     * @param {*} value
     * @param {Neo.model.Component} [originModel]
     * @protected
     */
    internalSetData(key, value, originModel) {
        let me = this,
            data, keyLeaf, parentModel, scope;

        if (Neo.isObject(key)) {
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originModel)
            })
        } else {
            data    = me.getDataScope(key);
            keyLeaf = data.key;
            scope   = data.scope;

            if (scope?.hasOwnProperty(keyLeaf)) {
                scope[keyLeaf] = value
            } else {
                if (originModel) {
                    parentModel = me.getParent();

                    if (parentModel) {
                        parentModel.internalSetData(key, value, originModel)
                    } else {
                        originModel.addDataProperty(key, value)
                    }
                } else {
                    me.addDataProperty(key, value)
                }
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return Neo.isString(value) && value.startsWith('stores.')
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(config, preventOriginalConfig) {
        if (config.data) {
            config.data = Neo.merge(Neo.clone(this.constructor.config.data, true) || {}, config.data)
        }

        return super.mergeConfig(config, preventOriginalConfig)
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        let me      = this,
            binding = me.bindings && Neo.ns(key, false, me.bindings),
            component, config, hierarchyData, model;

        if (binding) {
            hierarchyData = {};

            Object.entries(binding).forEach(([componentId, configObject]) => {
                component = Neo.getComponent(componentId) || Neo.get(componentId); // timing issue: the cmp might not be registered inside manager.Component yet
                config = {};
                model = component.getModel();

                if (!hierarchyData[model.id]) {
                    hierarchyData[model.id] = model.getHierarchyData()
                }

                Object.entries(configObject).forEach(([configField, formatter]) => {
                    // we can not call me.callFormatter(), since a data property inside a parent model
                    // could have changed which is relying on data properties inside a closer model
                    config[configField] = model.callFormatter(formatter, hierarchyData[model.id])
                });

                component?.set(config)
            })
        }

        me.resolveFormulas({key, id: me.id, oldValue, value});

        me.fire('dataPropertyChange', {key, id: me.id, oldValue, value})
    }

    /**
     * This method will assign binding values at the earliest possible point inside the component lifecycle.
     * It can not store bindings though, since child component ids most likely do not exist yet.
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me     = this,
            config = {};

        if (component.bind) {
            me.createBindings(component);

            Object.entries(component.bind).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    value.key = me.getFormatterVariables(value.value)[0];
                    value = value.value
                }

                if (me.isStoreValue(value)) {
                    me.resolveStore(component, key, value.substring(7)) // remove the "stores." at the start
                } else {
                    config[key] = me.callFormatter(value)
                }
            });

            component.set(config)
        }
    }

    /**
     * Removes all bindings for a given component id inside this model
     * as well as inside all parent models.
     * @param {String} componentId
     */
    removeBindings(componentId) {
        let me          = this,
            parentModel = me.getParent();

        Object.entries(me.bindings).forEach(([dataProperty, binding]) => {
            delete binding[componentId]
        });

        parentModel?.removeBindings(componentId)
    }

    /**
     * Resolve the formulas initially and update, when data change
     * @param {Object} data data from event or null on initial call
     */
    resolveFormulas(data) {
        let me         = this,
            formulas   = me.formulas,
            initialRun = !data,
            affectFormula, bindObject, fn, key, result, value;

        if (formulas) {
            if (!initialRun && (!data.key || !data.value)) {
                console.warn('[ViewModel:formulas] missing key or value', data.key, data.value)
            }

            for ([key, value] of Object.entries(formulas)) {
                affectFormula = true;

                // Check if the change affects a formula
                if (!initialRun) {
                    affectFormula = Object.values(value.bind).includes(data.key)
                }

                if (affectFormula) {
                    // Create Bind-Object and fill with new values
                    bindObject = Neo.clone(value.bind);
                    fn         = value.get;

                    Object.keys(bindObject).forEach((key, index) => {
                        bindObject[key] = me.getData(bindObject[key])
                    });

                    // Calc the formula
                    result = fn(bindObject);

                    // Assign if no error or null
                    if (isNaN(result)) {
                        me.setData(key, null)
                    } else {
                        me.setData(key, result)
                    }
                }
            }
        }
    }

    /**
     * @param {Neo.component.Base} component
     * @param {String} configName
     * @param {String} storeName
     */
    resolveStore(component, configName, storeName) {
        component[configName] = this.getStore(storeName)
    }

    /**
     * The method will assign all values to the closest model where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     * @param {Object|String} key
     * @param {*} value
     */
    setData(key, value) {
        this.internalSetData(key, value, this)
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent models.
     * @param {Object|String} key
     * @param {*} value
     */
    setDataAtSameLevel(key, value) {
        this.internalSetData(key, value)
    }
}

Neo.applyClassConfig(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb250YWluZXJfVmlld3BvcnRfbWpzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBUztBQUNoQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFFBQVEsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEdUI7QUFDTztBQUNOO0FBQ0s7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBSTtBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFD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Qjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxTQUFTLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tb2RlbC9Db21wb25lbnQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBWaWV3cG9ydCBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udGFpbmVyLlZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udGFpbmVyLlZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3ZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3ZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyAnbmVvLWJvZHktdmlld3BvcnQnIHRvIHRoZSBkb2N1bWVudC5ib2R5XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFwcGx5Qm9keUNscz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWluZyB0aGF0IGEgVmlld3BvcnQgaXMgdGhlIHRvcCBsZXZlbCB2aWV3IG9mIHlvdXIgYXBwLCBhbmQgeW91IHdhbnQgdG8gbW91bnQgaXQgcmlnaHQgYXdheS5cbiAgICAgICAgICogQ291bGQgYmUgd2l0aG91dCBhbnkgaXRlbXMuIFVzZSBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby12aWV3cG9ydCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby12aWV3cG9ydCddXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgdGhpcy5hcHBseUJvZHlDbHMgJiYgTmVvLm1haW4uRG9tQWNjZXNzLmFwcGx5Qm9keUNscyh7XG4gICAgICAgICAgICBhcHBOYW1lOiB0aGlzLmFwcE5hbWUsXG4gICAgICAgICAgICBjbHMgICAgOiBbJ25lby1ib2R5LXZpZXdwb3J0J11cbiAgICAgICAgfSlcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKFZpZXdwb3J0KTtcblxuZXhwb3J0IGRlZmF1bHQgVmlld3BvcnQ7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbmNvbnN0IGRhdGFWYXJpYWJsZVJlZ2V4ID0gL2RhdGEoKD8hKFxcLlthLXpfXVxcdypcXChcXCkpKVxcLlthLXpfXVxcdyopKy9naSxcbiAgICAgIHZhcmlhYmxlTmFtZVJlZ2V4ID0gL15cXHcqLztcblxuLyoqXG4gKiBBbiBvcHRpb25hbCBjb21wb25lbnQgKHZpZXcpIG1vZGVsIGZvciBhZGRpbmcgYmluZGluZ3MgdG8gY29uZmlnc1xuICogQGNsYXNzIE5lby5tb2RlbC5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1vZGVsLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1vZGVsLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb21wb25lbnQtbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LW1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBiaW5kaW5nc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kaW5nc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRhdGFfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGZvcm11bGFzXz1udWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAgICBkYXRhOiB7XG4gICAgICAgICAqICAgICAgICAgYTogMSxcbiAgICAgICAgICogICAgICAgICBiOiAyXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqICAgICBmb3JtdWxhczoge1xuICAgICAgICAgKiAgICAgICAgIGFQbHVzQjoge1xuICAgICAgICAgKiAgICAgICAgICAgICBiaW5kOiB7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICBmb286ICdhJyxcbiAgICAgICAgICogICAgICAgICAgICAgICAgIGJhcjogJ2InXG4gICAgICAgICAqICAgICAgICAgICAgIH0sXG4gICAgICAgICAqICAgICAgICAgICAgIGdldChkYXRhKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5mb28gKyBkYXRhLmJhclxuICAgICAgICAgKiAgICAgICAgICAgICB9XG4gICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybXVsYXNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLm1vZGVsLkNvbXBvbmVudHxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc3RvcmVzXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZXNfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIuaXNVc2luZ1ZpZXdNb2RlbHMgPSB0cnVlO1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGdpdmVuIGtleS92YWx1ZSBjb21iaW5hdGlvbiBvbiB0aGlzIG1vZGVsIGxldmVsLlxuICAgICAqIFRoZSBtZXRob2QgaXMgdXNlZCBieSBzZXREYXRhKCkgJiBzZXREYXRhQXRTYW1lTGV2ZWwoKVxuICAgICAqIGluIGNhc2UgdGhlICBkYXRhIHByb3BlcnR5IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkRGF0YVByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEsIHNjb3BlO1xuXG4gICAgICAgIE5lby5ucyhrZXksIHRydWUsIG1lLmRhdGEpO1xuXG4gICAgICAgIGRhdGEgPSBtZS5nZXREYXRhU2NvcGUoa2V5KTtcbiAgICAgICAgc2NvcGUgPSBkYXRhLnNjb3BlO1xuXG4gICAgICAgIHNjb3BlW2RhdGEua2V5XSA9IHZhbHVlO1xuXG4gICAgICAgIG1lLmNyZWF0ZURhdGFQcm9wZXJ0aWVzKG1lLmRhdGEsICdkYXRhJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRhdGEgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY3JlYXRlRGF0YVByb3BlcnRpZXModmFsdWUsICdkYXRhJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZvcm11bGFzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGb3JtdWxhcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5yZXNvbHZlRm9ybXVsYXMobnVsbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGRhdGEgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldERhdGEodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5tb2RlbC5Db21wb25lbnR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5tb2RlbC5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGFyZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSA6IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZXMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBjb250cm9sbGVyID0gdGhpcy5jb21wb25lbnQuZ2V0Q29udHJvbGxlcigpO1xuXG4gICAgICAgIHZhbHVlICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCBzdG9yZVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlcj8ucGFyc2VDb25maWcoc3RvcmVWYWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZVtrZXldID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHN0b3JlVmFsdWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZvcm1hdHRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhPW51bGwgb3B0aW9uYWxseSBwYXNzIHRoaXMuZ2V0SGllcmFyY2h5RGF0YSgpIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBjYWxsRm9ybWF0dGVyKGZvcm1hdHRlciwgZGF0YT1udWxsKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0SGllcmFyY2h5RGF0YSgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmNhbGwodGhpcywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYmluZGluZyBpbiBjYXNlIGEgbWF0Y2hpbmcgZGF0YSBwcm9wZXJ0eSBkb2VzIGV4aXN0LlxuICAgICAqIE90aGVyd2lzZSBpdCB3aWxsIHVzZSB0aGUgY2xvc2VzdCBtb2RlbCB3aXRoIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXR0ZXJcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5nKGNvbXBvbmVudElkLCBrZXksIHZhbHVlLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmdldERhdGFTY29wZShrZXkpLFxuICAgICAgICAgICAgc2NvcGUgICA9IGRhdGEuc2NvcGUsXG4gICAgICAgICAgICBrZXlMZWFmID0gZGF0YS5rZXksXG4gICAgICAgICAgICBiaW5kaW5nU2NvcGUsIHBhcmVudE1vZGVsO1xuXG4gICAgICAgIGlmIChzY29wZT8uaGFzT3duUHJvcGVydHkoa2V5TGVhZikpIHtcbiAgICAgICAgICAgIGJpbmRpbmdTY29wZSA9IE5lby5ucyhgJHtrZXl9LiR7Y29tcG9uZW50SWR9YCwgdHJ1ZSwgbWUuYmluZGluZ3MpO1xuICAgICAgICAgICAgYmluZGluZ1Njb3BlW3ZhbHVlXSA9IGZvcm1hdHRlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50TW9kZWwuY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwga2V5LCB2YWx1ZSwgZm9ybWF0dGVyKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBtb2RlbC5Db21wb25lbnQgZm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgcHJvcGVydHknLCBjb21wb25lbnRJZCwga2V5TGVhZiwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYmluZGluZyBpbiBjYXNlIGEgbWF0Y2hpbmcgZGF0YSBwcm9wZXJ0eSBkb2VzIGV4aXN0LlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGNsb3Nlc3QgbW9kZWwgd2l0aCBhIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXR0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5nQnlGb3JtYXR0ZXIoY29tcG9uZW50SWQsIGZvcm1hdHRlciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZm9ybWF0dGVyVmFycyA9IG1lLmdldEZvcm1hdHRlclZhcmlhYmxlcyhmb3JtYXR0ZXIpO1xuXG4gICAgICAgIGZvcm1hdHRlclZhcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbWUuY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwga2V5LCB2YWx1ZSwgZm9ybWF0dGVyKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5ncyhjb21wb25lbnQpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29tcG9uZW50LmJpbmQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1N0b3JlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCaW5kaW5nQnlGb3JtYXR0ZXIoY29tcG9uZW50LmlkLCB2YWx1ZSwga2V5KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqL1xuICAgIGNyZWF0ZURhdGFQcm9wZXJ0aWVzKGNvbmZpZywgcGF0aCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICByb290ID0gTmVvLm5zKHBhdGgsIGZhbHNlLCBtZSksXG4gICAgICAgICAgICBkZXNjcmlwdG9yLCBrZXlWYWx1ZSwgbmV3UGF0aDtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhjb25maWcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnXycpKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iocm9vdCwga2V5KTtcbiAgICAgICAgICAgICAgICBuZXdQYXRoICAgID0gYCR7cGF0aH0uJHtrZXl9YFxuXG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGRlc2NyaXB0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZXNjcmlwdG9yLnNldCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5VmFsdWUgPSBjb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlRGF0YVByb3BlcnR5KGtleSwgbmV3UGF0aCwgcm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3Rba2V5XSA9IGtleVZhbHVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlRGF0YVByb3BlcnRpZXMoY29uZmlnW2tleV0sIG5ld1BhdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByb290PXRoaXMuZGF0YVxuICAgICAqL1xuICAgIGNyZWF0ZURhdGFQcm9wZXJ0eShrZXksIHBhdGgsIHJvb3Q9dGhpcy5kYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHBhdGg/LnN0YXJ0c1dpdGgoJ2RhdGEuJykpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyg1KVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvb3QsIGtleSwge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290WydfJyArIGtleV1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBfa2V5ICAgICA9IGBfJHtrZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByb290W19rZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyb290W19rZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb290LCBfa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGUgIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RbX2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghTmVvLmlzRXF1YWwodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vbkRhdGFQcm9wZXJ0eUNoYW5nZShwYXRoID8gcGF0aCA6IGtleSwgdmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldENvbnRyb2xsZXIobnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmdldENvbnRyb2xsZXIobnR5cGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjZXNzIHRoZSBjbG9zZXN0IGRhdGEgcHJvcGVydHkgaW5zaWRlIHRoZSBWTSBwYXJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudH0gb3JpZ2luTW9kZWw9dGhpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAqIEByZXR1cm5zIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldERhdGEoa2V5LCBvcmlnaW5Nb2RlbD10aGlzKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgICAgPSBtZS5nZXREYXRhU2NvcGUoa2V5KSxcbiAgICAgICAgICAgIHNjb3BlICAgPSBkYXRhLnNjb3BlLFxuICAgICAgICAgICAga2V5TGVhZiA9IGRhdGEua2V5LFxuICAgICAgICAgICAgcGFyZW50TW9kZWw7XG5cbiAgICAgICAgaWYgKHNjb3BlPy5oYXNPd25Qcm9wZXJ0eShrZXlMZWFmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlW2tleUxlYWZdXG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmICghcGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGRhdGEgcHJvcGVydHkgJyR7a2V5fScgZG9lcyBub3QgZXhpc3QuYCwgb3JpZ2luTW9kZWwpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50TW9kZWwuZ2V0RGF0YShrZXksIG9yaWdpbk1vZGVsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZ2V0IHRoZSBzY29wZSBmb3IgYSBuZXN0ZWQgZGF0YSBwcm9wZXJ0eSB2aWEgTmVvLm5zKCkgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTogcGFzc2luZyB0aGUgdmFsdWUgJ2Zvby5iYXIuYmF6JyB3aWxsIHJldHVybiB0aGUgYmFyIG9iamVjdCBhcyB0aGUgc2NvcGVcbiAgICAgKiBhbmQgJ2JheicgYXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREYXRhU2NvcGUoa2V5KSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleUxlYWYgPSBrZXksXG4gICAgICAgICAgICBkYXRhICAgID0gbWUuZGF0YTtcblxuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIGtleSAgICAgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGtleUxlYWYgPSBrZXkucG9wKCk7XG4gICAgICAgICAgICBkYXRhICAgID0gTmVvLm5zKGtleS5qb2luKCcuJyksIGZhbHNlLCBkYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleSAgOiBrZXlMZWFmLFxuICAgICAgICAgICAgc2NvcGU6IGRhdGFcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGRhdGEgdmFyaWFibGVzIGZyb20gYSBnaXZlbiBmb3JtYXR0ZXIgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0dGVyVmFyaWFibGVzKHZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5jb25maWcuZW52aXJvbm1lbnQgPT09ICdkaXN0L3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMzcxXG4gICAgICAgICAgICAvLyBpbnNpZGUgZGlzdC9wcm9kIHRoZSBmb3JtYXR0ZXI6XG4gICAgICAgICAgICAvLyBkYXRhID0+IERhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGEuY3VycmVudERhdGUpXG4gICAgICAgICAgICAvLyB3aWxsIGdldCBtaW5pZmllZCB0bzpcbiAgICAgICAgICAgIC8vIGU9PnMuWi5jb252ZXJ0VG95eXl5bW1kZChlLmN1cnJlbnREYXRlKVxuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdHJhdGVneTogZmluZCB0aGUgZmlyc3QgdmFyaWFibGUgbmFtZSA9PiBcImVcIlxuICAgICAgICAgICAgLy8gcmVwbGFjZSBpdCB3aXRoIFwiZGF0YVwiOlxuICAgICAgICAgICAgLy8gZGF0YT0+cy5aLmNvbnZlcnRUb3l5eXltbWRkKGRhdGEuY3VycmVudERhdGUpXG4gICAgICAgICAgICAvLyBmcm9tIHRoZXJlIHdlIGNhbiB1c2UgdGhlIGRldiBtb2RlIHJlZ2V4IGFnYWluLlxuXG4gICAgICAgICAgICBsZXQgZGF0YU5hbWUgICAgICAgPSB2YWx1ZS5tYXRjaCh2YXJpYWJsZU5hbWVSZWdleClbMF0sXG4gICAgICAgICAgICAgICAgdmFyaWFibGVSZWdFeHAgPSBuZXcgUmVnRXhwKGAoXnxbXlxcXFx3Ll0pKCR7ZGF0YU5hbWV9KSg/IVxcXFx3KWAsICdnJyk7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSh2YXJpYWJsZVJlZ0V4cCwgJyQxZGF0YScpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YVZhcnMgPSB2YWx1ZS5tYXRjaChkYXRhVmFyaWFibGVSZWdleCkgfHwgW10sXG4gICAgICAgICAgICByZXN1bHQgICA9IFtdO1xuXG4gICAgICAgIGRhdGFWYXJzLmZvckVhY2godmFyaWFibGUgPT4ge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBcImRhdGEuXCIgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnN1YnN0cig1KTtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChyZXN1bHQsIHZhcmlhYmxlKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHQuc29ydCgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXJnZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhPXRoaXMuZ2V0UGxhaW5EYXRhKClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZ2V0SGllcmFyY2h5RGF0YShkYXRhPXRoaXMuZ2V0UGxhaW5EYXRhKCkpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnQgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnBhcmVudC5nZXRIaWVyYXJjaHlEYXRhKGRhdGEpLFxuICAgICAgICAgICAgICAgIC4uLm1lLmdldFBsYWluRGF0YSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuZ2V0UGxhaW5EYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGxhaW4gdmVyc2lvbiBvZiB0aGlzLmRhdGEuXG4gICAgICogVGhpcyBleGNsdWRlcyB0aGUgcHJvcGVydHkgZ2V0dGVycyAmIHNldHRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGE9dGhpcy5kYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRQbGFpbkRhdGEoZGF0YT10aGlzLmRhdGEpIHtcbiAgICAgICAgbGV0IHBsYWluRGF0YSA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHBsYWluRGF0YVtrZXldID0gdGhpcy5nZXRQbGFpbkRhdGEodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWluRGF0YVtrZXldID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBsYWluRGF0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBtb2RlbCBpbnNpZGUgdGhlIGNvbXBvbmVudHMgcGFyZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLm1vZGVsLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCwgcGFyZW50SWQ7XG5cbiAgICAgICAgaWYgKG1lLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnBhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50SWQgPSBtZS5jb21wb25lbnQucGFyZW50SWQ7XG4gICAgICAgIHBhcmVudENvbXBvbmVudCA9IHBhcmVudElkICYmIE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQ/LmdldE1vZGVsKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY2VzcyB0aGUgY2xvc2VzdCBzdG9yZSBpbnNpZGUgdGhlIFZNIHBhcmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtOZW8ubW9kZWwuQ29tcG9uZW50fSBvcmlnaW5Nb2RlbD10aGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICogQHJldHVybnMgeyp9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5LCBvcmlnaW5Nb2RlbD10aGlzKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RvcmVzID0gbWUuc3RvcmVzLFxuICAgICAgICAgICAgcGFyZW50TW9kZWw7XG5cbiAgICAgICAgaWYgKHN0b3Jlcz8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3Jlc1trZXldXG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmICghcGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHN0b3JlICcke2tleX0nIG5vdCBmb3VuZCBpbnNpZGUgdGhpcyBtb2RlbCBvciBwYXJlbnRzLmAsIG9yaWdpbk1vZGVsKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudE1vZGVsLmdldFN0b3JlKGtleSwgb3JpZ2luTW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGF2b2lkIGNvZGUgcmVkdW5kYW5jeS5cbiAgICAgKiBVc2Ugc2V0RGF0YSgpIG9yIHNldERhdGFBdFNhbWVMZXZlbCgpIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBQYXNzaW5nIGFuIG9yaWdpbk1vZGVsIHBhcmFtIHdpbGwgdHJ5IHRvIHNldCBlYWNoIGtleSBvbiB0aGUgY2xvc2VzdCBwcm9wZXJ0eSBtYXRjaFxuICAgICAqIGluc2lkZSB0aGUgcGFyZW50IG1vZGVsIGNoYWluID0+IHNldERhdGEoKVxuICAgICAqIE5vdCBwYXNzaW5nIGl0IHdpbGwgc2V0IGFsbCB2YWx1ZXMgb24gdGhlIG1vZGVsIHdoZXJlIHRoZSBtZXRob2QgZ2V0cyBjYWxsZWQgPT4gc2V0RGF0YUF0U2FtZUxldmVsKClcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5tb2RlbC5Db21wb25lbnR9IFtvcmlnaW5Nb2RlbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW50ZXJuYWxTZXREYXRhKGtleSwgdmFsdWUsIG9yaWdpbk1vZGVsKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhLCBrZXlMZWFmLCBwYXJlbnRNb2RlbCwgc2NvcGU7XG5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhrZXkpLmZvckVhY2goKFtkYXRhS2V5LCBkYXRhVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuaW50ZXJuYWxTZXREYXRhKGRhdGFLZXksIGRhdGFWYWx1ZSwgb3JpZ2luTW9kZWwpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmdldERhdGFTY29wZShrZXkpO1xuICAgICAgICAgICAga2V5TGVhZiA9IGRhdGEua2V5O1xuICAgICAgICAgICAgc2NvcGUgICA9IGRhdGEuc2NvcGU7XG5cbiAgICAgICAgICAgIGlmIChzY29wZT8uaGFzT3duUHJvcGVydHkoa2V5TGVhZikpIHtcbiAgICAgICAgICAgICAgICBzY29wZVtrZXlMZWFmXSA9IHZhbHVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5Nb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50TW9kZWwuaW50ZXJuYWxTZXREYXRhKGtleSwgdmFsdWUsIG9yaWdpbk1vZGVsKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luTW9kZWwuYWRkRGF0YVByb3BlcnR5KGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5hZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb252ZW5pZW5jZSBtZXRob2QgdG8gY2hlY2sgaWYgYSBiaW5kaW5nIHZhbHVlIGlzIHN1cHBvc2VkIHRvIG1hdGNoIGEgc3RvcmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1N0b3JlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lby5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aCgnc3RvcmVzLicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBvcmRlciBjb25maWdzIGFyZSBhcHBsaWVkIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRPcmlnaW5hbENvbmZpZ10gVHJ1ZSBwcmV2ZW50cyB0aGUgaW5zdGFuY2UgZnJvbSBnZXR0aW5nIGFuIG9yaWdpbmFsQ29uZmlnIHByb3BlcnR5XG4gICAgICogQHJldHVybnMge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgbWVyZ2VDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5kYXRhKSB7XG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IE5lby5tZXJnZShOZW8uY2xvbmUodGhpcy5jb25zdHJ1Y3Rvci5jb25maWcuZGF0YSwgdHJ1ZSkgfHwge30sIGNvbmZpZy5kYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLm1lcmdlQ29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uRGF0YVByb3BlcnR5Q2hhbmdlKGtleSwgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJpbmRpbmcgPSBtZS5iaW5kaW5ncyAmJiBOZW8ubnMoa2V5LCBmYWxzZSwgbWUuYmluZGluZ3MpLFxuICAgICAgICAgICAgY29tcG9uZW50LCBjb25maWcsIGhpZXJhcmNoeURhdGEsIG1vZGVsO1xuXG4gICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICBoaWVyYXJjaHlEYXRhID0ge307XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGJpbmRpbmcpLmZvckVhY2goKFtjb21wb25lbnRJZCwgY29uZmlnT2JqZWN0XSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoY29tcG9uZW50SWQpIHx8IE5lby5nZXQoY29tcG9uZW50SWQpOyAvLyB0aW1pbmcgaXNzdWU6IHRoZSBjbXAgbWlnaHQgbm90IGJlIHJlZ2lzdGVyZWQgaW5zaWRlIG1hbmFnZXIuQ29tcG9uZW50IHlldFxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgICAgIG1vZGVsID0gY29tcG9uZW50LmdldE1vZGVsKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhpZXJhcmNoeURhdGFbbW9kZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoeURhdGFbbW9kZWwuaWRdID0gbW9kZWwuZ2V0SGllcmFyY2h5RGF0YSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnT2JqZWN0KS5mb3JFYWNoKChbY29uZmlnRmllbGQsIGZvcm1hdHRlcl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIG5vdCBjYWxsIG1lLmNhbGxGb3JtYXR0ZXIoKSwgc2luY2UgYSBkYXRhIHByb3BlcnR5IGluc2lkZSBhIHBhcmVudCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBoYXZlIGNoYW5nZWQgd2hpY2ggaXMgcmVseWluZyBvbiBkYXRhIHByb3BlcnRpZXMgaW5zaWRlIGEgY2xvc2VyIG1vZGVsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tjb25maWdGaWVsZF0gPSBtb2RlbC5jYWxsRm9ybWF0dGVyKGZvcm1hdHRlciwgaGllcmFyY2h5RGF0YVttb2RlbC5pZF0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQ/LnNldChjb25maWcpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUucmVzb2x2ZUZvcm11bGFzKHtrZXksIGlkOiBtZS5pZCwgb2xkVmFsdWUsIHZhbHVlfSk7XG5cbiAgICAgICAgbWUuZmlyZSgnZGF0YVByb3BlcnR5Q2hhbmdlJywge2tleSwgaWQ6IG1lLmlkLCBvbGRWYWx1ZSwgdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYXNzaWduIGJpbmRpbmcgdmFsdWVzIGF0IHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBwb2ludCBpbnNpZGUgdGhlIGNvbXBvbmVudCBsaWZlY3ljbGUuXG4gICAgICogSXQgY2FuIG5vdCBzdG9yZSBiaW5kaW5ncyB0aG91Z2gsIHNpbmNlIGNoaWxkIGNvbXBvbmVudCBpZHMgbW9zdCBsaWtlbHkgZG8gbm90IGV4aXN0IHlldC5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50PXRoaXMuY29tcG9uZW50XG4gICAgICovXG4gICAgcGFyc2VDb25maWcoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5iaW5kKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVCaW5kaW5ncyhjb21wb25lbnQpO1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb21wb25lbnQuYmluZCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUua2V5ID0gbWUuZ2V0Rm9ybWF0dGVyVmFyaWFibGVzKHZhbHVlLnZhbHVlKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtZS5pc1N0b3JlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlc29sdmVTdG9yZShjb21wb25lbnQsIGtleSwgdmFsdWUuc3Vic3RyaW5nKDcpKSAvLyByZW1vdmUgdGhlIFwic3RvcmVzLlwiIGF0IHRoZSBzdGFydFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1trZXldID0gbWUuY2FsbEZvcm1hdHRlcih2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29tcG9uZW50LnNldChjb25maWcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBiaW5kaW5ncyBmb3IgYSBnaXZlbiBjb21wb25lbnQgaWQgaW5zaWRlIHRoaXMgbW9kZWxcbiAgICAgKiBhcyB3ZWxsIGFzIGluc2lkZSBhbGwgcGFyZW50IG1vZGVscy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50SWRcbiAgICAgKi9cbiAgICByZW1vdmVCaW5kaW5ncyhjb21wb25lbnRJZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhtZS5iaW5kaW5ncykuZm9yRWFjaCgoW2RhdGFQcm9wZXJ0eSwgYmluZGluZ10pID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBiaW5kaW5nW2NvbXBvbmVudElkXVxuICAgICAgICB9KTtcblxuICAgICAgICBwYXJlbnRNb2RlbD8ucmVtb3ZlQmluZGluZ3MoY29tcG9uZW50SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSB0aGUgZm9ybXVsYXMgaW5pdGlhbGx5IGFuZCB1cGRhdGUsIHdoZW4gZGF0YSBjaGFuZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBkYXRhIGZyb20gZXZlbnQgb3IgbnVsbCBvbiBpbml0aWFsIGNhbGxcbiAgICAgKi9cbiAgICByZXNvbHZlRm9ybXVsYXMoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBmb3JtdWxhcyAgID0gbWUuZm9ybXVsYXMsXG4gICAgICAgICAgICBpbml0aWFsUnVuID0gIWRhdGEsXG4gICAgICAgICAgICBhZmZlY3RGb3JtdWxhLCBiaW5kT2JqZWN0LCBmbiwga2V5LCByZXN1bHQsIHZhbHVlO1xuXG4gICAgICAgIGlmIChmb3JtdWxhcykge1xuICAgICAgICAgICAgaWYgKCFpbml0aWFsUnVuICYmICghZGF0YS5rZXkgfHwgIWRhdGEudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbVmlld01vZGVsOmZvcm11bGFzXSBtaXNzaW5nIGtleSBvciB2YWx1ZScsIGRhdGEua2V5LCBkYXRhLnZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmb3JtdWxhcykpIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RGb3JtdWxhID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGFuZ2UgYWZmZWN0cyBhIGZvcm11bGFcbiAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxSdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0Rm9ybXVsYSA9IE9iamVjdC52YWx1ZXModmFsdWUuYmluZCkuaW5jbHVkZXMoZGF0YS5rZXkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFmZmVjdEZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIEJpbmQtT2JqZWN0IGFuZCBmaWxsIHdpdGggbmV3IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBiaW5kT2JqZWN0ID0gTmVvLmNsb25lKHZhbHVlLmJpbmQpO1xuICAgICAgICAgICAgICAgICAgICBmbiAgICAgICAgID0gdmFsdWUuZ2V0O1xuXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGJpbmRPYmplY3QpLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRPYmplY3Rba2V5XSA9IG1lLmdldERhdGEoYmluZE9iamVjdFtrZXldKVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjIHRoZSBmb3JtdWxhXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKGJpbmRPYmplY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBpZiBubyBlcnJvciBvciBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXREYXRhKGtleSwgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldERhdGEoa2V5LCByZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmVOYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZVN0b3JlKGNvbXBvbmVudCwgY29uZmlnTmFtZSwgc3RvcmVOYW1lKSB7XG4gICAgICAgIGNvbXBvbmVudFtjb25maWdOYW1lXSA9IHRoaXMuZ2V0U3RvcmUoc3RvcmVOYW1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2Qgd2lsbCBhc3NpZ24gYWxsIHZhbHVlcyB0byB0aGUgY2xvc2VzdCBtb2RlbCB3aGVyZSBpdCBmaW5kcyBhbiBleGlzdGluZyBrZXkuXG4gICAgICogSW4gY2FzZSBubyBtYXRjaCBpcyBmb3VuZCBpbnNpZGUgdGhlIHBhcmVudCBjaGFpbiwgYSBuZXcgZGF0YSBwcm9wZXJ0eSB3aWxsIGdldCBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc2V0RGF0YShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTZXREYXRhKGtleSwgdmFsdWUsIHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIGluc3RlYWQgb2Ygc2V0RGF0YSgpIGluIGNhc2UgeW91IHdhbnQgdG8gZW5mb3JjZVxuICAgICAqIHNldHRpbmcgYWxsIGtleXMgb24gdGhpcyBpbnN0YW5jZSBpbnN0ZWFkIG9mIGxvb2tpbmcgZm9yIG1hdGNoZXMgaW5zaWRlIHBhcmVudCBtb2RlbHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc2V0RGF0YUF0U2FtZUxldmVsKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSlcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==