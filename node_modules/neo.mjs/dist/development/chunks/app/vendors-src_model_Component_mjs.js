"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_model_Component_mjs"],{

/***/ "./src/model/Component.mjs":
/*!*********************************!*\
  !*** ./src/model/Component.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");





const dataVariableRegex = /data((?!(\.[a-z_]\w*\(\)))\.[a-z_]\w*)+/gi,
      variableNameRegex = /^\w*/;

/**
 * An optional component (view) model for adding bindings to configs
 * @class Neo.model.Component
 * @extends Neo.core.Base
 */
class Component extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.model.Component'
         * @protected
         */
        className: 'Neo.model.Component',
        /**
         * @member {String} ntype='component-model'
         * @protected
         */
        ntype: 'component-model',
        /**
         * @member {Object|null} bindings_=null
         * @protected
         */
        bindings_: null,
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Object|null} data_=null
         */
        data_: null,
        /**
         * @member {Object|null} formulas_=null
         *
         * @example
         *     data: {
         *         a: 1,
         *         b: 2
         *     }
         *     formulas: {
         *         aPlusB: {
         *             bind: {
         *                 foo: 'a',
         *                 bar: 'b'
         *             },
         *             get(data) {
         *                 return data.foo + data.bar
         *             }
         *         }
         *     }
         */
        formulas_: null,
        /**
         * @member {Neo.model.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object|null} stores_=null
         */
        stores_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        Neo.currentWorker.isUsingViewModels = true;
        super.construct(config);
        this.bindings = {}
    }

    /**
     * Adds a given key/value combination on this model level.
     * The method is used by setData() & setDataAtSameLevel()
     * in case the  data property does not exist yet.
     * @param {String} key
     * @param {*} value
     * @private
     */
    addDataProperty(key, value) {
        let me = this,
            data, scope;

        Neo.ns(key, true, me.data);

        data = me.getDataScope(key);
        scope = data.scope;

        scope[data.key] = value;

        me.createDataProperties(me.data, 'data')
    }

    /**
     * Triggered after the data config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        value && this.createDataProperties(value, 'data')
    }

    /**
     * Triggered after the formulas config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetFormulas(value, oldValue) {
        value && this.resolveFormulas(null)
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return value || {}
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.model.Component|null} value
     * @param {Neo.model.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value ? value : this.getParent()
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        let controller = this.component.getController();

        value && Object.entries(value).forEach(([key, storeValue]) => {
            controller?.parseConfig(storeValue);
            value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(storeValue)
        });

        return value
    }

    /**
     * @param {Function} formatter
     * @param {Object} data=null optionally pass this.getHierarchyData() for performance reasons
     * @returns {String}
     */
    callFormatter(formatter, data=null) {
        if (!data) {
            data = this.getHierarchyData()
        }

        return formatter.call(this, data)
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} key
     * @param {String} value
     * @param {String} formatter
     */
    createBinding(componentId, key, value, formatter) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            bindingScope, parentModel;

        if (scope?.hasOwnProperty(keyLeaf)) {
            bindingScope = Neo.ns(`${key}.${componentId}`, true, me.bindings);
            bindingScope[value] = formatter
        } else {
            parentModel = me.getParent();

            if (parentModel) {
                parentModel.createBinding(componentId, key, value, formatter)
            } else {
                console.error('No model.Component found with the specified data property', componentId, keyLeaf, value)
            }
        }
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise, it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} formatter
     * @param {String} value
     */
    createBindingByFormatter(componentId, formatter, value) {
        let me            = this,
            formatterVars = me.getFormatterVariables(formatter);

        formatterVars.forEach(key => {
            me.createBinding(componentId, key, value, formatter)
        })
    }

    /**
     * @param {Neo.component.Base} component
     */
    createBindings(component) {
        Object.entries(component.bind).forEach(([key, value]) => {
            if (Neo.isObject(value)) {
                value = value.value
            }

            if (!this.isStoreValue(value)) {
                this.createBindingByFormatter(component.id, value, key)
            }
        })
    }

    /**
     * @param {Object} config
     * @param {String} path
     */
    createDataProperties(config, path) {
        let me   = this,
            root = Neo.ns(path, false, me),
            descriptor, keyValue, newPath;

        Object.entries(config).forEach(([key, value]) => {
            if (!key.startsWith('_')) {
                descriptor = Object.getOwnPropertyDescriptor(root, key);
                newPath    = `${path}.${key}`

                if (!(typeof descriptor === 'object' && typeof descriptor.set === 'function')) {
                    keyValue = config[key];
                    me.createDataProperty(key, newPath, root);
                    root[key] = keyValue
                }

                if (Neo.isObject(value)) {
                    me.createDataProperties(config[key], newPath)
                }
            }
        })
    }

    /**
     * @param {String} key
     * @param {String} path
     * @param {Object} root=this.data
     */
    createDataProperty(key, path, root=this.data) {
        let me = this;

        if (path?.startsWith('data.')) {
            path = path.substring(5)
        }

        Object.defineProperty(root, key, {
            get() {
                return root['_' + key]
            },

            set(value) {
                let _key     = `_${key}`,
                    oldValue = root[_key];

                if (!root[_key]) {
                    Object.defineProperty(root, _key, {
                        enumerable: false,
                        value,
                        writable  : true
                    })
                } else {
                    root[_key] = value
                }

                if (!Neo.isEqual(value, oldValue)) {
                    me.onDataPropertyChange(path ? path : key, value, oldValue)
                }
            }
        })
    }

    /**
     * Convenience shortcut
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        return this.component.getController(ntype)
    }

    /**
     * Access the closest data property inside the VM parent chain.
     * @param {String} key
     * @param {Neo.model.Component} originModel=this for internal usage only
     * @returns {*} value
     */
    getData(key, originModel=this) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            parentModel;

        if (scope?.hasOwnProperty(keyLeaf)) {
            return scope[keyLeaf]
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`data property '${key}' does not exist.`, originModel)
        }

        return parentModel.getData(key, originModel)
    }

    /**
     * Helper method to get the scope for a nested data property via Neo.ns() if needed.
     *
     * Example: passing the value 'foo.bar.baz' will return the bar object as the scope
     * and 'baz' as the key.
     * @param key
     * @returns {Object}
     */
    getDataScope(key) {
        let me      = this,
            keyLeaf = key,
            data    = me.data;

        if (key.includes('.')) {
            key     = key.split('.');
            keyLeaf = key.pop();
            data    = Neo.ns(key.join('.'), false, data)
        }

        return {
            key  : keyLeaf,
            scope: data
        }
    }

    /**
     * Extracts data variables from a given formatter string
     * @param {String} value
     */
    getFormatterVariables(value) {
        if (Neo.isFunction(value)) {
            value = value.toString()
        }

        if (Neo.config.environment === 'dist/production') {
            // see: https://github.com/neomjs/neo/issues/2371
            // inside dist/prod the formatter:
            // data => DateUtil.convertToyyyymmdd(data.currentDate)
            // will get minified to:
            // e=>s.Z.convertToyyyymmdd(e.currentDate)
            // the new strategy: find the first variable name => "e"
            // replace it with "data":
            // data=>s.Z.convertToyyyymmdd(data.currentDate)
            // from there we can use the dev mode regex again.

            let dataName       = value.match(variableNameRegex)[0],
                variableRegExp = new RegExp(`(^|[^\\w.])(${dataName})(?!\\w)`, 'g');

            value = value.replace(variableRegExp, '$1data')
        }

        let dataVars = value.match(dataVariableRegex) || [],
            result   = [];

        dataVars.forEach(variable => {
            // remove the "data." at the start
            variable = variable.substr(5);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(result, variable)
        });

        result.sort();

        return result
    }

    /**
     * Returns the merged data
     * @param {Object} data=this.getPlainData()
     * @returns {Object} data
     */
    getHierarchyData(data=this.getPlainData()) {
        let me     = this,
            parent = me.getParent();

        if (parent) {
            return {
                ...parent.getHierarchyData(data),
                ...me.getPlainData()
            }
        }

        return me.getPlainData()
    }

    /**
     * Returns a plain version of this.data.
     * This excludes the property getters & setters.
     * @param {Object} data=this.data
     * @returns {Object}
     */
    getPlainData(data=this.data) {
        let plainData = {};

        Object.entries(data).forEach(([key, value]) => {
            if (Neo.typeOf(value) === 'Object') {
                plainData[key] = this.getPlainData(value)
            } else {
                plainData[key] = value
            }
        });

        return plainData
    }

    /**
     * Get the closest model inside the components parent tree
     * @returns {Neo.model.Component|null}
     */
    getParent() {
        let me = this;

        if (me.parent) {
            return me.parent
        }

        return me.component.parent?.getModel() || null
    }

    /**
     * Access the closest store inside the VM parent chain.
     * @param {String} key
     * @param {Neo.model.Component} originModel=this for internal usage only
     * @returns {Neo.data.Store}
     */
    getStore(key, originModel=this) {
        let me     = this,
            stores = me.stores,
            parentModel;

        if (stores?.hasOwnProperty(key)) {
            return stores[key]
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`store '${key}' not found inside this model or parents.`, originModel)
        }

        return parentModel.getStore(key, originModel)
    }

    /**
     * Internal method to avoid code redundancy.
     * Use setData() or setDataAtSameLevel() instead.
     *
     * Passing an originModel param will try to set each key on the closest property match
     * inside the parent model chain => setData()
     * Not passing it will set all values on the model where the method gets called => setDataAtSameLevel()
     * @param {Object|String} key
     * @param {*} value
     * @param {Neo.model.Component} [originModel]
     * @protected
     */
    internalSetData(key, value, originModel) {
        let me = this,
            data, keyLeaf, parentModel, scope;

        if (Neo.isObject(value) && !value.isRecord) {
            Object.entries(value).forEach(([dataKey, dataValue]) => {
                me.internalSetData(`${key}.${dataKey}`, dataValue, originModel)
            })
        } else if (Neo.isObject(key)) {
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originModel)
            })
        } else {
            data    = me.getDataScope(key);
            keyLeaf = data.key;
            scope   = data.scope;

            if (scope?.hasOwnProperty(keyLeaf)) {
                scope[keyLeaf] = value
            } else {
                if (originModel) {
                    parentModel = me.getParent();

                    if (parentModel) {
                        parentModel.internalSetData(key, value, originModel)
                    } else {
                        originModel.addDataProperty(key, value)
                    }
                } else {
                    me.addDataProperty(key, value)
                }
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return Neo.isString(value) && value.startsWith('stores.')
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(config, preventOriginalConfig) {
        if (config.data) {
            config.data = Neo.merge(Neo.clone(this.constructor.config.data, true) || {}, config.data)
        }

        return super.mergeConfig(config, preventOriginalConfig)
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        let me      = this,
            binding = me.bindings && Neo.ns(key, false, me.bindings),
            component, config, hierarchyData, model;

        if (binding) {
            hierarchyData = {};

            Object.entries(binding).forEach(([componentId, configObject]) => {
                component = Neo.getComponent(componentId) || Neo.get(componentId); // timing issue: the cmp might not be registered inside manager.Component yet
                config    = {};
                model     = component.getModel() || me;

                if (!hierarchyData[model.id]) {
                    hierarchyData[model.id] = model.getHierarchyData()
                }

                Object.entries(configObject).forEach(([configField, formatter]) => {
                    // we can not call me.callFormatter(), since a data property inside a parent model
                    // could have changed which is relying on data properties inside a closer model
                    config[configField] = model.callFormatter(formatter, hierarchyData[model.id])
                });

                component?.set(config)
            })
        }

        me.resolveFormulas({key, id: me.id, oldValue, value});

        me.fire('dataPropertyChange', {key, id: me.id, oldValue, value})
    }

    /**
     * This method will assign binding values at the earliest possible point inside the component lifecycle.
     * It can not store bindings though, since child component ids most likely do not exist yet.
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me     = this,
            config = {};

        if (component.bind) {
            me.createBindings(component);

            Object.entries(component.bind).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    value.key = me.getFormatterVariables(value.value)[0];
                    value = value.value
                }

                if (me.isStoreValue(value)) {
                    me.resolveStore(component, key, value.substring(7)) // remove the "stores." at the start
                } else {
                    config[key] = me.callFormatter(value)
                }
            });

            component.set(config)
        }
    }

    /**
     * Removes all bindings for a given component id inside this model
     * as well as inside all parent models.
     * @param {String} componentId
     */
    removeBindings(componentId) {
        let me          = this,
            parentModel = me.getParent();

        Object.entries(me.bindings).forEach(([dataProperty, binding]) => {
            delete binding[componentId]
        });

        parentModel?.removeBindings(componentId)
    }

    /**
     * Resolve the formulas initially and update, when data change
     * @param {Object} data data from event or null on initial call
     */
    resolveFormulas(data) {
        let me         = this,
            formulas   = me.formulas,
            initialRun = !data,
            affectFormula, bindObject, fn, key, result, value;

        if (formulas) {
            if (!initialRun && (!data.key || !data.value)) {
                console.warn('[ViewModel:formulas] missing key or value', data.key, data.value)
            }

            for ([key, value] of Object.entries(formulas)) {
                affectFormula = true;

                // Check if the change affects a formula
                if (!initialRun) {
                    affectFormula = Object.values(value.bind).includes(data.key)
                }

                if (affectFormula) {
                    // Create Bind-Object and fill with new values
                    bindObject = Neo.clone(value.bind);
                    fn         = value.get;

                    Object.keys(bindObject).forEach((key, index) => {
                        bindObject[key] = me.getData(bindObject[key])
                    });

                    // Calc the formula
                    result = fn(bindObject);

                    // Assign if no error or null
                    if (isNaN(result)) {
                        me.setData(key, null)
                    } else {
                        me.setData(key, result)
                    }
                }
            }
        }
    }

    /**
     * @param {Neo.component.Base} component
     * @param {String} configName
     * @param {String} storeName
     */
    resolveStore(component, configName, storeName) {
        let store = this.getStore(storeName);

        if (component[configName] !== store) {
            component[configName] = store
        }
    }

    /**
     * The method will assign all values to the closest model where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     * @param {Object|String} key
     * @param {*} value
     */
    setData(key, value) {
        this.internalSetData(key, value, this)
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent models.
     * @param {Object|String} key
     * @param {*} value
     */
    setDataAtSameLevel(key, value) {
        this.internalSetData(key, value)
    }
}

Neo.setupClass(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStDO0FBQ087QUFDTjtBQUNLOztBQUVyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQUk7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7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ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tb2RlbC9Db21wb25lbnQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuY29uc3QgZGF0YVZhcmlhYmxlUmVnZXggPSAvZGF0YSgoPyEoXFwuW2Etel9dXFx3KlxcKFxcKSkpXFwuW2Etel9dXFx3KikrL2dpLFxuICAgICAgdmFyaWFibGVOYW1lUmVnZXggPSAvXlxcdyovO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIGNvbXBvbmVudCAodmlldykgbW9kZWwgZm9yIGFkZGluZyBiaW5kaW5ncyB0byBjb25maWdzXG4gKiBAY2xhc3MgTmVvLm1vZGVsLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubW9kZWwuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubW9kZWwuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1tb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb21wb25lbnQtbW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGJpbmRpbmdzXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJpbmRpbmdzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZGF0YV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZm9ybXVsYXNfPW51bGxcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogICAgIGRhdGE6IHtcbiAgICAgICAgICogICAgICAgICBhOiAxLFxuICAgICAgICAgKiAgICAgICAgIGI6IDJcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogICAgIGZvcm11bGFzOiB7XG4gICAgICAgICAqICAgICAgICAgYVBsdXNCOiB7XG4gICAgICAgICAqICAgICAgICAgICAgIGJpbmQ6IHtcbiAgICAgICAgICogICAgICAgICAgICAgICAgIGZvbzogJ2EnLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgYmFyOiAnYidcbiAgICAgICAgICogICAgICAgICAgICAgfSxcbiAgICAgICAgICogICAgICAgICAgICAgZ2V0KGRhdGEpIHtcbiAgICAgICAgICogICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmZvbyArIGRhdGEuYmFyXG4gICAgICAgICAqICAgICAgICAgICAgIH1cbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICBmb3JtdWxhc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8ubW9kZWwuQ29tcG9uZW50fG51bGx9IHBhcmVudF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBzdG9yZXNfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3Jlc186IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5pc1VzaW5nVmlld01vZGVscyA9IHRydWU7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZ2l2ZW4ga2V5L3ZhbHVlIGNvbWJpbmF0aW9uIG9uIHRoaXMgbW9kZWwgbGV2ZWwuXG4gICAgICogVGhlIG1ldGhvZCBpcyB1c2VkIGJ5IHNldERhdGEoKSAmIHNldERhdGFBdFNhbWVMZXZlbCgpXG4gICAgICogaW4gY2FzZSB0aGUgIGRhdGEgcHJvcGVydHkgZG9lcyBub3QgZXhpc3QgeWV0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSwgc2NvcGU7XG5cbiAgICAgICAgTmVvLm5zKGtleSwgdHJ1ZSwgbWUuZGF0YSk7XG5cbiAgICAgICAgZGF0YSA9IG1lLmdldERhdGFTY29wZShrZXkpO1xuICAgICAgICBzY29wZSA9IGRhdGEuc2NvcGU7XG5cbiAgICAgICAgc2NvcGVbZGF0YS5rZXldID0gdmFsdWU7XG5cbiAgICAgICAgbWUuY3JlYXRlRGF0YVByb3BlcnRpZXMobWUuZGF0YSwgJ2RhdGEnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZGF0YSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5jcmVhdGVEYXRhUHJvcGVydGllcyh2YWx1ZSwgJ2RhdGEnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZm9ybXVsYXMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZvcm11bGFzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnJlc29sdmVGb3JtdWxhcyhudWxsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZGF0YSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RGF0YSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwYXJlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYXJlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlIDogdGhpcy5nZXRQYXJlbnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0b3JlcyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3Jlcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGNvbnRyb2xsZXIgPSB0aGlzLmNvbXBvbmVudC5nZXRDb250cm9sbGVyKCk7XG5cbiAgICAgICAgdmFsdWUgJiYgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHN0b3JlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyPy5wYXJzZUNvbmZpZyhzdG9yZVZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlW2tleV0gPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2Uoc3RvcmVWYWx1ZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9ybWF0dGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGE9bnVsbCBvcHRpb25hbGx5IHBhc3MgdGhpcy5nZXRIaWVyYXJjaHlEYXRhKCkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNhbGxGb3JtYXR0ZXIoZm9ybWF0dGVyLCBkYXRhPW51bGwpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5nZXRIaWVyYXJjaHlEYXRhKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuY2FsbCh0aGlzLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBiaW5kaW5nIGluIGNhc2UgYSBtYXRjaGluZyBkYXRhIHByb3BlcnR5IGRvZXMgZXhpc3QuXG4gICAgICogT3RoZXJ3aXNlIGl0IHdpbGwgdXNlIHRoZSBjbG9zZXN0IG1vZGVsIHdpdGggYSBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdHRlclxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmcoY29tcG9uZW50SWQsIGtleSwgdmFsdWUsIGZvcm1hdHRlcikge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhICAgID0gbWUuZ2V0RGF0YVNjb3BlKGtleSksXG4gICAgICAgICAgICBzY29wZSAgID0gZGF0YS5zY29wZSxcbiAgICAgICAgICAgIGtleUxlYWYgPSBkYXRhLmtleSxcbiAgICAgICAgICAgIGJpbmRpbmdTY29wZSwgcGFyZW50TW9kZWw7XG5cbiAgICAgICAgaWYgKHNjb3BlPy5oYXNPd25Qcm9wZXJ0eShrZXlMZWFmKSkge1xuICAgICAgICAgICAgYmluZGluZ1Njb3BlID0gTmVvLm5zKGAke2tleX0uJHtjb21wb25lbnRJZH1gLCB0cnVlLCBtZS5iaW5kaW5ncyk7XG4gICAgICAgICAgICBiaW5kaW5nU2NvcGVbdmFsdWVdID0gZm9ybWF0dGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRNb2RlbC5jcmVhdGVCaW5kaW5nKGNvbXBvbmVudElkLCBrZXksIHZhbHVlLCBmb3JtYXR0ZXIpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIG1vZGVsLkNvbXBvbmVudCBmb3VuZCB3aXRoIHRoZSBzcGVjaWZpZWQgZGF0YSBwcm9wZXJ0eScsIGNvbXBvbmVudElkLCBrZXlMZWFmLCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBiaW5kaW5nIGluIGNhc2UgYSBtYXRjaGluZyBkYXRhIHByb3BlcnR5IGRvZXMgZXhpc3QuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgY2xvc2VzdCBtb2RlbCB3aXRoIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdHRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmdCeUZvcm1hdHRlcihjb21wb25lbnRJZCwgZm9ybWF0dGVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBmb3JtYXR0ZXJWYXJzID0gbWUuZ2V0Rm9ybWF0dGVyVmFyaWFibGVzKGZvcm1hdHRlcik7XG5cbiAgICAgICAgZm9ybWF0dGVyVmFycy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBtZS5jcmVhdGVCaW5kaW5nKGNvbXBvbmVudElkLCBrZXksIHZhbHVlLCBmb3JtYXR0ZXIpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmdzKGNvbXBvbmVudCkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhjb21wb25lbnQuYmluZCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU3RvcmVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJpbmRpbmdCeUZvcm1hdHRlcihjb21wb25lbnQuaWQsIHZhbHVlLCBrZXkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICovXG4gICAgY3JlYXRlRGF0YVByb3BlcnRpZXMoY29uZmlnLCBwYXRoKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHJvb3QgPSBOZW8ubnMocGF0aCwgZmFsc2UsIG1lKSxcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsIGtleVZhbHVlLCBuZXdQYXRoO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWtleS5zdGFydHNXaXRoKCdfJykpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyb290LCBrZXkpO1xuICAgICAgICAgICAgICAgIG5ld1BhdGggICAgPSBgJHtwYXRofS4ke2tleX1gXG5cbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlWYWx1ZSA9IGNvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVEYXRhUHJvcGVydHkoa2V5LCBuZXdQYXRoLCByb290KTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFtrZXldID0ga2V5VmFsdWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVEYXRhUHJvcGVydGllcyhjb25maWdba2V5XSwgbmV3UGF0aClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3Q9dGhpcy5kYXRhXG4gICAgICovXG4gICAgY3JlYXRlRGF0YVByb3BlcnR5KGtleSwgcGF0aCwgcm9vdD10aGlzLmRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAocGF0aD8uc3RhcnRzV2l0aCgnZGF0YS4nKSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDUpXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocm9vdCwga2V5LCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RbJ18nICsga2V5XVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IF9rZXkgICAgID0gYF8ke2tleX1gLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJvb3RbX2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RbX2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvb3QsIF9rZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZSAgOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFtfa2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm9uRGF0YVByb3BlcnR5Q2hhbmdlKHBhdGggPyBwYXRoIDoga2V5LCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtudHlwZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29udHJvbGxlcihudHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZ2V0Q29udHJvbGxlcihudHlwZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdGhlIGNsb3Nlc3QgZGF0YSBwcm9wZXJ0eSBpbnNpZGUgdGhlIFZNIHBhcmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtOZW8ubW9kZWwuQ29tcG9uZW50fSBvcmlnaW5Nb2RlbD10aGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICogQHJldHVybnMgeyp9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0RGF0YShrZXksIG9yaWdpbk1vZGVsPXRoaXMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmdldERhdGFTY29wZShrZXkpLFxuICAgICAgICAgICAgc2NvcGUgICA9IGRhdGEuc2NvcGUsXG4gICAgICAgICAgICBrZXlMZWFmID0gZGF0YS5rZXksXG4gICAgICAgICAgICBwYXJlbnRNb2RlbDtcblxuICAgICAgICBpZiAoc2NvcGU/Lmhhc093blByb3BlcnR5KGtleUxlYWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVba2V5TGVhZl1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE1vZGVsID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKCFwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgZGF0YSBwcm9wZXJ0eSAnJHtrZXl9JyBkb2VzIG5vdCBleGlzdC5gLCBvcmlnaW5Nb2RlbClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRNb2RlbC5nZXREYXRhKGtleSwgb3JpZ2luTW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBnZXQgdGhlIHNjb3BlIGZvciBhIG5lc3RlZCBkYXRhIHByb3BlcnR5IHZpYSBOZW8ubnMoKSBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOiBwYXNzaW5nIHRoZSB2YWx1ZSAnZm9vLmJhci5iYXonIHdpbGwgcmV0dXJuIHRoZSBiYXIgb2JqZWN0IGFzIHRoZSBzY29wZVxuICAgICAqIGFuZCAnYmF6JyBhcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldERhdGFTY29wZShrZXkpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAga2V5TGVhZiA9IGtleSxcbiAgICAgICAgICAgIGRhdGEgICAgPSBtZS5kYXRhO1xuXG4gICAgICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAga2V5ICAgICA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAga2V5TGVhZiA9IGtleS5wb3AoKTtcbiAgICAgICAgICAgIGRhdGEgICAgPSBOZW8ubnMoa2V5LmpvaW4oJy4nKSwgZmFsc2UsIGRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5ICA6IGtleUxlYWYsXG4gICAgICAgICAgICBzY29wZTogZGF0YVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgZGF0YSB2YXJpYWJsZXMgZnJvbSBhIGdpdmVuIGZvcm1hdHRlciBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGb3JtYXR0ZXJWYXJpYWJsZXModmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2Rpc3QvcHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIzNzFcbiAgICAgICAgICAgIC8vIGluc2lkZSBkaXN0L3Byb2QgdGhlIGZvcm1hdHRlcjpcbiAgICAgICAgICAgIC8vIGRhdGEgPT4gRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0YS5jdXJyZW50RGF0ZSlcbiAgICAgICAgICAgIC8vIHdpbGwgZ2V0IG1pbmlmaWVkIHRvOlxuICAgICAgICAgICAgLy8gZT0+cy5aLmNvbnZlcnRUb3l5eXltbWRkKGUuY3VycmVudERhdGUpXG4gICAgICAgICAgICAvLyB0aGUgbmV3IHN0cmF0ZWd5OiBmaW5kIHRoZSBmaXJzdCB2YXJpYWJsZSBuYW1lID0+IFwiZVwiXG4gICAgICAgICAgICAvLyByZXBsYWNlIGl0IHdpdGggXCJkYXRhXCI6XG4gICAgICAgICAgICAvLyBkYXRhPT5zLlouY29udmVydFRveXl5eW1tZGQoZGF0YS5jdXJyZW50RGF0ZSlcbiAgICAgICAgICAgIC8vIGZyb20gdGhlcmUgd2UgY2FuIHVzZSB0aGUgZGV2IG1vZGUgcmVnZXggYWdhaW4uXG5cbiAgICAgICAgICAgIGxldCBkYXRhTmFtZSAgICAgICA9IHZhbHVlLm1hdGNoKHZhcmlhYmxlTmFtZVJlZ2V4KVswXSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVJlZ0V4cCA9IG5ldyBSZWdFeHAoYChefFteXFxcXHcuXSkoJHtkYXRhTmFtZX0pKD8hXFxcXHcpYCwgJ2cnKTtcblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHZhcmlhYmxlUmVnRXhwLCAnJDFkYXRhJylcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhVmFycyA9IHZhbHVlLm1hdGNoKGRhdGFWYXJpYWJsZVJlZ2V4KSB8fCBbXSxcbiAgICAgICAgICAgIHJlc3VsdCAgID0gW107XG5cbiAgICAgICAgZGF0YVZhcnMuZm9yRWFjaCh2YXJpYWJsZSA9PiB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIFwiZGF0YS5cIiBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUuc3Vic3RyKDUpO1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKHJlc3VsdCwgdmFyaWFibGUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC5zb3J0KCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lcmdlZCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGE9dGhpcy5nZXRQbGFpbkRhdGEoKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBnZXRIaWVyYXJjaHlEYXRhKGRhdGE9dGhpcy5nZXRQbGFpbkRhdGEoKSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucGFyZW50LmdldEhpZXJhcmNoeURhdGEoZGF0YSksXG4gICAgICAgICAgICAgICAgLi4ubWUuZ2V0UGxhaW5EYXRhKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5nZXRQbGFpbkRhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwbGFpbiB2ZXJzaW9uIG9mIHRoaXMuZGF0YS5cbiAgICAgKiBUaGlzIGV4Y2x1ZGVzIHRoZSBwcm9wZXJ0eSBnZXR0ZXJzICYgc2V0dGVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YT10aGlzLmRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFBsYWluRGF0YShkYXRhPXRoaXMuZGF0YSkge1xuICAgICAgICBsZXQgcGxhaW5EYXRhID0ge307XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcGxhaW5EYXRhW2tleV0gPSB0aGlzLmdldFBsYWluRGF0YSh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhaW5EYXRhW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGxhaW5EYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IG1vZGVsIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8ubW9kZWwuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5jb21wb25lbnQucGFyZW50Py5nZXRNb2RlbCgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdGhlIGNsb3Nlc3Qgc3RvcmUgaW5zaWRlIHRoZSBWTSBwYXJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudH0gb3JpZ2luTW9kZWw9dGhpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKi9cbiAgICBnZXRTdG9yZShrZXksIG9yaWdpbk1vZGVsPXRoaXMpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdG9yZXMgPSBtZS5zdG9yZXMsXG4gICAgICAgICAgICBwYXJlbnRNb2RlbDtcblxuICAgICAgICBpZiAoc3RvcmVzPy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVzW2tleV1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE1vZGVsID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKCFwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgc3RvcmUgJyR7a2V5fScgbm90IGZvdW5kIGluc2lkZSB0aGlzIG1vZGVsIG9yIHBhcmVudHMuYCwgb3JpZ2luTW9kZWwpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50TW9kZWwuZ2V0U3RvcmUoa2V5LCBvcmlnaW5Nb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gYXZvaWQgY29kZSByZWR1bmRhbmN5LlxuICAgICAqIFVzZSBzZXREYXRhKCkgb3Igc2V0RGF0YUF0U2FtZUxldmVsKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIFBhc3NpbmcgYW4gb3JpZ2luTW9kZWwgcGFyYW0gd2lsbCB0cnkgdG8gc2V0IGVhY2gga2V5IG9uIHRoZSBjbG9zZXN0IHByb3BlcnR5IG1hdGNoXG4gICAgICogaW5zaWRlIHRoZSBwYXJlbnQgbW9kZWwgY2hhaW4gPT4gc2V0RGF0YSgpXG4gICAgICogTm90IHBhc3NpbmcgaXQgd2lsbCBzZXQgYWxsIHZhbHVlcyBvbiB0aGUgbW9kZWwgd2hlcmUgdGhlIG1ldGhvZCBnZXRzIGNhbGxlZCA9PiBzZXREYXRhQXRTYW1lTGV2ZWwoKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudH0gW29yaWdpbk1vZGVsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSwgb3JpZ2luTW9kZWwpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEsIGtleUxlYWYsIHBhcmVudE1vZGVsLCBzY29wZTtcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiAhdmFsdWUuaXNSZWNvcmQpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbZGF0YUtleSwgZGF0YVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmludGVybmFsU2V0RGF0YShgJHtrZXl9LiR7ZGF0YUtleX1gLCBkYXRhVmFsdWUsIG9yaWdpbk1vZGVsKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoa2V5KS5mb3JFYWNoKChbZGF0YUtleSwgZGF0YVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmludGVybmFsU2V0RGF0YShkYXRhS2V5LCBkYXRhVmFsdWUsIG9yaWdpbk1vZGVsKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgICAgPSBtZS5nZXREYXRhU2NvcGUoa2V5KTtcbiAgICAgICAgICAgIGtleUxlYWYgPSBkYXRhLmtleTtcbiAgICAgICAgICAgIHNjb3BlICAgPSBkYXRhLnNjb3BlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcGU/Lmhhc093blByb3BlcnR5KGtleUxlYWYpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVba2V5TGVhZl0gPSB2YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE1vZGVsLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCBvcmlnaW5Nb2RlbClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbk1vZGVsLmFkZERhdGFQcm9wZXJ0eShrZXksIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWRkRGF0YVByb3BlcnR5KGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY29udmVuaWVuY2UgbWV0aG9kIHRvIGNoZWNrIGlmIGEgYmluZGluZyB2YWx1ZSBpcyBzdXBwb3NlZCB0byBtYXRjaCBhIHN0b3JlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdG9yZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLnN0YXJ0c1dpdGgoJ3N0b3Jlcy4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgb3JkZXIgY29uZmlncyBhcmUgYXBwbGllZCB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIG1lcmdlQ29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuZGF0YSkge1xuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBOZW8ubWVyZ2UoTmVvLmNsb25lKHRoaXMuY29uc3RydWN0b3IuY29uZmlnLmRhdGEsIHRydWUpIHx8IHt9LCBjb25maWcuZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5tZXJnZUNvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkRhdGFQcm9wZXJ0eUNoYW5nZShrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBiaW5kaW5nID0gbWUuYmluZGluZ3MgJiYgTmVvLm5zKGtleSwgZmFsc2UsIG1lLmJpbmRpbmdzKSxcbiAgICAgICAgICAgIGNvbXBvbmVudCwgY29uZmlnLCBoaWVyYXJjaHlEYXRhLCBtb2RlbDtcblxuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgaGllcmFyY2h5RGF0YSA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhiaW5kaW5nKS5mb3JFYWNoKChbY29tcG9uZW50SWQsIGNvbmZpZ09iamVjdF0pID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGNvbXBvbmVudElkKSB8fCBOZW8uZ2V0KGNvbXBvbmVudElkKTsgLy8gdGltaW5nIGlzc3VlOiB0aGUgY21wIG1pZ2h0IG5vdCBiZSByZWdpc3RlcmVkIGluc2lkZSBtYW5hZ2VyLkNvbXBvbmVudCB5ZXRcbiAgICAgICAgICAgICAgICBjb25maWcgICAgPSB7fTtcbiAgICAgICAgICAgICAgICBtb2RlbCAgICAgPSBjb21wb25lbnQuZ2V0TW9kZWwoKSB8fCBtZTtcblxuICAgICAgICAgICAgICAgIGlmICghaGllcmFyY2h5RGF0YVttb2RlbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGllcmFyY2h5RGF0YVttb2RlbC5pZF0gPSBtb2RlbC5nZXRIaWVyYXJjaHlEYXRhKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb25maWdPYmplY3QpLmZvckVhY2goKFtjb25maWdGaWVsZCwgZm9ybWF0dGVyXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gbm90IGNhbGwgbWUuY2FsbEZvcm1hdHRlcigpLCBzaW5jZSBhIGRhdGEgcHJvcGVydHkgaW5zaWRlIGEgcGFyZW50IG1vZGVsXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvdWxkIGhhdmUgY2hhbmdlZCB3aGljaCBpcyByZWx5aW5nIG9uIGRhdGEgcHJvcGVydGllcyBpbnNpZGUgYSBjbG9zZXIgbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2NvbmZpZ0ZpZWxkXSA9IG1vZGVsLmNhbGxGb3JtYXR0ZXIoZm9ybWF0dGVyLCBoaWVyYXJjaHlEYXRhW21vZGVsLmlkXSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudD8uc2V0KGNvbmZpZylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS5yZXNvbHZlRm9ybXVsYXMoe2tleSwgaWQ6IG1lLmlkLCBvbGRWYWx1ZSwgdmFsdWV9KTtcblxuICAgICAgICBtZS5maXJlKCdkYXRhUHJvcGVydHlDaGFuZ2UnLCB7a2V5LCBpZDogbWUuaWQsIG9sZFZhbHVlLCB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBhc3NpZ24gYmluZGluZyB2YWx1ZXMgYXQgdGhlIGVhcmxpZXN0IHBvc3NpYmxlIHBvaW50IGluc2lkZSB0aGUgY29tcG9uZW50IGxpZmVjeWNsZS5cbiAgICAgKiBJdCBjYW4gbm90IHN0b3JlIGJpbmRpbmdzIHRob3VnaCwgc2luY2UgY2hpbGQgY29tcG9uZW50IGlkcyBtb3N0IGxpa2VseSBkbyBub3QgZXhpc3QgeWV0LlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnQ9dGhpcy5jb21wb25lbnRcbiAgICAgKi9cbiAgICBwYXJzZUNvbmZpZyhjb21wb25lbnQ9dGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSB7fTtcblxuICAgICAgICBpZiAoY29tcG9uZW50LmJpbmQpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUJpbmRpbmdzKGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbXBvbmVudC5iaW5kKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5rZXkgPSBtZS5nZXRGb3JtYXR0ZXJWYXJpYWJsZXModmFsdWUudmFsdWUpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmlzU3RvcmVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVzb2x2ZVN0b3JlKGNvbXBvbmVudCwga2V5LCB2YWx1ZS5zdWJzdHJpbmcoNykpIC8vIHJlbW92ZSB0aGUgXCJzdG9yZXMuXCIgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2tleV0gPSBtZS5jYWxsRm9ybWF0dGVyKHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb21wb25lbnQuc2V0KGNvbmZpZylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGJpbmRpbmdzIGZvciBhIGdpdmVuIGNvbXBvbmVudCBpZCBpbnNpZGUgdGhpcyBtb2RlbFxuICAgICAqIGFzIHdlbGwgYXMgaW5zaWRlIGFsbCBwYXJlbnQgbW9kZWxzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqL1xuICAgIHJlbW92ZUJpbmRpbmdzKGNvbXBvbmVudElkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1lLmJpbmRpbmdzKS5mb3JFYWNoKChbZGF0YVByb3BlcnR5LCBiaW5kaW5nXSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGJpbmRpbmdbY29tcG9uZW50SWRdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBhcmVudE1vZGVsPy5yZW1vdmVCaW5kaW5ncyhjb21wb25lbnRJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHRoZSBmb3JtdWxhcyBpbml0aWFsbHkgYW5kIHVwZGF0ZSwgd2hlbiBkYXRhIGNoYW5nZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIGRhdGEgZnJvbSBldmVudCBvciBudWxsIG9uIGluaXRpYWwgY2FsbFxuICAgICAqL1xuICAgIHJlc29sdmVGb3JtdWxhcyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZvcm11bGFzICAgPSBtZS5mb3JtdWxhcyxcbiAgICAgICAgICAgIGluaXRpYWxSdW4gPSAhZGF0YSxcbiAgICAgICAgICAgIGFmZmVjdEZvcm11bGEsIGJpbmRPYmplY3QsIGZuLCBrZXksIHJlc3VsdCwgdmFsdWU7XG5cbiAgICAgICAgaWYgKGZvcm11bGFzKSB7XG4gICAgICAgICAgICBpZiAoIWluaXRpYWxSdW4gJiYgKCFkYXRhLmtleSB8fCAhZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tWaWV3TW9kZWw6Zm9ybXVsYXNdIG1pc3Npbmcga2V5IG9yIHZhbHVlJywgZGF0YS5rZXksIGRhdGEudmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZvcm11bGFzKSkge1xuICAgICAgICAgICAgICAgIGFmZmVjdEZvcm11bGEgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNoYW5nZSBhZmZlY3RzIGEgZm9ybXVsYVxuICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbFJ1bikge1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RGb3JtdWxhID0gT2JqZWN0LnZhbHVlcyh2YWx1ZS5iaW5kKS5pbmNsdWRlcyhkYXRhLmtleSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWZmZWN0Rm9ybXVsYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgQmluZC1PYmplY3QgYW5kIGZpbGwgd2l0aCBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGJpbmRPYmplY3QgPSBOZW8uY2xvbmUodmFsdWUuYmluZCk7XG4gICAgICAgICAgICAgICAgICAgIGZuICAgICAgICAgPSB2YWx1ZS5nZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYmluZE9iamVjdCkuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZE9iamVjdFtrZXldID0gbWUuZ2V0RGF0YShiaW5kT2JqZWN0W2tleV0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGMgdGhlIGZvcm11bGFcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4oYmluZE9iamVjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIGlmIG5vIGVycm9yIG9yIG51bGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldERhdGEoa2V5LCBudWxsKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0RGF0YShrZXksIHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZU5hbWVcbiAgICAgKi9cbiAgICByZXNvbHZlU3RvcmUoY29tcG9uZW50LCBjb25maWdOYW1lLCBzdG9yZU5hbWUpIHtcbiAgICAgICAgbGV0IHN0b3JlID0gdGhpcy5nZXRTdG9yZShzdG9yZU5hbWUpO1xuXG4gICAgICAgIGlmIChjb21wb25lbnRbY29uZmlnTmFtZV0gIT09IHN0b3JlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRbY29uZmlnTmFtZV0gPSBzdG9yZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB3aWxsIGFzc2lnbiBhbGwgdmFsdWVzIHRvIHRoZSBjbG9zZXN0IG1vZGVsIHdoZXJlIGl0IGZpbmRzIGFuIGV4aXN0aW5nIGtleS5cbiAgICAgKiBJbiBjYXNlIG5vIG1hdGNoIGlzIGZvdW5kIGluc2lkZSB0aGUgcGFyZW50IGNoYWluLCBhIG5ldyBkYXRhIHByb3BlcnR5IHdpbGwgZ2V0IGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXREYXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSwgdGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiBzZXREYXRhKCkgaW4gY2FzZSB5b3Ugd2FudCB0byBlbmZvcmNlXG4gICAgICogc2V0dGluZyBhbGwga2V5cyBvbiB0aGlzIGluc3RhbmNlIGluc3RlYWQgb2YgbG9va2luZyBmb3IgbWF0Y2hlcyBpbnNpZGUgcGFyZW50IG1vZGVscy5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXREYXRhQXRTYW1lTGV2ZWwoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlKVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9