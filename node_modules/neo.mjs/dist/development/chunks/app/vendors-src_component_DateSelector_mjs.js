"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_DateSelector_mjs"],{

/***/ "./src/component/DateSelector.mjs":
/*!****************************************!*\
  !*** ./src/component/DateSelector.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _selection_DateSelectorModel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selection/DateSelectorModel.mjs */ "./src/selection/DateSelectorModel.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.component.DateSelector
 * @extends Neo.component.Base
 */
class DateSelector extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.DateSelector'
         * @protected
         */
        className: 'Neo.component.DateSelector',
        /**
         * @member {String} ntype='dateselector'
         * @protected
         */
        ntype: 'dateselector',
        /**
         * @member {String[]} baseCls=['neo-dateselector']
         */
        baseCls: ['neo-dateselector'],
        /**
         * Stores the last date change which got triggered while a month / year transition was running
         * @member {Date|null} cachedUpdate=null
         * @protected
         */
        cachedUpdate: null,
        /**
         * Date object created on the value config
         * @member {Date|null} currentDate_=null
         * @protected
         */
        currentDate_: null,
        /**
         * @member {String} dateFormat='Y-m-d'
         */
        dateFormat: 'Y-m-d',
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='short'
         */
        dayNameFormat_: 'short',
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * Internal flag to prevent changing the date while change animations are still running
         * @member {Boolean} isUpdating_=false
         * @protected
         */
        isUpdating_: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * @member {String} locale_=Neo.config.locale
         */
        locale_: Neo.config.locale,
        /**
         * Used for wheel events. min value = 1.
         * A higher value means lesser sensitivity for wheel events
         * => you need to scroll "more" to trigger a month / year change
         * @member {Number} mouseWheelDelta=1
         */
        mouseWheelDelta: 1,
        /**
         * True to scroll new years in from the top
         * @member {Boolean} scrollNewYearFromTop=false
         */
        scrollNewYearFromTop: false,
        /**
         * Either pass a selection.Model module, an instance or a config object
         * @member {Object|Neo.selection.Model} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * True to show inner cell & header cell borders
         * @member {Boolean} showCellBorders_=true
         */
        showCellBorders_: false,
        /**
         * True to show the days of the previous or next month (not selectable)
         * @member {Boolean} showDisabledDays_=true
         */
        showDisabledDays_: true,
        /**
         * @member {Boolean} showWeekends_=true
         */
        showWeekends_: true,
        /**
         * True to use sliding animations
         * @member {Boolean} useAnimations=true
         */
        useAnimations: true,
        /**
         * @member {String} value_=DateUtil.convertToyyyymmdd(new Date())
         */
        value_: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(todayDate),
        /**
         * 0-6 => Sun-Sat
         * @member {Number} weekStartDay_=0
         */
        weekStartDay_: 0,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tabIndex: -1, cn: [
            {cls: ['neo-dateselector-header'], cn: [
                {cls: ['neo-nav-button', 'neo-prev-button']},
                {cls: ['neo-center-region'], cn: [
                    {cls: ['neo-month-text']},
                    {cls: ['neo-year-text']}
                ]},
                {cls: ['neo-nav-button', 'neo-next-button']}
            ]},
            {cls: ['neo-dateselector-content'], cn: []}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click: me.onComponentClick, scope: me},
            {wheel: me.onComponentWheel, scope: me}
        ]);
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        let me = this,
            dayIncrement, method, methodParams,  monthIncrement, yearIncrement;

        if (me.mounted) {
            dayIncrement   = value.getDate()     - oldValue.getDate();
            monthIncrement = value.getMonth()    - oldValue.getMonth();
            yearIncrement  = value.getFullYear() - oldValue.getFullYear();

            if (monthIncrement !== 0) { // gets used when month & year changed as well
                method       = 'changeMonth';
                methodParams = [monthIncrement, yearIncrement];
            } else if (yearIncrement !== 0) {
                method       = 'changeYear';
                methodParams = [yearIncrement];
            } else if (dayIncrement !== 0) {
                me.selectionModel.select(me.id + '__' + _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(value));
            }

            if (method) {
                if (me.containsFocus) {
                    Neo.main.DomAccess.focus({
                        id: me.id
                    }).then(data => {
                        me[method](...methodParams);
                    });
                } else {
                    me[method](...methodParams);
                }
            }
        } else if (value) {
            me.updateHeaderMonth(0, 0, true);
            me.updateHeaderYear(0, true);
            me.recreateDayViewContent(false, false)
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        this.updateHeaderDays(value, oldValue);
    }

    /**
     * Triggered after the isUpdating config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsUpdating(value, oldValue) {
        if (value === false) {
            let me = this;

            if (me.cachedUpdate && me.cachedUpdate !== new Date(`${me.value}T00:00:00.000Z`)) {
                me.afterSetValue(me.value, _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(me.cachedUpdate));
            }

            me.cachedUpdate = null;
        }
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue !== undefined) {
            let me   = this,
                dt   = new Intl.DateTimeFormat(me.locale, {month: 'short'});

            me.updateHeaderDays(me.dayNameFormat, '', true);

            me.getHeaderMonthEl().html = dt.format(me.currentDate);

            me.update();
        }
    }

    /**
     * Triggered after the showCellBorders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowCellBorders(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][value ? 'remove' : 'add'](cls, 'neo-hide-inner-borders');
        me.cls = cls;
    }

    /**
     * Triggered after the showDisabledDays config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowDisabledDays(value, oldValue) {
        oldValue !== undefined && this.recreateDayViewContent();
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        if (oldValue !== undefined) {
            let me  = this,
                len = 7,
                i, item;

            me.getCenterContentEl().cn.forEach((row, index) => {
                // ignore the header
                if (index > 0) {
                    for (i=0; i < len; i++) {
                        item = row.cn[i];

                        if (item.cls.includes('neo-weekend')) {
                            if (value) {
                                delete item.removeDom;
                            } else {
                                item.removeDom = true;
                            }
                        }
                    }
                }
            });

            // triggers the vdom update
            me.updateHeaderDays(me.dayNameFormat, '')
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        oldValue !== undefined && value.register(this)
    }

    /**
     * Triggered after the value config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this;

        if (!me.isUpdating) {
            me.currentDate = new Date(`${value}T00:00:00.000Z`);

            me.fire('change', {
                component: me,
                oldValue,
                value
            })
        } else {
            me.cacheUpdate()
        }
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        oldValue !== undefined && this.recreateDayViewContent(false, false);
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.dayNameFormats);
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue && oldValue.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_DateSelectorModel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }

    /**
     * Triggered before the weekStartDay config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetWeekStartDay(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'weekStartDay', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.weekStartDays);
    }

    /**
     * Stores the last date change which could not get applied while a transition was running
     * @param {Date} [date=this.currentDate]
     * @protected
     */
    cacheUpdate(date=this.currentDate) {
        this.cachedUpdate = date;
    }

    /**
     * @param {Number} increment
     * @param {Number} yearIncrement
     */
    changeMonth(increment, yearIncrement) {
        let me             = this,
            slideDirection = yearIncrement > 0 ? 'right' : yearIncrement < 0 ? 'left' : increment < 0 ? 'left' : 'right',
            headerMonthOpts, vdom, x;

        if (!me.useAnimations) {
            me.recreateContent(increment, yearIncrement);
        } else {
            if (!me.isUpdating) {
                me.isUpdating = true;

                me.getDomRect([me.getCenterContentEl().id, me.getHeaderMonthEl().id]).then(data => {
                    vdom = me.vdom;
                    x    = slideDirection === 'right' ? 0 : -data[0].width;

                    vdom.cn.push(
                        {cls: ['neo-relative'], cn: [
                            {cls: ['neo-animation-wrapper'], style: {height: `${data[0].height}px`, transform: `translateX(${x}px)`, width: `${2 * data[0].width}px`}, cn: [
                                {cls: ['neo-dateselector-content'], cn: []}
                            ]}
                        ]}
                    );

                    headerMonthOpts = me.updateHeaderMonth(increment, yearIncrement, true, data[1]);

                    if (yearIncrement !== 0) {
                        me.updateHeaderYear(increment, true);
                    }

                    me.createDayViewContent(true, vdom.cn[2].cn[0].cn[0]);
                    vdom.cn[2].cn[0].cn[slideDirection === 'right'? 'unshift' : 'push'](vdom.cn[1]);
                    vdom.cn.splice(1, 1);

                    me.promiseVdomUpdate().then(() => {
                        me.changeMonthTransitionCallback({data: data[0], slideDirection: slideDirection});
                        me.updateHeaderMonthTransitionCallback(headerMonthOpts);
                        me.update();

                        setTimeout(() => {
                            me.changeMonthWrapperCallback(slideDirection);
                            me.updateHeaderMonthWrapperCallback(headerMonthOpts);
                            me.triggerVdomUpdate();
                        }, 300);
                    });
                });
            } else {
                me.cacheUpdate();
            }
        }
    }

    /**
     * Slides the wrapper div to the left or right
     * @param {Object} opts
     * @param {Object} opts.data
     * @param {String} opts.slideDirection
     * @protected
     */
    changeMonthTransitionCallback(opts) {
        let me   = this,
            vdom = me.vdom,
            {data, slideDirection} = opts,
            x;

        x = slideDirection === 'right' ? -data.width : 0;
        vdom.cn[1].cn[0].style.transform = `translateX(${x}px)`;
    }

    /**
     * Replaces the wrapper div with the target month
     * @param {String} slideDirection
     * @protected
     */
    changeMonthWrapperCallback(slideDirection) {
        let me   = this,
            vdom = me.vdom;

        vdom.cn[1] = vdom.cn[1].cn[0].cn[slideDirection === 'right' ? 1 : 0];
    }

    /**
     * @param {Number} increment
     */
    changeYear(increment) {
        let me = this,
            scrollFromTop, style, vdom, y;

        if (!me.useAnimations) {
            me.recreateContent(0, increment);
        } else {
            if (!me.isUpdating) {
                me.isUpdating = true;

                me.getDomRect(me.getCenterContentEl().id).then(data => {
                    scrollFromTop = me.scrollNewYearFromTop && increment < 0 || !me.scrollNewYearFromTop && increment > 0;
                    vdom          = me.vdom;
                    y             = scrollFromTop ? 0 : -data.height;

                    style = {
                        flexDirection: 'column',
                        height       : `${2 * data.height}px`,
                        transform    : `translateY(${y}px)`,
                        width        : `${data.width}px`
                    };

                    vdom.cn.push(
                        {cls: ['neo-relative'], cn: [
                            {cls: ['neo-animation-wrapper'], style: style, cn: [
                                {cls: ['neo-dateselector-content'], cn: []}
                            ]}
                        ]}
                    );

                    me.updateHeaderYear(increment, true);

                    me.createDayViewContent(true, vdom.cn[2].cn[0].cn[0]);
                    vdom.cn[2].cn[0].cn[scrollFromTop ? 'unshift' : 'push'](vdom.cn[1]);
                    vdom.cn.splice(1, 1);

                    me.promiseVdomUpdate(vdom).then(() => {
                        y = scrollFromTop ? -data.height : 0;
                        vdom.cn[1].cn[0].style.transform = `translateY(${y}px)`;
                        me.update();

                        setTimeout(() => {
                            vdom.cn[1] = vdom.cn[1].cn[0].cn[scrollFromTop ? 1 : 0];
                            me.triggerVdomUpdate();
                        }, 300);
                    });
                });
            } else {
                me.cacheUpdate();
            }
        }
    }

    /**
     *
     */
    createDayNamesRow() {
        let me   = this,
            date = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(me.currentDate),
            i    = 0,
            len  = 7,
            row  = {cls: ['neo-row', 'neo-header-row'], cn: []},
            config, day;

        date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

        for (; i < len; i++) {
            config =
            {cls: ['neo-cell'], cn: [
                {cls : ['neo-cell-content'], html: me.intlFormat_day.format(date)}
            ]};

            day = date.getDay();

            if (!me.showWeekends && (day === 0 || day === 6)) {
                config.removeDom = true;
            }

            row.cn.push(config);

            date.setDate(date.getDate() + 1);
        }

        return row;
    }

    /**
     * @param {Boolean} silent=false true to update the vdom silently
     * @param {Object} [containerEl]
     */
    createDayViewContent(silent=false, containerEl) {
        let me              = this,
            currentDate     = me.currentDate,
            currentDay      = currentDate.getDate(),
            currentMonth    = currentDate.getMonth(),
            currentYear     = currentDate.getFullYear(),
            date            = me.currentDate, // cloned
            valueDate       = new Date(`${me.value}T00:00:00.000Z`),
            valueMonth      = valueDate.getMonth(),
            valueYear       = valueDate.getFullYear(),
            daysInMonth     = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].getDaysInMonth(currentDate),
            firstDayInMonth = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].getFirstDayOfMonth(currentDate),
            firstDayOffset  = firstDayInMonth - me.weekStartDay,
            centerEl        = containerEl || me.getCenterContentEl(),
            columns         = 7,
            i               = 0,
            cellId, config, dateDay, day, hasContent, j, row, rows;

        firstDayOffset = firstDayOffset < 0 ? firstDayOffset + 7 : firstDayOffset;
        rows           = (daysInMonth + firstDayOffset) / 7 > 5 ? 6 : 5;
        day            = 1 - firstDayOffset;

        date.setDate(day);

        centerEl.cn.push(me.createDayNamesRow());

        for (; i < rows; i++) {
            row = {cls: ['neo-row'], cn: []};

            for (j=0; j < columns; j++) {
                hasContent = day > 0 && day <= daysInMonth;
                cellId     = me.getCellId(currentYear, currentMonth + 1, day);

                dateDay = date.getDay();

                config ={
                    id      : cellId,
                    cls     : hasContent ? ['neo-cell'] : ['neo-cell', 'neo-disabled'],
                    tabIndex: hasContent ? -1 : null,
                    cn: [{
                        cls : ['neo-cell-content'],
                        html: hasContent ? day : me.showDisabledDays ? date.getDate() : ''
                    }]
                };

                if (dateDay === 0 || dateDay === 6) {
                    if (!me.showWeekends) {
                        config.removeDom = true;
                    }

                    config.cls.push('neo-weekend');
                }

                if (today.year === currentYear && today.month === currentMonth && today.day === day) {
                    config.cn[0].cls.push('neo-today');
                }

                if (valueYear === currentYear && valueMonth === currentMonth && day === currentDay) {
                    config.cls.push('neo-selected');
                    me.selectionModel.items = [cellId]; // silent update
                }

                row.cn.push(config);

                date.setDate(date.getDate() + 1);

                day++;
            }

            centerEl.cn.push(row);
        }

        !silent && me.update()
    }

    /**
     *
     */
    focusCurrentItem() {
        this.focus(this.selectionModel.items[0]);
    }

    /**
     * @param {Number|String} year
     * @param {Number|String} month
     * @param {Number|String} day
     * @returns {String} id
     */
    getCellId(year, month, day) {
        day = day.toString();

        if (day.length < 2) {
            day = '0' + day;
        }

        month = month.toString();

        if (month.length < 2) {
            month = '0' + month;
        }

        return this.id + '__' + year + '-' + month + '-' + day;
    }

    /**
     * @returns {Object}
     */
    getCenterContentEl() {
        return this.vdom.cn[1];
    }

    /**
     * @returns {Object}
     */
    getHeaderMonthEl() {
        return this.vdom.cn[0].cn[1].cn[0];
    }

    /**
     * @returns {Object}
     */
    getHeaderYearEl() {
        return this.vdom.cn[0].cn[1].cn[1];
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        let me     = this,
            cellEl = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(me.vdom, data.path[0].id),
            date   = me.currentDate; // cloned

        date.setDate(parseInt(cellEl.vdom.cn[0].html));
        date = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(date);

        // We want to always trigger a change event.
        // Reason: A form.field.Date can have a null value, and we want to select the current date.
        me._value = date;
        me.afterSetValue(date, null);
    }

    /**
     * @param {Object} data
     */
    onComponentClick(data) {
        let me  = this,
            cls = data.path[0].cls,
            date, monthIncrement;

             if (cls.includes('neo-cell'))        {me.onCellClick(data);}
        else if (cls.includes('neo-next-button')) {monthIncrement =  1;}
        else if (cls.includes('neo-prev-button')) {monthIncrement = -1;}

        if (monthIncrement) {
            date = me.currentDate; // cloned
            date.setMonth(date.getMonth() + monthIncrement);
            me.value = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(date);
        }
    }

    /**
     * @param {Object} data
     */
    onComponentWheel(data) {
        let me         = this,
            wheelDelta = me.mouseWheelDelta,
            date, monthIncrement, yearIncrement;

        if (Math.abs(data.deltaY) >= Math.abs(data.deltaX)) {
                 if (data.deltaY >=  wheelDelta) {yearIncrement  =  1;}
            else if (data.deltaY <= -wheelDelta) {yearIncrement  = -1;}
        } else {
                 if (data.deltaX >=  wheelDelta) {monthIncrement =  1;}
            else if (data.deltaX <= -wheelDelta) {monthIncrement = -1;}
        }

        if (monthIncrement) {
            date = me.currentDate; // cloned
            date.setMonth(date.getMonth() + monthIncrement);
            me.value = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(date);
        } else if (yearIncrement) {
            date = me.currentDate; // cloned
            date.setFullYear(date.getFullYear() + yearIncrement);
            me.value = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(date);
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.selectionModel?.register(this);
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        this.value = items[0].split('__')[1]
    }

    /**
     * Recreates the current centerEl, month & year el
     * @param {Number} monthIncrement
     * @param {Number} yearIncrement
     * @param {Boolean} [silent=false]
     * @protected
     */
    recreateContent(monthIncrement, yearIncrement, silent=false) {
        let me = this;

        me.recreateDayViewContent(true);

        monthIncrement !== 0 && me.updateHeaderMonth(monthIncrement, yearIncrement, true);
        yearIncrement  !== 0 && me.updateHeaderYear(yearIncrement, true);

        me.triggerVdomUpdate(silent);
    }

    /**
     * Recreates the current centerEl
     * @param {Boolean} [silent=false]
     * @param {Boolean} [syncIds=true]
     * @protected
     */
    recreateDayViewContent(silent=false, syncIds=true) {
        let me = this;

        me.getCenterContentEl().cn = [];
        me.createDayViewContent(true);

        if (syncIds) {
            me.syncVdomIds();
        }

        me.triggerVdomUpdate(silent);
    }

    /**
     * Triggers a vdom update & sets isUpdating
     * @param {Boolean} [silent=false]
     * @protected
     */
    triggerVdomUpdate(silent=false) {
        if (!silent) {
            let me = this;

            me.isUpdating = true;

            me.promiseVdomUpdate(me.vdom).then(() => {
                me.isUpdating = false;
            });
        }
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     */
    updateHeaderDays(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});

        if (oldValue !== undefined) {
            let centerEl = me.getCenterContentEl().cn[0],
                date     = me.currentDate, // cloned
                vdom     = me.vdom,
                i        = 0,
                day, node;

            date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

            for (; i < 7; i++) {
                node = centerEl.cn[i];

                node.cn[0].html = me.intlFormat_day.format(date);

                day = date.getDay();

                if (!me.showWeekends && (day === 0 || day === 6)) {
                    node.removeDom = true;
                } else {
                    delete node.removeDom;
                }

                date.setDate(date.getDate() + 1);
            }

            me[silent ? '_vdom' : 'vdom'] = vdom;
        }
    }

    /**
     * @param {Number} increment
     * @param {Number} yearIncrement
     * @param {Boolean} silent=false
     * @param {Object} monthElDomRect
     * @returns {Object|null} opts or null in case no transitions are needed
     */
    updateHeaderMonth(increment, yearIncrement, silent=false, monthElDomRect) {
        let me             = this,
            dt             = new Intl.DateTimeFormat(me.locale, {month: 'short'}),
            currentMonth   = dt.format(me.currentDate),
            monthEl        = me.getHeaderMonthEl(),
            slideDirection = yearIncrement > 0 ? 'bottom' : yearIncrement < 0 ? 'top' : increment < 0 ? 'top' : 'bottom',
            vdom           = me.vdom,
            headerCenterEl, y;

        if (!me.mounted || !me.useAnimations) {
            monthEl.html = currentMonth;
            !silent && me.update()
            return null;
        } else {
            y = slideDirection === 'top' ? 0 : -monthElDomRect.height;

            vdom.cn[0].cn[1].cn.unshift({
                cls  : ['neo-relative-header'],
                style: {
                    height: monthElDomRect.height + 'px',
                    width : monthElDomRect.width  + 'px'
                },
                cn: [{
                    cls: ['neo-animation-wrapper-header'],
                    cn : [],
                    style: {
                        height   : 2 * monthElDomRect.height + 'px',
                        transform: `translateY(${y}px)`,
                        width    : monthElDomRect.width + 'px'
                    }
                }]
            });

            headerCenterEl = vdom.cn[0].cn[1];

            headerCenterEl.cn[0].cn[0].cn.push({
                cls : ['neo-month-text'],
                html: currentMonth
            });

            headerCenterEl.cn[0].cn[0].cn[slideDirection === 'top' ? 'unshift' : 'push'](headerCenterEl.cn[1]);
            headerCenterEl.cn.splice(1, 1);

            me[silent ? '_vdom' : 'vdom'] = vdom;

            return {
                data: monthElDomRect,
                headerCenterEl,
                increment,
                yearIncrement
            };
        }
    }

    /**
     * Slides the wrapper div to the top or bottom
     * @param {Object} opts
     * @param {Object} opts.data
     * @param {Object} opts.headerCenterEl
     * @param {Number} opts.increment
     * @param {Number} opts.yearIncrement
     * @protected
     */
    updateHeaderMonthTransitionCallback(opts) {
        let {data, headerCenterEl, increment, yearIncrement} = opts,
            slideDirection = yearIncrement > 0 ? 'bottom' : yearIncrement < 0 ? 'top' : increment < 0 ? 'top' : 'bottom',
            y;

        y = slideDirection === 'top' ? -data.height : 0;
        headerCenterEl.cn[0].cn[0].style.transform = `translateY(${y}px)`;
    }

    /**
     * Replaces the wrapper div to the left or right
     * @param {Object} opts
     * @param {Object} opts.headerCenterEl
     * @param {Number} opts.increment
     * @param {Number} opts.yearIncrement
     * @protected
     */
    updateHeaderMonthWrapperCallback(opts) {
        let {headerCenterEl, increment, yearIncrement} = opts,
            slideDirection = yearIncrement > 0 ? 'bottom' : yearIncrement < 0 ? 'top' : increment < 0 ? 'top' : 'bottom';

        headerCenterEl.cn[0] = headerCenterEl.cn[0].cn[0].cn[slideDirection === 'top' ? 1 : 0];
    }

    /**
     * @param {Number} increment
     * @param {Boolean} [silent=false]
     */
    updateHeaderYear(increment, silent=false) {
        let me     = this,
            yearEl = me.getHeaderYearEl();

        yearEl.html = me.currentDate.getFullYear();

        !silent && me.update()
    }
}

Neo.applyClassConfig(DateSelector);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DateSelector);


/***/ }),

/***/ "./src/selection/DateSelectorModel.mjs":
/*!*********************************************!*\
  !*** ./src/selection/DateSelectorModel.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");



/**
 * @class Neo.selection.DateSelectorModel
 * @extends Neo.selection.Model
 */
class DateSelectorModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.DateSelectorModel'
         * @protected
         */
        className: 'Neo.selection.DateSelectorModel',
        /**
         * @member {String} ntype='selection-dateselectormodel'
         * @protected
         */
        ntype: 'selection-dateselectormodel',
        /**
         * true to stay inside the same column when navigating up or downwards
         * @member {Boolean} stayInColumn=false
         */
        stayInColumn: false
    }

    /**
     * @param {Object} data
     * @returns {Date}
     */
    getCellDate(data) {
        let selection = this.getSelection(),
            idArray, tmpArray;

        if (selection[0]) {
            idArray = selection[0].split('__');
        } else {
            idArray = data.path[0].id.split('__');
        }

        tmpArray = idArray[1].split('-').map(e => parseInt(e));

        tmpArray[1]--; // the month inside the view is 1 based, a date needs 0 based

        return new Date(...tmpArray);
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        this.onNavKeyRow(data, 7);
    }

    /**
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        this.onNavKeyColumn(data, -1);
    }

    /**
     * @param {Object} data
     */
    onKeyDownRight(data) {
        this.onNavKeyColumn(data, 1);
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        this.onNavKeyRow(data, -7);
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKeyColumn(data, step) {
        let me       = this,
            cellDate = me.getCellDate(data),
            view     = me.view,
            daysInMonth, id, newDay;

        daysInMonth = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getDaysInMonth(cellDate);
        newDay      = (cellDate.getDate() + step) % daysInMonth;

        newDay = newDay === 0 ? daysInMonth : newDay;

        id = view.getCellId(cellDate.getFullYear(), cellDate.getMonth() + 1, newDay);

        me.select(id);
        view.focus(id);
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKeyRow(data, step) {
        let me       = this,
            cellDate = me.getCellDate(data),
            view     = me.view,
            daysInMonth, id, newDay;

        daysInMonth = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getDaysInMonth(cellDate);
        newDay      = cellDate.getDate() + step;

        if (newDay > daysInMonth) {
            if (!me.stayInColumn) {
                newDay += 1;
            }

            while (newDay > 7) {
                newDay -= step;
            }
        } else if (newDay < 1) {
            if (!me.stayInColumn) {
                newDay -= 1;
            }

            while (newDay < daysInMonth - 6) {
                newDay -= step;
            }
        }

        id = view.getCellId(cellDate.getFullYear(), cellDate.getMonth() + 1, newDay);

        me.select(id);
        view.focus(id);
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me    = this,
            scope = {scope: me.id},
            view  = me.view;

        if (view.keys) {
            view.keys._keys.push(
                {fn: 'onKeyDownDown'  ,key: 'Down'  ,...scope},
                {fn: 'onKeyDownLeft'  ,key: 'Left'  ,...scope},
                {fn: 'onKeyDownRight' ,key: 'Right' ,...scope},
                {fn: 'onKeyDownUp'    ,key: 'Up'    ,...scope}
            );
        }
    }

    /**
     *
     */
    unregister() {
        let me    = this,
            scope = {scope: me.id},
            view  = me.view;

        if (view.keys) {
            view.keys.removeKeys([
                {fn: 'onKeyDownDown'  ,key: 'Down'  ,...scope},
                {fn: 'onKeyDownLeft'  ,key: 'Left'  ,...scope},
                {fn: 'onKeyDownRight' ,key: 'Right' ,...scope},
                {fn: 'onKeyDownUp'    ,key: 'Up'    ,...scope}
            ]);
        }

        super.unregister();
    }
}

Neo.applyClassConfig(DateSelectorModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DateSelectorModel);


/***/ }),

/***/ "./src/util/Date.mjs":
/*!***************************!*\
  !*** ./src/util/Date.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Date
 * @extends Neo.core.Base
 */
class DateUtil extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Date'
         * @protected
         */
        className: 'Neo.util.Date',
        /**
         * Valid values for dayNameFormat
         * @member {String[]} dayNameFormats=['narrow', 'short', 'long']
         * @protected
         * @static
         */
        dayNameFormats: ['narrow', 'short', 'long'],
        /**
         * Valid values for monthNameFormat
         * @member {String[]} monthNameFormats=['narrow', 'short', 'long']
         * @protected
         * @static
         */
        monthNameFormats: ['narrow', 'short', 'long'],
        /**
         * Valid values for dayNameFormat
         * @member {Number[]} weekStartDays=[0, 1, 2, 3, 4, 5, 6]
         * @protected
         * @static
         */
        weekStartDays: [0, 1, 2, 3, 4, 5, 6]
    }

    /**
     * Clones a Date instance using the same value
     * @param {Date|null} date
     * @returns {Date|null} the cloned date object
     */
    static clone(date) {
        return date && new Date(date.valueOf()) || null;
    }

    /**
     * Returns the yyyy-mm-dd formatted value of a given Date instance
     * @param {Date} date
     * @returns {String} the yyyy-mm-dd formatted date
     */
    static convertToyyyymmdd(date) {
        return new Date(date.getTime() - (date.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
    }

    /**
     * Returns the amount of days inside the month of a passed date object
     * @param {Date} date
     * @returns {Number} days inside the month
     */
    static getDaysInMonth(date) {
        return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
    }

    /**
     * @param {Date} date
     * @param {Number} weekStartDay 0-6
     * @returns {Number}
     */
    static getFirstDayOffset(date, weekStartDay) {
        let firstDayInMonth = DateUtil.getFirstDayOfMonth(date),
            firstDayOffset  = firstDayInMonth - weekStartDay;

        return firstDayOffset < 0 ? firstDayOffset + 7 : firstDayOffset;
    }

    /**
     * Returns the day number of the first day of a passed date object
     * @param {Date} date
     * @returns {Number} 0-6 (Sun-Sat)
     */
    static getFirstDayOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth(), 1).getDay();
    }

    /**
     * Returns the week number of the passed date
     * https://en.wikipedia.org/wiki/ISO_8601
     * @param {Date} targetDate
     * @returns {Number}
     */
    static getWeekOfYear(targetDate) {
        let date      = new Date(targetDate.valueOf()),
            dayNumber = (targetDate.getUTCDay() + 6) % 7,
            firstThursday;

        date.setUTCDate(date.getUTCDate() - dayNumber + 3);
        firstThursday = date.valueOf();
        date.setUTCMonth(0, 1);

        if (date.getUTCDay() !== 4) {
            date.setUTCMonth(0, 1 + ((4 - date.getUTCDay()) + 7) % 7);
        }

        return Math.ceil((firstThursday - date) /  (7 * 24 * 3600 * 1000)) + 1;
    }

    /**
     * @param {Date} date
     * @param {Number} weekStartDay 0-6
     * @returns {Number} 5-6
     */
    static getWeeksOfMonth(date, weekStartDay) {
        let daysInMonth    = DateUtil.getDaysInMonth(date),
            firstDayOffset = DateUtil.getFirstDayOffset(date, weekStartDay);

        return (daysInMonth + firstDayOffset) / 7 > 5 ? 6 : 5;
    }

    /**
     * Returns true in case the day, month & year of 2 given Date objects are the same
     * @param {Date} date1
     * @param {Date} date2
     * @returns {Boolean}
     */
    static matchDate(date1, date2) {
        return date1.getFullYear() === date2.getFullYear() &&
               date1.getMonth()    === date2.getMonth()    &&
               date1.getDate()     === date2.getDate();
    }
}

Neo.applyClassConfig(DateUtil);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DateUtil);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfRGF0ZVNlbGVjdG9yX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ2I7QUFDd0I7QUFDbEI7QUFDQztBQUNEOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFTO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxnQkFBZ0Isd0VBQTBCO0FBQzFDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWE7QUFDYixpQkFBaUIsMkNBQTJDO0FBQzVELGlCQUFpQjtBQUNqQixxQkFBcUIsd0JBQXdCO0FBQzdDLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsd0RBQXdELHdFQUEwQjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1FQUFtRSxTQUFTO0FBQzVFLDJDQUEyQyx3RUFBMEI7QUFDckU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZUFBZTs7QUFFMUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLE1BQU07O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsK0VBQWlDO0FBQzFHOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtFQUFpQyxRQUFRLHdFQUFpQjtBQUN6RTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsOEVBQWdDO0FBQ3hHOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLDZCQUE2Qix3Q0FBd0MsV0FBVyxlQUFlLDhCQUE4QixFQUFFLGdCQUFnQixrQkFBa0IsSUFBSTtBQUNySyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsOENBQThDO0FBQ3hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQzs7QUFFQTtBQUNBLHlEQUF5RCxFQUFFO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRCxxREFBcUQsRUFBRTtBQUN2RCwwQ0FBMEMsV0FBVztBQUNyRDs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RSxFQUFFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUFjO0FBQ2pDO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EOztBQUVBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQSw4QkFBOEIscUVBQXVCO0FBQ3JELDhCQUE4Qix5RUFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxVQUFVO0FBQ3pCLG1CQUFtQjs7QUFFbkIsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFzQjtBQUMzQyxxQ0FBcUM7O0FBRXJDO0FBQ0EsZUFBZSx3RUFBMEI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQsbURBQW1EO0FBQ25ELG1EQUFtRDs7QUFFbkQ7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSx1QkFBdUIsd0VBQTBCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsVUFBVTtBQUNWLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSx1QkFBdUIsd0VBQTBCO0FBQ2pELFVBQVU7QUFDVixtQ0FBbUM7QUFDbkM7QUFDQSx1QkFBdUIsd0VBQTBCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFLGVBQWU7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGVBQWU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRSxFQUFFO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFlBQVksRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2OEJZO0FBQ0w7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtEQUFLO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IscUVBQXVCO0FBQzdDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxRUFBdUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUE2QztBQUM5RCxpQkFBaUIsNkNBQTZDO0FBQzlELGlCQUFpQiw2Q0FBNkM7QUFDOUQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQsaUJBQWlCLDZDQUE2QztBQUM5RCxpQkFBaUIsNkNBQTZDO0FBQzlELGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxpQkFBaUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hMRzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQUk7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L0RhdGVTZWxlY3Rvci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vRGF0ZVNlbGVjdG9yTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9EYXRlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICAgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IERhdGVTZWxlY3Rvck1vZGVsIGZyb20gJy4uL3NlbGVjdGlvbi9EYXRlU2VsZWN0b3JNb2RlbC5tanMnO1xuaW1wb3J0IERhdGVVdGlsICAgICAgICAgIGZyb20gJy4uL3V0aWwvRGF0ZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcblxuY29uc3QgdG9kYXlEYXRlID0gbmV3IERhdGUoKTtcblxuY29uc3QgdG9kYXkgPSB7XG4gICAgZGF5ICA6IHRvZGF5RGF0ZS5nZXREYXRlKCksXG4gICAgbW9udGg6IHRvZGF5RGF0ZS5nZXRNb250aCgpLFxuICAgIHllYXIgOiB0b2RheURhdGUuZ2V0RnVsbFllYXIoKVxufTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5EYXRlU2VsZWN0b3JcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBEYXRlU2VsZWN0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5EYXRlU2VsZWN0b3InXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuRGF0ZVNlbGVjdG9yJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2RhdGVzZWxlY3RvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkYXRlc2VsZWN0b3InLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZGF0ZXNlbGVjdG9yJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRhdGVzZWxlY3RvciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIHRoZSBsYXN0IGRhdGUgY2hhbmdlIHdoaWNoIGdvdCB0cmlnZ2VyZWQgd2hpbGUgYSBtb250aCAvIHllYXIgdHJhbnNpdGlvbiB3YXMgcnVubmluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfG51bGx9IGNhY2hlZFVwZGF0ZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNhY2hlZFVwZGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGUgb2JqZWN0IGNyZWF0ZWQgb24gdGhlIHZhbHVlIGNvbmZpZ1xuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfG51bGx9IGN1cnJlbnREYXRlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnREYXRlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGF0ZUZvcm1hdD0nWS1tLWQnXG4gICAgICAgICAqL1xuICAgICAgICBkYXRlRm9ybWF0OiAnWS1tLWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm1hdCBvZiB0aGUgY29sdW1uIGhlYWRlcnMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6IG5hcnJvdywgc2hvcnQgJiBsb25nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGF5TmFtZUZvcm1hdF89J3Nob3J0J1xuICAgICAgICAgKi9cbiAgICAgICAgZGF5TmFtZUZvcm1hdF86ICdzaG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfZGF5PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF9kYXk6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHByZXZlbnQgY2hhbmdpbmcgdGhlIGRhdGUgd2hpbGUgY2hhbmdlIGFuaW1hdGlvbnMgYXJlIHN0aWxsIHJ1bm5pbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNVcGRhdGluZ189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNVcGRhdGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbG9jYWxlXz1OZW8uY29uZmlnLmxvY2FsZVxuICAgICAgICAgKi9cbiAgICAgICAgbG9jYWxlXzogTmVvLmNvbmZpZy5sb2NhbGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciB3aGVlbCBldmVudHMuIG1pbiB2YWx1ZSA9IDEuXG4gICAgICAgICAqIEEgaGlnaGVyIHZhbHVlIG1lYW5zIGxlc3NlciBzZW5zaXRpdml0eSBmb3Igd2hlZWwgZXZlbnRzXG4gICAgICAgICAqID0+IHlvdSBuZWVkIHRvIHNjcm9sbCBcIm1vcmVcIiB0byB0cmlnZ2VyIGEgbW9udGggLyB5ZWFyIGNoYW5nZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1vdXNlV2hlZWxEZWx0YT0xXG4gICAgICAgICAqL1xuICAgICAgICBtb3VzZVdoZWVsRGVsdGE6IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNjcm9sbCBuZXcgeWVhcnMgaW4gZnJvbSB0aGUgdG9wXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNjcm9sbE5ld1llYXJGcm9tVG9wPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxOZXdZZWFyRnJvbVRvcDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFaXRoZXIgcGFzcyBhIHNlbGVjdGlvbi5Nb2RlbCBtb2R1bGUsIGFuIGluc3RhbmNlIG9yIGEgY29uZmlnIG9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8TmVvLnNlbGVjdGlvbi5Nb2RlbH0gc2VsZWN0aW9uTW9kZWxfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2hvdyBpbm5lciBjZWxsICYgaGVhZGVyIGNlbGwgYm9yZGVyc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q2VsbEJvcmRlcnNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dDZWxsQm9yZGVyc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBzaG93IHRoZSBkYXlzIG9mIHRoZSBwcmV2aW91cyBvciBuZXh0IG1vbnRoIChub3Qgc2VsZWN0YWJsZSlcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0Rpc2FibGVkRGF5c189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0Rpc2FibGVkRGF5c186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93V2Vla2VuZHNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dXZWVrZW5kc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHVzZSBzbGlkaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQW5pbWF0aW9ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBbmltYXRpb25zOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB2YWx1ZV89RGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQobmV3IERhdGUoKSlcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQodG9kYXlEYXRlKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAtNiA9PiBTdW4tU2F0XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gd2Vla1N0YXJ0RGF5Xz0wXG4gICAgICAgICAqL1xuICAgICAgICB3ZWVrU3RhcnREYXlfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWJJbmRleDogLTEsIGNuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1kYXRlc2VsZWN0b3ItaGVhZGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tbmF2LWJ1dHRvbicsICduZW8tcHJldi1idXR0b24nXX0sXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tY2VudGVyLXJlZ2lvbiddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tb250aC10ZXh0J119LFxuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby15ZWFyLXRleHQnXX1cbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1uYXYtYnV0dG9uJywgJ25lby1uZXh0LWJ1dHRvbiddfVxuICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1kYXRlc2VsZWN0b3ItY29udGVudCddLCBjbjogW119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAge2NsaWNrOiBtZS5vbkNvbXBvbmVudENsaWNrLCBzY29wZTogbWV9LFxuICAgICAgICAgICAge3doZWVsOiBtZS5vbkNvbXBvbmVudFdoZWVsLCBzY29wZTogbWV9XG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY3VycmVudERhdGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtEYXRlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDdXJyZW50RGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGRheUluY3JlbWVudCwgbWV0aG9kLCBtZXRob2RQYXJhbXMsICBtb250aEluY3JlbWVudCwgeWVhckluY3JlbWVudDtcblxuICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgZGF5SW5jcmVtZW50ICAgPSB2YWx1ZS5nZXREYXRlKCkgICAgIC0gb2xkVmFsdWUuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgbW9udGhJbmNyZW1lbnQgPSB2YWx1ZS5nZXRNb250aCgpICAgIC0gb2xkVmFsdWUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIHllYXJJbmNyZW1lbnQgID0gdmFsdWUuZ2V0RnVsbFllYXIoKSAtIG9sZFZhbHVlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgICAgIGlmIChtb250aEluY3JlbWVudCAhPT0gMCkgeyAvLyBnZXRzIHVzZWQgd2hlbiBtb250aCAmIHllYXIgY2hhbmdlZCBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgbWV0aG9kICAgICAgID0gJ2NoYW5nZU1vbnRoJztcbiAgICAgICAgICAgICAgICBtZXRob2RQYXJhbXMgPSBbbW9udGhJbmNyZW1lbnQsIHllYXJJbmNyZW1lbnRdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh5ZWFySW5jcmVtZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kICAgICAgID0gJ2NoYW5nZVllYXInO1xuICAgICAgICAgICAgICAgIG1ldGhvZFBhcmFtcyA9IFt5ZWFySW5jcmVtZW50XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF5SW5jcmVtZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWwuc2VsZWN0KG1lLmlkICsgJ19fJyArIERhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWUuY29udGFpbnNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3MuZm9jdXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1lLmlkXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZVttZXRob2RdKC4uLm1ldGhvZFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lW21ldGhvZF0oLi4ubWV0aG9kUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUhlYWRlck1vbnRoKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyWWVhcigwLCB0cnVlKTtcbiAgICAgICAgICAgIG1lLnJlY3JlYXRlRGF5Vmlld0NvbnRlbnQoZmFsc2UsIGZhbHNlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXlOYW1lRm9ybWF0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSGVhZGVyRGF5cyh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNVcGRhdGluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzVXBkYXRpbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChtZS5jYWNoZWRVcGRhdGUgJiYgbWUuY2FjaGVkVXBkYXRlICE9PSBuZXcgRGF0ZShgJHttZS52YWx1ZX1UMDA6MDA6MDAuMDAwWmApKSB7XG4gICAgICAgICAgICAgICAgbWUuYWZ0ZXJTZXRWYWx1ZShtZS52YWx1ZSwgRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQobWUuY2FjaGVkVXBkYXRlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmNhY2hlZFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxvY2FsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRMb2NhbGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZHQgICA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KG1lLmxvY2FsZSwge21vbnRoOiAnc2hvcnQnfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZUhlYWRlckRheXMobWUuZGF5TmFtZUZvcm1hdCwgJycsIHRydWUpO1xuXG4gICAgICAgICAgICBtZS5nZXRIZWFkZXJNb250aEVsKCkuaHRtbCA9IGR0LmZvcm1hdChtZS5jdXJyZW50RGF0ZSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93Q2VsbEJvcmRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93Q2VsbEJvcmRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ3JlbW92ZScgOiAnYWRkJ10oY2xzLCAnbmVvLWhpZGUtaW5uZXItYm9yZGVycycpO1xuICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93RGlzYWJsZWREYXlzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0Rpc2FibGVkRGF5cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJlY3JlYXRlRGF5Vmlld0NvbnRlbnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dXZWVrZW5kcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dXZWVrZW5kcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGxlbiA9IDcsXG4gICAgICAgICAgICAgICAgaSwgaXRlbTtcblxuICAgICAgICAgICAgbWUuZ2V0Q2VudGVyQ29udGVudEVsKCkuY24uZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gcm93LmNuW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jbHMuaW5jbHVkZXMoJ25lby13ZWVrZW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0ucmVtb3ZlRG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdHJpZ2dlcnMgdGhlIHZkb20gdXBkYXRlXG4gICAgICAgICAgICBtZS51cGRhdGVIZWFkZXJEYXlzKG1lLmRheU5hbWVGb3JtYXQsICcnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIG1lLmN1cnJlbnREYXRlID0gbmV3IERhdGUoYCR7dmFsdWV9VDAwOjAwOjAwLjAwMFpgKTtcblxuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5jYWNoZVVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdlZWtTdGFydERheSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXZWVrU3RhcnREYXkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yZWNyZWF0ZURheVZpZXdDb250ZW50KGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZGF5TmFtZUZvcm1hdCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkYXlOYW1lRm9ybWF0JywgRGF0ZVV0aWwucHJvdG90eXBlLmRheU5hbWVGb3JtYXRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiBvbGRWYWx1ZS5kZXN0cm95KCk7XG5cbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgRGF0ZVNlbGVjdG9yTW9kZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHdlZWtTdGFydERheSBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFdlZWtTdGFydERheSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3dlZWtTdGFydERheScsIERhdGVVdGlsLnByb3RvdHlwZS53ZWVrU3RhcnREYXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGxhc3QgZGF0ZSBjaGFuZ2Ugd2hpY2ggY291bGQgbm90IGdldCBhcHBsaWVkIHdoaWxlIGEgdHJhbnNpdGlvbiB3YXMgcnVubmluZ1xuICAgICAqIEBwYXJhbSB7RGF0ZX0gW2RhdGU9dGhpcy5jdXJyZW50RGF0ZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FjaGVVcGRhdGUoZGF0ZT10aGlzLmN1cnJlbnREYXRlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVXBkYXRlID0gZGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5jcmVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJJbmNyZW1lbnRcbiAgICAgKi9cbiAgICBjaGFuZ2VNb250aChpbmNyZW1lbnQsIHllYXJJbmNyZW1lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHNsaWRlRGlyZWN0aW9uID0geWVhckluY3JlbWVudCA+IDAgPyAncmlnaHQnIDogeWVhckluY3JlbWVudCA8IDAgPyAnbGVmdCcgOiBpbmNyZW1lbnQgPCAwID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgICAgIGhlYWRlck1vbnRoT3B0cywgdmRvbSwgeDtcblxuICAgICAgICBpZiAoIW1lLnVzZUFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIG1lLnJlY3JlYXRlQ29udGVudChpbmNyZW1lbnQsIHllYXJJbmNyZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtZS5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgbWUuaXNVcGRhdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBtZS5nZXREb21SZWN0KFttZS5nZXRDZW50ZXJDb250ZW50RWwoKS5pZCwgbWUuZ2V0SGVhZGVyTW9udGhFbCgpLmlkXSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbSA9IG1lLnZkb207XG4gICAgICAgICAgICAgICAgICAgIHggICAgPSBzbGlkZURpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IDAgOiAtZGF0YVswXS53aWR0aDtcblxuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1yZWxhdGl2ZSddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWFuaW1hdGlvbi13cmFwcGVyJ10sIHN0eWxlOiB7aGVpZ2h0OiBgJHtkYXRhWzBdLmhlaWdodH1weGAsIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHt4fXB4KWAsIHdpZHRoOiBgJHsyICogZGF0YVswXS53aWR0aH1weGB9LCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1kYXRlc2VsZWN0b3ItY29udGVudCddLCBjbjogW119XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyTW9udGhPcHRzID0gbWUudXBkYXRlSGVhZGVyTW9udGgoaW5jcmVtZW50LCB5ZWFySW5jcmVtZW50LCB0cnVlLCBkYXRhWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoeWVhckluY3JlbWVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyWWVhcihpbmNyZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlRGF5Vmlld0NvbnRlbnQodHJ1ZSwgdmRvbS5jblsyXS5jblswXS5jblswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY25bMl0uY25bMF0uY25bc2xpZGVEaXJlY3Rpb24gPT09ICdyaWdodCc/ICd1bnNoaWZ0JyA6ICdwdXNoJ10odmRvbS5jblsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24uc3BsaWNlKDEsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLnByb21pc2VWZG9tVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5jaGFuZ2VNb250aFRyYW5zaXRpb25DYWxsYmFjayh7ZGF0YTogZGF0YVswXSwgc2xpZGVEaXJlY3Rpb246IHNsaWRlRGlyZWN0aW9ufSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVIZWFkZXJNb250aFRyYW5zaXRpb25DYWxsYmFjayhoZWFkZXJNb250aE9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmNoYW5nZU1vbnRoV3JhcHBlckNhbGxiYWNrKHNsaWRlRGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVIZWFkZXJNb250aFdyYXBwZXJDYWxsYmFjayhoZWFkZXJNb250aE9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXJWZG9tVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuY2FjaGVVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNsaWRlcyB0aGUgd3JhcHBlciBkaXYgdG8gdGhlIGxlZnQgb3IgcmlnaHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5zbGlkZURpcmVjdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjaGFuZ2VNb250aFRyYW5zaXRpb25DYWxsYmFjayhvcHRzKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gPSBtZS52ZG9tLFxuICAgICAgICAgICAge2RhdGEsIHNsaWRlRGlyZWN0aW9ufSA9IG9wdHMsXG4gICAgICAgICAgICB4O1xuXG4gICAgICAgIHggPSBzbGlkZURpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IC1kYXRhLndpZHRoIDogMDtcbiAgICAgICAgdmRvbS5jblsxXS5jblswXS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3h9cHgpYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyB0aGUgd3JhcHBlciBkaXYgd2l0aCB0aGUgdGFyZ2V0IG1vbnRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNsaWRlRGlyZWN0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYW5nZU1vbnRoV3JhcHBlckNhbGxiYWNrKHNsaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gPSBtZS52ZG9tO1xuXG4gICAgICAgIHZkb20uY25bMV0gPSB2ZG9tLmNuWzFdLmNuWzBdLmNuW3NsaWRlRGlyZWN0aW9uID09PSAncmlnaHQnID8gMSA6IDBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmNyZW1lbnRcbiAgICAgKi9cbiAgICBjaGFuZ2VZZWFyKGluY3JlbWVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgc2Nyb2xsRnJvbVRvcCwgc3R5bGUsIHZkb20sIHk7XG5cbiAgICAgICAgaWYgKCFtZS51c2VBbmltYXRpb25zKSB7XG4gICAgICAgICAgICBtZS5yZWNyZWF0ZUNvbnRlbnQoMCwgaW5jcmVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbWUuaXNVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbWUuZ2V0RG9tUmVjdChtZS5nZXRDZW50ZXJDb250ZW50RWwoKS5pZCkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRnJvbVRvcCA9IG1lLnNjcm9sbE5ld1llYXJGcm9tVG9wICYmIGluY3JlbWVudCA8IDAgfHwgIW1lLnNjcm9sbE5ld1llYXJGcm9tVG9wICYmIGluY3JlbWVudCA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHZkb20gICAgICAgICAgPSBtZS52ZG9tO1xuICAgICAgICAgICAgICAgICAgICB5ICAgICAgICAgICAgID0gc2Nyb2xsRnJvbVRvcCA/IDAgOiAtZGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAgICAgICA6IGAkezIgKiBkYXRhLmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gICAgOiBgdHJhbnNsYXRlWSgke3l9cHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICA6IGAke2RhdGEud2lkdGh9cHhgXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jbi5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tcmVsYXRpdmUnXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1hbmltYXRpb24td3JhcHBlciddLCBzdHlsZTogc3R5bGUsIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWRhdGVzZWxlY3Rvci1jb250ZW50J10sIGNuOiBbXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVIZWFkZXJZZWFyKGluY3JlbWVudCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlRGF5Vmlld0NvbnRlbnQodHJ1ZSwgdmRvbS5jblsyXS5jblswXS5jblswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY25bMl0uY25bMF0uY25bc2Nyb2xsRnJvbVRvcCA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10odmRvbS5jblsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24uc3BsaWNlKDEsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLnByb21pc2VWZG9tVXBkYXRlKHZkb20pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHNjcm9sbEZyb21Ub3AgPyAtZGF0YS5oZWlnaHQgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmRvbS5jblsxXS5jblswXS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke3l9cHgpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuWzFdID0gdmRvbS5jblsxXS5jblswXS5jbltzY3JvbGxGcm9tVG9wID8gMSA6IDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXJWZG9tVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuY2FjaGVVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlRGF5TmFtZXNSb3coKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGUgPSBEYXRlVXRpbC5jbG9uZShtZS5jdXJyZW50RGF0ZSksXG4gICAgICAgICAgICBpICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgPSA3LFxuICAgICAgICAgICAgcm93ICA9IHtjbHM6IFsnbmVvLXJvdycsICduZW8taGVhZGVyLXJvdyddLCBjbjogW119LFxuICAgICAgICAgICAgY29uZmlnLCBkYXk7XG5cbiAgICAgICAgZGF0ZS5zZXREYXRlKG1lLmN1cnJlbnREYXRlLmdldERhdGUoKSAtIG1lLmN1cnJlbnREYXRlLmdldERheSgpICsgbWUud2Vla1N0YXJ0RGF5KTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcgPVxuICAgICAgICAgICAge2NsczogWyduZW8tY2VsbCddLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHMgOiBbJ25lby1jZWxsLWNvbnRlbnQnXSwgaHRtbDogbWUuaW50bEZvcm1hdF9kYXkuZm9ybWF0KGRhdGUpfVxuICAgICAgICAgICAgXX07XG5cbiAgICAgICAgICAgIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgICAgICAgIGlmICghbWUuc2hvd1dlZWtlbmRzICYmIChkYXkgPT09IDAgfHwgZGF5ID09PSA2KSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5yZW1vdmVEb20gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb3cuY24ucHVzaChjb25maWcpO1xuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2UgdHJ1ZSB0byB1cGRhdGUgdGhlIHZkb20gc2lsZW50bHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRhaW5lckVsXVxuICAgICAqL1xuICAgIGNyZWF0ZURheVZpZXdDb250ZW50KHNpbGVudD1mYWxzZSwgY29udGFpbmVyRWwpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSAgICAgPSBtZS5jdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXkgICAgICA9IGN1cnJlbnREYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIGN1cnJlbnRNb250aCAgICA9IGN1cnJlbnREYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICBjdXJyZW50WWVhciAgICAgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZSAgICAgICAgICAgID0gbWUuY3VycmVudERhdGUsIC8vIGNsb25lZFxuICAgICAgICAgICAgdmFsdWVEYXRlICAgICAgID0gbmV3IERhdGUoYCR7bWUudmFsdWV9VDAwOjAwOjAwLjAwMFpgKSxcbiAgICAgICAgICAgIHZhbHVlTW9udGggICAgICA9IHZhbHVlRGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgdmFsdWVZZWFyICAgICAgID0gdmFsdWVEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXlzSW5Nb250aCAgICAgPSBEYXRlVXRpbC5nZXREYXlzSW5Nb250aChjdXJyZW50RGF0ZSksXG4gICAgICAgICAgICBmaXJzdERheUluTW9udGggPSBEYXRlVXRpbC5nZXRGaXJzdERheU9mTW9udGgoY3VycmVudERhdGUpLFxuICAgICAgICAgICAgZmlyc3REYXlPZmZzZXQgID0gZmlyc3REYXlJbk1vbnRoIC0gbWUud2Vla1N0YXJ0RGF5LFxuICAgICAgICAgICAgY2VudGVyRWwgICAgICAgID0gY29udGFpbmVyRWwgfHwgbWUuZ2V0Q2VudGVyQ29udGVudEVsKCksXG4gICAgICAgICAgICBjb2x1bW5zICAgICAgICAgPSA3LFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGNlbGxJZCwgY29uZmlnLCBkYXRlRGF5LCBkYXksIGhhc0NvbnRlbnQsIGosIHJvdywgcm93cztcblxuICAgICAgICBmaXJzdERheU9mZnNldCA9IGZpcnN0RGF5T2Zmc2V0IDwgMCA/IGZpcnN0RGF5T2Zmc2V0ICsgNyA6IGZpcnN0RGF5T2Zmc2V0O1xuICAgICAgICByb3dzICAgICAgICAgICA9IChkYXlzSW5Nb250aCArIGZpcnN0RGF5T2Zmc2V0KSAvIDcgPiA1ID8gNiA6IDU7XG4gICAgICAgIGRheSAgICAgICAgICAgID0gMSAtIGZpcnN0RGF5T2Zmc2V0O1xuXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXkpO1xuXG4gICAgICAgIGNlbnRlckVsLmNuLnB1c2gobWUuY3JlYXRlRGF5TmFtZXNSb3coKSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHJvdyA9IHtjbHM6IFsnbmVvLXJvdyddLCBjbjogW119O1xuXG4gICAgICAgICAgICBmb3IgKGo9MDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgIGhhc0NvbnRlbnQgPSBkYXkgPiAwICYmIGRheSA8PSBkYXlzSW5Nb250aDtcbiAgICAgICAgICAgICAgICBjZWxsSWQgICAgID0gbWUuZ2V0Q2VsbElkKGN1cnJlbnRZZWFyLCBjdXJyZW50TW9udGggKyAxLCBkYXkpO1xuXG4gICAgICAgICAgICAgICAgZGF0ZURheSA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPXtcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IGNlbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICA6IGhhc0NvbnRlbnQgPyBbJ25lby1jZWxsJ10gOiBbJ25lby1jZWxsJywgJ25lby1kaXNhYmxlZCddLFxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogaGFzQ29udGVudCA/IC0xIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1jZWxsLWNvbnRlbnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IGhhc0NvbnRlbnQgPyBkYXkgOiBtZS5zaG93RGlzYWJsZWREYXlzID8gZGF0ZS5nZXREYXRlKCkgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0ZURheSA9PT0gMCB8fCBkYXRlRGF5ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuc2hvd1dlZWtlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jbHMucHVzaCgnbmVvLXdlZWtlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodG9kYXkueWVhciA9PT0gY3VycmVudFllYXIgJiYgdG9kYXkubW9udGggPT09IGN1cnJlbnRNb250aCAmJiB0b2RheS5kYXkgPT09IGRheSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuY25bMF0uY2xzLnB1c2goJ25lby10b2RheScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVllYXIgPT09IGN1cnJlbnRZZWFyICYmIHZhbHVlTW9udGggPT09IGN1cnJlbnRNb250aCAmJiBkYXkgPT09IGN1cnJlbnREYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKCduZW8tc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWwuaXRlbXMgPSBbY2VsbElkXTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdy5jbi5wdXNoKGNvbmZpZyk7XG5cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcblxuICAgICAgICAgICAgICAgIGRheSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjZW50ZXJFbC5jbi5wdXNoKHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmb2N1c0N1cnJlbnRJdGVtKCkge1xuICAgICAgICB0aGlzLmZvY3VzKHRoaXMuc2VsZWN0aW9uTW9kZWwuaXRlbXNbMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbW9udGhcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGRheVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGlkXG4gICAgICovXG4gICAgZ2V0Q2VsbElkKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAgICAgZGF5ID0gZGF5LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGRheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBkYXkgPSAnMCcgKyBkYXk7XG4gICAgICAgIH1cblxuICAgICAgICBtb250aCA9IG1vbnRoLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKG1vbnRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIG1vbnRoID0gJzAnICsgbW9udGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pZCArICdfXycgKyB5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRDZW50ZXJDb250ZW50RWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJNb250aEVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzFdLmNuWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0SGVhZGVyWWVhckVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzFdLmNuWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DZWxsQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNlbGxFbCA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQobWUudmRvbSwgZGF0YS5wYXRoWzBdLmlkKSxcbiAgICAgICAgICAgIGRhdGUgICA9IG1lLmN1cnJlbnREYXRlOyAvLyBjbG9uZWRcblxuICAgICAgICBkYXRlLnNldERhdGUocGFyc2VJbnQoY2VsbEVsLnZkb20uY25bMF0uaHRtbCkpO1xuICAgICAgICBkYXRlID0gRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSk7XG5cbiAgICAgICAgLy8gV2Ugd2FudCB0byBhbHdheXMgdHJpZ2dlciBhIGNoYW5nZSBldmVudC5cbiAgICAgICAgLy8gUmVhc29uOiBBIGZvcm0uZmllbGQuRGF0ZSBjYW4gaGF2ZSBhIG51bGwgdmFsdWUsIGFuZCB3ZSB3YW50IHRvIHNlbGVjdCB0aGUgY3VycmVudCBkYXRlLlxuICAgICAgICBtZS5fdmFsdWUgPSBkYXRlO1xuICAgICAgICBtZS5hZnRlclNldFZhbHVlKGRhdGUsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db21wb25lbnRDbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gZGF0YS5wYXRoWzBdLmNscyxcbiAgICAgICAgICAgIGRhdGUsIG1vbnRoSW5jcmVtZW50O1xuXG4gICAgICAgICAgICAgaWYgKGNscy5pbmNsdWRlcygnbmVvLWNlbGwnKSkgICAgICAgIHttZS5vbkNlbGxDbGljayhkYXRhKTt9XG4gICAgICAgIGVsc2UgaWYgKGNscy5pbmNsdWRlcygnbmVvLW5leHQtYnV0dG9uJykpIHttb250aEluY3JlbWVudCA9ICAxO31cbiAgICAgICAgZWxzZSBpZiAoY2xzLmluY2x1ZGVzKCduZW8tcHJldi1idXR0b24nKSkge21vbnRoSW5jcmVtZW50ID0gLTE7fVxuXG4gICAgICAgIGlmIChtb250aEluY3JlbWVudCkge1xuICAgICAgICAgICAgZGF0ZSA9IG1lLmN1cnJlbnREYXRlOyAvLyBjbG9uZWRcbiAgICAgICAgICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgbW9udGhJbmNyZW1lbnQpO1xuICAgICAgICAgICAgbWUudmFsdWUgPSBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db21wb25lbnRXaGVlbChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHdoZWVsRGVsdGEgPSBtZS5tb3VzZVdoZWVsRGVsdGEsXG4gICAgICAgICAgICBkYXRlLCBtb250aEluY3JlbWVudCwgeWVhckluY3JlbWVudDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZGF0YS5kZWx0YVkpID49IE1hdGguYWJzKGRhdGEuZGVsdGFYKSkge1xuICAgICAgICAgICAgICAgICBpZiAoZGF0YS5kZWx0YVkgPj0gIHdoZWVsRGVsdGEpIHt5ZWFySW5jcmVtZW50ICA9ICAxO31cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuZGVsdGFZIDw9IC13aGVlbERlbHRhKSB7eWVhckluY3JlbWVudCAgPSAtMTt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIGlmIChkYXRhLmRlbHRhWCA+PSAgd2hlZWxEZWx0YSkge21vbnRoSW5jcmVtZW50ID0gIDE7fVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5kZWx0YVggPD0gLXdoZWVsRGVsdGEpIHttb250aEluY3JlbWVudCA9IC0xO31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb250aEluY3JlbWVudCkge1xuICAgICAgICAgICAgZGF0ZSA9IG1lLmN1cnJlbnREYXRlOyAvLyBjbG9uZWRcbiAgICAgICAgICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgbW9udGhJbmNyZW1lbnQpO1xuICAgICAgICAgICAgbWUudmFsdWUgPSBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKTtcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFySW5jcmVtZW50KSB7XG4gICAgICAgICAgICBkYXRlID0gbWUuY3VycmVudERhdGU7IC8vIGNsb25lZFxuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyB5ZWFySW5jcmVtZW50KTtcbiAgICAgICAgICAgIG1lLnZhbHVlID0gRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbD8ucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gaXRlbXNbMF0uc3BsaXQoJ19fJylbMV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNyZWF0ZXMgdGhlIGN1cnJlbnQgY2VudGVyRWwsIG1vbnRoICYgeWVhciBlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aEluY3JlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFySW5jcmVtZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZWNyZWF0ZUNvbnRlbnQobW9udGhJbmNyZW1lbnQsIHllYXJJbmNyZW1lbnQsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnJlY3JlYXRlRGF5Vmlld0NvbnRlbnQodHJ1ZSk7XG5cbiAgICAgICAgbW9udGhJbmNyZW1lbnQgIT09IDAgJiYgbWUudXBkYXRlSGVhZGVyTW9udGgobW9udGhJbmNyZW1lbnQsIHllYXJJbmNyZW1lbnQsIHRydWUpO1xuICAgICAgICB5ZWFySW5jcmVtZW50ICAhPT0gMCAmJiBtZS51cGRhdGVIZWFkZXJZZWFyKHllYXJJbmNyZW1lbnQsIHRydWUpO1xuXG4gICAgICAgIG1lLnRyaWdnZXJWZG9tVXBkYXRlKHNpbGVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjcmVhdGVzIHRoZSBjdXJyZW50IGNlbnRlckVsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N5bmNJZHM9dHJ1ZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVjcmVhdGVEYXlWaWV3Q29udGVudChzaWxlbnQ9ZmFsc2UsIHN5bmNJZHM9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmdldENlbnRlckNvbnRlbnRFbCgpLmNuID0gW107XG4gICAgICAgIG1lLmNyZWF0ZURheVZpZXdDb250ZW50KHRydWUpO1xuXG4gICAgICAgIGlmIChzeW5jSWRzKSB7XG4gICAgICAgICAgICBtZS5zeW5jVmRvbUlkcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudHJpZ2dlclZkb21VcGRhdGUoc2lsZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIHZkb20gdXBkYXRlICYgc2V0cyBpc1VwZGF0aW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0cmlnZ2VyVmRvbVVwZGF0ZShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBtZS5wcm9taXNlVmRvbVVwZGF0ZShtZS52ZG9tKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICB1cGRhdGVIZWFkZXJEYXlzKHZhbHVlLCBvbGRWYWx1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaW50bEZvcm1hdF9kYXkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChtZS5sb2NhbGUsIHt3ZWVrZGF5OiB2YWx1ZX0pO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgY2VudGVyRWwgPSBtZS5nZXRDZW50ZXJDb250ZW50RWwoKS5jblswXSxcbiAgICAgICAgICAgICAgICBkYXRlICAgICA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgICAgICB2ZG9tICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGRheSwgbm9kZTtcblxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKG1lLmN1cnJlbnREYXRlLmdldERhdGUoKSAtIG1lLmN1cnJlbnREYXRlLmdldERheSgpICsgbWUud2Vla1N0YXJ0RGF5KTtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICBub2RlID0gY2VudGVyRWwuY25baV07XG5cbiAgICAgICAgICAgICAgICBub2RlLmNuWzBdLmh0bWwgPSBtZS5pbnRsRm9ybWF0X2RheS5mb3JtYXQoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBkYXkgPSBkYXRlLmdldERheSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5zaG93V2Vla2VuZHMgJiYgKGRheSA9PT0gMCB8fCBkYXkgPT09IDYpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5yZW1vdmVEb207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmNyZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhckluY3JlbWVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vbnRoRWxEb21SZWN0XG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfSBvcHRzIG9yIG51bGwgaW4gY2FzZSBubyB0cmFuc2l0aW9ucyBhcmUgbmVlZGVkXG4gICAgICovXG4gICAgdXBkYXRlSGVhZGVyTW9udGgoaW5jcmVtZW50LCB5ZWFySW5jcmVtZW50LCBzaWxlbnQ9ZmFsc2UsIG1vbnRoRWxEb21SZWN0KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkdCAgICAgICAgICAgICA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KG1lLmxvY2FsZSwge21vbnRoOiAnc2hvcnQnfSksXG4gICAgICAgICAgICBjdXJyZW50TW9udGggICA9IGR0LmZvcm1hdChtZS5jdXJyZW50RGF0ZSksXG4gICAgICAgICAgICBtb250aEVsICAgICAgICA9IG1lLmdldEhlYWRlck1vbnRoRWwoKSxcbiAgICAgICAgICAgIHNsaWRlRGlyZWN0aW9uID0geWVhckluY3JlbWVudCA+IDAgPyAnYm90dG9tJyA6IHllYXJJbmNyZW1lbnQgPCAwID8gJ3RvcCcgOiBpbmNyZW1lbnQgPCAwID8gJ3RvcCcgOiAnYm90dG9tJyxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIGhlYWRlckNlbnRlckVsLCB5O1xuXG4gICAgICAgIGlmICghbWUubW91bnRlZCB8fCAhbWUudXNlQW5pbWF0aW9ucykge1xuICAgICAgICAgICAgbW9udGhFbC5odG1sID0gY3VycmVudE1vbnRoO1xuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0gc2xpZGVEaXJlY3Rpb24gPT09ICd0b3AnID8gMCA6IC1tb250aEVsRG9tUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZkb20uY25bMF0uY25bMV0uY24udW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLXJlbGF0aXZlLWhlYWRlciddLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogbW9udGhFbERvbVJlY3QuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBtb250aEVsRG9tUmVjdC53aWR0aCAgKyAncHgnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbjogW3tcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBbJ25lby1hbmltYXRpb24td3JhcHBlci1oZWFkZXInXSxcbiAgICAgICAgICAgICAgICAgICAgY24gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAgIDogMiAqIG1vbnRoRWxEb21SZWN0LmhlaWdodCArICdweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKCR7eX1weClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggICAgOiBtb250aEVsRG9tUmVjdC53aWR0aCArICdweCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaGVhZGVyQ2VudGVyRWwgPSB2ZG9tLmNuWzBdLmNuWzFdO1xuXG4gICAgICAgICAgICBoZWFkZXJDZW50ZXJFbC5jblswXS5jblswXS5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1tb250aC10ZXh0J10sXG4gICAgICAgICAgICAgICAgaHRtbDogY3VycmVudE1vbnRoXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaGVhZGVyQ2VudGVyRWwuY25bMF0uY25bMF0uY25bc2xpZGVEaXJlY3Rpb24gPT09ICd0b3AnID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShoZWFkZXJDZW50ZXJFbC5jblsxXSk7XG4gICAgICAgICAgICBoZWFkZXJDZW50ZXJFbC5jbi5zcGxpY2UoMSwgMSk7XG5cbiAgICAgICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBtb250aEVsRG9tUmVjdCxcbiAgICAgICAgICAgICAgICBoZWFkZXJDZW50ZXJFbCxcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgeWVhckluY3JlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNsaWRlcyB0aGUgd3JhcHBlciBkaXYgdG8gdGhlIHRvcCBvciBib3R0b21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5oZWFkZXJDZW50ZXJFbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRzLmluY3JlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRzLnllYXJJbmNyZW1lbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlSGVhZGVyTW9udGhUcmFuc2l0aW9uQ2FsbGJhY2sob3B0cykge1xuICAgICAgICBsZXQge2RhdGEsIGhlYWRlckNlbnRlckVsLCBpbmNyZW1lbnQsIHllYXJJbmNyZW1lbnR9ID0gb3B0cyxcbiAgICAgICAgICAgIHNsaWRlRGlyZWN0aW9uID0geWVhckluY3JlbWVudCA+IDAgPyAnYm90dG9tJyA6IHllYXJJbmNyZW1lbnQgPCAwID8gJ3RvcCcgOiBpbmNyZW1lbnQgPCAwID8gJ3RvcCcgOiAnYm90dG9tJyxcbiAgICAgICAgICAgIHk7XG5cbiAgICAgICAgeSA9IHNsaWRlRGlyZWN0aW9uID09PSAndG9wJyA/IC1kYXRhLmhlaWdodCA6IDA7XG4gICAgICAgIGhlYWRlckNlbnRlckVsLmNuWzBdLmNuWzBdLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKCR7eX1weClgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHRoZSB3cmFwcGVyIGRpdiB0byB0aGUgbGVmdCBvciByaWdodFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuaGVhZGVyQ2VudGVyRWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0cy5pbmNyZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0cy55ZWFySW5jcmVtZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUhlYWRlck1vbnRoV3JhcHBlckNhbGxiYWNrKG9wdHMpIHtcbiAgICAgICAgbGV0IHtoZWFkZXJDZW50ZXJFbCwgaW5jcmVtZW50LCB5ZWFySW5jcmVtZW50fSA9IG9wdHMsXG4gICAgICAgICAgICBzbGlkZURpcmVjdGlvbiA9IHllYXJJbmNyZW1lbnQgPiAwID8gJ2JvdHRvbScgOiB5ZWFySW5jcmVtZW50IDwgMCA/ICd0b3AnIDogaW5jcmVtZW50IDwgMCA/ICd0b3AnIDogJ2JvdHRvbSc7XG5cbiAgICAgICAgaGVhZGVyQ2VudGVyRWwuY25bMF0gPSBoZWFkZXJDZW50ZXJFbC5jblswXS5jblswXS5jbltzbGlkZURpcmVjdGlvbiA9PT0gJ3RvcCcgPyAxIDogMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluY3JlbWVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICB1cGRhdGVIZWFkZXJZZWFyKGluY3JlbWVudCwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgeWVhckVsID0gbWUuZ2V0SGVhZGVyWWVhckVsKCk7XG5cbiAgICAgICAgeWVhckVsLmh0bWwgPSBtZS5jdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKERhdGVTZWxlY3Rvcik7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGVTZWxlY3RvcjtcbiIsImltcG9ydCBEYXRlVXRpbCBmcm9tICcuLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBNb2RlbCAgICBmcm9tICcuL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uRGF0ZVNlbGVjdG9yTW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uTW9kZWxcbiAqL1xuY2xhc3MgRGF0ZVNlbGVjdG9yTW9kZWwgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLkRhdGVTZWxlY3Rvck1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLkRhdGVTZWxlY3Rvck1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi1kYXRlc2VsZWN0b3Jtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tZGF0ZXNlbGVjdG9ybW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSB0byBzdGF5IGluc2lkZSB0aGUgc2FtZSBjb2x1bW4gd2hlbiBuYXZpZ2F0aW5nIHVwIG9yIGRvd253YXJkc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzdGF5SW5Db2x1bW49ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHN0YXlJbkNvbHVtbjogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAqL1xuICAgIGdldENlbGxEYXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBpZEFycmF5LCB0bXBBcnJheTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uWzBdKSB7XG4gICAgICAgICAgICBpZEFycmF5ID0gc2VsZWN0aW9uWzBdLnNwbGl0KCdfXycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWRBcnJheSA9IGRhdGEucGF0aFswXS5pZC5zcGxpdCgnX18nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcEFycmF5ID0gaWRBcnJheVsxXS5zcGxpdCgnLScpLm1hcChlID0+IHBhcnNlSW50KGUpKTtcblxuICAgICAgICB0bXBBcnJheVsxXS0tOyAvLyB0aGUgbW9udGggaW5zaWRlIHRoZSB2aWV3IGlzIDEgYmFzZWQsIGEgZGF0ZSBuZWVkcyAwIGJhc2VkXG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKC4uLnRtcEFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkRvd24oZGF0YSkge1xuICAgICAgICB0aGlzLm9uTmF2S2V5Um93KGRhdGEsIDcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duTGVmdChkYXRhKSB7XG4gICAgICAgIHRoaXMub25OYXZLZXlDb2x1bW4oZGF0YSwgLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duUmlnaHQoZGF0YSkge1xuICAgICAgICB0aGlzLm9uTmF2S2V5Q29sdW1uKGRhdGEsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duVXAoZGF0YSkge1xuICAgICAgICB0aGlzLm9uTmF2S2V5Um93KGRhdGEsIC03KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgb25OYXZLZXlDb2x1bW4oZGF0YSwgc3RlcCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2VsbERhdGUgPSBtZS5nZXRDZWxsRGF0ZShkYXRhKSxcbiAgICAgICAgICAgIHZpZXcgICAgID0gbWUudmlldyxcbiAgICAgICAgICAgIGRheXNJbk1vbnRoLCBpZCwgbmV3RGF5O1xuXG4gICAgICAgIGRheXNJbk1vbnRoID0gRGF0ZVV0aWwuZ2V0RGF5c0luTW9udGgoY2VsbERhdGUpO1xuICAgICAgICBuZXdEYXkgICAgICA9IChjZWxsRGF0ZS5nZXREYXRlKCkgKyBzdGVwKSAlIGRheXNJbk1vbnRoO1xuXG4gICAgICAgIG5ld0RheSA9IG5ld0RheSA9PT0gMCA/IGRheXNJbk1vbnRoIDogbmV3RGF5O1xuXG4gICAgICAgIGlkID0gdmlldy5nZXRDZWxsSWQoY2VsbERhdGUuZ2V0RnVsbFllYXIoKSwgY2VsbERhdGUuZ2V0TW9udGgoKSArIDEsIG5ld0RheSk7XG5cbiAgICAgICAgbWUuc2VsZWN0KGlkKTtcbiAgICAgICAgdmlldy5mb2N1cyhpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIG9uTmF2S2V5Um93KGRhdGEsIHN0ZXApIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNlbGxEYXRlID0gbWUuZ2V0Q2VsbERhdGUoZGF0YSksXG4gICAgICAgICAgICB2aWV3ICAgICA9IG1lLnZpZXcsXG4gICAgICAgICAgICBkYXlzSW5Nb250aCwgaWQsIG5ld0RheTtcblxuICAgICAgICBkYXlzSW5Nb250aCA9IERhdGVVdGlsLmdldERheXNJbk1vbnRoKGNlbGxEYXRlKTtcbiAgICAgICAgbmV3RGF5ICAgICAgPSBjZWxsRGF0ZS5nZXREYXRlKCkgKyBzdGVwO1xuXG4gICAgICAgIGlmIChuZXdEYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgICAgaWYgKCFtZS5zdGF5SW5Db2x1bW4pIHtcbiAgICAgICAgICAgICAgICBuZXdEYXkgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKG5ld0RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXkgLT0gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXdEYXkgPCAxKSB7XG4gICAgICAgICAgICBpZiAoIW1lLnN0YXlJbkNvbHVtbikge1xuICAgICAgICAgICAgICAgIG5ld0RheSAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAobmV3RGF5IDwgZGF5c0luTW9udGggLSA2KSB7XG4gICAgICAgICAgICAgICAgbmV3RGF5IC09IHN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZCA9IHZpZXcuZ2V0Q2VsbElkKGNlbGxEYXRlLmdldEZ1bGxZZWFyKCksIGNlbGxEYXRlLmdldE1vbnRoKCkgKyAxLCBuZXdEYXkpO1xuXG4gICAgICAgIG1lLnNlbGVjdChpZCk7XG4gICAgICAgIHZpZXcuZm9jdXMoaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoY29tcG9uZW50KTtcblxuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc2NvcGUgPSB7c2NvcGU6IG1lLmlkfSxcbiAgICAgICAgICAgIHZpZXcgID0gbWUudmlldztcblxuICAgICAgICBpZiAodmlldy5rZXlzKSB7XG4gICAgICAgICAgICB2aWV3LmtleXMuX2tleXMucHVzaChcbiAgICAgICAgICAgICAgICB7Zm46ICdvbktleURvd25Eb3duJyAgLGtleTogJ0Rvd24nICAsLi4uc2NvcGV9LFxuICAgICAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkxlZnQnICAsa2V5OiAnTGVmdCcgICwuLi5zY29wZX0sXG4gICAgICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICxrZXk6ICdSaWdodCcgLC4uLnNjb3BlfSxcbiAgICAgICAgICAgICAgICB7Zm46ICdvbktleURvd25VcCcgICAgLGtleTogJ1VwJyAgICAsLi4uc2NvcGV9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc2NvcGUgPSB7c2NvcGU6IG1lLmlkfSxcbiAgICAgICAgICAgIHZpZXcgID0gbWUudmlldztcblxuICAgICAgICBpZiAodmlldy5rZXlzKSB7XG4gICAgICAgICAgICB2aWV3LmtleXMucmVtb3ZlS2V5cyhbXG4gICAgICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicgICxrZXk6ICdEb3duJyAgLC4uLnNjb3BlfSxcbiAgICAgICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgLGtleTogJ0xlZnQnICAsLi4uc2NvcGV9LFxuICAgICAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAsa2V5OiAnUmlnaHQnICwuLi5zY29wZX0sXG4gICAgICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnICAgICxrZXk6ICdVcCcgICAgLC4uLnNjb3BlfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKCk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhEYXRlU2VsZWN0b3JNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGVTZWxlY3Rvck1vZGVsO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkRhdGVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgRGF0ZVV0aWwgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkRhdGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLkRhdGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGZvciBkYXlOYW1lRm9ybWF0XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkYXlOYW1lRm9ybWF0cz1bJ25hcnJvdycsICdzaG9ydCcsICdsb25nJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBkYXlOYW1lRm9ybWF0czogWyduYXJyb3cnLCAnc2hvcnQnLCAnbG9uZyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGZvciBtb250aE5hbWVGb3JtYXRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IG1vbnRoTmFtZUZvcm1hdHM9WyduYXJyb3cnLCAnc2hvcnQnLCAnbG9uZyddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgbW9udGhOYW1lRm9ybWF0czogWyduYXJyb3cnLCAnc2hvcnQnLCAnbG9uZyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGZvciBkYXlOYW1lRm9ybWF0XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcltdfSB3ZWVrU3RhcnREYXlzPVswLCAxLCAyLCAzLCA0LCA1LCA2XVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtTdGFydERheXM6IFswLCAxLCAyLCAzLCA0LCA1LCA2XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lcyBhIERhdGUgaW5zdGFuY2UgdXNpbmcgdGhlIHNhbWUgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0RhdGV8bnVsbH0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtEYXRlfG51bGx9IHRoZSBjbG9uZWQgZGF0ZSBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY2xvbmUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZSAmJiBuZXcgRGF0ZShkYXRlLnZhbHVlT2YoKSkgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5eXl5LW1tLWRkIGZvcm1hdHRlZCB2YWx1ZSBvZiBhIGdpdmVuIERhdGUgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgeXl5eS1tbS1kZCBmb3JtYXR0ZWQgZGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0VG95eXl5bW1kZChkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgZGF5cyBpbnNpZGUgdGhlIG1vbnRoIG9mIGEgcGFzc2VkIGRhdGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICogQHJldHVybnMge051bWJlcn0gZGF5cyBpbnNpZGUgdGhlIG1vbnRoXG4gICAgICovXG4gICAgc3RhdGljIGdldERheXNJbk1vbnRoKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgMCkuZ2V0RGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3ZWVrU3RhcnREYXkgMC02XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Rmlyc3REYXlPZmZzZXQoZGF0ZSwgd2Vla1N0YXJ0RGF5KSB7XG4gICAgICAgIGxldCBmaXJzdERheUluTW9udGggPSBEYXRlVXRpbC5nZXRGaXJzdERheU9mTW9udGgoZGF0ZSksXG4gICAgICAgICAgICBmaXJzdERheU9mZnNldCAgPSBmaXJzdERheUluTW9udGggLSB3ZWVrU3RhcnREYXk7XG5cbiAgICAgICAgcmV0dXJuIGZpcnN0RGF5T2Zmc2V0IDwgMCA/IGZpcnN0RGF5T2Zmc2V0ICsgNyA6IGZpcnN0RGF5T2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRheSBudW1iZXIgb2YgdGhlIGZpcnN0IGRheSBvZiBhIHBhc3NlZCBkYXRlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IDAtNiAoU3VuLVNhdClcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Rmlyc3REYXlPZk1vbnRoKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKS5nZXREYXkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgcGFzc2VkIGRhdGVcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gdGFyZ2V0RGF0ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGdldFdlZWtPZlllYXIodGFyZ2V0RGF0ZSkge1xuICAgICAgICBsZXQgZGF0ZSAgICAgID0gbmV3IERhdGUodGFyZ2V0RGF0ZS52YWx1ZU9mKCkpLFxuICAgICAgICAgICAgZGF5TnVtYmVyID0gKHRhcmdldERhdGUuZ2V0VVRDRGF5KCkgKyA2KSAlIDcsXG4gICAgICAgICAgICBmaXJzdFRodXJzZGF5O1xuXG4gICAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIGRheU51bWJlciArIDMpO1xuICAgICAgICBmaXJzdFRodXJzZGF5ID0gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG5cbiAgICAgICAgaWYgKGRhdGUuZ2V0VVRDRGF5KCkgIT09IDQpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSArICgoNCAtIGRhdGUuZ2V0VVRDRGF5KCkpICsgNykgJSA3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoKGZpcnN0VGh1cnNkYXkgLSBkYXRlKSAvICAoNyAqIDI0ICogMzYwMCAqIDEwMDApKSArIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdlZWtTdGFydERheSAwLTZcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSA1LTZcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0V2Vla3NPZk1vbnRoKGRhdGUsIHdlZWtTdGFydERheSkge1xuICAgICAgICBsZXQgZGF5c0luTW9udGggICAgPSBEYXRlVXRpbC5nZXREYXlzSW5Nb250aChkYXRlKSxcbiAgICAgICAgICAgIGZpcnN0RGF5T2Zmc2V0ID0gRGF0ZVV0aWwuZ2V0Rmlyc3REYXlPZmZzZXQoZGF0ZSwgd2Vla1N0YXJ0RGF5KTtcblxuICAgICAgICByZXR1cm4gKGRheXNJbk1vbnRoICsgZmlyc3REYXlPZmZzZXQpIC8gNyA+IDUgPyA2IDogNTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaW4gY2FzZSB0aGUgZGF5LCBtb250aCAmIHllYXIgb2YgMiBnaXZlbiBEYXRlIG9iamVjdHMgYXJlIHRoZSBzYW1lXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlMVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hEYXRlKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gZGF0ZTEuZ2V0RnVsbFllYXIoKSA9PT0gZGF0ZTIuZ2V0RnVsbFllYXIoKSAmJlxuICAgICAgICAgICAgICAgZGF0ZTEuZ2V0TW9udGgoKSAgICA9PT0gZGF0ZTIuZ2V0TW9udGgoKSAgICAmJlxuICAgICAgICAgICAgICAgZGF0ZTEuZ2V0RGF0ZSgpICAgICA9PT0gZGF0ZTIuZ2V0RGF0ZSgpO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoRGF0ZVV0aWwpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRlVXRpbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==