"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_Container_mjs"],{

/***/ "./src/form/Container.mjs":
/*!********************************!*\
  !*** ./src/form/Container.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../form/field/Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");





/**
 * @class Neo.form.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.Container'
         * @protected
         */
        className: 'Neo.form.Container',
        /**
         * @member {String} ntype='form-container'
         * @protected
         */
        ntype: 'form-container',
        /**
         * @member {String[]} baseCls=['neo-form-container'],
         * @protected
         */
        baseCls: ['neo-form-container'],
        /**
         * @member {Object} vdom={tag: 'form',cn:[],onsubmit:'return false;'}
         */
        vdom:
        {tag: 'form', cn: [], onsubmit: 'return false;'}
    }

    /**
     * Helper function used by setValues() which wraps the leaves of a tree structure into a new property.
     * @param {Object} values
     * @param {String} configName
     * @param {String[]} fieldPaths
     * @param {String} currentPath=''
     */
    static adjustTreeLeaves(values={}, configName, fieldPaths, currentPath='') {
        let assign, newPath, type;

        Object.entries(values).forEach(([key, value]) => {
            assign  = true;
            newPath = currentPath === '' ? key : `${currentPath}.${key}`;
            type    = Neo.typeOf(value);

            if (type === 'Array' || type === 'Object') {
                assign = fieldPaths.includes(newPath);

                if (type === 'Array') {
                    value.forEach((item, index) => {
                        if (Neo.typeOf(item) === 'Object') {
                            this.adjustTreeLeaves(item, configName, fieldPaths, `${newPath}[${index}]`)
                        }
                    })
                } else if (type === 'Object') {
                    this.adjustTreeLeaves(value, configName, fieldPaths, newPath)
                }
            }

            if (assign) {
                if (key === configName) {
                    values[key] = value
                } else {
                    values[key] = {[configName]: value}
                }
            }
        })
    }

    /**
     * @param {Neo.container.Base} parent
     * @param {Object[]} modules
     * @returns {Object[]}
     */
    findNotLoadedModules(parent=this, modules=[]) {
        parent.items.forEach(item => {
            if (Neo.typeOf(item.module) === 'Function' && !item.isLoading) {
                modules.push({item, parent})
            } else {
                item.items && this.findNotLoadedModules(item, modules)
            }
        });

        return modules
    }

    /**
     * Either pass a field name or id
     * @param {String} name
     * @returns {Promise<Neo.form.field.Base|null>} fields
     */
    async getField(name) {
        await this.loadModules();

        let fields = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(this),
            field;

        for (field of fields) {
            if (field instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
                if (field.name === name || field.id === name) {
                    return field
                }
            }
        }

        return null
    }

    /**
     * @param {Neo.form.field.Base} field
     * @returns {String}
     */
    getFieldPath(field) {
        let path = field.formGroup ? field.formGroup.split('.') : [];

        path.push(field.name || field.id);

        return path.join('.')
    }

    /**
     * @returns {Promise<Neo.form.field.Base[]>} fields
     */
    async getFields() {
        let fields = [];

        await this.loadModules();

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(this).forEach(field => {
            field instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] && fields.push(field)
        });

        return fields
    }


    /**
     * This function will return one of the following states:
     * - clean      => all fields are clean (untouched)
     * - invalid    => at least one field is invalid
     * - valid      => all required fields are valid
     * - inProgress => at least one field is valid, at least one field is clean
     * @returns {Promise<String>}
     */
    async getFormState() {
        let fields           = await this.getFields(),
            i                = 0,
            hasCleanFields   = false,
            hasAlertFields   = false,
            hasInvalidFields = false,
            hasUncleanFields = false,
            hasValidFields   = false,
            len              = fields.length,
            field, isClean, isValid;

        for (; i < len; i++) {
            field   = fields[i];
            isClean = field.clean;
            isValid = field.isValid();

            if (!isClean && !isValid) {
                if (field.isEmptyAndRequired?.()) {
                    hasAlertFields = true
                } else {
                    return 'invalid'
                }
            } else if (isValid) {
                hasValidFields = true
            } else if (!isValid) {
                if (field.isEmptyAndRequired?.()) {
                    hasAlertFields = true
                } else {
                    hasInvalidFields = true
                }
            }

            if (isClean) {
                hasCleanFields = true
            } else {
                hasUncleanFields = true
            }
        }

        if (!hasAlertFields && !hasInvalidFields) {
            return 'valid'
        }

        if (!hasAlertFields && hasCleanFields && !hasUncleanFields) {
            return 'clean'
        }

        return 'inProgress'
    }

    /**
     * @returns {Promise<Object>}
     */
    async getValues() {
        let fields = await this.getFields(),
            Radio  = Neo.form.field.Radio,
            values = {},
            fieldName, key, ns, nsArray, value;

        fields.forEach(field => {
            value = field.getValue();

            if (field.name) {
                fieldName = field.name;

                if (field.formGroup) {
                    fieldName = field.formGroup + '.' + fieldName;
                }

                nsArray = fieldName.split('.');
                key     = nsArray.pop();
                ns      = Neo.nsWithArrays(nsArray, true, values);
            } else {
                key = field.id;
                ns  = values
            }

            // Ensuring that Radios will not return arrays
            if (Radio && field instanceof Radio) {
                // Only overwrite an existing value with a checked value
                if (Object.hasOwn(ns, key)) {
                    if (value !== field.uncheckedValue) {
                        ns[key] = value
                    }
                } else {
                    ns[key] = value
                }
            }
            /*
             * CheckBoxes need custom logic
             * => we only want to pass the uncheckedValue in case the field does not belong to a group
             * (multiple fields using the same name)
             */
            else if (Object.hasOwn(ns, key) && value !== undefined) {
                if (ns[key] === field.uncheckedValue) {
                    ns[key] = []
                } else if (!Array.isArray(ns[key])) {
                    ns[key] = [ns[key]]
                }

                value !== field.uncheckedValue && ns[key].unshift(value)
            } else if (value !== undefined) {
                ns[key] = value
            }
        });

        return values
    }

    /**
     * Returns true in case no form field isValid() call returns false
     * @returns {Promise<Boolean>}
     */
    async isValid() {
        let fields = await this.getFields(),
            i      = 0,
            len    = fields.length;

        for (; i < len; i++) {
            if (!fields[i].isValid()) {
                return false
            }
        }

        return true
    }

    /**
     * Loads all not loaded items inside card layouts
     * @returns {Promise<Neo.component.Base[]>}
     */
    async loadModules() {
        let me       = this,
            modules  = me.findNotLoadedModules(),
            promises = [];

        modules.forEach(module => {
            promises.push(module.parent.layout.loadModule(module.item));
        });

        modules = await Promise.all(promises);

        return modules
    }

    /**
     * Resets field values by field name or field id.
     * Fields not included with a value will get reset to null.
     * @param {Object} [values]
     */
    async reset(values={}) {
        let me     = this,
            fields = await me.getFields(),
            path, value;

        fields.forEach(field => {
            path  = me.getFieldPath(field);
            value = Neo.nsWithArrays(path, false, values);

            field.reset(path ? value : null)
        })
    }

    /**
     * Set field configs by field name or field id
     * @param {Object} configs={}
     * @param {Boolean} suspendEvents=false
     */
    async setConfigs(configs={}, suspendEvents=false) {
        let me     = this,
            fields = await me.getFields(),
            fieldConfigs, isCheckBox, isRadio, path, value;

        fields.forEach(field => {
            path         = me.getFieldPath(field);
            fieldConfigs = Neo.nsWithArrays(path, false, configs);

            if (fieldConfigs) {
                if (suspendEvents) {
                    field.suspendEvents = true
                }

                isCheckBox = Neo.form.field?.CheckBox && field instanceof Neo.form.field.CheckBox;
                isRadio    = Neo.form.field?.Radio    && field instanceof Neo.form.field.Radio;
                value      = fieldConfigs.value;

                if (isCheckBox || isRadio) {
                    /*
                     * we want to only change the checked state, in case a value is set.
                     * since fields of the same group might need it too, we are cloning the fieldConfigs
                     */
                    if (Object.hasOwn(fieldConfigs, 'value')) {
                        fieldConfigs = Neo.clone(fieldConfigs, true);

                        if (isRadio) {
                            fieldConfigs.checked = field.value === value
                        } else if (isCheckBox) {
                            if (Neo.typeOf(value) === 'Array') {
                                if (value.includes(field.value)) {
                                    fieldConfigs.checked = true
                                }
                            } else {
                                fieldConfigs.checked = field.value === value
                            }
                        }

                        delete fieldConfigs.value
                    }
                }

                field.set(fieldConfigs)

                if (suspendEvents) {
                    delete field.suspendEvents
                }
            }
        })
    }

    /**
     * Set field values by field name or field id
     * @param {Object} values={}
     * @param {Boolean} suspendEvents=false
     */
    async setValues(values={}, suspendEvents=false) {
        let fields     = await this.getFields(),
            fieldPaths = [],
            path;

        // Grouped CheckBoxes & Radios can have the same path
        // => using NeoArray to ensure they only get added once
        fields.map(field => {
            path = field.getPath();
            path && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(fieldPaths, path)
        });

        values = Neo.clone(values, true);

        Container.adjustTreeLeaves(values, 'value', fieldPaths);

        await this.setConfigs(values, suspendEvents)
    }

    /**
     * Updates the invalid state for all fields which have validate() implemented.
     * This can be useful for create-entity forms which show up "clean" until pressing a submit button.
     * @returns {Promise<Boolean>}
     */
    async validate() {
        let isValid = true,
            fields  = await this.getFields(),
            validField;

        fields.forEach(field => {
            validField = field.validate?.(false);

            if (!validField) {
                isValid = false
            }
        });

        return isValid
    }
}

Neo.setupClass(Container);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Container);


/***/ }),

/***/ "./src/form/field/Base.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        fireChangeEvent    : {type: 'debounce', timer: 1000},
        fireUserChangeEvent: {type: 'debounce', timer: 1000}
    }
    /**
     * Valid values for isTouchedEvent
     * @member {String[]} isTouchedEvents=['focusEnter','focusLeave']
     * @protected
     * @static
     */
    static isTouchedEvents = ['focusEnter', 'focusLeave']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         */
        formGroup_: null,
        /**
         * True indicates that a user has interacted with the form field
         * @member {Boolean} isTouched_=false
         */
        isTouched_: false,
        /**
         * Event name which sets isTouched to true. Valid options are 'focusEnter' & 'focusLeave'
         * @member {String} isTouched_=false
         */
        isTouchedEvent_: 'focusLeave',
        /**
         * @member {String|null} name_=null
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * Triggered after the name isTouched got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetIsTouched(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'neo-is-touched', value);
        this.cls = cls;
    }

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.getInputEl().role = value;
        this.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {
        oldValue !== undefined && this.fireChangeEvent(value, oldValue)
    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString;
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Triggered before the isTouchedEvent config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetIsTouchedEvent(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'isTouchedEvent')
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value;
        } else {
            delete me.getInputEl()[key];
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*}      value
     * @param {*}      oldValue
     * @param {String} eventName
     */
    doFireChangeEvent(value, oldValue, eventName) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            formEvent     = 'field' + Neo.capitalize(eventName),
            opts          = {component: me, oldValue, value};

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        me.fire(eventName, opts);

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire(formEvent, opts)
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'change')
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireUserChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'userChange')
    }

    /**
     * Forms in neo can be nested. This method will return the closest parent which is a form.Container or null.
     * @returns {Neo.form.Container|null}
     */
    getClosestForm() {
        let me            = this,
            FormContainer = Neo.form?.Container,
            parent;

        for (parent of _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me)) {
            if (FormContainer && parent instanceof FormContainer) {
                return parent
            }
        }

        return null
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        // fields could have formGroups, but no name.
        // returning the namespace can confuse form.Container.adjustTreeLeaves(),
        // since namespaces could be considered as field instances.
        if (!me.name) {
            return null
        }

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getValue() {
        return this.value;
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true;
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        super.onFocusLeave(data);

        if (this.isTouchedEvent === 'focusEnter') {
            this.isTouched = true
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave(data);

        let me            = this,
            FormContainer = Neo.form?.Container,
            opts          = {...data, component: me, value: me.getValue()};

        if (me.isTouchedEvent === 'focusLeave') {
            me.isTouched = true
        }

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', opts)
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.value = value;
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true;
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDQztBQUNFO0FBQ1A7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFhO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxNQUFNLHlDQUF5QztBQUMzRTtBQUNBO0FBQ0EsU0FBUyw2Q0FBNkM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVksR0FBRyxJQUFJO0FBQ3ZFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVEsR0FBRyxNQUFNO0FBQ3BHO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLG1DQUFtQztBQUNwRDtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDhEQUFnQjtBQUNyQzs7QUFFQTtBQUNBLGlDQUFpQyw0REFBUztB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akI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw4REFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiOztBQUVBOztBQUVBLGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZUNvbnRhaW5lciAgICBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IEJhc2VGaWVsZCAgICAgICAgZnJvbSAnLi4vZm9ybS9maWVsZC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Zvcm0tY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Zvcm0tY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWZvcm0tY29udGFpbmVyJ10sXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWZvcm0tY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209e3RhZzogJ2Zvcm0nLGNuOltdLG9uc3VibWl0OidyZXR1cm4gZmFsc2U7J31cbiAgICAgICAgICovXG4gICAgICAgIHZkb206XG4gICAgICAgIHt0YWc6ICdmb3JtJywgY246IFtdLCBvbnN1Ym1pdDogJ3JldHVybiBmYWxzZTsnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIGJ5IHNldFZhbHVlcygpIHdoaWNoIHdyYXBzIHRoZSBsZWF2ZXMgb2YgYSB0cmVlIHN0cnVjdHVyZSBpbnRvIGEgbmV3IHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkUGF0aHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFBhdGg9JydcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRqdXN0VHJlZUxlYXZlcyh2YWx1ZXM9e30sIGNvbmZpZ05hbWUsIGZpZWxkUGF0aHMsIGN1cnJlbnRQYXRoPScnKSB7XG4gICAgICAgIGxldCBhc3NpZ24sIG5ld1BhdGgsIHR5cGU7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGFzc2lnbiAgPSB0cnVlO1xuICAgICAgICAgICAgbmV3UGF0aCA9IGN1cnJlbnRQYXRoID09PSAnJyA/IGtleSA6IGAke2N1cnJlbnRQYXRofS4ke2tleX1gO1xuICAgICAgICAgICAgdHlwZSAgICA9IE5lby50eXBlT2YodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0FycmF5JyB8fCB0eXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGFzc2lnbiA9IGZpZWxkUGF0aHMuaW5jbHVkZXMobmV3UGF0aCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoaXRlbSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RUcmVlTGVhdmVzKGl0ZW0sIGNvbmZpZ05hbWUsIGZpZWxkUGF0aHMsIGAke25ld1BhdGh9WyR7aW5kZXh9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkanVzdFRyZWVMZWF2ZXModmFsdWUsIGNvbmZpZ05hbWUsIGZpZWxkUGF0aHMsIG5ld1BhdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXNzaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gY29uZmlnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB7W2NvbmZpZ05hbWVdOiB2YWx1ZX1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29udGFpbmVyLkJhc2V9IHBhcmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG1vZHVsZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgZmluZE5vdExvYWRlZE1vZHVsZXMocGFyZW50PXRoaXMsIG1vZHVsZXM9W10pIHtcbiAgICAgICAgcGFyZW50Lml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLnR5cGVPZihpdGVtLm1vZHVsZSkgPT09ICdGdW5jdGlvbicgJiYgIWl0ZW0uaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlcy5wdXNoKHtpdGVtLCBwYXJlbnR9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLml0ZW1zICYmIHRoaXMuZmluZE5vdExvYWRlZE1vZHVsZXMoaXRlbSwgbW9kdWxlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1vZHVsZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFaXRoZXIgcGFzcyBhIGZpZWxkIG5hbWUgb3IgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby5mb3JtLmZpZWxkLkJhc2V8bnVsbD59IGZpZWxkc1xuICAgICAqL1xuICAgIGFzeW5jIGdldEZpZWxkKG5hbWUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTW9kdWxlcygpO1xuXG4gICAgICAgIGxldCBmaWVsZHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkQ29tcG9uZW50cyh0aGlzKSxcbiAgICAgICAgICAgIGZpZWxkO1xuXG4gICAgICAgIGZvciAoZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBCYXNlRmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PT0gbmFtZSB8fCBmaWVsZC5pZCA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmZvcm0uZmllbGQuQmFzZX0gZmllbGRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEZpZWxkUGF0aChmaWVsZCkge1xuICAgICAgICBsZXQgcGF0aCA9IGZpZWxkLmZvcm1Hcm91cCA/IGZpZWxkLmZvcm1Hcm91cC5zcGxpdCgnLicpIDogW107XG5cbiAgICAgICAgcGF0aC5wdXNoKGZpZWxkLm5hbWUgfHwgZmllbGQuaWQpO1xuXG4gICAgICAgIHJldHVybiBwYXRoLmpvaW4oJy4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby5mb3JtLmZpZWxkLkJhc2VbXT59IGZpZWxkc1xuICAgICAqL1xuICAgIGFzeW5jIGdldEZpZWxkcygpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1vZHVsZXMoKTtcblxuICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkQ29tcG9uZW50cyh0aGlzKS5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGZpZWxkIGluc3RhbmNlb2YgQmFzZUZpZWxkICYmIGZpZWxkcy5wdXNoKGZpZWxkKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmllbGRzXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIG9uZSBvZiB0aGUgZm9sbG93aW5nIHN0YXRlczpcbiAgICAgKiAtIGNsZWFuICAgICAgPT4gYWxsIGZpZWxkcyBhcmUgY2xlYW4gKHVudG91Y2hlZClcbiAgICAgKiAtIGludmFsaWQgICAgPT4gYXQgbGVhc3Qgb25lIGZpZWxkIGlzIGludmFsaWRcbiAgICAgKiAtIHZhbGlkICAgICAgPT4gYWxsIHJlcXVpcmVkIGZpZWxkcyBhcmUgdmFsaWRcbiAgICAgKiAtIGluUHJvZ3Jlc3MgPT4gYXQgbGVhc3Qgb25lIGZpZWxkIGlzIHZhbGlkLCBhdCBsZWFzdCBvbmUgZmllbGQgaXMgY2xlYW5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdHJpbmc+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZvcm1TdGF0ZSgpIHtcbiAgICAgICAgbGV0IGZpZWxkcyAgICAgICAgICAgPSBhd2FpdCB0aGlzLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBoYXNDbGVhbkZpZWxkcyAgID0gZmFsc2UsXG4gICAgICAgICAgICBoYXNBbGVydEZpZWxkcyAgID0gZmFsc2UsXG4gICAgICAgICAgICBoYXNJbnZhbGlkRmllbGRzID0gZmFsc2UsXG4gICAgICAgICAgICBoYXNVbmNsZWFuRmllbGRzID0gZmFsc2UsXG4gICAgICAgICAgICBoYXNWYWxpZEZpZWxkcyAgID0gZmFsc2UsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgICAgID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICAgIGZpZWxkLCBpc0NsZWFuLCBpc1ZhbGlkO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZpZWxkICAgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICBpc0NsZWFuID0gZmllbGQuY2xlYW47XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmllbGQuaXNWYWxpZCgpO1xuXG4gICAgICAgICAgICBpZiAoIWlzQ2xlYW4gJiYgIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuaXNFbXB0eUFuZFJlcXVpcmVkPy4oKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNBbGVydEZpZWxkcyA9IHRydWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2ludmFsaWQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaGFzVmFsaWRGaWVsZHMgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmlzRW1wdHlBbmRSZXF1aXJlZD8uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQWxlcnRGaWVsZHMgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzSW52YWxpZEZpZWxkcyA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgaGFzQ2xlYW5GaWVsZHMgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhc1VuY2xlYW5GaWVsZHMgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc0FsZXJ0RmllbGRzICYmICFoYXNJbnZhbGlkRmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZhbGlkJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNBbGVydEZpZWxkcyAmJiBoYXNDbGVhbkZpZWxkcyAmJiAhaGFzVW5jbGVhbkZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuICdjbGVhbidcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnaW5Qcm9ncmVzcydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldFZhbHVlcygpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBSYWRpbyAgPSBOZW8uZm9ybS5maWVsZC5SYWRpbyxcbiAgICAgICAgICAgIHZhbHVlcyA9IHt9LFxuICAgICAgICAgICAgZmllbGROYW1lLCBrZXksIG5zLCBuc0FycmF5LCB2YWx1ZTtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGQubmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5mb3JtR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGQuZm9ybUdyb3VwICsgJy4nICsgZmllbGROYW1lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5zQXJyYXkgPSBmaWVsZE5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBrZXkgICAgID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgICAgICBucyAgICAgID0gTmVvLm5zV2l0aEFycmF5cyhuc0FycmF5LCB0cnVlLCB2YWx1ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBmaWVsZC5pZDtcbiAgICAgICAgICAgICAgICBucyAgPSB2YWx1ZXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5zdXJpbmcgdGhhdCBSYWRpb3Mgd2lsbCBub3QgcmV0dXJuIGFycmF5c1xuICAgICAgICAgICAgaWYgKFJhZGlvICYmIGZpZWxkIGluc3RhbmNlb2YgUmFkaW8pIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IG92ZXJ3cml0ZSBhbiBleGlzdGluZyB2YWx1ZSB3aXRoIGEgY2hlY2tlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKG5zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmllbGQudW5jaGVja2VkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5zW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbnNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIENoZWNrQm94ZXMgbmVlZCBjdXN0b20gbG9naWNcbiAgICAgICAgICAgICAqID0+IHdlIG9ubHkgd2FudCB0byBwYXNzIHRoZSB1bmNoZWNrZWRWYWx1ZSBpbiBjYXNlIHRoZSBmaWVsZCBkb2VzIG5vdCBiZWxvbmcgdG8gYSBncm91cFxuICAgICAgICAgICAgICogKG11bHRpcGxlIGZpZWxkcyB1c2luZyB0aGUgc2FtZSBuYW1lKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QuaGFzT3duKG5zLCBrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobnNba2V5XSA9PT0gZmllbGQudW5jaGVja2VkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbnNba2V5XSA9IFtdXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShuc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBuc1trZXldID0gW25zW2tleV1dXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgIT09IGZpZWxkLnVuY2hlY2tlZFZhbHVlICYmIG5zW2tleV0udW5zaGlmdCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5zW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGluIGNhc2Ugbm8gZm9ybSBmaWVsZCBpc1ZhbGlkKCkgY2FsbCByZXR1cm5zIGZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgaXNWYWxpZCgpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgID0gZmllbGRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkc1tpXS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIG5vdCBsb2FkZWQgaXRlbXMgaW5zaWRlIGNhcmQgbGF5b3V0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby5jb21wb25lbnQuQmFzZVtdPn1cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkTW9kdWxlcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1vZHVsZXMgID0gbWUuZmluZE5vdExvYWRlZE1vZHVsZXMoKSxcbiAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgbW9kdWxlcy5mb3JFYWNoKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1vZHVsZS5wYXJlbnQubGF5b3V0LmxvYWRNb2R1bGUobW9kdWxlLml0ZW0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kdWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICByZXR1cm4gbW9kdWxlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBmaWVsZCB2YWx1ZXMgYnkgZmllbGQgbmFtZSBvciBmaWVsZCBpZC5cbiAgICAgKiBGaWVsZHMgbm90IGluY2x1ZGVkIHdpdGggYSB2YWx1ZSB3aWxsIGdldCByZXNldCB0byBudWxsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVzXVxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0KHZhbHVlcz17fSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpZWxkcyA9IGF3YWl0IG1lLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgcGF0aCwgdmFsdWU7XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgcGF0aCAgPSBtZS5nZXRGaWVsZFBhdGgoZmllbGQpO1xuICAgICAgICAgICAgdmFsdWUgPSBOZW8ubnNXaXRoQXJyYXlzKHBhdGgsIGZhbHNlLCB2YWx1ZXMpO1xuXG4gICAgICAgICAgICBmaWVsZC5yZXNldChwYXRoID8gdmFsdWUgOiBudWxsKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBmaWVsZCBjb25maWdzIGJ5IGZpZWxkIG5hbWUgb3IgZmllbGQgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlncz17fVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VzcGVuZEV2ZW50cz1mYWxzZVxuICAgICAqL1xuICAgIGFzeW5jIHNldENvbmZpZ3MoY29uZmlncz17fSwgc3VzcGVuZEV2ZW50cz1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpZWxkcyA9IGF3YWl0IG1lLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgZmllbGRDb25maWdzLCBpc0NoZWNrQm94LCBpc1JhZGlvLCBwYXRoLCB2YWx1ZTtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBwYXRoICAgICAgICAgPSBtZS5nZXRGaWVsZFBhdGgoZmllbGQpO1xuICAgICAgICAgICAgZmllbGRDb25maWdzID0gTmVvLm5zV2l0aEFycmF5cyhwYXRoLCBmYWxzZSwgY29uZmlncyk7XG5cbiAgICAgICAgICAgIGlmIChmaWVsZENvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5zdXNwZW5kRXZlbnRzID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlzQ2hlY2tCb3ggPSBOZW8uZm9ybS5maWVsZD8uQ2hlY2tCb3ggJiYgZmllbGQgaW5zdGFuY2VvZiBOZW8uZm9ybS5maWVsZC5DaGVja0JveDtcbiAgICAgICAgICAgICAgICBpc1JhZGlvICAgID0gTmVvLmZvcm0uZmllbGQ/LlJhZGlvICAgICYmIGZpZWxkIGluc3RhbmNlb2YgTmVvLmZvcm0uZmllbGQuUmFkaW87XG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICA9IGZpZWxkQ29uZmlncy52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrQm94IHx8IGlzUmFkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogd2Ugd2FudCB0byBvbmx5IGNoYW5nZSB0aGUgY2hlY2tlZCBzdGF0ZSwgaW4gY2FzZSBhIHZhbHVlIGlzIHNldC5cbiAgICAgICAgICAgICAgICAgICAgICogc2luY2UgZmllbGRzIG9mIHRoZSBzYW1lIGdyb3VwIG1pZ2h0IG5lZWQgaXQgdG9vLCB3ZSBhcmUgY2xvbmluZyB0aGUgZmllbGRDb25maWdzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZENvbmZpZ3MsICd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZENvbmZpZ3MgPSBOZW8uY2xvbmUoZmllbGRDb25maWdzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmFkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZENvbmZpZ3MuY2hlY2tlZCA9IGZpZWxkLnZhbHVlID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NoZWNrQm94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhmaWVsZC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkQ29uZmlncy5jaGVja2VkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRDb25maWdzLmNoZWNrZWQgPSBmaWVsZC52YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZENvbmZpZ3MudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpZWxkLnNldChmaWVsZENvbmZpZ3MpXG5cbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmllbGQuc3VzcGVuZEV2ZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZmllbGQgdmFsdWVzIGJ5IGZpZWxkIG5hbWUgb3IgZmllbGQgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXNwZW5kRXZlbnRzPWZhbHNlXG4gICAgICovXG4gICAgYXN5bmMgc2V0VmFsdWVzKHZhbHVlcz17fSwgc3VzcGVuZEV2ZW50cz1mYWxzZSkge1xuICAgICAgICBsZXQgZmllbGRzICAgICA9IGF3YWl0IHRoaXMuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBmaWVsZFBhdGhzID0gW10sXG4gICAgICAgICAgICBwYXRoO1xuXG4gICAgICAgIC8vIEdyb3VwZWQgQ2hlY2tCb3hlcyAmIFJhZGlvcyBjYW4gaGF2ZSB0aGUgc2FtZSBwYXRoXG4gICAgICAgIC8vID0+IHVzaW5nIE5lb0FycmF5IHRvIGVuc3VyZSB0aGV5IG9ubHkgZ2V0IGFkZGVkIG9uY2VcbiAgICAgICAgZmllbGRzLm1hcChmaWVsZCA9PiB7XG4gICAgICAgICAgICBwYXRoID0gZmllbGQuZ2V0UGF0aCgpO1xuICAgICAgICAgICAgcGF0aCAmJiBOZW9BcnJheS5hZGQoZmllbGRQYXRocywgcGF0aClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFsdWVzID0gTmVvLmNsb25lKHZhbHVlcywgdHJ1ZSk7XG5cbiAgICAgICAgQ29udGFpbmVyLmFkanVzdFRyZWVMZWF2ZXModmFsdWVzLCAndmFsdWUnLCBmaWVsZFBhdGhzKTtcblxuICAgICAgICBhd2FpdCB0aGlzLnNldENvbmZpZ3ModmFsdWVzLCBzdXNwZW5kRXZlbnRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludmFsaWQgc3RhdGUgZm9yIGFsbCBmaWVsZHMgd2hpY2ggaGF2ZSB2YWxpZGF0ZSgpIGltcGxlbWVudGVkLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgY3JlYXRlLWVudGl0eSBmb3JtcyB3aGljaCBzaG93IHVwIFwiY2xlYW5cIiB1bnRpbCBwcmVzc2luZyBhIHN1Ym1pdCBidXR0b24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZSxcbiAgICAgICAgICAgIGZpZWxkcyAgPSBhd2FpdCB0aGlzLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgdmFsaWRGaWVsZDtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICB2YWxpZEZpZWxkID0gZmllbGQudmFsaWRhdGU/LihmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRGaWVsZCkge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaXNWYWxpZFxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoQ29udGFpbmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyO1xuIiwiaW1wb3J0IENvbXBvbmVudCAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZm9ybSBmaWVsZHNcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7XG4gICAgICAgIGZpcmVDaGFuZ2VFdmVudCAgICA6IHt0eXBlOiAnZGVib3VuY2UnLCB0aW1lcjogMTAwMH0sXG4gICAgICAgIGZpcmVVc2VyQ2hhbmdlRXZlbnQ6IHt0eXBlOiAnZGVib3VuY2UnLCB0aW1lcjogMTAwMH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBpc1RvdWNoZWRFdmVudFxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBpc1RvdWNoZWRFdmVudHM9Wydmb2N1c0VudGVyJywnZm9jdXNMZWF2ZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUb3VjaGVkRXZlbnRzID0gWydmb2N1c0VudGVyJywgJ2ZvY3VzTGVhdmUnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Jhc2VmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdiYXNlZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybSBncm91cHMgY2FuIGdldCBzZXQgb24gYW55IHBhcmVudCBjb21wb25lbnQgbGV2ZWwuXG4gICAgICAgICAqIEFuIGFsdGVybmF0aXZlIHdheSBmb3IgdXNpbmcgZG90cyBpbiBmaWVsZCBuYW1lcy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybUdyb3VwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaW5kaWNhdGVzIHRoYXQgYSB1c2VyIGhhcyBpbnRlcmFjdGVkIHdpdGggdGhlIGZvcm0gZmllbGRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNUb3VjaGVkXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNUb3VjaGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBuYW1lIHdoaWNoIHNldHMgaXNUb3VjaGVkIHRvIHRydWUuIFZhbGlkIG9wdGlvbnMgYXJlICdmb2N1c0VudGVyJyAmICdmb2N1c0xlYXZlJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlzVG91Y2hlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzVG91Y2hlZEV2ZW50XzogJ2ZvY3VzTGVhdmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IG5hbWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogTmVvIGl0c2VsZiBkb2VzIG5vdCBuZWVkIGZpZWxkIG5hbWVzIHRvIGdldCBtYXBwZWQgdG8gdGhlIERPTSAoaW5wdXQgbm9kZXMpLFxuICAgICAgICAgKiBleGNlcHQgZm9yIENoZWNrQm94ZXMgJiBSYWRpb3MgdG8gd29yay4gSXQgY2FuIGJlIHVzZWZ1bCBmb3IgdGVzdGluZyB0b29sc1xuICAgICAgICAgKiAmIGFjY2Vzc2liaWxpdHkgdGhvdWdoLCBzbyB0aGUgZGVmYXVsdCBnb3Qgc2V0IHRvIHRydWUuXG4gICAgICAgICAqIEZlZWwgZnJlZSB0byBjaGFuZ2UgaXQgdG8gZmFsc2UgdG8ga2VlcCB0aGUgRE9NIG1pbmltYWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlck5hbWVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlck5hbWVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gY2FzZSByZW5kZXJOYW1lIGlzIHNldCB0byB0cnVlLCB5b3UgY2FuIG9wdGlvbmFsbHkgcmVuZGVyIHRoZSBjb21iaW5hdGlvblxuICAgICAgICAgKiBvZiBhbGwgZm9ybUdyb3VwKHMpICYgdGhlIGZpZWxkIG5hbWUgaW50byB0aGUgRE9NID0+IGlucHV0IG5vZGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyUGF0aD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJQYXRoOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Kn0gdmFsdWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGNhY2hlIGZvciBmb3JtR3JvdXBzIG9mIGFsbCBwYXJlbnQgbGV2ZWxzXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cFN0cmluZz1udWxsXG4gICAgICovXG4gICAgZm9ybUdyb3VwU3RyaW5nID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGNhY2hlIGZvciBmb3JtR3JvdXAocykgYW5kIHRoZSBmaWVsZCBuYW1lXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHBhdGg9bnVsbFxuICAgICAqL1xuICAgIHBhdGggPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG5hbWUgaXNUb3VjaGVkIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNUb3VjaGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1pcy10b3VjaGVkJywgdmFsdWUpO1xuICAgICAgICB0aGlzLmNscyA9IGNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0TmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZW5kZXJOYW1lICYmIG1lLmNoYW5nZUlucHV0RWxLZXkoJ25hbWUnLCBtZS5yZW5kZXJQYXRoID8gbWUuZ2V0UGF0aCgpIDogdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb2xlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb2xlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmdldElucHV0RWwoKS5yb2xlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZm9ybUdyb3VwIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBwYXJlbnRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldEZvcm1Hcm91cCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JvdXAgPSBbXSxcbiAgICAgICAgICAgIHJldHVyblZhbHVlO1xuXG4gICAgICAgIGlmIChtZS5mb3JtR3JvdXBTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5mb3JtR3JvdXBTdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAmJiBncm91cC5wdXNoKHZhbHVlKTtcblxuICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgIHBhcmVudC5mb3JtR3JvdXAgJiYgZ3JvdXAudW5zaGlmdChwYXJlbnQuZm9ybUdyb3VwKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm5WYWx1ZSA9IGdyb3VwLmpvaW4oJy4nKTtcblxuICAgICAgICBtZS5mb3JtR3JvdXBTdHJpbmcgPSByZXR1cm5WYWx1ZTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBpc1RvdWNoZWRFdmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldElzVG91Y2hlZEV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnaXNUb3VjaGVkRXZlbnQnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlIG9mIGEgaW5wdXRFbCB2ZG9tIG9iamVjdCBhdHRyaWJ1dGUgb3IgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IGhhcyBubyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcnxPYmplY3R8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjaGFuZ2VJbnB1dEVsS2V5KGtleSwgdmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSB8fCBOZW8uaXNCb29sZWFuKHZhbHVlKSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgbWUuZ2V0SW5wdXRFbCgpW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5nZXRJbnB1dEVsKClba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICovXG4gICAgZG9GaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlLCBldmVudE5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICBmb3JtRXZlbnQgICAgID0gJ2ZpZWxkJyArIE5lby5jYXBpdGFsaXplKGV2ZW50TmFtZSksXG4gICAgICAgICAgICBvcHRzICAgICAgICAgID0ge2NvbXBvbmVudDogbWUsIG9sZFZhbHVlLCB2YWx1ZX07XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKG1lLmdldEdyb3VwVmFsdWUpKSB7XG4gICAgICAgICAgICBvcHRzLmdyb3VwVmFsdWUgPSBtZS5nZXRHcm91cFZhbHVlKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmZpcmUoZXZlbnROYW1lLCBvcHRzKTtcblxuICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZpcmUoZm9ybUV2ZW50LCBvcHRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb0ZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUsICdjaGFuZ2UnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZVVzZXJDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb0ZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUsICd1c2VyQ2hhbmdlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtcyBpbiBuZW8gY2FuIGJlIG5lc3RlZC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgcGFyZW50IHdoaWNoIGlzIGEgZm9ybS5Db250YWluZXIgb3IgbnVsbC5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmZvcm0uQ29udGFpbmVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q2xvc2VzdEZvcm0oKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyLFxuICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgIGZvciAocGFyZW50IG9mIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkpIHtcbiAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRJbnB1dEVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tYmluYXRpb24gb2YgdGhlIGZpZWxkIGZvcm1Hcm91cChzKSAmIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHBhdGg7XG5cbiAgICAgICAgLy8gZmllbGRzIGNvdWxkIGhhdmUgZm9ybUdyb3VwcywgYnV0IG5vIG5hbWUuXG4gICAgICAgIC8vIHJldHVybmluZyB0aGUgbmFtZXNwYWNlIGNhbiBjb25mdXNlIGZvcm0uQ29udGFpbmVyLmFkanVzdFRyZWVMZWF2ZXMoKSxcbiAgICAgICAgLy8gc2luY2UgbmFtZXNwYWNlcyBjb3VsZCBiZSBjb25zaWRlcmVkIGFzIGZpZWxkIGluc3RhbmNlcy5cbiAgICAgICAgaWYgKCFtZS5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5wYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gbWUuZm9ybUdyb3VwID8gbWUuZm9ybUdyb3VwLnNwbGl0KCcuJykgOiBbXTtcblxuICAgICAgICAgICAgbWUubmFtZSAmJiBwYXRoLnB1c2gobWUubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5wYXRoID0gcGF0aC5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnBhdGgpIHtcbiAgICAgICAgICAgIG1lLnBhdGggPSAnbm9uZSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5wYXRoID09PSAnbm9uZScgPyBudWxsOiBtZS5wYXRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Gb2N1c0VudGVyKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hlZEV2ZW50ID09PSAnZm9jdXNFbnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyLFxuICAgICAgICAgICAgb3B0cyAgICAgICAgICA9IHsuLi5kYXRhLCBjb21wb25lbnQ6IG1lLCB2YWx1ZTogbWUuZ2V0VmFsdWUoKX07XG5cbiAgICAgICAgaWYgKG1lLmlzVG91Y2hlZEV2ZW50ID09PSAnZm9jdXNMZWF2ZScpIHtcbiAgICAgICAgICAgIG1lLmlzVG91Y2hlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihtZS5nZXRHcm91cFZhbHVlKSkge1xuICAgICAgICAgICAgb3B0cy5ncm91cFZhbHVlID0gbWUuZ2V0R3JvdXBWYWx1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZpcmUoJ2ZpZWxkRm9jdXNMZWF2ZScsIG9wdHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZmllbGQgdG8gYSBuZXcgdmFsdWUgb3IgbnVsbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWU9bnVsbFxuICAgICAqL1xuICAgIHJlc2V0KHZhbHVlPW51bGwpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY2xpZW50LXNpZGUgZmllbGQgZXJyb3JzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2xpZW50LXNpZGUgZXJyb3JzXG4gICAgICovXG4gICAgdmFsaWRhdGUoc2lsZW50PXRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBjaGFuZ2UgZXZlbnQgZmlyZXMgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAqIEBldmVudCBjaGFuZ2VcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=