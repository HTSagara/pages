"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_treeAccordion_app_mjs"],{

/***/ "./examples/treeAccordion/MainContainer.mjs":
/*!**************************************************!*\
  !*** ./examples/treeAccordion/MainContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_tree_Accordion_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/tree/Accordion.mjs */ "./src/tree/Accordion.mjs");
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/container/Panel.mjs */ "./src/container/Panel.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _src_model_Component_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../src/model/Component.mjs */ "./src/model/Component.mjs");







// Do not remove the ViewController nor ViewModel



/**
 * @class Neo.examples.treeAccordion.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className           : 'Neo.examples.treeAccordion.MainContainer',
        autoMount           : true,
        configItemLabelWidth: 100,
        configItemWidth     : 230,
        layout              : {ntype: 'hbox', align: 'stretch'},
        cls                 : ['examples-container-accordion']
    }

    createConfigurationComponents() {
        let me       = this,
            treeList = me.exampleComponent.items[0];

        return [{
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            checked       : treeList.rootParentsAreCollapsible,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'rootParentsAreCollapsible')},
            valueLabelText: 'rootParentsAreCollapsible'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            checked       : treeList.firstParentIsVisible,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'firstParentIsVisible')},
            style         : {marginTop: '10px'},
            valueLabelText: 'firstParentIsVisible'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            checked       : treeList.showIcon,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'showIcon')},
            style         : {marginTop: '10px'},
            valueLabelText: 'showIcon'
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable: true,
            labelText: 'height',
            listeners: {change: me.onConfigChange.bind(me, 'height')},
            maxValue : 1200,
            minValue : 250,
            stepSize : 50,
            value    : 650,
            style    : {marginTop: '10px'}
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable: true,
            labelText: 'width',
            listeners: {change: me.onConfigChange.bind(me, 'width')},
            maxValue : 1200,
            minValue : 200,
            stepSize : 3,
            style    : {marginTop: '10px'},
            value    : 400
        }, {
            ntype  : 'button',
            handler: me.onRemoveDomButtonClick.bind(me),
            style  : {marginTop: '20px'},
            text   : 'Remove DOM',
            width  : 100
        }];
    }

    /**
     * @returns {*}
     */
    createExampleComponent() {
        const me    = this,
              store = Neo.create(_src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], {
                  keyProperty: 'id',
                  model      : {
                      fields: [
                          {name: 'collapsed', type: 'Boolean'},
                          {name: 'content', type: 'String'},
                          {name: 'iconCls', type: 'String'},
                          {name: 'id', type: 'Integer'},
                          {name: 'isLeaf', type: 'Boolean'},
                          {name: 'name', type: 'String'},
                          {name: 'parentId', type: 'Integer'}
                      ]
                  },

                  autoLoad: true,
                  url     : '../../examples/treeAccordion/tree.json'
              });

        return Neo.ntype({
            ntype: 'container',

            model: {
                data: {
                    selection: [{name: 'Please select something'}]
                }
            },

            layout: {ntype: 'hbox', align: 'stretch'},
            items : [{
                module: _src_tree_Accordion_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],

                bind: {selection: {twoWay: true, value: data => data.selection}},

                store: store,

                /**
                 * We are using data-binding.
                 * Here is an example for listener and controller
                 */
                // controller: {
                //     module: ViewController,
                //
                //     onAccordionItemClick(record) {
                //         let viewport = Neo.get('neo-configuration-viewport-1'),
                //             outputEl = viewport.getReference('output');
                //
                //         outputEl.html = record.name;
                //     }
                // },
                //
                // listeners: {
                //     leafItemClick: 'onAccordionItemClick'
                // }

                listeners: {
                    selectPreFirstItem: () => Neo.log('listener selectPreFirstItem fired'),
                    selectPostLastItem: () => Neo.log('listener selectPostLastItem fired')
                }
            }, {
                module: _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                height: 150,
                flex : 1,

                itemDefaults: {
                    style: {
                        padding: '10px'
                    }
                },

                headers: [{
                    dock : 'top',
                    style: {borderRightColor: 'transparent'},

                    items: [{
                        ntype: 'label',
                        text : 'Accordion Selection'
                    }]
                }],

                items: [{
                    ntype    : 'component',
                    reference: 'output',
                    bind     : {html: data => data.selection[0].name}
                }]
            }]
        });
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        this.exampleComponent.items[0][config] = opts.value;
    }

    /**
     *
     * @param data
     */
    onRemoveDomButtonClick(data) {
        let accordion = this.exampleComponent.items[0];
        accordion.hidden = !accordion.hidden
    }
}

Neo.applyClassConfig(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./examples/treeAccordion/app.mjs":
/*!****************************************!*\
  !*** ./examples/treeAccordion/app.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/treeAccordion/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.treeAccordion'
});


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me        = this,
            component = me.component,
            listenerId;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            listenerId = component.on('constructed', () => {
                component.un('constructed', listenerId);
                me.onComponentConstructed()
            });
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @returns {Neo.controller.Component|null}
     */
    getHandlerScope(handlerName, component) {
        let me     = this,
            parent = me.parent;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            const handlerCb = component.resolveCallback(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an erly binding
            if (handlerCb.fn) {
                return true;
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent ?
            parent.getHandlerScope(handlerName) : null;
    }

    /**
     * sameLevelOnly=false will return the closest VM inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getModel(sameLevelOnly=false) {
        let component = this.component;
        return sameLevelOnly ? component.model : component.getModel()
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me = this;

        if (me.parent) {
            return me.parent;
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut for accessing model.Component based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getModel().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me        = this,
            handler   = component.handler,
            listeners = component.listeners,
            reference = component.reference,
            validator = component.validator,
            eventHandler, handlerScope;

        if (handler && typeof handler === 'string') {
            handlerScope = me.getHandlerScope(handler, component);

            // If the handler name was not resolved in the Component itself, bind it
            if (handlerScope !== true) {
                component.handler = handlerScope[handler].bind(component.handlerScope || handlerScope);
            }
        }

        if (listeners) {
            Object.entries(listeners).forEach(([key, value]) => {
                if (key !== 'scope' && key !== 'delegate') {
                    if (Neo.isString(value)) {
                        eventHandler = value;
                        handlerScope = me.getHandlerScope(eventHandler, component);

                        if (!handlerScope) {
                            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].logError('Unknown event handler for', eventHandler, component)
                        } else if (handlerScope !== true) {
                            listeners[key] = {};
                            listeners[key].fn = handlerScope[eventHandler].bind(handlerScope)
                        }
                    } else {
                        value.forEach(listener => {
                            if (Neo.isObject(listener) && listener.hasOwnProperty('fn') && Neo.isString(listener.fn)) {
                                eventHandler = listener.fn;
                                handlerScope = me.getHandlerScope(eventHandler, component);

                                if (!handlerScope) {
                                    console.error('Unknown event handler for', eventHandler, component)
                                } else if (handlerScope !== true) {
                                    listener.fn = handlerScope[eventHandler].bind(handlerScope)
                                }
                            }
                        });
                    }
                }
            });
        }

        if (Neo.isString(validator)) {
            handlerScope = me.getHandlerScope(validator);

            if (!handlerScope) {
                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].logError('Unknown validator for', component.id, component)
            } else {
                component.validator = handlerScope[validator].bind(handlerScope)
            }
        }

        if (reference) {
            me.references[reference] = component
        }
    }

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseDomListeners(component=this.component) {
        let me           = this,
            domListeners = component.domListeners,
            eventHandler, scope;

        if (domListeners) {
            domListeners.forEach(domListener => {
                Object.entries(domListener).forEach(([key, value]) => {
                    eventHandler = null;

                    if (key !== 'scope' && key !== 'delegate') {
                        if (Neo.isString(value)) {
                            eventHandler = value;
                        } else if (Neo.isObject(value) && value.hasOwnProperty('fn') && Neo.isString(value.fn)) {
                            eventHandler = value.fn;
                        }

                        if (eventHandler) {
                            scope = me.getHandlerScope(eventHandler);

                            if (!scope) {
                                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].logError('Unknown domEvent handler for', eventHandler, component)
                            } else {
                                domListener[key] = scope[eventHandler].bind(scope)
                            }
                        }
                    }
                })
            })
        }
    }

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me = this,
            references = me.references,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break;
            }
        }

        me.getParent()?.removeReference(component)
    }
}

Neo.applyClassConfig(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ }),

/***/ "./src/selection/TreeAccordionModel.mjs":
/*!**********************************************!*\
  !*** ./src/selection/TreeAccordionModel.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TreeModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeModel.mjs */ "./src/selection/TreeModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.selection.TreeAccordionModel
 * @extends Neo.selection.TreeModel
 */
class TreeAccordionModel extends _TreeModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.TreeAccordionModel'
         * @protected
         */
        className: 'Neo.selection.TreeAccordionModel',
        /**
         * @member {String} ntype='selection-treeaccordionmodel'
         * @protected
         */
        ntype: 'selection-treeaccordionmodel'
    }

    /**
     * Tries to find a child and returns it
     * @param {Object} record
     * @returns {Object|null}
     */
    checkForChild(record) {
        const view     = this.view,
              recordId = record[view.getKeyProperty()];
        let childRecord = null;

        for (const item of view.store.items) {
            if (item.parentId === recordId) {
                childRecord = item;
                break;
            }
        }

        return childRecord;
    }

    /**
     * Return the parent record if any
     * @param {Object} record
     * @returns {Object|null}
     */
    checkForParent(record) {
        if (record.parentId) {
            const view = this.view;

            return view.store.get(record.parentId);
        } else {
            return null;
        }
    }

    /**
     * Depending on {-1|1} step return
     * -1: previous record OR parent record
     *  1: next record or null
     *
     * @param {Object} record
     * @param {Number} step
     * @returns {Object|null}
     */
    checkForSibling(record, step) {
        const view           = this.view,
              store          = view.store,
              parentRecordId = record.parentId,
              recordId       = record[view.getKeyProperty()];
        let hasFoundNext   = false,
            nextItemRecord = null,
            previousItemRecord;

        for (let item of store.items) {
            if (hasFoundNext && item.parentId === parentRecordId) {
                nextItemRecord = item;
                break;
            }

            if (!hasFoundNext && item.parentId === parentRecordId) {
                if (!hasFoundNext && item[view.getKeyProperty()] === recordId) {
                    if (step === -1) break;
                    hasFoundNext = true;
                } else {
                    previousItemRecord = item;
                }
            }
        }

        return step === 1 ? nextItemRecord : (previousItemRecord || store.get(parentRecordId));
    }

    /**
     * Find the next sibling of a parent item
     * @param {Object} record
     * @returns {Object|null}
     */
    checkNextParentSibling(record) {
        const parent = this.view.store.get(record.parentId);
        let parentSibling = this.checkForSibling(parent, 1);

        if (!parentSibling && parent.parentId) this.checkNextParentSibling(parent);

        return parentSibling;
    }

    /**
     * Called by keys (List.mjs:register)
     * Toggle collapse or if isLeaf select next item
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        let me     = this,
            view   = me.view,
            itemId = me.getSelection()[0],
            record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || record.collapsed) {
            me.onKeyDownRight(data);
        } else {
            me.onKeyDownLeft(data);
        }
    }

    /**
     * Called by keys (List.mjs:register)
     * Deselect all and fire event selectPostLastItem
     * @param {Object} data
     */
    onKeyDownEscape(data) {
        let me = this;

        me.deselectAll();
    }

    /**
     * Collapse folder or select previous
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        const me     = this,
              view   = me.view,
              itemId = me.getSelection()[0];

        if (!itemId) {
            me.selectRoot();
            return;
        }

        const record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || record.collapsed || !view.rootParentsAreCollapsible) {
            me.onNavKey(data, -1);
        } else {
            me.toggleCollapsed(record, itemId, true);
        }
    }

    /**
     * Open folder or select next
     * @param {Object} data
     */
    onKeyDownRight(data) {
        const me     = this,
              view   = me.view,
              itemId = me.getSelection()[0];

        if (!itemId) {
            me.selectRoot();
            return;
        }

        const record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || !record.collapsed) {
            me.onNavKey(data, 1);
        } else {
            me.toggleCollapsed(record, itemId, false);
        }
    }

    /**
     * Handles 'up' and 'down' keys
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        const me   = this,
              view = me.view,
              item = me.getSelection()[0];
        let newRecord;

        if (item) {
            const recordId = view.getItemRecordId(item);
            let record = view.store.get(recordId);

            if (step === 1) {
                if (!record.isLeaf && !record.collapsed) {
                    // find first child
                    newRecord = this.checkForChild(record);
                } else {
                    // find next sibling
                    newRecord = this.checkForSibling(record, step);
                    // no ==> loop through parent next siblings until no parent
                    if (!newRecord) {
                        newRecord = this.checkNextParentSibling(record);
                    }
                }
                // current item was the last item
                if (!newRecord) {
                    me.deselectAll();
                    view.fire('selectPostLastItem');
                }
            } else if (step === -1) {
                // check previous sibling
                newRecord = this.checkForSibling(record, step);
                // no ==> get parent
                if (!newRecord) {
                    newRecord = this.checkForParent(record);
                }
                // current item was the first item
                if (!newRecord) {
                    me.deselectAll();
                    view.fire('selectPreFirstItem');
                }
            }
        } else {
            me.selectRoot();
        }

        if (newRecord) {
            const itemId = view.getItemId(newRecord[me.view.getKeyProperty()]);

            me.selectAndScrollIntoView(itemId);
        }
    }

    /**
     * Select an item and scroll the tree to show the item in the center
     * @param {String} itemId
     */
    selectAndScrollIntoView(itemId) {
        const me = this;

        me.select(itemId);

        Neo.main.DomAccess.scrollIntoView({
            id   : itemId,
            block: 'center'
        });
    }

    /**
     * Select the root item of the tree
     */
    selectRoot() {
        const me    = this,
              view  = me.view,
              store = view.store;
        let rootItemId;

        for (let record of store.items) {
            if (!record.parentId) {
                rootItemId = view.getItemId(record[me.view.getKeyProperty()]);
                break;
            }
        }

        me.selectAndScrollIntoView(rootItemId);
    }

    /**
     * Return the parent record if any
     * @param {Object} record
     * @param {String} itemId
     * @param {Boolean} collapse
     */
    toggleCollapsed(record, itemId, collapse) {
        const me    = this,
              item  = me.view.getVdomChild(itemId),
              clsFn = collapse ? 'remove' : 'add';

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][clsFn](item.cls, 'neo-folder-open');
        me.view.update();

        record.collapsed = collapse;
    }
}

Neo.applyClassConfig(TreeAccordionModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TreeAccordionModel);

/***/ }),

/***/ "./src/tree/Accordion.mjs":
/*!********************************!*\
  !*** ./src/tree/Accordion.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tree_List_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/List.mjs */ "./src/tree/List.mjs");
/* harmony import */ var _selection_TreeAccordionModel_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection/TreeAccordionModel.mjs */ "./src/selection/TreeAccordionModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.tree.Accordion
 * @extends Neo.tree.List
 *
 * Accordion Store expects the following fields
 *
 *      [
 *          iconCls,        // can be defined in fields:icon
 *          content,        // can be defined in fields:text
 *          name,           // can be defined in fields:header
 *
 *          collapsed,      // collapsed state for non-leaf-items
 *          isLeaf,         // defines it item is leaf-item
 *          id,             // defines item id
 *          parentId        // leaf or sub-items need a parentId
 *      ]
 *
 */
class AccordionTree extends _tree_List_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tree.Accordion'
         * @protected
         */
        className: 'Neo.tree.Accordion',
        /**
         * @member {String} ntype='treeaccordion'
         * @protected
         */
        ntype: 'treeaccordion',
        /**
         * @member {String[]} baseCls=['neo-tree-accordion']
         */
        baseCls: ['neo-tree-list'],
        /**
         * Set to false to hide the initial root item
         * @member {Boolean} firstParentIsVisible=true
         */
        firstParentIsVisible_: true,
        /**
         * Define the field names for the store to show header, text and icon
         * @member {Object} fields={header:'name',icon:'iconCls',text:'content'}
         */
        fields: {
            header: 'name',
            icon  : 'iconCls',
            text  : 'content'
        },
        /**
         * Set to false will auto expand root parent items and disallow collapsing
         * @member {Boolean} rootParentIsCollapsible=false
         */
        rootParentsAreCollapsible_: false,
        /**
         * Currently selected item, which is bindable
         * @member {Record[]|null} selection=null
         *
         * @example
         *     module: AccordionTree,
         *     bind  : {selection: {twoWay: true, value: data => data.selection}}
         *
         *     ntype: 'component',
         *     bind : {html: data => data.selection[0].name}
         */
        selection_: null,
        /**
         * Set to false will hide the icons for all leaf items
         * @member {Boolean} showIcon=true
         */
        showIcon_: true,
        /**
         * @member {Boolean} showCollapseExpandAllIcons=true
         */
        showCollapseExpandAllIcons: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'ul', cls: ['neo-list-container', 'neo-list', 'neo-accordion-style'], tabIndex: -1, cn: []}
        ]}
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.addDomListeners({
            focusin: me.onFocus,
            scope  : me
        })
    }

    /**
     * Called when changing firstParentIsVisible
     * First store item gets marked and additional css class
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetFirstParentIsVisible(value, oldValue) {
        const toggleFn = !value ? 'addCls' : 'removeCls';

        this[toggleFn]('first-parent-not-visible');

        if (this.store.first()) {
            this.store.first().visible = value;
        }
    }

    /**
     * Called when changing rootParentsAreCollapsible
     * Ensures that root items are expanded if not collapsible
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetRootParentsAreCollapsible(value, oldValue) {
        const me       = this,
              toggleFn = !value ? 'addCls' : 'removeCls';

        me[toggleFn]('root-not-collapsible');

        if (me.rendered && value === false) {
            const store = me.store;

            store.items.forEach(record => {
                if (record.parentId === null && !record.isLeaf) {
                    me.expandItem(record);
                }
            })
        }
    }

    /**
     * Called when changing showIcon
     * Changes the display of the icons
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetShowIcon(value, oldValue) {
        const me    = this,
              store = me.store,
              hide  = !value;

        store.items.forEach((record) => {
            const itemId   = me.getItemId(record[me.getKeyProperty()]),
                  vdom     = me.getVdomChild(itemId),
                  itemVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(vdom, 'icon');

            if (record.isLeaf) {
                itemVdom.removeDom = hide;
            }
        })

        me.update()
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].beforeSetInstance(value, _selection_TreeAccordionModel_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }

    /**
     * Remove all items from the accordion
     * If you do not need to update the view after clearing, set `withUpdate = false`
     *
     * @param {Boolean} [withUpdate=true]
     */
    clear(withUpdate=true) {
        delete this.getVdomRoot().cn[0].cn

        withUpdate && this.update();
    }

    /**
     * Remove all items from the selection
     */
    clearSelection() {
        this.selectionModel.deselectAll();
    }

    /**
     * @param {String} [parentId] The parent node
     * @param {Object} [vdomRoot] The vdom template root for the current sub tree
     * @param {Number} level The hierarchy level of the tree
     * @returns {Object} vdomRoot
     * @protected
     */
    createItems(parentId, vdomRoot, level) {
        let me        = this,
            items     = me.store.find('parentId', parentId),
            itemCls   = me.itemCls,
            folderCls = me.folderCls,
            cls, id, itemIconCls, tmpRoot;

        if (items.length > 0) {
            if (!vdomRoot.cn) {
                vdomRoot.cn = [];
            }

            if (parentId !== null) {
                vdomRoot.cn.push({
                    tag: 'ul',
                    cls: ['neo-list'],
                    cn : [],
                    id : `${me.id}__${parentId}__ul`
                });

                tmpRoot = vdomRoot.cn[vdomRoot.cn.length - 1];
            } else {
                tmpRoot = vdomRoot;
            }

            items.forEach(item => {
                cls = [itemCls];

                itemIconCls = ['neo-accordion-item-icon'];
                if (item.iconCls) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(itemIconCls, item.iconCls.split(' '));
                }


                if (item.isLeaf) {
                    cls.push(itemCls + (item.singleton ? '-leaf-singleton' : '-leaf'));
                } else {
                    cls.push(folderCls);

                    if (!item.parentId && !me.rootParentsAreCollapsible) {

                        cls.push('neo-not-collapsible');
                        if (item.collapsed) {
                            item.collapsed = false;
                        }
                    }
                    if (!item.collapsed) {
                        cls.push('neo-folder-open');
                    }
                }

                id = me.getItemId(item.id);

                tmpRoot.cn.push({
                    tag: 'li',
                    cls,
                    id,
                    cn : [{
                        flag     : 'iconCls',
                        tag      : 'span',
                        cls      : itemIconCls,
                        id       : id + '__icon',
                        removeDom: (!item.isLeaf || !me.showIcon)
                    }, {
                        cls  : [itemCls + '-content'],
                        id   : id + '__item-content',
                        style: {pointerEvents: 'none'},
                        cn   : [{
                            flag     : 'name',
                            tag      : 'span',
                            cls      : [itemCls + '-content-header'],
                            id       : id + '__item-content-header',
                            innerHTML: item[me.fields.header]
                        }, {
                            flag     : 'content',
                            tag      : 'span',
                            cls      : [itemCls + '-content-text'],
                            id       : id + '__item-content-text',
                            innerHTML: item[me.fields.text]
                        }]
                    }],
                    style: {
                        position: item.isLeaf ? null : 'sticky',
                        top     : item.isLeaf ? null : (level * 38) + 'px',
                        zIndex  : item.isLeaf ? null : (20 / (level + 1)),
                    }
                });

                tmpRoot = me.createItems(item.id, tmpRoot, level + 1);
            });
        }

        return vdomRoot;
    }


    /**
     * Expands an item based on the record
     * @param {Object} record
     */
    expandItem(record) {
        const me     = this,
              itemId = me.getItemId(record[me.getKeyProperty()]),
              item   = me.getVdomChild(itemId);

        record.collapsed = false;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(item.cls, 'neo-folder-open');
        me.update();
    }

    /**
     * @param {Object} item
     * @param {Object} data
     */
    onItemClick(item, data) {
        super.onItemClick(item, data);

        const me             = this,
              selectionModel = me.selectionModel,
              itemId         = item.id,
              id             = Number(itemId.split('__')[1]),
              record         = me.store.get(id);

        selectionModel.select(item.id);

        if (!record.isLeaf) {
            /**
             * The folderItemClick event fires when a click occurs on a list item which does have child items.
             * Passes the item record to the event handler.
             * @event folderItemClick
             * @returns {Object} record
             */
            me.fire('folderItemClick', {record});

            record.collapsed = !record.collapsed
        }
    }

    /**
     * To place the root item at the correct location
     * @returns {Object}
     */
    getListItemsRoot() {
        return this.vdom.cn[0];
    }

    /**
     * Accordion gaining focus without selection => setSelection
     * @param {Object} data
     */
    onFocus(data) {
        const me        = this,
              selModel  = me.selectionModel,
              selection = selModel.getSelection()[0];

        if (!selection) selModel.selectRoot();
    }

    /**
     * Called from SelectionModel select()
     * @param {String[]} value
     */
    onSelect(value) {
        const me = this;
        let records = [];

        value.forEach((selectItemId) => {
            let id     = me.getItemRecordId(selectItemId),
                record = me.store.get(id);

            records.push(record);
        });

        me.selection = records;
    }

    /**
     * After the store loaded, create the items for the list
     * @param {Record[]} records
     */
    onStoreLoad(records) {
        let me = this,
            listenerId;

        me.clear(false);

        if (!me.mounted && me.rendering) {
            listenerId = me.on('mounted', () => {
                me.un('mounted', listenerId);
                me.createItems(null, me.getListItemsRoot(), 0);
                me.update()
            });
        } else {
            me.createItems(null, me.getListItemsRoot(), 0);
            me.update()
        }
    }

    /**
     * Update a record
     * @param {Object}         data
     * @param {Object[]}       data.fields
     * @param {Number}         data.index
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     */
    onStoreRecordChange(data) {
        let me     = this,
            record = data.record,
            fields = data.fields,
            itemId = me.getItemId(record[me.getKeyProperty()]),
            vdom   = me.getVdomChild(itemId),
            itemVdom;

        fields.forEach((field) => {
            itemVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(vdom, field.name);

            if (itemVdom) {
                if (field.name === 'iconCls') {
                    const clsItems = field.value.split(' '),
                          cls      = ['neo-accordion-item-icon'];

                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(cls, clsItems);
                    itemVdom.cls = cls;
                } else {
                    itemVdom.html = field.value;
                }
            }
        });

        me.update()
    }

    /**
     * Set the selection either bei record id or record.
     * You can pass a record or a recordId as value
     *
     * @param {Record|Record[]|Number|Number[]|String|String[]} value
     */
    setSelection(value) {
        if (value === null) {
            this.clearSelection();
            return;
        }

        // In case you pass in an array use only the first item
        if (Neo.isArray(value)) value = value[0];

        const me = this;
        let recordKeyProperty, elId;

        if (Neo.isObject(value)) {
            // Record
            recordKeyProperty = value[me.getKeyProperty()];
        } else {
            // RecordId
            recordKeyProperty = value;
        }

        elId = me.getItemId(recordKeyProperty);

        me.selectionModel.selectAndScrollIntoView(elId);
    }
}

Neo.applyClassConfig(AccordionTree);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AccordionTree);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX3RyZWVBY2NvcmRpb25fYXBwX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7O0FBRVA7QUFDSztBQUNGO0FBQ0Y7QUFDTDtBQUN0RDtBQUNnRTtBQUNMOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsb0VBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdFQUFnRTtBQUM3RjtBQUNBLFNBQVM7QUFDVCw0QkFBNEIsb0VBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJEQUEyRDtBQUN4Riw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsU0FBUztBQUNULDRCQUE0QixvRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0NBQStDO0FBQzVFLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLGtFQUFXO0FBQ2xDO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQTZDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVCx1QkFBdUIsa0VBQVc7QUFDbEM7QUFDQTtBQUNBLHdCQUF3Qiw0Q0FBNEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyREFBSztBQUN0QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlELDJCQUEyQixnQ0FBZ0M7QUFDM0QsMkJBQTJCLGdDQUFnQztBQUMz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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHNEQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdURBQVE7QUFDNUI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBaUQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL3RyZWVBY2NvcmRpb24vTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL3RyZWVBY2NvcmRpb24vYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9UcmVlQWNjb3JkaW9uTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdHJlZS9BY2NvcmRpb24ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb25maWd1cmF0aW9uVmlld3BvcnQgZnJvbSAnLi4vQ29uZmlndXJhdGlvblZpZXdwb3J0Lm1qcyc7XG5cbmltcG9ydCBBY2NvcmRpb25UcmVlICBmcm9tICcuLi8uLi9zcmMvdHJlZS9BY2NvcmRpb24ubWpzJztcbmltcG9ydCBDaGVja0JveCAgICAgICBmcm9tIFwiLi4vLi4vc3JjL2Zvcm0vZmllbGQvQ2hlY2tCb3gubWpzXCI7XG5pbXBvcnQgTnVtYmVyRmllbGQgICAgZnJvbSAnLi4vLi4vc3JjL2Zvcm0vZmllbGQvTnVtYmVyLm1qcyc7XG5pbXBvcnQgUGFuZWwgICAgICAgICAgZnJvbSAnLi4vLi4vc3JjL2NvbnRhaW5lci9QYW5lbC5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgIGZyb20gJy4uLy4uL3NyYy9kYXRhL1N0b3JlLm1qcyc7XG4vLyBEbyBub3QgcmVtb3ZlIHRoZSBWaWV3Q29udHJvbGxlciBub3IgVmlld01vZGVsXG5pbXBvcnQgVmlld0NvbnRyb2xsZXIgZnJvbSAnLi4vLi4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgVmlld01vZGVsICAgICAgZnJvbSAnLi4vLi4vc3JjL21vZGVsL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMudHJlZUFjY29yZGlvbi5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZXhhbXBsZXMuQ29uZmlndXJhdGlvblZpZXdwb3J0XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBDb25maWd1cmF0aW9uVmlld3BvcnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIGNsYXNzTmFtZSAgICAgICAgICAgOiAnTmVvLmV4YW1wbGVzLnRyZWVBY2NvcmRpb24uTWFpbkNvbnRhaW5lcicsXG4gICAgICAgIGF1dG9Nb3VudCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICBjb25maWdJdGVtTGFiZWxXaWR0aDogMTAwLFxuICAgICAgICBjb25maWdJdGVtV2lkdGggICAgIDogMjMwLFxuICAgICAgICBsYXlvdXQgICAgICAgICAgICAgIDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICBjbHMgICAgICAgICAgICAgICAgIDogWydleGFtcGxlcy1jb250YWluZXItYWNjb3JkaW9uJ11cbiAgICB9XG5cbiAgICBjcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50cygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRyZWVMaXN0ID0gbWUuZXhhbXBsZUNvbXBvbmVudC5pdGVtc1swXTtcblxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgOiBDaGVja0JveCxcbiAgICAgICAgICAgIGNoZWNrZWQgICAgICAgOiB0cmVlTGlzdC5yb290UGFyZW50c0FyZUNvbGxhcHNpYmxlLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICA6IHRydWUsXG4gICAgICAgICAgICBoaWRlVmFsdWVMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgIDoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ3Jvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUnKX0sXG4gICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogJ3Jvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgOiBDaGVja0JveCxcbiAgICAgICAgICAgIGNoZWNrZWQgICAgICAgOiB0cmVlTGlzdC5maXJzdFBhcmVudElzVmlzaWJsZSxcbiAgICAgICAgICAgIGhpZGVMYWJlbCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgaGlkZVZhbHVlTGFiZWw6IGZhbHNlLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgICA6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdmaXJzdFBhcmVudElzVmlzaWJsZScpfSxcbiAgICAgICAgICAgIHN0eWxlICAgICAgICAgOiB7bWFyZ2luVG9wOiAnMTBweCd9LFxuICAgICAgICAgICAgdmFsdWVMYWJlbFRleHQ6ICdmaXJzdFBhcmVudElzVmlzaWJsZSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IENoZWNrQm94LFxuICAgICAgICAgICAgY2hlY2tlZCAgICAgICA6IHRyZWVMaXN0LnNob3dJY29uLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICA6IHRydWUsXG4gICAgICAgICAgICBoaWRlVmFsdWVMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgIDoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ3Nob3dJY29uJyl9LFxuICAgICAgICAgICAgc3R5bGUgICAgICAgICA6IHttYXJnaW5Ub3A6ICcxMHB4J30sXG4gICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogJ3Nob3dJY29uJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IE51bWJlckZpZWxkLFxuICAgICAgICAgICAgY2xlYXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2hlaWdodCcpfSxcbiAgICAgICAgICAgIG1heFZhbHVlIDogMTIwMCxcbiAgICAgICAgICAgIG1pblZhbHVlIDogMjUwLFxuICAgICAgICAgICAgc3RlcFNpemUgOiA1MCxcbiAgICAgICAgICAgIHZhbHVlICAgIDogNjUwLFxuICAgICAgICAgICAgc3R5bGUgICAgOiB7bWFyZ2luVG9wOiAnMTBweCd9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogTnVtYmVyRmllbGQsXG4gICAgICAgICAgICBjbGVhcmFibGU6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICd3aWR0aCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICd3aWR0aCcpfSxcbiAgICAgICAgICAgIG1heFZhbHVlIDogMTIwMCxcbiAgICAgICAgICAgIG1pblZhbHVlIDogMjAwLFxuICAgICAgICAgICAgc3RlcFNpemUgOiAzLFxuICAgICAgICAgICAgc3R5bGUgICAgOiB7bWFyZ2luVG9wOiAnMTBweCd9LFxuICAgICAgICAgICAgdmFsdWUgICAgOiA0MDBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbnR5cGUgIDogJ2J1dHRvbicsXG4gICAgICAgICAgICBoYW5kbGVyOiBtZS5vblJlbW92ZURvbUJ1dHRvbkNsaWNrLmJpbmQobWUpLFxuICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpblRvcDogJzIwcHgnfSxcbiAgICAgICAgICAgIHRleHQgICA6ICdSZW1vdmUgRE9NJyxcbiAgICAgICAgICAgIHdpZHRoICA6IDEwMFxuICAgICAgICB9XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjcmVhdGVFeGFtcGxlQ29tcG9uZW50KCkge1xuICAgICAgICBjb25zdCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICAgIHN0b3JlID0gTmVvLmNyZWF0ZShTdG9yZSwge1xuICAgICAgICAgICAgICAgICAga2V5UHJvcGVydHk6ICdpZCcsXG4gICAgICAgICAgICAgICAgICBtb2RlbCAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2NvbGxhcHNlZCcsIHR5cGU6ICdCb29sZWFuJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnY29udGVudCcsIHR5cGU6ICdTdHJpbmcnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdpY29uQ2xzJywgdHlwZTogJ1N0cmluZyd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgdHlwZTogJ0ludGVnZXInfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdpc0xlYWYnLCB0eXBlOiAnQm9vbGVhbid9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ25hbWUnLCB0eXBlOiAnU3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncGFyZW50SWQnLCB0eXBlOiAnSW50ZWdlcid9XG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICB1cmwgICAgIDogJy4uLy4uL2V4YW1wbGVzL3RyZWVBY2NvcmRpb24vdHJlZS5qc29uJ1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gTmVvLm50eXBlKHtcbiAgICAgICAgICAgIG50eXBlOiAnY29udGFpbmVyJyxcblxuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogW3tuYW1lOiAnUGxlYXNlIHNlbGVjdCBzb21ldGhpbmcnfV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgIGl0ZW1zIDogW3tcbiAgICAgICAgICAgICAgICBtb2R1bGU6IEFjY29yZGlvblRyZWUsXG5cbiAgICAgICAgICAgICAgICBiaW5kOiB7c2VsZWN0aW9uOiB7dHdvV2F5OiB0cnVlLCB2YWx1ZTogZGF0YSA9PiBkYXRhLnNlbGVjdGlvbn19LFxuXG4gICAgICAgICAgICAgICAgc3RvcmU6IHN0b3JlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2UgYXJlIHVzaW5nIGRhdGEtYmluZGluZy5cbiAgICAgICAgICAgICAgICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgZm9yIGxpc3RlbmVyIGFuZCBjb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gY29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIC8vICAgICBtb2R1bGU6IFZpZXdDb250cm9sbGVyLFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIG9uQWNjb3JkaW9uSXRlbUNsaWNrKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IHZpZXdwb3J0ID0gTmVvLmdldCgnbmVvLWNvbmZpZ3VyYXRpb24tdmlld3BvcnQtMScpLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIG91dHB1dEVsID0gdmlld3BvcnQuZ2V0UmVmZXJlbmNlKCdvdXRwdXQnKTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgb3V0cHV0RWwuaHRtbCA9IHJlY29yZC5uYW1lO1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfSxcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgIC8vICAgICBsZWFmSXRlbUNsaWNrOiAnb25BY2NvcmRpb25JdGVtQ2xpY2snXG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFByZUZpcnN0SXRlbTogKCkgPT4gTmVvLmxvZygnbGlzdGVuZXIgc2VsZWN0UHJlRmlyc3RJdGVtIGZpcmVkJyksXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFBvc3RMYXN0SXRlbTogKCkgPT4gTmVvLmxvZygnbGlzdGVuZXIgc2VsZWN0UG9zdExhc3RJdGVtIGZpcmVkJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBQYW5lbCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDE1MCxcbiAgICAgICAgICAgICAgICBmbGV4IDogMSxcblxuICAgICAgICAgICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzEwcHgnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgaGVhZGVyczogW3tcbiAgICAgICAgICAgICAgICAgICAgZG9jayA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge2JvcmRlclJpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCd9LFxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0IDogJ0FjY29yZGlvbiBTZWxlY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfV0sXG5cbiAgICAgICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAnb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgYmluZCAgICAgOiB7aHRtbDogZGF0YSA9PiBkYXRhLnNlbGVjdGlvblswXS5uYW1lfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkNvbmZpZ0NoYW5nZShjb25maWcsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5leGFtcGxlQ29tcG9uZW50Lml0ZW1zWzBdW2NvbmZpZ10gPSBvcHRzLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvblJlbW92ZURvbUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IGFjY29yZGlvbiA9IHRoaXMuZXhhbXBsZUNvbXBvbmVudC5pdGVtc1swXTtcbiAgICAgICAgYWNjb3JkaW9uLmhpZGRlbiA9ICFhY2NvcmRpb24uaGlkZGVuXG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhNYWluQ29udGFpbmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFpbkNvbnRhaW5lcjtcbiIsImltcG9ydCBNYWluQ29udGFpbmVyIGZyb20gJy4vTWFpbkNvbnRhaW5lci5tanMnO1xuXG5leHBvcnQgY29uc3Qgb25TdGFydCA9ICgpID0+IE5lby5hcHAoe1xuICAgIG1haW5WaWV3OiBNYWluQ29udGFpbmVyLFxuICAgIG5hbWUgICAgOiAnTmVvLmV4YW1wbGVzLnRyZWVBY2NvcmRpb24nXG59KTtcbiIsImltcG9ydCBCYXNlICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1jb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1jb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZWZlcmVuY2VzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlczogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LFxuICAgICAgICAgICAgbGlzdGVuZXJJZDtcblxuICAgICAgICBtZS5yZWZlcmVuY2VzID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVySWQgPSBjb21wb25lbnQub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bignY29uc3RydWN0ZWQnLCBsaXN0ZW5lcklkKTtcbiAgICAgICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFBhcmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlck5hbWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnQgPSBtZS5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhzIGZ1bmN0aW9uICpuYW1lKiBmaXJzdCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZi5cbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgaXQsIHJldHVybiB0cnVlIHNvIGNhbGxpbmcgY29kZSBrbm93cyBub3QgdG8gY29udGludWUgdG8gc2VhcmNoLlxuICAgICAgICAgICAgY29uc3QgaGFuZGxlckNiID0gY29tcG9uZW50LnJlc29sdmVDYWxsYmFjayhoYW5kbGVyTmFtZSwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBmbiBpcyByZXNvbHZlZCBpbiB0aGUgQ29tcG9uZW50IG9yIGl0cyBvd24gcGFyZW50IGNoYWluLlxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3RhdHVzIGluZGljYXRpbmcgdGhhdCB3ZSBkbyBub3QgbmVlZCBhbiBlcmx5IGJpbmRpbmdcbiAgICAgICAgICAgIGlmIChoYW5kbGVyQ2IuZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZW8uaXNGdW5jdGlvbihtZVtoYW5kbGVyTmFtZV0pID9cbiAgICAgICAgICAgIG1lIDogcGFyZW50ID9cbiAgICAgICAgICAgIHBhcmVudC5nZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYW1lTGV2ZWxPbmx5PWZhbHNlIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFZNIGluc2lkZSB0aGUgY29tcG9uZW50IHBhcmVudCB0cmVlLFxuICAgICAqIGluIGNhc2UgdGhlcmUgaXMgbm9uZSBvbiB0aGUgc2FtZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW1lTGV2ZWxPbmx5PWZhbHNlXVxuICAgICAqL1xuICAgIGdldE1vZGVsKHNhbWVMZXZlbE9ubHk9ZmFsc2UpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gc2FtZUxldmVsT25seSA/IGNvbXBvbmVudC5tb2RlbCA6IGNvbXBvbmVudC5nZXRNb2RlbCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IGNvbnRyb2xsZXIgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLmNvbXBvbmVudC5wYXJlbnQ/LmdldENvbnRyb2xsZXIoKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9kbzogdXBkYXRlIGNoYW5nZWQgcmVmZXJlbmNlcyAoZS5nLiBjb250YWluZXIucmVtb3ZlKCkgdGhlbiBjb250YWluZXIuYWRkKCkgdXNpbmcgdGhlIHNhbWUga2V5KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5yZWZlcmVuY2VzW25hbWVdO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5jb21wb25lbnQuZG93bih7cmVmZXJlbmNlOiBuYW1lfSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZWZlcmVuY2VzW25hbWVdID0gY29tcG9uZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50IHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgYWNjZXNzaW5nIG1vZGVsLkNvbXBvbmVudCBiYXNlZCBkYXRhLlN0b3Jlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vZGVsKCkuZ2V0U3RvcmUoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluc2lkZSB5b3VyIHZpZXcgY29udHJvbGxlcnMgYXMgYSBzdGFydGluZyBwb2ludCBpbiBjYXNlIHlvdSBuZWVkIHJlZmVyZW5jZXNcbiAgICAgKiAoaW5zdGVhZCBvZiB1c2luZyBvbkNvbnN0cnVjdGVkKCkgaW5zaWRlIHlvdXIgY29udHJvbGxlcilcbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudENvbnN0cnVjdGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnQ9dGhpcy5jb21wb25lbnRcbiAgICAgKi9cbiAgICBwYXJzZUNvbmZpZyhjb21wb25lbnQ9dGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYW5kbGVyICAgPSBjb21wb25lbnQuaGFuZGxlcixcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IGNvbXBvbmVudC5saXN0ZW5lcnMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBjb21wb25lbnQucmVmZXJlbmNlLFxuICAgICAgICAgICAgdmFsaWRhdG9yID0gY29tcG9uZW50LnZhbGlkYXRvcixcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgaGFuZGxlclNjb3BlO1xuXG4gICAgICAgIGlmIChoYW5kbGVyICYmIHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXIsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIG5hbWUgd2FzIG5vdCByZXNvbHZlZCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZiwgYmluZCBpdFxuICAgICAgICAgICAgaWYgKGhhbmRsZXJTY29wZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5oYW5kbGVyID0gaGFuZGxlclNjb3BlW2hhbmRsZXJdLmJpbmQoY29tcG9uZW50LmhhbmRsZXJTY29wZSB8fCBoYW5kbGVyU2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobGlzdGVuZXJzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnc2NvcGUnICYmIGtleSAhPT0gJ2RlbGVnYXRlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyU2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUoZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIGZvcicsIGV2ZW50SGFuZGxlciwgY29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyU2NvcGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1trZXldLmZuID0gaGFuZGxlclNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChoYW5kbGVyU2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGxpc3RlbmVyKSAmJiBsaXN0ZW5lci5oYXNPd25Qcm9wZXJ0eSgnZm4nKSAmJiBOZW8uaXNTdHJpbmcobGlzdGVuZXIuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IGxpc3RlbmVyLmZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyU2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUoZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgZm9yJywgZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlclNjb3BlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5mbiA9IGhhbmRsZXJTY29wZVtldmVudEhhbmRsZXJdLmJpbmQoaGFuZGxlclNjb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsaWRhdG9yKSkge1xuICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKHZhbGlkYXRvcik7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9yKCdVbmtub3duIHZhbGlkYXRvciBmb3InLCBjb21wb25lbnQuaWQsIGNvbXBvbmVudClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnZhbGlkYXRvciA9IGhhbmRsZXJTY29wZVt2YWxpZGF0b3JdLmJpbmQoaGFuZGxlclNjb3BlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tyZWZlcmVuY2VdID0gY29tcG9uZW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50PXRoaXMuY29tcG9uZW50XG4gICAgICovXG4gICAgcGFyc2VEb21MaXN0ZW5lcnMoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gY29tcG9uZW50LmRvbUxpc3RlbmVycyxcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgc2NvcGU7XG5cbiAgICAgICAgaWYgKGRvbUxpc3RlbmVycykge1xuICAgICAgICAgICAgZG9tTGlzdGVuZXJzLmZvckVhY2goZG9tTGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRvbUxpc3RlbmVyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnc2NvcGUnICYmIGtleSAhPT0gJ2RlbGVnYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZm4nKSAmJiBOZW8uaXNTdHJpbmcodmFsdWUuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gdmFsdWUuZm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShldmVudEhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ1Vua25vd24gZG9tRXZlbnQgaGFuZGxlciBmb3InLCBldmVudEhhbmRsZXIsIGNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21MaXN0ZW5lcltrZXldID0gc2NvcGVbZXZlbnRIYW5kbGVyXS5iaW5kKHNjb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lsbCBnZXQgY2FsbGVkIGJ5IGNvbXBvbmVudC5CYXNlOiBkZXN0cm95KCkgaW4gY2FzZSB0aGUgY29tcG9uZW50IGhhcyBhIHJlZmVyZW5jZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmVmZXJlbmNlcyA9IG1lLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gcmVmZXJlbmNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlZmVyZW5jZXNba2V5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmdldFBhcmVudCgpPy5yZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuIiwiaW1wb3J0IFRyZWVNb2RlbCBmcm9tICcuL1RyZWVNb2RlbC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tIFwiLi4vdXRpbC9BcnJheS5tanNcIjtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5UcmVlQWNjb3JkaW9uTW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uVHJlZU1vZGVsXG4gKi9cbmNsYXNzIFRyZWVBY2NvcmRpb25Nb2RlbCBleHRlbmRzIFRyZWVNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLlRyZWVBY2NvcmRpb25Nb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5UcmVlQWNjb3JkaW9uTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLXRyZWVhY2NvcmRpb25tb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tdHJlZWFjY29yZGlvbm1vZGVsJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWVzIHRvIGZpbmQgYSBjaGlsZCBhbmQgcmV0dXJucyBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgY2hlY2tGb3JDaGlsZChyZWNvcmQpIHtcbiAgICAgICAgY29uc3QgdmlldyAgICAgPSB0aGlzLnZpZXcsXG4gICAgICAgICAgICAgIHJlY29yZElkID0gcmVjb3JkW3ZpZXcuZ2V0S2V5UHJvcGVydHkoKV07XG4gICAgICAgIGxldCBjaGlsZFJlY29yZCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZpZXcuc3RvcmUuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudElkID09PSByZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVjb3JkID0gaXRlbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZFJlY29yZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBhcmVudCByZWNvcmQgaWYgYW55XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja0ZvclBhcmVudChyZWNvcmQpIHtcbiAgICAgICAgaWYgKHJlY29yZC5wYXJlbnRJZCkge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudmlldztcblxuICAgICAgICAgICAgcmV0dXJuIHZpZXcuc3RvcmUuZ2V0KHJlY29yZC5wYXJlbnRJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcGVuZGluZyBvbiB7LTF8MX0gc3RlcCByZXR1cm5cbiAgICAgKiAtMTogcHJldmlvdXMgcmVjb3JkIE9SIHBhcmVudCByZWNvcmRcbiAgICAgKiAgMTogbmV4dCByZWNvcmQgb3IgbnVsbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGNoZWNrRm9yU2libGluZyhyZWNvcmQsIHN0ZXApIHtcbiAgICAgICAgY29uc3QgdmlldyAgICAgICAgICAgPSB0aGlzLnZpZXcsXG4gICAgICAgICAgICAgIHN0b3JlICAgICAgICAgID0gdmlldy5zdG9yZSxcbiAgICAgICAgICAgICAgcGFyZW50UmVjb3JkSWQgPSByZWNvcmQucGFyZW50SWQsXG4gICAgICAgICAgICAgIHJlY29yZElkICAgICAgID0gcmVjb3JkW3ZpZXcuZ2V0S2V5UHJvcGVydHkoKV07XG4gICAgICAgIGxldCBoYXNGb3VuZE5leHQgICA9IGZhbHNlLFxuICAgICAgICAgICAgbmV4dEl0ZW1SZWNvcmQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNJdGVtUmVjb3JkO1xuXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2Ygc3RvcmUuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChoYXNGb3VuZE5leHQgJiYgaXRlbS5wYXJlbnRJZCA9PT0gcGFyZW50UmVjb3JkSWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0SXRlbVJlY29yZCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzRm91bmROZXh0ICYmIGl0ZW0ucGFyZW50SWQgPT09IHBhcmVudFJlY29yZElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNGb3VuZE5leHQgJiYgaXRlbVt2aWV3LmdldEtleVByb3BlcnR5KCldID09PSByZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gLTEpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBoYXNGb3VuZE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSXRlbVJlY29yZCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ZXAgPT09IDEgPyBuZXh0SXRlbVJlY29yZCA6IChwcmV2aW91c0l0ZW1SZWNvcmQgfHwgc3RvcmUuZ2V0KHBhcmVudFJlY29yZElkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbmV4dCBzaWJsaW5nIG9mIGEgcGFyZW50IGl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGNoZWNrTmV4dFBhcmVudFNpYmxpbmcocmVjb3JkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMudmlldy5zdG9yZS5nZXQocmVjb3JkLnBhcmVudElkKTtcbiAgICAgICAgbGV0IHBhcmVudFNpYmxpbmcgPSB0aGlzLmNoZWNrRm9yU2libGluZyhwYXJlbnQsIDEpO1xuXG4gICAgICAgIGlmICghcGFyZW50U2libGluZyAmJiBwYXJlbnQucGFyZW50SWQpIHRoaXMuY2hlY2tOZXh0UGFyZW50U2libGluZyhwYXJlbnQpO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRTaWJsaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBrZXlzIChMaXN0Lm1qczpyZWdpc3RlcilcbiAgICAgKiBUb2dnbGUgY29sbGFwc2Ugb3IgaWYgaXNMZWFmIHNlbGVjdCBuZXh0IGl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVudGVyKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2aWV3ICAgPSBtZS52aWV3LFxuICAgICAgICAgICAgaXRlbUlkID0gbWUuZ2V0U2VsZWN0aW9uKClbMF0sXG4gICAgICAgICAgICByZWNvcmQgPSB2aWV3LnN0b3JlLmdldCh2aWV3LmdldEl0ZW1SZWNvcmRJZChpdGVtSWQpKTtcblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiB8fCByZWNvcmQuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBtZS5vbktleURvd25SaWdodChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLm9uS2V5RG93bkxlZnQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkga2V5cyAoTGlzdC5tanM6cmVnaXN0ZXIpXG4gICAgICogRGVzZWxlY3QgYWxsIGFuZCBmaXJlIGV2ZW50IHNlbGVjdFBvc3RMYXN0SXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRXNjYXBlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kZXNlbGVjdEFsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlIGZvbGRlciBvciBzZWxlY3QgcHJldmlvdXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkxlZnQoZGF0YSkge1xuICAgICAgICBjb25zdCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICB2aWV3ICAgPSBtZS52aWV3LFxuICAgICAgICAgICAgICBpdGVtSWQgPSBtZS5nZXRTZWxlY3Rpb24oKVswXTtcblxuICAgICAgICBpZiAoIWl0ZW1JZCkge1xuICAgICAgICAgICAgbWUuc2VsZWN0Um9vdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjb3JkID0gdmlldy5zdG9yZS5nZXQodmlldy5nZXRJdGVtUmVjb3JkSWQoaXRlbUlkKSk7XG5cbiAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgfHwgcmVjb3JkLmNvbGxhcHNlZCB8fCAhdmlldy5yb290UGFyZW50c0FyZUNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgICBtZS5vbk5hdktleShkYXRhLCAtMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS50b2dnbGVDb2xsYXBzZWQocmVjb3JkLCBpdGVtSWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiBmb2xkZXIgb3Igc2VsZWN0IG5leHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blJpZ2h0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgdmlldyAgID0gbWUudmlldyxcbiAgICAgICAgICAgICAgaXRlbUlkID0gbWUuZ2V0U2VsZWN0aW9uKClbMF07XG5cbiAgICAgICAgaWYgKCFpdGVtSWQpIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdFJvb3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHZpZXcuc3RvcmUuZ2V0KHZpZXcuZ2V0SXRlbVJlY29yZElkKGl0ZW1JZCkpO1xuXG4gICAgICAgIGlmIChyZWNvcmQuaXNMZWFmIHx8ICFyZWNvcmQuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBtZS5vbk5hdktleShkYXRhLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnRvZ2dsZUNvbGxhcHNlZChyZWNvcmQsIGl0ZW1JZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyAndXAnIGFuZCAnZG93bicga2V5c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBvbk5hdktleShkYXRhLCBzdGVwKSB7XG4gICAgICAgIGNvbnN0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgICB2aWV3ID0gbWUudmlldyxcbiAgICAgICAgICAgICAgaXRlbSA9IG1lLmdldFNlbGVjdGlvbigpWzBdO1xuICAgICAgICBsZXQgbmV3UmVjb3JkO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmRJZCA9IHZpZXcuZ2V0SXRlbVJlY29yZElkKGl0ZW0pO1xuICAgICAgICAgICAgbGV0IHJlY29yZCA9IHZpZXcuc3RvcmUuZ2V0KHJlY29yZElkKTtcblxuICAgICAgICAgICAgaWYgKHN0ZXAgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY29yZC5pc0xlYWYgJiYgIXJlY29yZC5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBuZXdSZWNvcmQgPSB0aGlzLmNoZWNrRm9yQ2hpbGQocmVjb3JkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIG5leHQgc2libGluZ1xuICAgICAgICAgICAgICAgICAgICBuZXdSZWNvcmQgPSB0aGlzLmNoZWNrRm9yU2libGluZyhyZWNvcmQsIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICAvLyBubyA9PT4gbG9vcCB0aHJvdWdoIHBhcmVudCBuZXh0IHNpYmxpbmdzIHVudGlsIG5vIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1JlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVjb3JkID0gdGhpcy5jaGVja05leHRQYXJlbnRTaWJsaW5nKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBpdGVtIHdhcyB0aGUgbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3RQb3N0TGFzdEl0ZW0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgcHJldmlvdXMgc2libGluZ1xuICAgICAgICAgICAgICAgIG5ld1JlY29yZCA9IHRoaXMuY2hlY2tGb3JTaWJsaW5nKHJlY29yZCwgc3RlcCk7XG4gICAgICAgICAgICAgICAgLy8gbm8gPT0+IGdldCBwYXJlbnRcbiAgICAgICAgICAgICAgICBpZiAoIW5ld1JlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdSZWNvcmQgPSB0aGlzLmNoZWNrRm9yUGFyZW50KHJlY29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaXRlbSB3YXMgdGhlIGZpcnN0IGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAoIW5ld1JlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmZpcmUoJ3NlbGVjdFByZUZpcnN0SXRlbScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdFJvb3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JZCA9IHZpZXcuZ2V0SXRlbUlkKG5ld1JlY29yZFttZS52aWV3LmdldEtleVByb3BlcnR5KCldKTtcblxuICAgICAgICAgICAgbWUuc2VsZWN0QW5kU2Nyb2xsSW50b1ZpZXcoaXRlbUlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhbiBpdGVtIGFuZCBzY3JvbGwgdGhlIHRyZWUgdG8gc2hvdyB0aGUgaXRlbSBpbiB0aGUgY2VudGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqL1xuICAgIHNlbGVjdEFuZFNjcm9sbEludG9WaWV3KGl0ZW1JZCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2VsZWN0KGl0ZW1JZCk7XG5cbiAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgIGlkICAgOiBpdGVtSWQsXG4gICAgICAgICAgICBibG9jazogJ2NlbnRlcidcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSByb290IGl0ZW0gb2YgdGhlIHRyZWVcbiAgICAgKi9cbiAgICBzZWxlY3RSb290KCkge1xuICAgICAgICBjb25zdCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICAgIHZpZXcgID0gbWUudmlldyxcbiAgICAgICAgICAgICAgc3RvcmUgPSB2aWV3LnN0b3JlO1xuICAgICAgICBsZXQgcm9vdEl0ZW1JZDtcblxuICAgICAgICBmb3IgKGxldCByZWNvcmQgb2Ygc3RvcmUuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghcmVjb3JkLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgcm9vdEl0ZW1JZCA9IHZpZXcuZ2V0SXRlbUlkKHJlY29yZFttZS52aWV3LmdldEtleVByb3BlcnR5KCldKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNlbGVjdEFuZFNjcm9sbEludG9WaWV3KHJvb3RJdGVtSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcGFyZW50IHJlY29yZCBpZiBhbnlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGFwc2VcbiAgICAgKi9cbiAgICB0b2dnbGVDb2xsYXBzZWQocmVjb3JkLCBpdGVtSWQsIGNvbGxhcHNlKSB7XG4gICAgICAgIGNvbnN0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgaXRlbSAgPSBtZS52aWV3LmdldFZkb21DaGlsZChpdGVtSWQpLFxuICAgICAgICAgICAgICBjbHNGbiA9IGNvbGxhcHNlID8gJ3JlbW92ZScgOiAnYWRkJztcblxuICAgICAgICBOZW9BcnJheVtjbHNGbl0oaXRlbS5jbHMsICduZW8tZm9sZGVyLW9wZW4nKTtcbiAgICAgICAgbWUudmlldy51cGRhdGUoKTtcblxuICAgICAgICByZWNvcmQuY29sbGFwc2VkID0gY29sbGFwc2U7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhUcmVlQWNjb3JkaW9uTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBUcmVlQWNjb3JkaW9uTW9kZWw7IiwiaW1wb3J0IFRyZWVMaXN0ICAgICAgICAgICBmcm9tICcuLi90cmVlL0xpc3QubWpzJztcbmltcG9ydCBUcmVlQWNjb3JkaW9uTW9kZWwgZnJvbSBcIi4uL3NlbGVjdGlvbi9UcmVlQWNjb3JkaW9uTW9kZWwubWpzXCI7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gXCIuLi91dGlsL0FycmF5Lm1qc1wiO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCAgICBmcm9tIFwiLi4vdXRpbC9DbGFzc1N5c3RlbS5tanNcIjtcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSBcIi4uL3V0aWwvVkRvbS5tanNcIjtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRyZWUuQWNjb3JkaW9uXG4gKiBAZXh0ZW5kcyBOZW8udHJlZS5MaXN0XG4gKlxuICogQWNjb3JkaW9uIFN0b3JlIGV4cGVjdHMgdGhlIGZvbGxvd2luZyBmaWVsZHNcbiAqXG4gKiAgICAgIFtcbiAqICAgICAgICAgIGljb25DbHMsICAgICAgICAvLyBjYW4gYmUgZGVmaW5lZCBpbiBmaWVsZHM6aWNvblxuICogICAgICAgICAgY29udGVudCwgICAgICAgIC8vIGNhbiBiZSBkZWZpbmVkIGluIGZpZWxkczp0ZXh0XG4gKiAgICAgICAgICBuYW1lLCAgICAgICAgICAgLy8gY2FuIGJlIGRlZmluZWQgaW4gZmllbGRzOmhlYWRlclxuICpcbiAqICAgICAgICAgIGNvbGxhcHNlZCwgICAgICAvLyBjb2xsYXBzZWQgc3RhdGUgZm9yIG5vbi1sZWFmLWl0ZW1zXG4gKiAgICAgICAgICBpc0xlYWYsICAgICAgICAgLy8gZGVmaW5lcyBpdCBpdGVtIGlzIGxlYWYtaXRlbVxuICogICAgICAgICAgaWQsICAgICAgICAgICAgIC8vIGRlZmluZXMgaXRlbSBpZFxuICogICAgICAgICAgcGFyZW50SWQgICAgICAgIC8vIGxlYWYgb3Igc3ViLWl0ZW1zIG5lZWQgYSBwYXJlbnRJZFxuICogICAgICBdXG4gKlxuICovXG5jbGFzcyBBY2NvcmRpb25UcmVlIGV4dGVuZHMgVHJlZUxpc3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRyZWUuQWNjb3JkaW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udHJlZS5BY2NvcmRpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndHJlZWFjY29yZGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0cmVlYWNjb3JkaW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRyZWUtYWNjb3JkaW9uJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRyZWUtbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGZhbHNlIHRvIGhpZGUgdGhlIGluaXRpYWwgcm9vdCBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGZpcnN0UGFyZW50SXNWaXNpYmxlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGZpcnN0UGFyZW50SXNWaXNpYmxlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSB0aGUgZmllbGQgbmFtZXMgZm9yIHRoZSBzdG9yZSB0byBzaG93IGhlYWRlciwgdGV4dCBhbmQgaWNvblxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGZpZWxkcz17aGVhZGVyOiduYW1lJyxpY29uOidpY29uQ2xzJyx0ZXh0Oidjb250ZW50J31cbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgaGVhZGVyOiAnbmFtZScsXG4gICAgICAgICAgICBpY29uICA6ICdpY29uQ2xzJyxcbiAgICAgICAgICAgIHRleHQgIDogJ2NvbnRlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gZmFsc2Ugd2lsbCBhdXRvIGV4cGFuZCByb290IHBhcmVudCBpdGVtcyBhbmQgZGlzYWxsb3cgY29sbGFwc2luZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByb290UGFyZW50SXNDb2xsYXBzaWJsZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcm9vdFBhcmVudHNBcmVDb2xsYXBzaWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIHdoaWNoIGlzIGJpbmRhYmxlXG4gICAgICAgICAqIEBtZW1iZXIge1JlY29yZFtdfG51bGx9IHNlbGVjdGlvbj1udWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAgICBtb2R1bGU6IEFjY29yZGlvblRyZWUsXG4gICAgICAgICAqICAgICBiaW5kICA6IHtzZWxlY3Rpb246IHt0d29XYXk6IHRydWUsIHZhbHVlOiBkYXRhID0+IGRhdGEuc2VsZWN0aW9ufX1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICogICAgIGJpbmQgOiB7aHRtbDogZGF0YSA9PiBkYXRhLnNlbGVjdGlvblswXS5uYW1lfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byBmYWxzZSB3aWxsIGhpZGUgdGhlIGljb25zIGZvciBhbGwgbGVhZiBpdGVtc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93SWNvbj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SWNvbl86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29uczogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7dGFnOiAndWwnLCBjbHM6IFsnbmVvLWxpc3QtY29udGFpbmVyJywgJ25lby1saXN0JywgJ25lby1hY2NvcmRpb24tc3R5bGUnXSwgdGFiSW5kZXg6IC0xLCBjbjogW119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgZm9jdXNpbjogbWUub25Gb2N1cyxcbiAgICAgICAgICAgIHNjb3BlICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gY2hhbmdpbmcgZmlyc3RQYXJlbnRJc1Zpc2libGVcbiAgICAgKiBGaXJzdCBzdG9yZSBpdGVtIGdldHMgbWFya2VkIGFuZCBhZGRpdGlvbmFsIGNzcyBjbGFzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldEZpcnN0UGFyZW50SXNWaXNpYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCB0b2dnbGVGbiA9ICF2YWx1ZSA/ICdhZGRDbHMnIDogJ3JlbW92ZUNscyc7XG5cbiAgICAgICAgdGhpc1t0b2dnbGVGbl0oJ2ZpcnN0LXBhcmVudC1ub3QtdmlzaWJsZScpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0b3JlLmZpcnN0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZmlyc3QoKS52aXNpYmxlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2luZyByb290UGFyZW50c0FyZUNvbGxhcHNpYmxlXG4gICAgICogRW5zdXJlcyB0aGF0IHJvb3QgaXRlbXMgYXJlIGV4cGFuZGVkIGlmIG5vdCBjb2xsYXBzaWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgdG9nZ2xlRm4gPSAhdmFsdWUgPyAnYWRkQ2xzJyA6ICdyZW1vdmVDbHMnO1xuXG4gICAgICAgIG1lW3RvZ2dsZUZuXSgncm9vdC1ub3QtY29sbGFwc2libGUnKTtcblxuICAgICAgICBpZiAobWUucmVuZGVyZWQgJiYgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZSA9IG1lLnN0b3JlO1xuXG4gICAgICAgICAgICBzdG9yZS5pdGVtcy5mb3JFYWNoKHJlY29yZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5wYXJlbnRJZCA9PT0gbnVsbCAmJiAhcmVjb3JkLmlzTGVhZikge1xuICAgICAgICAgICAgICAgICAgICBtZS5leHBhbmRJdGVtKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5naW5nIHNob3dJY29uXG4gICAgICogQ2hhbmdlcyB0aGUgZGlzcGxheSBvZiB0aGUgaWNvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93SWNvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgICBzdG9yZSA9IG1lLnN0b3JlLFxuICAgICAgICAgICAgICBoaWRlICA9ICF2YWx1ZTtcblxuICAgICAgICBzdG9yZS5pdGVtcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JZCAgID0gbWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSksXG4gICAgICAgICAgICAgICAgICB2ZG9tICAgICA9IG1lLmdldFZkb21DaGlsZChpdGVtSWQpLFxuICAgICAgICAgICAgICAgICAgaXRlbVZkb20gPSBWRG9tVXRpbC5nZXRCeUZsYWcodmRvbSwgJ2ljb24nKTtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBpdGVtVmRvbS5yZW1vdmVEb20gPSBoaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uc2VsZWN0aW9uLk1vZGVsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBUcmVlQWNjb3JkaW9uTW9kZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgaXRlbXMgZnJvbSB0aGUgYWNjb3JkaW9uXG4gICAgICogSWYgeW91IGRvIG5vdCBuZWVkIHRvIHVwZGF0ZSB0aGUgdmlldyBhZnRlciBjbGVhcmluZywgc2V0IGB3aXRoVXBkYXRlID0gZmFsc2VgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVXBkYXRlPXRydWVdXG4gICAgICovXG4gICAgY2xlYXIod2l0aFVwZGF0ZT10cnVlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmdldFZkb21Sb290KCkuY25bMF0uY25cblxuICAgICAgICB3aXRoVXBkYXRlICYmIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBpdGVtcyBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdEFsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyZW50SWRdIFRoZSBwYXJlbnQgbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbVJvb3RdIFRoZSB2ZG9tIHRlbXBsYXRlIHJvb3QgZm9yIHRoZSBjdXJyZW50IHN1YiB0cmVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBoaWVyYXJjaHkgbGV2ZWwgb2YgdGhlIHRyZWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tUm9vdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcyhwYXJlbnRJZCwgdmRvbVJvb3QsIGxldmVsKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgICAgID0gbWUuc3RvcmUuZmluZCgncGFyZW50SWQnLCBwYXJlbnRJZCksXG4gICAgICAgICAgICBpdGVtQ2xzICAgPSBtZS5pdGVtQ2xzLFxuICAgICAgICAgICAgZm9sZGVyQ2xzID0gbWUuZm9sZGVyQ2xzLFxuICAgICAgICAgICAgY2xzLCBpZCwgaXRlbUljb25DbHMsIHRtcFJvb3Q7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghdmRvbVJvb3QuY24pIHtcbiAgICAgICAgICAgICAgICB2ZG9tUm9vdC5jbiA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2ZG9tUm9vdC5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiAndWwnLFxuICAgICAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLWxpc3QnXSxcbiAgICAgICAgICAgICAgICAgICAgY24gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaWQgOiBgJHttZS5pZH1fXyR7cGFyZW50SWR9X191bGBcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSB2ZG9tUm9vdC5jblt2ZG9tUm9vdC5jbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wUm9vdCA9IHZkb21Sb290O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNscyA9IFtpdGVtQ2xzXTtcblxuICAgICAgICAgICAgICAgIGl0ZW1JY29uQ2xzID0gWyduZW8tYWNjb3JkaW9uLWl0ZW0taWNvbiddO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmljb25DbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGl0ZW1JY29uQ2xzLCBpdGVtLmljb25DbHMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzLnB1c2goaXRlbUNscyArIChpdGVtLnNpbmdsZXRvbiA/ICctbGVhZi1zaW5nbGV0b24nIDogJy1sZWFmJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKGZvbGRlckNscyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLnBhcmVudElkICYmICFtZS5yb290UGFyZW50c0FyZUNvbGxhcHNpYmxlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tbm90LWNvbGxhcHNpYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZm9sZGVyLW9wZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlkID0gbWUuZ2V0SXRlbUlkKGl0ZW0uaWQpO1xuXG4gICAgICAgICAgICAgICAgdG1wUm9vdC5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiAnbGknLFxuICAgICAgICAgICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBjbiA6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnICAgICA6ICdpY29uQ2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyAgICAgIDogJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBpdGVtSWNvbkNscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogaWQgKyAnX19pY29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogKCFpdGVtLmlzTGVhZiB8fCAhbWUuc2hvd0ljb24pXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyAgOiBbaXRlbUNscyArICctY29udGVudCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICA6IGlkICsgJ19faXRlbS1jb250ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7cG9pbnRlckV2ZW50czogJ25vbmUnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNuICAgOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgICAgIDogJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyAgICAgIDogJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogW2l0ZW1DbHMgKyAnLWNvbnRlbnQtaGVhZGVyJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBpZCArICdfX2l0ZW0tY29udGVudC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogaXRlbVttZS5maWVsZHMuaGVhZGVyXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgICAgIDogJ2NvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyAgICAgIDogJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogW2l0ZW1DbHMgKyAnLWNvbnRlbnQtdGV4dCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogaWQgKyAnX19pdGVtLWNvbnRlbnQtdGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MOiBpdGVtW21lLmZpZWxkcy50ZXh0XVxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaXRlbS5pc0xlYWYgPyBudWxsIDogJ3N0aWNreScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgICAgIDogaXRlbS5pc0xlYWYgPyBudWxsIDogKGxldmVsICogMzgpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleCAgOiBpdGVtLmlzTGVhZiA/IG51bGwgOiAoMjAgLyAobGV2ZWwgKyAxKSksXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSBtZS5jcmVhdGVJdGVtcyhpdGVtLmlkLCB0bXBSb290LCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbVJvb3Q7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFuIGl0ZW0gYmFzZWQgb24gdGhlIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKi9cbiAgICBleHBhbmRJdGVtKHJlY29yZCkge1xuICAgICAgICBjb25zdCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICBpdGVtSWQgPSBtZS5nZXRJdGVtSWQocmVjb3JkW21lLmdldEtleVByb3BlcnR5KCldKSxcbiAgICAgICAgICAgICAgaXRlbSAgID0gbWUuZ2V0VmRvbUNoaWxkKGl0ZW1JZCk7XG5cbiAgICAgICAgcmVjb3JkLmNvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChpdGVtLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuICAgICAgICBtZS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25JdGVtQ2xpY2soaXRlbSwgZGF0YSkge1xuICAgICAgICBzdXBlci5vbkl0ZW1DbGljayhpdGVtLCBkYXRhKTtcblxuICAgICAgICBjb25zdCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsID0gbWUuc2VsZWN0aW9uTW9kZWwsXG4gICAgICAgICAgICAgIGl0ZW1JZCAgICAgICAgID0gaXRlbS5pZCxcbiAgICAgICAgICAgICAgaWQgICAgICAgICAgICAgPSBOdW1iZXIoaXRlbUlkLnNwbGl0KCdfXycpWzFdKSxcbiAgICAgICAgICAgICAgcmVjb3JkICAgICAgICAgPSBtZS5zdG9yZS5nZXQoaWQpO1xuXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsLnNlbGVjdChpdGVtLmlkKTtcblxuICAgICAgICBpZiAoIXJlY29yZC5pc0xlYWYpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGZvbGRlckl0ZW1DbGljayBldmVudCBmaXJlcyB3aGVuIGEgY2xpY2sgb2NjdXJzIG9uIGEgbGlzdCBpdGVtIHdoaWNoIGRvZXMgaGF2ZSBjaGlsZCBpdGVtcy5cbiAgICAgICAgICAgICAqIFBhc3NlcyB0aGUgaXRlbSByZWNvcmQgdG8gdGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAgICAgKiBAZXZlbnQgZm9sZGVySXRlbUNsaWNrXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWNvcmRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWUuZmlyZSgnZm9sZGVySXRlbUNsaWNrJywge3JlY29yZH0pO1xuXG4gICAgICAgICAgICByZWNvcmQuY29sbGFwc2VkID0gIXJlY29yZC5jb2xsYXBzZWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvIHBsYWNlIHRoZSByb290IGl0ZW0gYXQgdGhlIGNvcnJlY3QgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldExpc3RJdGVtc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjb3JkaW9uIGdhaW5pbmcgZm9jdXMgd2l0aG91dCBzZWxlY3Rpb24gPT4gc2V0U2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkZvY3VzKGRhdGEpIHtcbiAgICAgICAgY29uc3QgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgc2VsTW9kZWwgID0gbWUuc2VsZWN0aW9uTW9kZWwsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbE1vZGVsLmdldFNlbGVjdGlvbigpWzBdO1xuXG4gICAgICAgIGlmICghc2VsZWN0aW9uKSBzZWxNb2RlbC5zZWxlY3RSb290KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGZyb20gU2VsZWN0aW9uTW9kZWwgc2VsZWN0KClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqL1xuICAgIG9uU2VsZWN0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgbGV0IHJlY29yZHMgPSBbXTtcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKChzZWxlY3RJdGVtSWQpID0+IHtcbiAgICAgICAgICAgIGxldCBpZCAgICAgPSBtZS5nZXRJdGVtUmVjb3JkSWQoc2VsZWN0SXRlbUlkKSxcbiAgICAgICAgICAgICAgICByZWNvcmQgPSBtZS5zdG9yZS5nZXQoaWQpO1xuXG4gICAgICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuc2VsZWN0aW9uID0gcmVjb3JkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZnRlciB0aGUgc3RvcmUgbG9hZGVkLCBjcmVhdGUgdGhlIGl0ZW1zIGZvciB0aGUgbGlzdFxuICAgICAqIEBwYXJhbSB7UmVjb3JkW119IHJlY29yZHNcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZChyZWNvcmRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBsaXN0ZW5lcklkO1xuXG4gICAgICAgIG1lLmNsZWFyKGZhbHNlKTtcblxuICAgICAgICBpZiAoIW1lLm1vdW50ZWQgJiYgbWUucmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcklkID0gbWUub24oJ21vdW50ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUudW4oJ21vdW50ZWQnLCBsaXN0ZW5lcklkKTtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVJdGVtcyhudWxsLCBtZS5nZXRMaXN0SXRlbXNSb290KCksIDApO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKG51bGwsIG1lLmdldExpc3RJdGVtc1Jvb3QoKSwgMCk7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgICAgIGRhdGEuZmllbGRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgZGF0YS5pbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqL1xuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZCA9IGRhdGEucmVjb3JkLFxuICAgICAgICAgICAgZmllbGRzID0gZGF0YS5maWVsZHMsXG4gICAgICAgICAgICBpdGVtSWQgPSBtZS5nZXRJdGVtSWQocmVjb3JkW21lLmdldEtleVByb3BlcnR5KCldKSxcbiAgICAgICAgICAgIHZkb20gICA9IG1lLmdldFZkb21DaGlsZChpdGVtSWQpLFxuICAgICAgICAgICAgaXRlbVZkb207XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpdGVtVmRvbSA9IFZEb21VdGlsLmdldEJ5RmxhZyh2ZG9tLCBmaWVsZC5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW1WZG9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09ICdpY29uQ2xzJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbHNJdGVtcyA9IGZpZWxkLnZhbHVlLnNwbGl0KCcgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNscyAgICAgID0gWyduZW8tYWNjb3JkaW9uLWl0ZW0taWNvbiddO1xuXG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsIGNsc0l0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVZkb20uY2xzID0gY2xzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1WZG9tLmh0bWwgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzZWxlY3Rpb24gZWl0aGVyIGJlaSByZWNvcmQgaWQgb3IgcmVjb3JkLlxuICAgICAqIFlvdSBjYW4gcGFzcyBhIHJlY29yZCBvciBhIHJlY29yZElkIGFzIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlY29yZHxSZWNvcmRbXXxOdW1iZXJ8TnVtYmVyW118U3RyaW5nfFN0cmluZ1tdfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIGNhc2UgeW91IHBhc3MgaW4gYW4gYXJyYXkgdXNlIG9ubHkgdGhlIGZpcnN0IGl0ZW1cbiAgICAgICAgaWYgKE5lby5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgIGxldCByZWNvcmRLZXlQcm9wZXJ0eSwgZWxJZDtcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gUmVjb3JkXG4gICAgICAgICAgICByZWNvcmRLZXlQcm9wZXJ0eSA9IHZhbHVlW21lLmdldEtleVByb3BlcnR5KCldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVjb3JkSWRcbiAgICAgICAgICAgIHJlY29yZEtleVByb3BlcnR5ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBlbElkID0gbWUuZ2V0SXRlbUlkKHJlY29yZEtleVByb3BlcnR5KTtcblxuICAgICAgICBtZS5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RBbmRTY3JvbGxJbnRvVmlldyhlbElkKTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKEFjY29yZGlvblRyZWUpO1xuXG5leHBvcnQgZGVmYXVsdCBBY2NvcmRpb25UcmVlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=