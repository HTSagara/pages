"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_manager_rpc_Message_mjs"],{

/***/ "./src/manager/rpc/Message.mjs":
/*!*************************************!*\
  !*** ./src/manager/rpc/Message.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.manager.rpc.Message
 * @extends Neo.manager.Base
 * @singleton
 */
class Message extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.rpc.Message'
         * @protected
         */
        className: 'Neo.manager.rpc.Message',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Object[]} sorters
         */
        sorters: [{
            direction: 'ASC',
            property : 'id'
        }]
    }

    /**
     * Stores the urls of endpoints for which a setTimeout() call is in progress
     * @member {String[]} endPointTimeouts=[]
     */
    endPointTimeouts = []
    /**
     * internal incrementing flag
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * Time window in ms for buffering incoming message requests
     * @member {Number} requestBuffer=20
     */
    requestBuffer = 20
    /**
     * @member {Object} socketConnections={}
     */
    socketConnections = {}
    /**
     * internal incrementing flag
     * @member {Number} transactionId=1
     * @protected
     */
    transactionId = 1

    /**
     *
     * @param {Object} msg
     * @returns {Promise<any>}
     */
    onMessage(msg) {
        let api = Neo.manager.rpc.Api.get(`${msg.service}.${msg.method}`);

        return this[`onMessage${Neo.capitalize(api.type)}`](msg, api);
    }

    /**
     *
     * @param {Object} msg
     * @param {Object} api
     * @protected
     * @returns {Promise<any>}
     */
    onMessageAjax(msg, api) {
        return new Promise((resolve, reject) => {
            let me  = this,
                url = api.url;

            me.register({
                id           : me.messageId,
                method       : msg.method,
                params       : msg.params,
                reject,
                resolve,
                service      : msg.service,
                transactionId: 0,
                url
            });

            me.messageId++;

            if (!me.endPointTimeouts.includes(url)) {
                me.endPointTimeouts.push(url);

                setTimeout(() => {
                    me.resolveBufferTimeout(url);
                }, me.requestBuffer)
            }
        });
    }

    /**
     *
     * @param {Object} msg
     * @param {Object} api
     * @protected
     * @returns {Promise<any>}
     */
    async onMessageWebsocket(msg, api) {
        let me         = this,
            url        = api.url,
            connection = me.socketConnections[url];

        if (!connection) {
            let module = await __webpack_require__.e(/*! import() */ "src_data_connection_WebSocket_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../../data/connection/WebSocket.mjs */ "./src/data/connection/WebSocket.mjs"));

            me.socketConnections[url] = connection = Neo.create(module.default, {serverAddress: url});
        }

        return await connection.promiseMessage(msg);
    }

    /**
     * @param {String} url
     */
    async resolveBufferTimeout(url) {
        let me            = this,
            itemIds       = [],
            processItems  = me.find({transactionId: 0, url}),
            requests      = [],
            transactionId = me.transactionId,
            response;

        processItems.forEach(item => {
            item.transactionId = transactionId;

            itemIds.push(item.id);

            requests.push({
                id     : item.id,
                method : item.method,
                params : item.params,
                service: item.service
            });
        });

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(me.endPointTimeouts, url);

        me.transactionId++;

        response = await Neo.Fetch.request(url, {}, 'post', JSON.stringify({tid: transactionId, requests}));

        processItems.forEach(item => {
            // todo: pass the item which is included inside the response object
            // todo: reject the Promise in case the item is missing

            item.resolve();
        });

        // todo: remove only the items which are included inside the response
        me.remove(itemIds);
    }
}

let instance = Neo.applyClassConfig(Message);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ }),

/***/ "./src/util/Array.mjs":
/*!****************************!*\
  !*** ./src/util/Array.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Array
 * @extends Neo.core.Base
 */
class NeoArray extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Array'
         * @protected
         */
        className: 'Neo.util.Array'
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static add(arr, items) {
        if (!Array.isArray(items)) {
            items = [items];
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.push(item);
            }
        });
    }

    /**
     * Returns an array of items which are present in array1, but not in array2
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static difference(array1=[], array2=[]) {
        return array1.filter(item => !array2.includes(item));
    }

    /**
     * Checks if the item is included by reference inside the array
     * @param {Array} arr
     * @param {*} item
     */
    static hasItem(arr, item) {
        return arr.includes(item);
    }

    /**
     * Returns an array of items which are present in array1 and array2
     * Only supports primitive items
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static intersection(array1=[], array2=[]) {
        return array1.filter(item => array2.includes(item));
    }

    /**
     * Moves an item inside arr from fromIndex to toIndex
     * @param {Array} arr
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    static move(arr, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return arr;
        }

        if (fromIndex >= arr.length) {
            fromIndex = arr.length - 1;
        }

        arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);
        return arr;
    }

    /**
     * Removes an item or array of items from an array. Only primitive items will get found
     * @param {Array} arr
     * @param {*} items
     */
    static remove(arr, items) {
        let index;

        if (!Array.isArray(items)) {
            items = [items];
        }

        items.forEach(item => {
            index = arr.indexOf(item);

            index > -1 && arr.splice(index, 1);
        });
    }

    /**
     * Convenience method to combine add & remove in one call.
     * You can pass single items or an array of items to add or to remove.
     * @param {Array} arr
     * @param {*} removeItems
     * @param {*} addItems
     */
    static removeAdd(arr, removeItems, addItems) {
        this.remove(arr, removeItems);
        this.add(arr, addItems);
    }

    /**
     * Removes an item from an array in case it does exist, otherwise adds it
     * @param {Array} arr
     * @param {*} item
     * @param {Boolean} [add]
     */
    static toggle(arr, item, add) {
        let operation;

        if (add === true) {
            operation = 'add';
        } else if (add === false) {
            operation = 'remove';
        } else {
            operation = this.hasItem(arr, item) ? 'remove' : 'add';
        }

        this[operation](arr, item);
    }

    /**
     * Returns an array of items which are present in the passed arrays.
     * Multiple arrays may be passed.
     * Only supports primitive items
     * @param {Array} array1
     * @param {Array} array2
     * @returns {Array}
     */
    static union() {
        return [...new Set(Array.prototype.concat(...arguments))];
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static unshift(arr, items) {
        if (!Array.isArray(items)) {
            items = [items];
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.unshift(item);
            }
        });
    }
}

Neo.applyClassConfig(NeoArray);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NeoArray);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2RhdGEvc3JjX21hbmFnZXJfcnBjX01lc3NhZ2VfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNTOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFJO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWSxHQUFHLFdBQVc7O0FBRXZFLGdDQUFnQyx5QkFBeUI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdOQUE2Qzs7QUFFNUUsaUZBQWlGLG1CQUFtQjtBQUNwRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQsUUFBUSx1REFBUTs7QUFFaEI7O0FBRUEsa0RBQWtELDBCQUEwQiw2QkFBNkI7O0FBRXpHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsUUFBUSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdktZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxRQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvcnBjL01lc3NhZ2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9BcnJheS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4uL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLnJwYy5NZXNzYWdlXG4gKiBAZXh0ZW5kcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIE1lc3NhZ2UgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLnJwYy5NZXNzYWdlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5ycGMuTWVzc2FnZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gc29ydGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgc29ydGVyczogW3tcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ0FTQycsXG4gICAgICAgICAgICBwcm9wZXJ0eSA6ICdpZCdcbiAgICAgICAgfV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIHVybHMgb2YgZW5kcG9pbnRzIGZvciB3aGljaCBhIHNldFRpbWVvdXQoKSBjYWxsIGlzIGluIHByb2dyZXNzXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGVuZFBvaW50VGltZW91dHM9W11cbiAgICAgKi9cbiAgICBlbmRQb2ludFRpbWVvdXRzID0gW11cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBpbmNyZW1lbnRpbmcgZmxhZ1xuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWVzc2FnZUlkPTFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbWVzc2FnZUlkID0gMVxuICAgIC8qKlxuICAgICAqIFRpbWUgd2luZG93IGluIG1zIGZvciBidWZmZXJpbmcgaW5jb21pbmcgbWVzc2FnZSByZXF1ZXN0c1xuICAgICAqIEBtZW1iZXIge051bWJlcn0gcmVxdWVzdEJ1ZmZlcj0yMFxuICAgICAqL1xuICAgIHJlcXVlc3RCdWZmZXIgPSAyMFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gc29ja2V0Q29ubmVjdGlvbnM9e31cbiAgICAgKi9cbiAgICBzb2NrZXRDb25uZWN0aW9ucyA9IHt9XG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgaW5jcmVtZW50aW5nIGZsYWdcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRyYW5zYWN0aW9uSWQ9MVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbklkID0gMVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBvbk1lc3NhZ2UobXNnKSB7XG4gICAgICAgIGxldCBhcGkgPSBOZW8ubWFuYWdlci5ycGMuQXBpLmdldChgJHttc2cuc2VydmljZX0uJHttc2cubWV0aG9kfWApO1xuXG4gICAgICAgIHJldHVybiB0aGlzW2Bvbk1lc3NhZ2Uke05lby5jYXBpdGFsaXplKGFwaS50eXBlKX1gXShtc2csIGFwaSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFwaVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIG9uTWVzc2FnZUFqYXgobXNnLCBhcGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHVybCA9IGFwaS51cmw7XG5cbiAgICAgICAgICAgIG1lLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgOiBtZS5tZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kICAgICAgIDogbXNnLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXMgICAgICAgOiBtc2cucGFyYW1zLFxuICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHNlcnZpY2UgICAgICA6IG1zZy5zZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IDAsXG4gICAgICAgICAgICAgICAgdXJsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUubWVzc2FnZUlkKys7XG5cbiAgICAgICAgICAgIGlmICghbWUuZW5kUG9pbnRUaW1lb3V0cy5pbmNsdWRlcyh1cmwpKSB7XG4gICAgICAgICAgICAgICAgbWUuZW5kUG9pbnRUaW1lb3V0cy5wdXNoKHVybCk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVzb2x2ZUJ1ZmZlclRpbWVvdXQodXJsKTtcbiAgICAgICAgICAgICAgICB9LCBtZS5yZXF1ZXN0QnVmZmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXBpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgb25NZXNzYWdlV2Vic29ja2V0KG1zZywgYXBpKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHVybCAgICAgICAgPSBhcGkudXJsLFxuICAgICAgICAgICAgY29ubmVjdGlvbiA9IG1lLnNvY2tldENvbm5lY3Rpb25zW3VybF07XG5cbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgbW9kdWxlID0gYXdhaXQgaW1wb3J0KCcuLi8uLi9kYXRhL2Nvbm5lY3Rpb24vV2ViU29ja2V0Lm1qcycpO1xuXG4gICAgICAgICAgICBtZS5zb2NrZXRDb25uZWN0aW9uc1t1cmxdID0gY29ubmVjdGlvbiA9IE5lby5jcmVhdGUobW9kdWxlLmRlZmF1bHQsIHtzZXJ2ZXJBZGRyZXNzOiB1cmx9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLnByb21pc2VNZXNzYWdlKG1zZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqL1xuICAgIGFzeW5jIHJlc29sdmVCdWZmZXJUaW1lb3V0KHVybCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtSWRzICAgICAgID0gW10sXG4gICAgICAgICAgICBwcm9jZXNzSXRlbXMgID0gbWUuZmluZCh7dHJhbnNhY3Rpb25JZDogMCwgdXJsfSksXG4gICAgICAgICAgICByZXF1ZXN0cyAgICAgID0gW10sXG4gICAgICAgICAgICB0cmFuc2FjdGlvbklkID0gbWUudHJhbnNhY3Rpb25JZCxcbiAgICAgICAgICAgIHJlc3BvbnNlO1xuXG4gICAgICAgIHByb2Nlc3NJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS50cmFuc2FjdGlvbklkID0gdHJhbnNhY3Rpb25JZDtcblxuICAgICAgICAgICAgaXRlbUlkcy5wdXNoKGl0ZW0uaWQpO1xuXG4gICAgICAgICAgICByZXF1ZXN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIG1ldGhvZCA6IGl0ZW0ubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtcyA6IGl0ZW0ucGFyYW1zLFxuICAgICAgICAgICAgICAgIHNlcnZpY2U6IGl0ZW0uc2VydmljZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShtZS5lbmRQb2ludFRpbWVvdXRzLCB1cmwpO1xuXG4gICAgICAgIG1lLnRyYW5zYWN0aW9uSWQrKztcblxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IE5lby5GZXRjaC5yZXF1ZXN0KHVybCwge30sICdwb3N0JywgSlNPTi5zdHJpbmdpZnkoe3RpZDogdHJhbnNhY3Rpb25JZCwgcmVxdWVzdHN9KSk7XG5cbiAgICAgICAgcHJvY2Vzc0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAvLyB0b2RvOiBwYXNzIHRoZSBpdGVtIHdoaWNoIGlzIGluY2x1ZGVkIGluc2lkZSB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICAgICAgICAvLyB0b2RvOiByZWplY3QgdGhlIFByb21pc2UgaW4gY2FzZSB0aGUgaXRlbSBpcyBtaXNzaW5nXG5cbiAgICAgICAgICAgIGl0ZW0ucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0b2RvOiByZW1vdmUgb25seSB0aGUgaXRlbXMgd2hpY2ggYXJlIGluY2x1ZGVkIGluc2lkZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgbWUucmVtb3ZlKGl0ZW1JZHMpO1xuICAgIH1cbn1cblxubGV0IGluc3RhbmNlID0gTmVvLmFwcGx5Q2xhc3NDb25maWcoTWVzc2FnZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkFycmF5XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIE5lb0FycmF5IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5BcnJheSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuQXJyYXknXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIG9yIEFycmF5IG9mIGl0ZW1zIHRvIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKiBPbmx5IHByaW1pdGl2ZSBpdGVtcyB3aWxsIGdldCBmb3VuZCBhcyBkdXBsaWNhdGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBhZGQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc107XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFhcnIuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEsIGJ1dCBub3QgaW4gYXJyYXkyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxPVtdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyPVtdXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkaWZmZXJlbmNlKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gIWFycmF5Mi5pbmNsdWRlcyhpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBpdGVtIGlzIGluY2x1ZGVkIGJ5IHJlZmVyZW5jZSBpbnNpZGUgdGhlIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICovXG4gICAgc3RhdGljIGhhc0l0ZW0oYXJyLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBhcnIuaW5jbHVkZXMoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEgYW5kIGFycmF5MlxuICAgICAqIE9ubHkgc3VwcG9ydHMgcHJpbWl0aXZlIGl0ZW1zXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxPVtdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyPVtdXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnRlcnNlY3Rpb24oYXJyYXkxPVtdLCBhcnJheTI9W10pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5MS5maWx0ZXIoaXRlbSA9PiBhcnJheTIuaW5jbHVkZXMoaXRlbSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGl0ZW0gaW5zaWRlIGFyciBmcm9tIGZyb21JbmRleCB0byB0b0luZGV4XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgc3RhdGljIG1vdmUoYXJyLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tSW5kZXggPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbUluZGV4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBhcnIuc3BsaWNlKHRvSW5kZXgsIDAsIGFyci5zcGxpY2UoZnJvbUluZGV4LCAxKVswXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGZyb20gYW4gYXJyYXkuIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmUoYXJyLCBpdGVtcykge1xuICAgICAgICBsZXQgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgIGluZGV4ID4gLTEgJiYgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBjb21iaW5lIGFkZCAmIHJlbW92ZSBpbiBvbmUgY2FsbC5cbiAgICAgKiBZb3UgY2FuIHBhc3Mgc2luZ2xlIGl0ZW1zIG9yIGFuIGFycmF5IG9mIGl0ZW1zIHRvIGFkZCBvciB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSByZW1vdmVJdGVtc1xuICAgICAqIEBwYXJhbSB7Kn0gYWRkSXRlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlQWRkKGFyciwgcmVtb3ZlSXRlbXMsIGFkZEl0ZW1zKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGFyciwgcmVtb3ZlSXRlbXMpO1xuICAgICAgICB0aGlzLmFkZChhcnIsIGFkZEl0ZW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSBpbiBjYXNlIGl0IGRvZXMgZXhpc3QsIG90aGVyd2lzZSBhZGRzIGl0XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWRkXVxuICAgICAqL1xuICAgIHN0YXRpYyB0b2dnbGUoYXJyLCBpdGVtLCBhZGQpIHtcbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcblxuICAgICAgICBpZiAoYWRkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSAnYWRkJztcbiAgICAgICAgfSBlbHNlIGlmIChhZGQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSAncmVtb3ZlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IHRoaXMuaGFzSXRlbShhcnIsIGl0ZW0pID8gJ3JlbW92ZScgOiAnYWRkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbb3BlcmF0aW9uXShhcnIsIGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gdGhlIHBhc3NlZCBhcnJheXMuXG4gICAgICogTXVsdGlwbGUgYXJyYXlzIG1heSBiZSBwYXNzZWQuXG4gICAgICogT25seSBzdXBwb3J0cyBwcmltaXRpdmUgaXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheTFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheTJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIHVuaW9uKCkge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5hcmd1bWVudHMpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIG9yIEFycmF5IG9mIGl0ZW1zIHRvIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKiBPbmx5IHByaW1pdGl2ZSBpdGVtcyB3aWxsIGdldCBmb3VuZCBhcyBkdXBsaWNhdGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyB1bnNoaWZ0KGFyciwgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghYXJyLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgYXJyLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoTmVvQXJyYXkpO1xuXG5leHBvcnQgZGVmYXVsdCBOZW9BcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==