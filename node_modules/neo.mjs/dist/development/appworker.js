/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$":
/*!************************************************************************************!*\
  !*** ././ lazy ^\.\/.*\.mjs$ include: (?:\/%7C\\)app.mjs$ strict namespace object ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./apps/colors/app.mjs": [
		"./apps/colors/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-apps_colors_app_mjs"
	],
	"./apps/colors/childapps/widget/app.mjs": [
		"./apps/colors/childapps/widget/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_colors_childapps_widget_app_mjs"
	],
	"./apps/covid/app.mjs": [
		"./apps/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-apps_covid_app_mjs-src_toolbar_Base_mjs"
	],
	"./apps/form/app.mjs": [
		"./apps/form/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-apps_form_app_mjs"
	],
	"./apps/krausest/app.mjs": [
		"./apps/krausest/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-apps_krausest_app_mjs"
	],
	"./apps/portal/app.mjs": [
		"./apps/portal/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_layout_Cube_mjs",
		"vendors-apps_portal_app_mjs"
	],
	"./apps/portal/childapps/preview/app.mjs": [
		"./apps/portal/childapps/preview/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_portal_childapps_preview_app_mjs"
	],
	"./apps/realworld/app.mjs": [
		"./apps/realworld/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-apps_realworld_app_mjs"
	],
	"./apps/realworld2/app.mjs": [
		"./apps/realworld2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_toolbar_Base_mjs",
		"vendors-examples_component_gallery_MainContainer_mjs",
		"vendors-apps_realworld2_app_mjs"
	],
	"./apps/route/app.mjs": [
		"./apps/route/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-apps_route_app_mjs"
	],
	"./apps/sharedcovid/app.mjs": [
		"./apps/sharedcovid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-apps_sharedcovid_app_mjs-src_toolbar_Base_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidchart/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidchart/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidchart_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidgallery/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidgallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidgallery_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidhelix/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidhelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidhelix_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidmap/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidmap/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidmap_app_mjs"
	],
	"./apps/shareddialog/app.mjs": [
		"./apps/shareddialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-apps_shareddialog_app_mjs-src_container_Panel_mjs"
	],
	"./apps/shareddialog/childapps/shareddialog2/app.mjs": [
		"./apps/shareddialog/childapps/shareddialog2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-apps_shareddialog_childapps_shareddialog2_app_mjs"
	],
	"./docs/app.mjs": [
		"./docs/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_draggable_DragZone_mjs",
		"vendors-src_tree_List_mjs",
		"vendors-docs_app_view_MainContainer_mjs",
		"vendors-docs_app_mjs-src_container_Viewport_mjs-src_controller_Component_mjs-src_toolbar_Base_mjs"
	],
	"./examples/button/base/app.mjs": [
		"./examples/button/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_button_base_app_mjs"
	],
	"./examples/button/split/app.mjs": [
		"./examples/button/split/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_button_split_app_mjs"
	],
	"./examples/calendar/basic/app.mjs": [
		"./examples/calendar/basic/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-src_calendar_view_MainContainerModel_mjs-src_container_Viewport_mjs",
		"vendors-examples_calendar_basic_app_mjs"
	],
	"./examples/calendar/weekview/app.mjs": [
		"./examples/calendar/weekview/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_calendar_view_week_Component_mjs",
		"vendors-src_calendar_view_MainContainerModel_mjs-src_container_Viewport_mjs",
		"examples_calendar_weekview_app_mjs-src_util_Date_mjs"
	],
	"./examples/charts/app.mjs": [
		"./examples/charts/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_charts_app_mjs"
	],
	"./examples/component/canvas/app.mjs": [
		"./examples/component/canvas/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_canvas_app_mjs"
	],
	"./examples/component/carousel/app.mjs": [
		"./examples/component/carousel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_component_carousel_app_mjs"
	],
	"./examples/component/chip/app.mjs": [
		"./examples/component/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_chip_app_mjs"
	],
	"./examples/component/circle/app.mjs": [
		"./examples/component/circle/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_Circle_mjs",
		"vendors-examples_component_circle_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/clock/app.mjs": [
		"./examples/component/clock/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_component_clock_app_mjs-src_form_field_Picker_mjs"
	],
	"./examples/component/coronaGallery/app.mjs": [
		"./examples/component/coronaGallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_coronaGallery_Viewport_mjs-src_selection_Model_mjs",
		"examples_component_coronaGallery_app_mjs"
	],
	"./examples/component/coronaHelix/app.mjs": [
		"./examples/component/coronaHelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_coronaHelix_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/dateSelector/app.mjs": [
		"./examples/component/dateSelector/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_component_dateSelector_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/gallery/app.mjs": [
		"./examples/component/gallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_gallery_MainContainer_mjs",
		"vendors-examples_component_gallery_app_mjs-src_container_Panel_mjs-src_container_Viewport_mjs-bd568a"
	],
	"./examples/component/helix/app.mjs": [
		"./examples/component/helix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_toolbar_Base_mjs",
		"examples_component_helix_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/multiWindowCoronaGallery/app.mjs": [
		"./examples/component/multiWindowCoronaGallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_coronaGallery_Viewport_mjs-src_selection_Model_mjs",
		"examples_component_multiWindowCoronaGallery_app_mjs"
	],
	"./examples/component/multiWindowCoronaGallery/childapp/app.mjs": [
		"./examples/component/multiWindowCoronaGallery/childapp/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_component_multiWindowCoronaGallery_childapp_app_mjs"
	],
	"./examples/component/multiWindowHelix/app.mjs": [
		"./examples/component/multiWindowHelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_toolbar_Base_mjs",
		"vendors-examples_component_multiWindowHelix_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/multiWindowHelix/childapp/app.mjs": [
		"./examples/component/multiWindowHelix/childapp/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_component_multiWindowHelix_childapp_app_mjs"
	],
	"./examples/component/mwc/button/app.mjs": [
		"./examples/component/mwc/button/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_mwc_button_app_mjs"
	],
	"./examples/component/mwc/buttons/app.mjs": [
		"./examples/component/mwc/buttons/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_component_mwc_buttons_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/mwc/textField/app.mjs": [
		"./examples/component/mwc/textField/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_mwc_textField_app_mjs"
	],
	"./examples/component/mwc/textFields/app.mjs": [
		"./examples/component/mwc/textFields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_component_mwc_textFields_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/process/app.mjs": [
		"./examples/component/process/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_component_process_app_mjs"
	],
	"./examples/component/process/realWorldExample/app.mjs": [
		"./examples/component/process/realWorldExample/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_process_realWorldExample_app_mjs"
	],
	"./examples/component/progress/app.mjs": [
		"./examples/component/progress/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_progress_app_mjs"
	],
	"./examples/component/splitter/app.mjs": [
		"./examples/component/splitter/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_draggable_DragZone_mjs",
		"examples_component_splitter_app_mjs"
	],
	"./examples/component/statusbadge/app.mjs": [
		"./examples/component/statusbadge/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_component_statusbadge_app_mjs"
	],
	"./examples/component/timer/app.mjs": [
		"./examples/component/timer/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_component_timer_app_mjs"
	],
	"./examples/component/toast/app.mjs": [
		"./examples/component/toast/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_toast_app_mjs"
	],
	"./examples/component/video/app.mjs": [
		"./examples/component/video/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_video_app_mjs"
	],
	"./examples/component/wrapper/cesiumJS/app.mjs": [
		"./examples/component/wrapper/cesiumJS/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_component_wrapper_cesiumJS_app_mjs"
	],
	"./examples/component/wrapper/googleMaps/app.mjs": [
		"./examples/component/wrapper/googleMaps/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-examples_component_wrapper_googleMaps_app_mjs-src_container_Panel_mjs"
	],
	"./examples/component/wrapper/monacoEditor/app.mjs": [
		"./examples/component/wrapper/monacoEditor/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_wrapper_MonacoEditor_mjs",
		"examples_component_wrapper_monacoEditor_app_mjs"
	],
	"./examples/container/accordion/app.mjs": [
		"./examples/container/accordion/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_container_accordion_app_mjs"
	],
	"./examples/container/base/app.mjs": [
		"./examples/container/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_container_base_app_mjs"
	],
	"./examples/core/config/app.mjs": [
		"./examples/core/config/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_core_config_app_mjs"
	],
	"./examples/dashboard/app.mjs": [
		"./examples/dashboard/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_dashboard_app_mjs"
	],
	"./examples/date/selectorContainer/app.mjs": [
		"./examples/date/selectorContainer/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_date_selectorContainer_app_mjs-src_selection_Model_mjs"
	],
	"./examples/dialog/app.mjs": [
		"./examples/dialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-examples_dialog_app_mjs-src_container_Panel_mjs"
	],
	"./examples/fieldWithPrefix/app.mjs": [
		"./examples/fieldWithPrefix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_fieldWithPrefix_app_mjs"
	],
	"./examples/fields/app.mjs": [
		"./examples/fields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_fields_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/form/field/checkbox/app.mjs": [
		"./examples/form/field/checkbox/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_checkbox_app_mjs"
	],
	"./examples/form/field/chip/app.mjs": [
		"./examples/form/field/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"examples_form_field_chip_app_mjs"
	],
	"./examples/form/field/color/app.mjs": [
		"./examples/form/field/color/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_form_field_color_app_mjs"
	],
	"./examples/form/field/combobox/app.mjs": [
		"./examples/form/field/combobox/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_form_field_combobox_app_mjs"
	],
	"./examples/form/field/date/app.mjs": [
		"./examples/form/field/date/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_form_field_date_app_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/email/app.mjs": [
		"./examples/form/field/email/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_email_app_mjs"
	],
	"./examples/form/field/fileupload/app.mjs": [
		"./examples/form/field/fileupload/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_fileupload_app_mjs"
	],
	"./examples/form/field/number/app.mjs": [
		"./examples/form/field/number/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_number_app_mjs"
	],
	"./examples/form/field/picker/app.mjs": [
		"./examples/form/field/picker/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_picker_app_mjs"
	],
	"./examples/form/field/radio/app.mjs": [
		"./examples/form/field/radio/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_radio_app_mjs"
	],
	"./examples/form/field/switch/app.mjs": [
		"./examples/form/field/switch/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_switch_app_mjs"
	],
	"./examples/form/field/text/app.mjs": [
		"./examples/form/field/text/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_text_app_mjs"
	],
	"./examples/form/field/textarea/app.mjs": [
		"./examples/form/field/textarea/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_textarea_app_mjs"
	],
	"./examples/form/field/time/app.mjs": [
		"./examples/form/field/time/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_form_field_time_app_mjs-src_form_field_Picker_mjs"
	],
	"./examples/form/field/trigger/copyToClipboard/app.mjs": [
		"./examples/form/field/trigger/copyToClipboard/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_trigger_copyToClipboard_app_mjs"
	],
	"./examples/form/field/url/app.mjs": [
		"./examples/form/field/url/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_url_app_mjs"
	],
	"./examples/form/fieldset/app.mjs": [
		"./examples/form/fieldset/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-examples_form_fieldset_app_mjs"
	],
	"./examples/grid/container/app.mjs": [
		"./examples/grid/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-examples_grid_container_app_mjs"
	],
	"./examples/grid/covid/app.mjs": [
		"./examples/grid/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-examples_grid_covid_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/layout/card/app.mjs": [
		"./examples/layout/card/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_layout_card_app_mjs"
	],
	"./examples/layout/cube/app.mjs": [
		"./examples/layout/cube/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_layout_Cube_mjs",
		"vendors-examples_layout_cube_app_mjs"
	],
	"./examples/layout/form/app.mjs": [
		"./examples/layout/form/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-examples_layout_form_app_mjs"
	],
	"./examples/list/animate/app.mjs": [
		"./examples/list/animate/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_list_animate_app_mjs"
	],
	"./examples/list/base/app.mjs": [
		"./examples/list/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"examples_list_base_app_mjs"
	],
	"./examples/list/chip/app.mjs": [
		"./examples/list/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_list_chip_app_mjs"
	],
	"./examples/list/circle/app.mjs": [
		"./examples/list/circle/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_component_Circle_mjs",
		"vendors-examples_list_circle_app_mjs"
	],
	"./examples/list/color/app.mjs": [
		"./examples/list/color/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"examples_list_color_app_mjs"
	],
	"./examples/menu/list/app.mjs": [
		"./examples/menu/list/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_menu_List_mjs",
		"examples_menu_list_app_mjs"
	],
	"./examples/menu/panel/app.mjs": [
		"./examples/menu/panel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_menu_List_mjs",
		"examples_menu_panel_app_mjs"
	],
	"./examples/model/advanced/app.mjs": [
		"./examples/model/advanced/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-examples_model_advanced_app_mjs"
	],
	"./examples/model/dialog/app.mjs": [
		"./examples/model/dialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-examples_model_dialog_app_mjs"
	],
	"./examples/model/extendedClass/app.mjs": [
		"./examples/model/extendedClass/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-examples_model_extendedClass_app_mjs"
	],
	"./examples/model/inline/app.mjs": [
		"./examples/model/inline/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-examples_model_inline_app_mjs"
	],
	"./examples/model/inlineNoModel/app.mjs": [
		"./examples/model/inlineNoModel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_model_inlineNoModel_app_mjs"
	],
	"./examples/model/multiWindow/app.mjs": [
		"./examples/model/multiWindow/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-examples_model_multiWindow_app_mjs"
	],
	"./examples/model/multiWindow2/app.mjs": [
		"./examples/model/multiWindow2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_model_multiWindow2_app_mjs"
	],
	"./examples/model/nestedData/app.mjs": [
		"./examples/model/nestedData/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-examples_model_nestedData_app_mjs"
	],
	"./examples/model/table/app.mjs": [
		"./examples/model/table/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_model_table_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/model/twoWay/app.mjs": [
		"./examples/model/twoWay/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_model_Component_mjs",
		"examples_model_twoWay_app_mjs"
	],
	"./examples/panel/app.mjs": [
		"./examples/panel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_panel_app_mjs"
	],
	"./examples/popover/app.mjs": [
		"./examples/popover/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_popover_app_mjs"
	],
	"./examples/preloadingAssets/app.mjs": [
		"./examples/preloadingAssets/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_preloadingAssets_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/remotesApi/basic/app.mjs": [
		"./examples/remotesApi/basic/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_remotesApi_basic_app_mjs"
	],
	"./examples/sitemap/app.mjs": [
		"./examples/sitemap/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_sitemap_app_mjs"
	],
	"./examples/tab/container/app.mjs": [
		"./examples/tab/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_tab_container_app_mjs"
	],
	"./examples/table/container/app.mjs": [
		"./examples/table/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_table_CellColumnModel_mjs-src_selection_table_-c5083f",
		"vendors-examples_table_container_app_mjs"
	],
	"./examples/table/covid/app.mjs": [
		"./examples/table/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_table_covid_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tableFiltering/app.mjs": [
		"./examples/tableFiltering/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_tableFiltering_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tablePerformance/app.mjs": [
		"./examples/tablePerformance/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_tablePerformance_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tableStore/app.mjs": [
		"./examples/tableStore/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_table_CellColumnModel_mjs-src_selection_table_-c5083f",
		"vendors-examples_tableStore_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tabs/app.mjs": [
		"./examples/tabs/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_tabs_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/todoList/version1/app.mjs": [
		"./examples/todoList/version1/app.mjs",
		"vendors-src_component_Base_mjs",
		"examples_todoList_version1_app_mjs"
	],
	"./examples/todoList/version2/app.mjs": [
		"./examples/todoList/version2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_todoList_version2_app_mjs"
	],
	"./examples/toolbar/breadcrumb/app.mjs": [
		"./examples/toolbar/breadcrumb/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_toolbar_breadcrumb_app_mjs"
	],
	"./examples/toolbar/paging/app.mjs": [
		"./examples/toolbar/paging/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_toolbar_paging_app_mjs"
	],
	"./examples/tree/app.mjs": [
		"./examples/tree/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_tree_List_mjs",
		"examples_tree_app_mjs"
	],
	"./examples/treeAccordion/app.mjs": [
		"./examples/treeAccordion/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_model_Component_mjs",
		"vendors-src_tree_List_mjs",
		"vendors-examples_treeAccordion_app_mjs"
	],
	"./examples/videoMove/app.mjs": [
		"./examples/videoMove/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_videoMove_app_mjs"
	],
	"./examples/viewport/app.mjs": [
		"./examples/viewport/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_viewport_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/worker/task/app.mjs": [
		"./examples/worker/task/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_worker_task_app_mjs"
	],
	"./test/components/app.mjs": [
		"./test/components/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-test_components_app_mjs"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/DefaultConfig.mjs":
/*!*******************************!*\
  !*** ./src/DefaultConfig.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const Neo = globalThis.Neo || {};

Neo.config = Neo.config || {};

/**
 * Config object for the neo.mjs framework which will get passed to all workers
 * You can change the configs, e.g. inside the index.html of your app
 * @memberOf module:Neo
 * @name config
 * @type Object
 */
const DefaultConfig = {
    /**
     * true will apply 'neo-body' to the document.body classList
     * @default true
     * @memberOf! module:Neo
     * @name config.applyBodyCls
     * @type Boolean
     */
    applyBodyCls: true,
    /**
     * Path to your app.mjs file. You can create multiple apps there if needed.
     * @default null
     * @memberOf! module:Neo
     * @name config.appPath
     * @type String|null
     */
    appPath: null,
    /**
     * Path to the neo.mjs directory
     * @default './'
     * @memberOf! module:Neo
     * @name config.basePath
     * @type String
     */
    basePath: './',
    /**
     * Pass a token in case you are using the CesiumJS main thread addon
     * See: https://github.com/neomjs/neo/blob/dev/src/main/addon/CesiumJS.mjs
     * @default null
     * @memberOf! module:Neo
     * @name config.cesiumJsToken
     * @type String|null
     */
    cesiumJsToken: null,
    /**
     * Set this config to false to disable the component logging using Ctrl-Right-Click
     * @default true
     * @memberOf! module:Neo
     * @name config.enableComponentLogger
     * @type Boolean
     */
    enableComponentLogger: true,
    /**
     * Set this config to true to enable util.Logger (Neo.log()) based logs in production
     * @default false
     * @memberOf! module:Neo
     * @name config.enableLogsInProduction
     * @type Boolean
     */
    enableLogsInProduction: false,
    /**
     * The current environment. Valid values: 'development', 'dist/development', 'dist/production'
     * This config will get auto-generated
     * @default 'dist/production'
     * @memberOf! module:Neo
     * @name config.environment
     * @type String
     */
    environment: 'dist/production',
    /**
     * In case you are using the GoogleMaps main thread addon, you can pass the API key here.
     * @default ''
     * @memberOf! module:Neo
     * @name config.googleMapsApiKey
     * @type String
     */
    googleMapsApiKey: '',
    /**
     * In case you are using the GoogleAnalytics main thread addon or useGoogleAnalytics: true,
     * you can change the gtag id here. Required for the online examples (gh pages)
     * @default 'G-DJ13071C55'
     * @memberOf! module:Neo
     * @name config.gtagId
     * @type String
     */
    gtagId: 'G-DJ13071C55',
    /**
     * Flag for running on https://neomjs.github.io/pages/
     * => to use local images paths instead of raw.githubusercontent.com
     * @default false
     * @memberOf! module:Neo
     * @name config.isGitHubPages
     * @type Boolean
     */
    isGitHubPages: true,
    /**
     * Flag for running the Neo main thread inside an iframe (Siesta Browser Harness)
     * @default false
     * @memberOf! module:Neo
     * @name config.isInsideSiesta
     * @type Boolean
     */
    isInsideSiesta: false,
    /**
     * delay in ms for the worker.Manager:loadApplication() call
     * @default 20
     * @memberOf! module:Neo
     * @name config.loadApplicationDelay
     * @type Number
     */
    loadApplicationDelay: 20,
    /**
     * Used by Intl.DateTimeFormat, for details take a look at:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @default 'default'
     * @memberOf! module:Neo
     * @name config.locale
     * @type String
     */
    locale: 'default',
    /**
     * true will log the delta updates inside the main thread(s) as well as the requestAnimation frames
     * @default false
     * @memberOf! module:Neo
     * @name config.logDeltaUpdates
     * @type Boolean
     */
    logDeltaUpdates: false,
    /**
     * true will log console warnings, in case a component tries to update() while a parent update is running.
     * A parent update results in a short delay, so you might want to resolve these collisions.
     * @default false
     * @memberOf! module:Neo
     * @name config.logVdomUpdateCollisions
     * @type Boolean
     */
    logVdomUpdateCollisions: false,
    /**
     * Add addons for the main thread
     * ./src/main/addon/ contains all framework related options.
     * You can also create your own addons within your workspace scope. Make sure to put them inside 'src/main/addon/'
     * and prefix them with 'WS/' inside your neo-config.json file.
     * Example: ['DragDrop', 'Stylesheet', 'WS/MyAddon']
     * @default ['DragDrop', 'Navigator', 'Stylesheet']
     * @memberOf! module:Neo
     * @name config.mainThreadAddons
     * @type String[]
     */
    mainThreadAddons: ['DragDrop', 'Navigator', 'Stylesheet'],
    /**
     * Pass the URL of a JSON-file, which contains the services and methods from your backend,
     * which you want to expose to the client.
     * See: https://github.com/neomjs/neo/projects/32
     * @default null
     * @memberOf! module:Neo
     * @name config.remotesApiUrl
     * @type String|null
     */
    remotesApiUrl: null,
    /**
     * You can visually show the amount of delta updates per second using this config.
     * It expects a dom node with the id "neo-delta-updates" as the rendering target.
     * @default false
     * @memberOf! module:Neo
     * @name config.renderCountDeltas
     * @type Boolean
     */
    renderCountDeltas: false,
    /**
     * Add themes you want to use here. The first theme will get applied.
     * @default ['neo-theme-light','neo-theme-dark','neo-theme-neo-light']
     * @memberOf! module:Neo
     * @name config.themes
     * @type String[]
     */
    themes: ['neo-theme-light', 'neo-theme-dark', 'neo-theme-neo-light'],
    /**
     * Flag for standalone Siesta module tests => prevent registerRemote worker messages
     * @default false
     * @memberOf! module:Neo
     * @name config.unitTestMode
     * @type Boolean
     */
    unitTestMode: false,
    /**
     * Experimental flag if an offscreen canvas worker should get created.
     * @default false
     * @memberOf! module:Neo
     * @name config.useCanvasWorker
     * @type Boolean
     */
    useCanvasWorker: false,
    /**
     * Flag if vdom ids should get mapped into DOM element ids.
     * false will convert them into a "data-neo-id" attribute.
     * @default true
     * @memberOf! module:Neo
     * @name config.useDomIds
     * @type Boolean
     */
    useDomIds: true,
    /**
     * True will automatically include the stylesheet
     * @default true
     * @memberOf! module:Neo
     * @name config.useFontAwesome
     * @type Boolean
     */
    useFontAwesome: true,
    /**
     * Intended for the online examples where we need an easy way to add GA to every generated app
     * @default false
     * @memberOf! module:Neo
     * @name config.useGoogleAnalytics
     * @type Boolean
     */
    useGoogleAnalytics: false,
    /**
     * True will add the ServiceWorker main thread addon to support caching of assets (PWA)
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
     *
     * You can also use a string to specify the target environment => 'dist/production'
     * @default false
     * @memberOf! module:Neo
     * @name config.useServiceWorker
     * @type Boolean|String
     */
    useServiceWorker: false,
    /**
     * Creates App, Data & VDom as SharedWorkers.
     * Set this one to true in case you want to connect multiple main threads.
     * @default false
     * @memberOf! module:Neo
     * @name config.useSharedWorkers
     * @type Boolean
     */
    useSharedWorkers: false,
    /**
     * True will generate a new task worker, which can get filled with own expensive remote methods
     * @default false
     * @memberOf! module:Neo
     * @name config.useTaskWorker
     * @type Boolean
     */
    useTaskWorker: false,
    /**
     * Adds global dom event listeners for mobile related events like rotate, swipe, tap
     * @default true
     * @memberOf! module:Neo
     * @name config.useTouchEvents
     * @type Boolean
     */
    useTouchEvents: true,
    /**
     * False will create the vdom.Helper within the App worker (experimental!)
     * @default true
     * @memberOf! module:Neo
     * @name config.useVdomWorker
     * @type Boolean
     */
    useVdomWorker: true,
    /**
     * buildScripts/injectPackageVersion.mjs will update this value
     * @default '7.7.0'
     * @memberOf! module:Neo
     * @name config.version
     * @type String
     */
    version: '7.7.0'
};

Object.assign(DefaultConfig, {
    /**
     * Path to the top level neo.mjs resources folder
     * @default Neo.config.basePath + 'resources/'
     * @memberOf! module:Neo
     * @name config.resourcesPath
     * @type String
     */
    resourcesPath: `${Neo.config.basePath || DefaultConfig.basePath}resources/`,
    /**
     * The default base URL for web worker entry points (App, Data, Vdom)
     * @default Neo.config.basePath + 'src/worker/'
     * @memberOf! module:Neo
     * @name config.workerBasePath
     * @type String
     */
    workerBasePath: `${Neo.config.basePath || DefaultConfig.basePath}src/worker/`,
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DefaultConfig);


/***/ }),

/***/ "./src/Neo.mjs":
/*!*********************!*\
  !*** ./src/Neo.mjs ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultConfig.mjs */ "./src/DefaultConfig.mjs");


const
    camelRegex   = /-./g,
    configSymbol = Symbol.for('configSymbol'),
    getSetCache  = Symbol('getSetCache'),
    typeDetector = {
        function: (item) => {
            if (item.prototype?.constructor.isClass) {
                return 'NeoClass'
            }
        },
        object: (item) => {
            if (item.constructor.isClass && item instanceof Neo.core.Base) {
                return 'NeoInstance'
            }
        }
    };

/**
 * The base module to enhance classes, create instances and the Neo namespace
 * @module Neo
 * @singleton
 * @borrows Neo.core.Util.bindMethods       as bindMethods
 * @borrows Neo.core.Util.capitalize        as capitalize
 * @borrows Neo.core.Util.createStyleObject as createStyleObject
 * @borrows Neo.core.Util.createStyles      as createStyles
 * @borrows Neo.core.Util.decamel           as decamel
 * @borrows Neo.core.Util.isArray           as isArray
 * @borrows Neo.core.Util.isBoolean         as isBoolean
 * @borrows Neo.core.Util.isDefined         as isDefined
 * @borrows Neo.core.Compare.isEqual        as isEqual
 * @borrows Neo.core.Util.isNumber          as isNumber
 * @borrows Neo.core.Util.isObject          as isObject
 * @borrows Neo.core.Util.isString          as isString
 * @borrows Neo.core.Util.toArray           as toArray
 * @tutorial 01_Concept
 */
let Neo = globalThis.Neo || {};

Neo = globalThis.Neo = Object.assign({
    /**
     * A map containing ntypes as key and Neo classes or singletons as values
     * @memberOf! module:Neo
     * @protected
     * @type Object
     */
    ntypeMap: {},
    /**
     * Needed for Neo.create. False for the main thread, true for the App, Data & Vdom worker
     * @memberOf! module:Neo
     * @protected
     * @type Boolean
     */
    insideWorker: typeof DedicatedWorkerGlobalScope !== 'undefined' || typeof WorkerGlobalScope !== 'undefined',

    /**
     * Maps methods from one namespace to another one
     * @example
     * // aliases
     * Neo.applyFromNs(Neo, Util, {
     *     createStyleObject: 'createStyleObject',
     *     createStyles     : 'createStyles',
     *     capitalize       : 'capitalize'
     * }, true);
     *
     * // e.g. Neo.core.Util.isObject => Neo.isObject
     * @memberOf module:Neo
     * @param {Neo|Neo.core.Base} target The target class or singleton Instance or Neo
     * @param {Neo.core.Base} namespace The class containing the methods
     * @param {Object} config
     * @param {Boolean} [bind] set this to true in case you want to bind methods to the "from" namespace
     * @returns {Object} target
     */
    applyFromNs(target, namespace, config, bind) {
        let fnName;

        if (target && Neo.typeOf(config) === 'Object') {
            Object.entries(config).forEach(([key, value]) => {
                fnName = namespace[value];
                target[key] = bind ? fnName.bind(namespace) : fnName
            })
        }

        return target
    },

    /**
     * Maps a class to the global Neo or App namespace.
     * Can get called for classes and singleton instances
     * @memberOf module:Neo
     * @param {Neo.core.Base} cls
     */
    applyToGlobalNs(cls) {
        let proto = typeof cls === 'function' ? cls.prototype: cls,
            className, nsArray, key, ns;

        if (proto.constructor.registerToGlobalNs === true) {
            className = proto.isClass ? proto.config.className : proto.className;

            nsArray = className.split('.');
            key     = nsArray.pop();
            ns      = Neo.ns(nsArray, true);
            ns[key] = cls
        }
    },

    /**
     * Copies all keys of defaults into target, in case they don't already exist
     * @memberOf module:Neo
     * @param {Object} target The target object
     * @param {Object} defaults The object containing the keys you want to copy
     * @returns {Object} target
     */
    assignDefaults(target, defaults) {
        if (target && Neo.typeOf(defaults) === 'Object') {
            Object.entries(defaults).forEach(([key, value]) => {
                if (!Object.hasOwn(target, key)) {
                    target[key] = value
                }
            })
        }

        return target
    },

    /**
     * Converts kebab-case strings into camel-case
     * @memberOf module:Neo
     * @param {String} value The target object
     * @returns {String}
     */
    camel(value) {
        return value.replace(camelRegex, match => match[1].toUpperCase())
    },

    /**
     * Makes the first character of a string uppercase
     * @memberOf module:Neo
     * @param {String} value
     * @returns {Boolean|String} Returns false for non string inputs
     */
    capitalize(value) {
        return value[0].toUpperCase() + value.slice(1)
    },

    /**
     * @memberOf module:Neo
     * @param {Object|Array|*} obj
     * @param {Boolean} deep=false Set this to true in case you want to clone nested objects as well
     * @param {Boolean} ignoreNeoInstances=false returns existing instances if set to true
     * @returns {Object|Array|*} the cloned input
     */
    clone(obj, deep=false, ignoreNeoInstances=false) {
        let out;

        return {
            Array      : () => !deep ? [...obj] : [...obj.map(val => Neo.clone(val, deep, ignoreNeoInstances))],
            Date       : () => new Date(obj.valueOf()),
            Map        : () => new Map(obj), // shallow copy
            NeoInstance: () => ignoreNeoInstances ? obj : this.cloneNeoInstance(obj),
            Set        : () => new Set(obj),

            Object: () => {
                out = {};

                Object.entries(obj).forEach(([key, value]) => {
                    out[key] = !deep ? value : Neo.clone(value, deep, ignoreNeoInstances)
                });

                return out
            }
        }[Neo.typeOf(obj)]?.() || obj
    },

    /**
     * Creates a new instance using the originalConfig without the id
     * @memberOf module:Neo
     * @param {Neo.core.Base} instance
     * @returns {Neo.core.Base} the cloned instance
     */
    cloneNeoInstance(instance) {
        let config = {...instance.originalConfig};

        delete config._id;
        delete config.id;

        return Neo.create(instance.className, config)
    },

    /**
     * Use Neo.create() instead of "new" to create instances of all Neo classes
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create(Button, {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create({
     *     module : Button,
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create('Neo.button.Base' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create({
     *     className: 'Neo.button.Base',
     *     iconCls  : 'fa fa-home',
     *     text     : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object|Neo.core.Base} className
     * @param {Object} [config]
     * @returns {Neo.core.Base|null} The new class instance
     * @tutorial 02_ClassSystem
     */
    create(className, config) {
        let type = Neo.typeOf(className),
            cls, instance;

        if (type === 'NeoClass') {
            cls = className
        } else {
            if (type === 'Object') {
                config = className;

                if (!config.className && !config.module) {
                    // using console.error instead of throw to show the config object
                    console.error('Class created with object configuration missing className or module property', config);
                    return null
                }

                className = config.className || config.module.prototype.className;
            }

            if (!exists(className)) {
                throw new Error('Class ' + className + ' does not exist')
            }

            cls = Neo.ns(className)
        }

        instance = new cls();

        instance.construct(config);
        instance.onConstructed();
        instance.onAfterConstructed();
        instance.init();

        return instance
    },

    /**
     *
     */
    emptyFn() {},

    /**
     * Checks if there is a set method for a given property key inside the prototype chain
     * @memberOf module:Neo
     * @param {Neo.core.Base} proto The top level prototype of a class
     * @param {String} key the property key to test
     * @returns {Boolean}
     */
    hasPropertySetter(proto, key) {
        let descriptor;

        while (proto.__proto__) {
            descriptor = Object.getOwnPropertyDescriptor(proto, key);

            if (typeof descriptor === 'object' && typeof descriptor.set === 'function') {
                return true
            }

            proto = proto.__proto__
        }

        return false
    },

    /**
     * Deep-merges a source object into a target object
     * @memberOf module:Neo
     * @param {Object} target
     * @param {Object} source
     * @param {Object} defaults
     * @returns {Object} target
     */
    merge(target, source, defaults) {
        if (defaults) {
            return Neo.merge(Neo.merge(target, defaults), source)
        }

        for (const key in source) {
            const value = source[key];

            if (Neo.typeOf(value) === 'Object') {
                target[key] = Neo.merge(target[key] || {}, value)
            } else {
                target[key] = value
            }
        }

        return target
    },

    /**
     * Maps a className string into a given or global namespace
     * @example
     * Neo.ns('Neo.button.Base', true);
     * // =>
     * // globalThis.Neo             = globalThis.Neo             || {};
     * // globalThis.Neo.button      = globalThis.Neo.button      || {};
     * // globalThis.Neo.button.Base = globalThis.Neo.button.Base || {};
     * // return globalThis.Neo.button.Base;
     *
     * @memberOf module:Neo
     * @param {Array|String} names The class name string containing dots or an Array of the string parts
     * @param {Boolean} [create] Set create to true to create empty objects for non-existing parts
     * @param {Object} [scope] Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    ns(names, create, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                prev[current] = {}
            }

            if (prev) {
                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Extended version of Neo.ns() which supports mapping into arrays.
     * @memberOf module:Neo
     * @param {Array|String} names The class name string containing dots or an Array of the string parts
     * @param {Boolean} [create] Set create to true to create empty objects for non-existing parts
     * @param {Object} [scope] Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    nsWithArrays(names, create, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                if (current.endsWith(']')) {
                    return createArrayNs(true, current, prev)
                }

                prev[current] = {}
            }

            if (prev) {
                if (current.endsWith(']')) {
                    return createArrayNs(false, current, prev)
                }

                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Creates instances of Neo classes using their ntype instead of the class name
     * @example
     * Neo.ntype('button' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.ntype({
     *     ntype  : 'button',
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object} ntype
     * @param {Object} [config]
     * @returns {Neo.core.Base}
     * @see {@link module:Neo.create create}
     */
    ntype(ntype, config) {
        if (typeof ntype === 'object') {
            config = ntype;

            if (!config.ntype) {
                throw new Error('Class defined with object configuration missing ntype property. ' + config.ntype)
            }

            ntype = config.ntype
        }

        let className = Neo.ntypeMap[ntype];

        if (!className) {
            throw new Error('ntype ' + ntype + ' does not exist')
        }

        return Neo.create(className, config)
    },

    /**
     * Internally used at the end of each class / module definition
     * @memberOf module:Neo
     * @template T
     * @param {T} cls
     * @returns {T}
     */
    setupClass(cls) {
        let baseCfg    = null,
            ntypeChain = [],
            {ntypeMap} = Neo,
            proto      = cls.prototype || cls,
            ns         = Neo.ns(proto.constructor.config.className, false),
            protos     = [],
            cfg, config, ctor, ntype;

        /*
         * If the namespace already exists, directly return it.
         * This can happen when using different versions of neo.mjs
         * => Especially singletons (IdGenerator) must stay unique.
         *
         * This can also happen when using different environments of neo.mjs in parallel.
         * Example: code.LivePreview running inside a dist/production app.
         */
        if (ns) {
            return ns
        }

        while (proto.__proto__) {
            ctor = proto.constructor;

            if (Object.hasOwn(ctor, 'classConfigApplied')) {
                baseCfg    = Neo.clone(ctor.config, true);
                ntypeChain = [...ctor.ntypeChain];
                break
            }

            protos.unshift(proto);
            proto = proto.__proto__
        }

        config = baseCfg || {};

        protos.forEach(element => {
            let mixins;

            ctor = element.constructor;

            cfg = ctor.config || {};

            if (Neo.overwrites) {
                ctor.applyOverwrites?.(cfg)
            }

            Object.entries(cfg).forEach(([key, value]) => {
                if (key.slice(-1) === '_') {
                    delete cfg[key];
                    key = key.slice(0, -1);
                    cfg[key] = value;
                    autoGenerateGetSet(element, key)
                }

                    // only apply properties which have no setters inside the prototype chain
                // those will get applied on create (Neo.core.Base -> initConfig)
                else if (!Neo.hasPropertySetter(element, key)) {
                    Object.defineProperty(element, key, {
                        enumerable: true,
                        value,
                        writable  : true
                    })
                }
            });

            if (Object.hasOwn(cfg, 'ntype')) {
                ntype = cfg.ntype;

                ntypeChain.unshift(ntype);

                // Running the docs app inside a workspace can pull in the same classes from different roots,
                // so we want to check for different class names as well
                if (Object.hasOwn(ntypeMap, ntype) && cfg.className !== ntypeMap[ntype]) {
                    throw new Error(`ntype conflict for '${ntype}' inside the classes:\n${ntypeMap[ntype]}\n${cfg.className}`)
                }

                ntypeMap[ntype] = cfg.className
            }

            mixins = Object.hasOwn(config, 'mixins') && config.mixins || [];

            if (ctor.observable) {
                mixins.push('Neo.core.Observable')
            }

            if (Object.hasOwn(cfg, 'mixins') && Array.isArray(cfg.mixins) && cfg.mixins.length > 0) {
                mixins.push(...cfg.mixins)
            }

            if (mixins.length > 0) {
                applyMixins(ctor, mixins);

                if (Neo.ns('Neo.core.Observable', false, ctor.prototype.mixins)) {
                    ctor.observable = true
                }
            }

            delete cfg.mixins;
            delete config.mixins;

            Object.assign(config, cfg);

            Object.assign(ctor, {
                classConfigApplied: true,
                config            : Neo.clone(config, true),
                isClass           : true,
                ntypeChain
            });

            !config.singleton && this.applyToGlobalNs(cls)
        });

        proto = cls.prototype || cls;

        ntypeChain.forEach(ntype => {
            proto[`is${Neo.capitalize(Neo.camel(ntype))}`] = true
        });

        if (proto.singleton) {
            cls = Neo.create(cls);
            Neo.applyToGlobalNs(cls)
        }

        return cls
    },

    /**
     * @param {*} item
     * @returns {String|null}
     */
    typeOf(item) {
        if (item === null || item === undefined) {
            return null
        }

        return typeDetector[typeof item]?.(item) || item.constructor.name
    }
}, Neo);

/**
 * List of class properties which are not supposed to get mixed into other classes
 * @type {string[]}
 * @private
 */
const ignoreMixin = [
    '_name',
    'classConfigApplied',
    'className',
    'constructor',
    'isClass',
    'mixin',
    'ntype',
    'observable',
    'registerToGlobalNs'
],

    charsRegex         = /\d+/g,
    extractArraysRegex = /^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;

/**
 * @param {Neo.core.Base} cls
 * @param {Array} mixins
 * @private
 */
function applyMixins(cls, mixins) {
    if (!Array.isArray(mixins)) {
        mixins = [mixins];
    }

    let i            = 0,
        len          = mixins.length,
        mixinClasses = {},
        mixin, mixinCls, mixinProto;

    for (;i < len;i++) {
        mixin = mixins[i];

        if (mixin.isClass) {
            mixinProto = mixin.prototype;
            mixinCls   = Neo.ns(mixinProto.className)
        } else {
            if (!exists(mixin)) {
                throw new Error('Attempting to mixin an undefined class: ' + mixin + ', ' + cls.prototype.className)
            }

            mixinCls   = Neo.ns(mixin);
            mixinProto = mixinCls.prototype;
        }

        mixinProto.className.split('.').reduce(mixReduce(mixinCls), mixinClasses);

        Object.getOwnPropertyNames(mixinProto).forEach(mixinProperty(cls.prototype, mixinProto))
    }

    cls.prototype.mixins = mixinClasses // todo: we should do a deep merge
}

/**
 * Creates get / set methods for class configs ending with an underscore
 * @param {Neo.core.Base} proto
 * @param {String} key
 * @private
 * @tutorial 02_ClassSystem
 */
function autoGenerateGetSet(proto, key) {
    if (Neo.hasPropertySetter(proto, key)) {
        throw('Config ' + key + '_ (' + proto.className + ') already has a set method, use beforeGet, beforeSet & afterSet instead')
    }

    if (!Neo[getSetCache]) {
        Neo[getSetCache] = {}
    }

    if (!Neo[getSetCache][key]) {
        Neo[getSetCache][key] = {
            get() {
                let me        = this,
                    beforeGet = `beforeGet${key[0].toUpperCase() + key.slice(1)}`,
                    hasNewKey = Object.hasOwn(me[configSymbol], key),
                    newKey    = me[configSymbol][key],
                    value     = hasNewKey ? newKey : me['_' + key];

                if (Array.isArray(value)) {
                    if (key !== 'items') {
                        value = [...value]
                    }
                } else if (value instanceof Date) {
                    value = new Date(value.valueOf())
                }

                if (hasNewKey) {
                    me[key] = value; // we do want to trigger the setter => beforeSet, afterSet
                    value = me['_' + key]; // return the value parsed by the setter
                    delete me[configSymbol][key]
                }

                if (typeof me[beforeGet] === 'function') {
                    value = me[beforeGet](value)
                }

                return value
            },

            set(value) {
                if (value === undefined) {
                    return
                }

                let me        = this,
                    _key      = '_' + key,
                    uKey      = key[0].toUpperCase() + key.slice(1),
                    beforeSet = 'beforeSet' + uKey,
                    afterSet  = 'afterSet'  + uKey,
                    oldValue  = me[_key];

                // every set call has to delete the matching symbol
                delete me[configSymbol][key];

                if (key !== 'items') {
                    value = Neo.clone(value, true, true)
                }

                // we do want to store the value before the beforeSet modification as well,
                // since it could get pulled by other beforeSet methods of different configs
                me[_key] = value;

                if (typeof me[beforeSet] === 'function') {
                    value = me[beforeSet](value, oldValue);

                    // If they don't return a value, that means no change
                    if (value === undefined) {
                        me[_key] = oldValue;
                        return
                    }

                    me[_key] = value;
                }

                if (
                    (key === 'vnode' && value !== oldValue) || // vnode trees can be huge, avoid a deep comparison
                    !Neo.isEqual(value, oldValue)
                ) {
                    me[afterSet]?.(value, oldValue);
                    me.afterSetConfig?.(key, value, oldValue)
                }
            }
        }
    }

    Object.defineProperty(proto, key, Neo[getSetCache][key])
}

/**
 * @param {Boolean} create
 * @param {Object} current
 * @param {Object} prev
 * @returns {Object|undefined}
 */
function createArrayNs(create, current, prev) {
    let arrDetails = parseArrayFromString(current),
        i          = 1,
        len        = arrDetails.length,
        arrItem, arrRoot;

    if (create) {
        prev[arrDetails[0]] = arrRoot = prev[arrDetails[0]] || []
    } else {
        arrRoot = prev[arrDetails[0]]
    }

    if (!arrRoot) {
        return
    }

    for (; i < len; i++) {
        arrItem = parseInt(arrDetails[i]);

        if (create) {
            arrRoot[arrItem] = arrRoot[arrItem] || {}
        }

        arrRoot = arrRoot[arrItem]
    }

    return arrRoot
}

/**
 * Checks if the class name exists inside the Neo or app namespace
 * @param {String} className
 * @returns {Boolean}
 * @private
 */
function exists(className) {
    try {
        return !!className.split('.').reduce((prev, current) => {
            return prev[current]
        }, globalThis)
    } catch(e) {
        return false
    }
}

/**
 * @param {Neo.core.Base} proto
 * @param {Neo.core.Base} mixinProto
 * @returns {Function}
 * @private
 */
function mixinProperty(proto, mixinProto) {
    return function(key) {
        if (~ignoreMixin.indexOf(key)) {
            return
        }

        if (proto[key]?._from) {
            if (mixinProto.className === proto[key]._from) {
                console.warn('Mixin set multiple times or already defined on a Base Class', proto.className, mixinProto.className, key);
                return
            }

            throw new Error(
                `${proto.className}: Multiple mixins defining same property (${mixinProto.className}, ${proto[key]._from}) => ${key}`
            )
        }

        proto[key] = mixinProto[key];

        Object.getOwnPropertyDescriptor(proto, key)._from = mixinProto.className;

        if (typeof proto[key] === 'function') {
            proto[key]._name = key
        }
    }
}

/**
 * @param mixinCls
 * @returns {Function}
 * @private
 */
function mixReduce(mixinCls) {
    return (prev, current, idx, arr) => {
        return prev[current] = idx !== arr.length -1 ? prev[current] || {} : mixinCls
    }
}

/**
 * @param {String} str
 * @returns {Function}
 * @private
 */
function parseArrayFromString(str) {
    return (extractArraysRegex.exec(str) || [null]).slice(1).reduce(
        (fun, args) => [fun].concat(args.match(charsRegex))
    )
}

Neo.config = Neo.config || {};

Neo.assignDefaults(Neo.config, _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo);


/***/ }),

/***/ "./src/collection/Base.mjs":
/*!*********************************!*\
  !*** ./src/collection/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Filter.mjs */ "./src/collection/Filter.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Sorter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Sorter.mjs */ "./src/collection/Sorter.mjs");






const countMutations   = Symbol('countMutations'),
      isFiltered       = Symbol('isFiltered'),
      isSorted         = Symbol('isSorted'),
      silentUpdateMode = Symbol('silentUpdateMode'),
      toAddArray       = Symbol('toAddArray'),
      toRemoveArray    = Symbol('toRemoveArray'),
      updatingIndex    = Symbol('updatingIndex');

/**
 * @class Neo.collection.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.collection.Base'
         * @protected
         */
        className: 'Neo.collection.Base',
        /**
         * @member {String} ntype='collection'
         * @protected
         */
        ntype: 'collection',
        /**
         * When filtering the collection for the first time, allItems will become a new collection for the unfiltered
         * state, using this id as the sourceCollectionId
         * @member {Neo.collection.Base|null} allItems=null
         * @protected
         */
        allItems: null,
        /**
         * True to sort the collection items when adding / inserting new ones
         * @member {Boolean} autoSort=true
         */
        autoSort: true,
        /**
         * Use 'primitive' for default filters, use 'advanced' for filters using a filterBy method
         * which need to iterate over other collection items
         * @member {String} filterMode='primitive'
         */
        filterMode: 'primitive',
        /**
         * An Array containing Neo.util.Filter config objects or instances
         * @member {Array} filters_=[]
         */
        filters_: [],
        /**
         * @member {Object[]|null} items_=null
         */
        items_: null,
        /**
         * The unique(!) key property of each collection item
         * @member {String} keyProperty='id'
         */
        keyProperty: 'id',
        /**
         * Adding new items without an id (keyProperty) will use a negative index, which will decrease by -1
         * for each new item
         * @member {Number} keyPropertyIndex=-1
         */
        keyPropertyIndex: -1,
        /**
         * A map containing the key & reference of each collection item for faster access
         * @member {Map} map_=null
         * @protected
         */
        map_: null,
        /**
         * An internal Array of the sort directions for faster access
         * @member {Array} sortDirections=null
         * @protected
         */
        sortDirections: null,
        /**
         * An internal Array of the sort properties for faster access
         * @member {Array} sortProperties=null
         * @protected
         */
        sortProperties: null,
        /**
         * An Array containing Neo.util.Sorter config objects or instances
         * @member {Array} sorters_=[]
         */
        sorters_: [],
        /**
         * The id of another collection instance to use as this data source
         * @member {String|null} sourceId_=null
         */
        sourceId_: null
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            symbolConfig = {enumerable: false, writable: true};

        me.items = me.items || [];

        Object.defineProperties(me, {
            [countMutations]  : {...symbolConfig, value: false},
            [isFiltered]      : {...symbolConfig, value: false},
            [isSorted]        : {...symbolConfig, value: false},
            [silentUpdateMode]: {...symbolConfig, value: false},
            [toAddArray]      : {...symbolConfig, value: []},
            [toRemoveArray]   : {...symbolConfig, value: []},
            [updatingIndex]   : {...symbolConfig, value: 0}
        });

        if (me.autoSort && me._sorters.length > 0) {
            me.doSort()
        }
    }

    /**
     * Adds one or more items to the end of the collection
     * @param {Array|Object} item The item(s) to add
     * @returns {Object[]} an array containing all added items
     */
    add(item) {
        return this.splice(null, null, item).addedItems
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        let me = this;

        value.forEach(filter => {
            if (filter.listenerApplied === false) {
                filter.on('change', me.onFilterChange, me);
                filter.listenerApplied = true
            }
        });

        oldValue && me.filter()
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetItems(value, oldValue) {
        if (value) {
            let me            = this,
                {keyProperty} = me,
                i             = 0,
                len           = value.length,
                item;

            for (; i < len; i++) {
                item = value[i];
                me.map.set(item[keyProperty], item)
            }
        }
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        let me = this;

        me.applySorterConfigs();

        value.forEach(sorter => {
            if (sorter.listenerApplied === false) {
                sorter.on('change', me.onSorterChange, me);
                sorter.listenerApplied = true
            }
        });

        oldValue && me.autoSort && me.doSort()
    }

    /**
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetSourceId(value, oldValue) {
        if (value) {
            let me     = this,
                source = Neo.get(value);

            me._items = [...source._items];
            me.map    = new Map(source.map); // creates a clone of the original map

            const listenersConfig = {
                mutate: me.onMutate,
                scope : me
            };

            source.on(listenersConfig);

            if (oldValue) {
                source = Neo.get(oldValue);
                source.un(listenersConfig)
            }
        }
    }

    /**
     * Saves the sort property & direction multiplier of each sorter inside 2 arrays for faster access when sorting
     * @protected
     */
    applySorterConfigs() {
        let me = this;

        me.sortDirections = [];
        me.sortProperties = [];

        me.sorters.forEach(sorter => {//console.log('forEach', sorter);
            me.sortDirections.push(sorter.directionMultiplier);
            me.sortProperties.push(sorter.property)
        })
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetFilters(value, oldValue) {
        if (!Array.isArray(value)) {
            value = value ? [value] : []
        }

        let len = oldValue && oldValue.length || 0,
            hasMatch, i;

        value.forEach((key, index) => {
            if (oldValue) {
                hasMatch = false;
                i        = 0;

                for (; i < len; i++) {
                    if (oldValue[i] === key) {
                        oldValue[i].set({
                            operator: key.operator,
                            property: key.property,
                            value   : key.value
                        });

                        hasMatch = true;
                        break
                    } else if (
                        oldValue[i].operator === (key.operator || '===') &&
                        oldValue[i].property === key.property &&
                        oldValue[i].value    === key.value
                    ) {
                        hasMatch = true;
                        break
                    }
                }
            }

            if (!hasMatch) {
                value[index] = Neo.create(_Filter_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], key)
            } else {
                value[index] = oldValue[i];
                oldValue.splice(i, 1);
                len--
            }
        });

        if (Array.isArray(oldValue)) {
            oldValue.forEach(key => {
                key.destroy();
            })
        }

        return value
    }

    /**
     * @param {Map|null} value
     * @param {Map|null} oldValue
     * @protected
     */
    beforeSetMap(value, oldValue) {
        return !value ? new Map() : value
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetSorters(value, oldValue) {
        if (!Array.isArray(value)) {
            value = value ? [value] : []
        }

        let len = oldValue?.length || 0,
            hasMatch, i;

        value.forEach((key, index) => {
            if (oldValue) {
                hasMatch = false;
                i        = 0;

                let {direction, property} = key;

                for (; i < len; i++) {
                    if (oldValue[i] === key) {
                        oldValue[i].set({direction, property});

                        hasMatch = true;
                        break
                    } else if (oldValue[i].property === property && oldValue[i].direction === direction) {
                        hasMatch = true;
                        break
                    }
                }
            }

            if (!hasMatch) {
                value[index] = Neo.create(_Sorter_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], key)
            } else {
                value[index] = oldValue[i];
                oldValue.splice(i, 1);
                len--
            }
        });

        oldValue?.forEach(key => {
            key.destroy()
        });

        return value
    }

    /**
     * @param opts
     * @protected
     */
    cacheUpdate(opts) {
        console.log('cacheUpdate', opts, this[toAddArray]);
        return;

        let me            = this,
            {keyProperty} = me,
            index, toAddMap, toRemoveMap;

        if (!me[silentUpdateMode]) {
            toAddMap    = me[toAddArray]   .map(e => e[keyProperty]);
            toRemoveMap = me[toRemoveArray].map(e => e[keyProperty]);

            opts.addedItems.forEach(item => {
                if (index = toRemoveMap.indexOf(item[keyProperty]) > - 1) {
                    me[toRemoveArray].splice(index, 1)
                } else if (toAddMap.indexOf(item[keyProperty]) < 0) {
                    me[toAddArray].push(item)
                }
            });

            opts.removedItems.forEach(item => {
                if (index = toAddMap.indexOf(item[keyProperty]) > - 1) {
                    me[toAddArray].splice(index, 1)
                } else if (toRemoveMap.indexOf(item[keyProperty]) < 0) {
                    me[toRemoveArray].push(item)
                }
            })
        }
    }

    /**
     * Removes all items and clears the map
     */
    clear() {
        this.splice(0, this.getCount())
    }

    /**
     * Clears all current filters and optionally restores the original ones in case they existed.
     * @param {boolean} [restoreOriginalFilters=false]
     */
    clearFilters(restoreOriginalFilters) {
        this.filters = restoreOriginalFilters ? Neo.clone(this.originalConfig.filters, true, true) : null
    }

    /**
     * Removes all items and clears the map, without firing a mutate event
     */
    clearSilent() {
        let me = this;

        me._items.splice(0, me.getCount());
        me.map.clear()
    }

    /**
     * Clears all current sorters and optionally restores the original ones in case they existed.
     * Without restoreInitialState as true this will not affect the current sorting of this collection.
     * @param {boolean} [restoreOriginalSorters=false]
     */
    clearSorters(restoreOriginalSorters) {
        this.sorters = restoreOriginalSorters ? Neo.clone(this.originalConfig.sorters, true, true) : null
    }

    /**
     * @returns {Neo.collection.Base} The cloned collection
     */
    clone() {
        let me      = this,
            config  = Neo.clone(me.originalConfig, true),
            filters = me._filters || [],
            sorters = me._sorters || [];

        delete config.id;
        delete config.filters;
        delete config.items;
        delete config.sorters;

        if (me._items.length > 0) {
            config.items = [...me._items]
        }

        config.filters = [];
        config.sorters = [];

        // todo: filters & sorters should push their current state and not the original one

        filters.forEach(function(filter) {
            config.filters.push(filter.originalConfig)
        });

        sorters.forEach(function(sorter) {
            config.sorters.push(sorter.originalConfig)
        });

        return Neo.create(Base, config)
    }

    /**
     * Clears the map & items array before the super call
     */
    destroy() {
        let me = this;

        me._items.splice(0, me._items.length);
        me.map.clear();

        super.destroy()
    }

    /**
     *
     * @param {Object[]} items=this._items
     * @param {Boolean} silent=false
     * @protected
     */
    doSort(items=this._items, silent=false) {
        let me                = this,
            previousItems     = [...items],
            {sorters, sortDirections, sortProperties} = me,
            countSorters      = sortProperties.length || 0,
            hasSortByMethod   = false,
            hasTransformValue = false,
            i, mappedItems, obj, sorter, sortProperty, sortValue;

        if (countSorters > 0) {
            sorters.forEach(key => {
                if (key.sortBy) {
                    hasSortByMethod = true
                }

                if (key.useTransformValue) {
                    hasTransformValue = true
                }
            });

            if (hasSortByMethod) {
                me._items.sort((a, b) => {
                    i = 0;

                    for (; i < countSorters; i++) {
                        sorter    = sorters[i];
                        sortValue = sorter[sorter.sortBy ? 'sortBy' : 'defaultSortBy'](a, b);

                        if (sortValue !== 0) {
                            return sortValue
                        }
                    }

                    return 0
                })
            } else {
                if (hasTransformValue) {
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Sorting_with_map
                    mappedItems = items.map((item, index) => {
                        obj = {index};
                        i   = 0;

                        for (; i < countSorters; i++) {
                            if (sorters[i].useTransformValue) {
                                obj[sortProperties[i]] = sorters[i].transformValue(item[sortProperties[i]])
                            } else {
                                obj[sortProperties[i]] = item[sortProperties[i]]
                            }
                        }

                        return obj
                    });
                } else {
                    mappedItems = items
                }

                mappedItems.sort((a, b) => {
                    i = 0;

                    for (; i < countSorters; i++) {
                        sortProperty = sortProperties[i];

                        if (a[sortProperty] > b[sortProperty]) {
                            return 1 * sortDirections[i]
                        }

                        if (a[sortProperty] < b[sortProperty]) {
                            return -1 * sortDirections[i]
                        }
                    }

                    return 0
                });

                if (hasTransformValue) {
                    me._items = mappedItems.map(el => {
                        return items[el.index]
                    })
                }
            }
        }

        me[isSorted] = countSorters > 0;

        if (!silent && me[updatingIndex] === 0) {
            me.fire('sort', {
                items: me._items,
                previousItems,
                scope: me
            })
        }
    }

    /**
     * Resumes the collection events.
     * If you started an update using the startSilentUpdateMode flag,
     * you must use the endSilentUpdateMode param for this call.
     * Using the endSilentUpdateMode param will not fire a mutation event.
     * @param {Boolean} [endSilentUpdateMode]
     * @see {@link Neo.collection.Base#startUpdate startUpdate}
     */
    endUpdate(endSilentUpdateMode) {
        const me = this;

        if (me[updatingIndex] > 0) {
            me[updatingIndex]--
        }

        if (endSilentUpdateMode) {
            me[silentUpdateMode] = false
        } else {
            me.fire('mutate', {
                addedItems  : me[toAddArray],
                removedItems: me[toRemoveArray]
            });

            me[toAddArray]   .splice(0, me[toAddArray]   .length);
            me[toRemoveArray].splice(0, me[toRemoveArray].length)
        }
    }

    /**
     * Needed for remote filtering
     * @returns {Object[]}
     */
    exportFilters() {
        let me      = this,
            filters = [],
            filter;

        me.filters?.forEach(key => {
            filter = key.export();

            filter && filters.push(filter)
        });

        return filters
    }

    /**
     * Needed for remote sorting
     * @returns {Object[]}
     */
    exportSorters() {
        let me      = this,
            sorters = [],
            sorter;

        me.sorters?.forEach(key => {
            sorter = key.export();

            sorter && sorters.push(sorter)
        });

        return sorters
    }

    /**
     * @protected
     */
    filter() {
        let me              = this,
            filters         = me._filters,
            countAllFilters = filters.length,
            countFilters    = 0,
            items           = me.allItems?._items || me._items,
            i               = 0,
            countItems      = items.length,
            filteredItems   = [],
            needsSorting    = false,
            oldItems        = [...me._items],
            config, isIncluded, item, j, tmpItems;

        for (; i < countAllFilters; i++) {
            if (!filters[i].disabled) {
                countFilters++
            }
        }

        if (countFilters === 0 && me.allItems) {
            if (me.sorters.length > 0) {
                needsSorting = true
            }

            me.clearSilent();

            me.items = [...me.allItems._items]
        } else {
            if (!me.allItems) {
                config = {...me.originalConfig};

                delete config.filters;
                delete config.items;
                delete config.sorters;

                me.allItems = Neo.create(Base, {
                    ...Neo.clone(config, true, true),
                    keyProperty: me.keyProperty,
                    sourceId   : me.id
                })
            }

            me.map.clear();

            if (me.filterMode === 'primitive') {
                // using for loops on purpose -> performance
                for (i = 0; i < countItems; i++) {
                    isIncluded = true;
                    item       = items[i];
                    j          = 0;

                    for (; j < countAllFilters; j++) {
                        if (filters[j].isFiltered(item, items, items)) {
                            isIncluded = false;
                            break
                        }
                    }

                    if (isIncluded) {
                        filteredItems.push(item);
                        me.map.set(item[me.keyProperty], item)
                    }
                }

                me._items = filteredItems // silent update, the map is already in place
            } else {
                filteredItems = [...items];

                for (j=0; j < countAllFilters; j++) {
                    tmpItems = [];

                    for (i = 0; i < countItems; i++) {
                        if (!filters[j].isFiltered(filteredItems[i], filteredItems, items)) {
                            tmpItems.push(filteredItems[i])
                        }
                    }

                    filteredItems = [...tmpItems];
                    countItems    = filteredItems.length
                }

                me.items = filteredItems // update the map
            }
        }

        me[isFiltered] = countFilters !== 0;

        if (needsSorting) {
            me.doSort(me.items, true)
        }

        me.fire('filter', {
            isFiltered: me[isFiltered],
            items     : me.items,
            oldItems,
            scope     : me
        })
    }

    /**
     * Returns items which match the property and value
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]}
     *     returnFirstMatch=false: Returns an empty Array in case no items are found
     *     returnFirstMatch=true:  Returns the first found item or null
     */
    find(property, value, returnFirstMatch=false) {
        let me               = this,
            items            = [],
            isObjectProperty = me.isItem(property),
            item, matchArray, propertiesArray, propertiesLength;

        if (isObjectProperty) {
            propertiesArray  = Object.entries(property);
            propertiesLength = propertiesArray.length;
        }

        for (item of me.items) {
            if (isObjectProperty) {
                matchArray = [];

                propertiesArray.forEach(([key, value]) => {
                    if (item[key] === value) {
                        matchArray.push(true)
                    }
                });

                if (matchArray.length === propertiesLength) {
                    if (returnFirstMatch) {
                        return item
                    }

                    items.push(item)
                }
            } else if (item[property] === value) {
                if (returnFirstMatch) {
                    return item
                }

                items.push(item)
            }
        }

        return returnFirstMatch ? null : items
    }

    /**
     * Returns all items in the collection for which the passed function returns true
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} fn.item The current collection item
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.getCount() The end index (up to, last value excluded)
     * @returns {Array} Returns an empty Array in case no items are found
     */
    findBy(fn, scope=this, start=0, end=this.getCount()) {
        let me    = this,
            items = [],
            i     = start;

        for (; i < end; i++) {
            if (fn.call(scope, me.items[i])) {
                items.push(me.items[i])
            }
        }

        return items
    }

    /**
     * Returns the first item which matches the property and value
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @returns {Object} Returns the first found item or null
     */
    findFirst(property, value) {
        return this.find(property, value, true)
    }

    /**
     * Returns the first item inside the collection
     * @returns {Object}
     */
    first() {
        return this._items[0]
    }

    /**
     * Returns the object associated to the key, or null if there is none.
     * @param key
     * @returns {Object|null}
     */
    get(key) {
        return this.map.get(key) || null
    }

    /**
     * Returns the item for a given index
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        return this._items[index]
    }

    /**
     * Returns the length of the internal items array
     * @returns {Number}
     */
    getCount() {
        return this._items.length
    }

    /**
     * @returns {Number}
     */
    getCountMutations() {
        return this[countMutations]
    }

    /**
     * Returns the first matching filter for the given property config
     * @param {String} property
     * @returns {Neo.collection.Filter|null}
     */
    getFilter(property) {
        let filters = this.filters || [],
            i       = 0,
            len     = filters.length;

        for (; i < len; i++) {
            if (filters[i].property === property) {
                return filters[i]
            }
        }

        return null
    }

    /**
     * Returns the key for a given index
     * @param {Number} index
     * @returns {Number|String|undefined}
     */
    getKeyAt(index) {
        let item = this._items[index];
        return item?.[this.keyProperty]
    }

    /**
     * Returns a shallow copy of a portion of the items array
     * @param {Number} [start] Zero-based index at which to begin extraction.
     * @param {Number} [end] Zero-based index before which to end extraction (extracts up to but not including end).
     * @returns {Array}
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
     */
    getRange(start, end) {
        return this._items.slice(start, end)
    }

    /**
     * Returns the Source Collection in case the sourceCollectionId config was set
     * @returns {Neo.collection.Base|undefined}
     */
    getSource() {
        return this.sourceId && Neo.get(this.sourceId)
    }

    /**
     * Returns a boolean asserting whether a value has been associated to the key in the Collection or not
     * @param {Number|String} key
     * @returns {Boolean}
     */
    has(key) {
        return this.map.has(key)
    }

    /**
     * Returns a boolean asserting whether an item exists in the Collection or not
     * @param {Object} item
     * @returns {Boolean}
     */
    hasItem(item) {
        return this.map.has(item[this.keyProperty])
    }

    /**
     * Returns the index for a given key or item
     * @param {Number|String|Object} key
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOf(key) {
        let me = this;
        return me._items.indexOf(me.isItem(key) ? key : me.map.get(key))
    }

    /**
     * Returns the index for a given item
     * @param {Object} item
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOfItem(item) {
        return this._items.indexOf(item)
    }

    /**
     * Returns the index for a given key
     * @param {Number|String} key
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOfKey(key) {
        return this._items.indexOf(this.map.get(key))
    }

    /**
     * Inserts an item or an array of items at the specified index
     * @param {Number} index
     * @param {Array|Object} item
     * @returns {Object[]} an array containing all added items
     */
    insert(index, item) {
        return this.splice(index, 0, item).addedItems
    }

    /**
     * @returns {Boolean} true in case the collection is filtered
     */
    isFiltered() {
        return this[isFiltered]
    }

    /**
     * @param {Object} item
     * @returns {boolean}
     * @protected
     */
    isFilteredItem(item) {
        let me         = this,
            filters    = me._filters,
            i          = 0,
            len        = filters.length,
            isFiltered = false;

        for (; i < len; i++) {
            if (filters[i].isFiltered(item)) {
                isFiltered = true;
                break
            }
        }

        return isFiltered
    }

    /**
     * Helper method to check if a given value is either an object or a neo data record
     * @param {*} value
     * @returns {Boolean}
     */
    isItem(value) {
        return Neo.isObject(value) || Neo.isRecord(value)
    }

    /**
     * @returns {Boolean} true in case the collection is sorted
     */
    isSorted() {
        return this[isSorted]
    }

    /**
     * Returns the last item inside the collection
     * @returns {Object}
     */
    last() {
        return this._items[this.getCount() -1]
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        this.filter()
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onMutate(opts) {
        let me = this;

        if (opts.preventBubbleUp) {
            me.preventBubbleUp = true
        }

        me.splice(null, opts.removedItems, opts.addedItems)
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onSorterChange(opts) {
        this.applySorterConfigs();
        this.doSort()
    }

    /**
     * Removes the last element from the items array and returns this element.
     * @returns {Object} The removed element from the collection; undefined if the collection is empty.
     */
    pop() {
        let mutation = this.splice(this.getCount() -1, 1);
        return mutation.removedItems[0]
    }

    /**
     * Adds one or more items to the end of the collection and returns the new items count
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    push(item) {
        return this.add(item)
    }

    /**
     * Removes a given key, item or Array containing keys|items
     * @param {Number|String|Object|Array} key
     * @returns {Number} the collection count
     */
    remove(key) {
        this.splice(0, Array.isArray(key) ? key : [key]);
        return this.getCount()
    }

    /**
     * Removes the item at the given index
     * @param {Number} index
     * @returns {Number} the collection count
     */
    removeAt(index) {
        this.splice(index, 1);
        return this.getCount()
    }

    /**
     * Reverses the items array in place.
     * Intended for collections without sorters.
     * @returns {Array} items
     */
    reverse() {
        return this._items.reverse()
    }

    /**
     * Removes the first element from the items array and returns this element.
     * @returns {Object} The removed element from the collection; undefined if the collection is empty.
     */
    shift() {
        let mutation = this.splice(0, 1);
        return mutation.addedItems[0]
    }

    /**
     * @param {function} callback Function to test for each item, taking three parameters:
     * @param {Object}   callback.item The current collection item being processed
     * @param {Number}  [callback.index] The index of the current item being processed
     * @param {Array}   [callback.items] The items array of the collection
     *
     * @param {Object} [scope] Value to use as "this" when executing the callback
     * @returns {boolean} true if the callback function returns a truthy value for any collection item, otherwise false
     */
    some(...args) {
        return this._items.some(...args)
    }

    /**
     * Removes items from and/or adds items to this collection
     * If the toRemoveArray is used, then the index is not used for removing, the entries are found by key and removed from where they are.
     * If index is not passed, toAddArray is appended to the Collection.
     * @param {Number|null} index
     * @param {Number|Object[]} [removeCountOrToRemoveArray]
     * @param {Object|Object[]} [toAddArray]
     * @returns {Object} An object containing the addedItems & removedItems arrays
     */
    splice(index, removeCountOrToRemoveArray, toAddArray) {
        let me                 = this,
            {keyProperty, map} = me,
            source             = me.getSource(),
            addedItems         = [],
            items              = me._items,
            removedItems       = [],
            removeCountAtIndex = Neo.isNumber(removeCountOrToRemoveArray) ? removeCountOrToRemoveArray : null,
            toRemoveArray      = Array.isArray(removeCountOrToRemoveArray) ? removeCountOrToRemoveArray : null,
            i, item, key, len, toAddMap;

        if (!Neo.isNumber(index) && removeCountAtIndex) {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].error(me.id + ': If index is not passed, removeCountAtIndex cannot be used')
        }

        toAddArray = toAddArray && !Array.isArray(toAddArray) ? [toAddArray] : toAddArray;

        if (toRemoveArray && (len = toRemoveArray.length) > 0) {
            if (toAddArray && toAddArray.length > 0) {
                toAddMap = toAddArray.map(e => e[keyProperty])
            }

            for (i=0; i < len; i++) {
                item = toRemoveArray[i];
                key  = me.isItem(item) ? item[keyProperty] : item;

                if (map.has(key)) {
                    if (!toAddMap || (toAddMap && toAddMap.indexOf(key) < 0)) {
                        removedItems.push(items.splice(me.indexOfKey(key), 1)[0]);
                        map.delete(key)
                    }
                }
            }
        } else if (removeCountAtIndex && removeCountAtIndex > 0) {
            removedItems.push(...items.splice(index, removeCountAtIndex));
            removedItems.forEach(e => {
                map.delete(e[keyProperty])
            })
        }

        if (toAddArray && (len = toAddArray.length) > 0) {
            for (i=0; i < len; i++) {
                item = toAddArray[i];
                key  = item[keyProperty];

                if (!key) {
                    item[keyProperty] = key = me.keyPropertyIndex;
                    me.keyPropertyIndex--
                }

                if (!map.has(key) && !me.isFilteredItem(item)) {
                    addedItems.push(item);
                    map.set(key, item)
                }
            }

            if (addedItems.length > 0) {
                items.splice(Neo.isNumber(index) ? index : items.length, 0, ...addedItems);

                if (me.autoSort && me._sorters.length > 0) {
                    me.doSort()
                }
            }
        }

        if (source) {
            if (!source.getSource()) {
                source.preventBubbleUp = true
            }

            if (!me.preventBubbleUp) {
                // console.log('source splice', source.id, 'added:', ...toAddArray, 'removed:', ...removedItems);
                me.startUpdate(true);
                source.splice(null, toRemoveArray || removedItems, toAddArray);
                me.endUpdate(true)
            }

            delete source.preventBubbleUp
        }

        if (addedItems.length > 0 || removedItems.length > 0) {
            me[countMutations]++
        }

        if (me[updatingIndex] === 0) {
            me.fire('mutate', {
                addedItems     : toAddArray,
                preventBubbleUp: me.preventBubbleUp,
                removedItems   : toRemoveArray || removedItems
            })
        } else if (!me[silentUpdateMode]) {
            me.cacheUpdate({
                addedItems,
                removedItems
            })
        }

        if (me[updatingIndex] === 0) {
            delete me.preventBubbleUp
        }

        return {addedItems, removedItems}
    }

    /**
     * Prevents the collection from firing events until endUpdate gets called.
     * If you start an update using the startSilentUpdateMode param,
     * the mutation event will not fire after using endUpdate()
     * (you must use the endSilentUpdateMode param for the endUpdate call in case you used
     * startSilentUpdateMode here)
     * @param {Boolean} [startSilentUpdateMode]
     * @see {@link Neo.collection.Base#endUpdate endUpdate}
     */
    startUpdate(startSilentUpdateMode) {
        if (startSilentUpdateMode) {
            this[silentUpdateMode] = true
        }

        this[updatingIndex]++
    }

    /**
     * Adds one or more elements to the beginning of the collection and returns the new items count
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    unshift(item) {
        this.splice(0, 0, item);
        return this.getCount()
    }
}

/**
 * The mutate event fires after every splice call (invoked by all methods which change the content of the items array).
 * @event mutate
 * @param {Object[]} addedItems
 * @param {Boolean} preventBubbleUp private
 * @param {Object[]} removedItems
 * @returns {Object}
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/collection/Filter.mjs":
/*!***********************************!*\
  !*** ./src/collection/Filter.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.collection.Filter
 * @extends Neo.core.Base
 */
class Filter extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true
    /**
     * Valid values for the operator config:<br>
     * ['==','===','!=','!==','<','<=','>','>=','endsWith','excluded','included','isDefined','isUndefined','like','startsWith']
     * @member {String[]} operators
     * @protected
     * @static
     */
    static operators = [
        '==', '===', '!=', '!==', '<', '<=', '>', '>=', 'endsWith', 'excluded', 'included',
        'isDefined', 'isUndefined', 'like', 'startsWith'
    ]

    static config = {
        /**
         * @member {String} className='Neo.collection.Filter'
         * @protected
         */
        className: 'Neo.collection.Filter',
        /**
         * @member {String} ntype='filter'
         * @protected
         */
        ntype: 'filter',
        /**
         * Setting disabled to true will exclude this filter from the collection filtering logic
         * @member {Boolean} disabled_=false
         */
        disabled_: false,
        /**
         * Provide a custom filtering function which has a higher priority than property, operator & value
         * @member {Function|null} filterBy_=null
         */
        filterBy_: null,
        /**
         * True means not filtering out items in case the value is '', null, [] or {}
         * @member {Boolean} includeEmptyValues=true
         */
        includeEmptyValues: true,
        /**
         * Set this flag to true before starting bulk updates (e.g. changing property & value)
         * to prevent multiple change events
         * @member {Boolean} isUpdating_=false
         */
        isUpdating_: false,
        /**
         * The owner util.Collection needs to apply an onChange listener once
         * @member {Boolean} listenerApplied=false
         * @protected
         */
        listenerApplied: false,
        /**
         * The operator to filter by (use the combination of property, operator & value)
         * Valid values:
         *
         * == (not recommended)
         * ===
         * != (not recommended)
         * !==
         * <
         * >=
         * >
         * >=
         * like (collectionValue.toLowerCase().indexOf(filterValue.toLowerCase()) > -1)
         * included (expects value to be an array)
         * excluded (expects value to be an array)
         * @member {String} operator='==='
         */
        operator_: '===',
        /**
         * The property to filter by (use the combination of property, operator & value)
         * @member {String} property_='id'
         */
        property_: 'id',
        /**
         * The scope to use for the filterBy method, in case it is provided. Defaults to this instance.
         * @member {Object|null} scope=null
         */
        scope: null,
        /**
         * The value to filter by (use the combination of property, operator & value)
         * @member {String} value_=null
         */
        value_: null
    }

    afterSetDisabled(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetFilterBy(value, oldValue) {
        // todo
    }

    afterSetIsUpdating(value, oldValue) {
        value === false && this.fireChangeEvent(value, oldValue)
    }

    afterSetOperator(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetProperty(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetValue(...args) {
        this.fireChangeEvent(...args)
    }

    beforeSetFilterBy(value, oldValue) {
        if (value && typeof value !== 'function') {
            Neo.logError('filterBy has to be a function', this);
            return oldValue
        }

        return value
    }

    /**
     * Triggered before the operator config gets changed.
     * @param {String|null} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetOperator(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'operator')
    }

    /**
     * Needed for remote filtering
     * @returns {Object|null}
     */
    export() {
        let me                          = this,
            {operator, property, value} = me;

        if (!me.filterBy) {
            return {operator, property, value}
        }

        return null
    }

    /**
     * @param value
     * @param oldValue
     */
    fireChangeEvent(value, oldValue) {
        let me = this;

        if (oldValue !== undefined && me.isUpdating !== true) {
            let {operator, property, value} = me;
            me.fire('change', {operator, property, value})
        }
    }

    /**
     * Checks if a collection item matches this filter
     * @param {Object} item The current collection item
     * @param {Array} filteredItems If the collection filterMode is not primitive contains the items which passed
     * the previous filters, otherwise all collection items
     * @param {Array} allItems all collection items
     * @returns {Boolean}
     */
    isFiltered(item, filteredItems, allItems) {
        let me = this,
            filterValue, recordValue;

        if (me._disabled) {
            return false
        }

        if (me._filterBy) {
            return me.filterBy.call(me.scope || me, {
                allItems,
                filteredItems,
                item,
                value: me._value
            })
        }

        if (me.includeEmptyValues && (me._value === null || Neo.isEmpty(me._value))) {
            return false
        }

        filterValue = me._value;
        recordValue = item[me._property];

        if (filterValue instanceof Date && recordValue instanceof Date) {
            filterValue = filterValue.valueOf();
            recordValue = recordValue.valueOf()
        }

        return !Filter[me._operator](recordValue, filterValue)
    }

    static ['=='] (a, b) {return a == b}
    static ['==='](a, b) {return a === b}
    static ['!='] (a, b) {return a != b}
    static ['!=='](a, b) {return a !== b}
    static ['<']  (a, b) {return a < b}
    static ['<='] (a, b) {return a <= b}
    static ['>']  (a, b) {return a > b}
    static ['>='] (a, b) {return a >= b}

    static ['endsWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().endsWith(b?.toLowerCase()) || false
    }

    static ['excluded'](a, b) {
        return b.indexOf(a) < 0
    }

    static ['included'](a, b) {
        return b.indexOf(a) > -1
    }

    static ['isDefined'](a, b) {
        return a !== undefined
    }

    static ['isUndefined'](a, b) {
        return a === undefined
    }

    static ['like'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().includes(b?.toLowerCase()) || false
    }

    static ['startsWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().startsWith(b?.toLowerCase()) || false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Filter));


/***/ }),

/***/ "./src/collection/Sorter.mjs":
/*!***********************************!*\
  !*** ./src/collection/Sorter.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.collection.Sorter
 * @extends Neo.core.Base
 */
class Sorter extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.collection.Sorter'
         * @protected
         */
        className: 'Neo.collection.Sorter',
        /**
         * @member {String} ntype='sorter'
         * @protected
         */
        ntype: 'sorter',
        /**
         * Internal config which maps the direction ASC to 1, -1 otherwise
         * @member {Number} directionMultiplier=1
         * @protected
         */
        directionMultiplier: 1,
        /**
         * The sort direction when using a property.
         * @member {String} direction_='ASC'
         */
        direction_: 'ASC',
        /**
         * The owner util.Collection needs to apply an onChange listener once
         * @member {boolean} listenerApplied=false
         * @protected
         */
        listenerApplied: false,
        /**
         * The property to sort by.
         * @member {String} property_='id'
         */
        property_: 'id',
        /**
         * Provide a custom sorting function, has a higher priority than property & direction
         * @member {Function|null} sortBy=null
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        sortBy: null,
        /**
         * True to use the transformValue method for each item (the method can get overridden)
         * @member {Boolean} useTransformValue=true
         * @protected
         */
        useTransformValue: true
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetDirection(value, oldValue) {
        let me = this;

        me.directionMultiplier = value === 'ASC' ? 1 : -1;

        if (oldValue) {
            me.fire('change', {
                direction: me.direction,
                property : me.property
            });
        }
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetProperty(value, oldValue) {
        let me = this;

        if (oldValue) {
            me.fire('change', {
                direction: me.direction,
                property : me.property
            });
        }
    }

    /**
     * Default sorter function which gets used by collections in case at least one sorter has a real sortBy method
     * @param a
     * @param b
     */
    defaultSortBy(a, b) {
        let me = this;

        a = a[me.property];
        b = b[me.property];

        if (me.useTransformValue) {
            a = me.transformValue(a);
            b = me.transformValue(b);
        }

        if (a > b) {
            return 1 * me.directionMultiplier;
        }

        if (a < b) {
            return -1 * me.directionMultiplier;
        }

        return 0;
    }

    /**
     * Needed for remote sorting
     * @returns {Object|null}
     */
    export() {
        let me                    = this,
            {direction, property} = me;

        if (!me.sortBy && direction && property) {
            return {direction, property}
        }

        return null
    }

    /**
     * @param {*} value
     * @returns {*} value
     */
    transformValue(value) {
        if (typeof value === 'string') {
            value = value.toLowerCase()
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Sorter));


/***/ }),

/***/ "./src/controller/Application.mjs":
/*!****************************************!*\
  !*** ./src/controller/Application.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");




/**
 * @class Neo.controller.Application
 * @extends Neo.controller.Base
 */
class Application extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.controller.Application'
         * @protected
         */
        className: 'Neo.controller.Application',
        /**
         * @member {String} ntype='application'
         * @protected
         */
        ntype: 'application',
        /**
         * @member {String|null} appThemeFolder=null
         */
        appThemeFolder: null,
        /**
         * @member {Neo.component.Base} mainView_=null
         */
        mainView_: null,
        /**
         * @member {Boolean} mounted=false
         * @protected
         */
        mounted: false,
        /**
         * @member {String} name='MyApp'
         */
        name: 'MyApp',
        /**
         * @member {String} parentId='document.body'
         */
        parentId: 'document.body',
        /**
         * @member {Boolean} rendered=false
         * @protected
         */
        rendered: false,
        /**
         * @member {Boolean} rendering=false
         * @protected
         */
        rendering: false,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        // to guarantee that the main view can access Neo.apps at any point,
        // we need to trigger its assignment at the end of the ctor.
        let mainView = config.mainView;
        delete config.mainView;

        super.construct(config);

        let me = this;

        me.windowId = Neo.config.windowId;

        Neo.apps = Neo.apps || {};

        Neo.apps[me.name] = me;

        Neo.currentWorker.registerApp(me.name);

        if (mainView) {
            me.mainView = mainView
        }
    }

    /**
     * Triggered after the mainView config got changed
     * @param {Neo.component.Base} value
     * @param {Neo.component.Base|null} oldValue
     * @protected
     */
    async afterSetMainView(value, oldValue) {
        if (value) {
            let me = this;

            // short delay to ensure changes from onHashChange() got applied
            await me.timeout(Neo.config.hash ? 200 : 10);

            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addContextMenuListener(me.mainView);

            await value.render(true)
        }
    }

    /**
     * Triggered before the mainView config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.component.Base|null}
     * @protected
     */
    beforeSetMainView(value, oldValue) {
        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, null, {
                appName : this.name,
                parentId: this.parentId,
                windowId: Neo.config.windowId
            })
        }

        return null
    }

    /**
     * Unregister the app from the CSS map
     * @param args
     */
    destroy(...args) {
        Neo.currentWorker.removeAppFromThemeMap(this.name);
        super.destroy(...args)
    }
}

Application = Neo.setupClass(Application);

// convenience shortcut
Neo.app = config => Neo.create({
    module: Application,
    ...config
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Application);


/***/ }),

/***/ "./src/controller/Base.mjs":
/*!*********************************!*\
  !*** ./src/controller/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");



const
    amountSlashesRegex = /\//g,
    routeParamRegex    = /{[^\s/]+}/g

/**
 * @class Neo.controller.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Base'
         * @protected
         */
        className: 'Neo.controller.Base',
        /**
         * @member {String} ntype='controller'
         * @protected
         */
        ntype: 'controller',
        /**
         * If the URL does not contain a hash value when creating this controller instance,
         * neo will set this hash value for us.
         * @member {String|null} defaultHash=null
         */
        defaultHash: null,
        /**
         * @member {String|null} defaultRoute=null
         */
        defaultRoute: null,
        /**
         * @member {Object} handleRoutes={}
         */
        handleRoutes: {},
        /**
         * @example
         * routes: {
         *     '/home'                         : 'handleHomeRoute',
         *     '/users/{userId}'               : {handler: 'handleUserRoute', preHandler: 'preHandleUserRoute'},
         *     '/users/{userId}/posts/{postId}': 'handlePostRoute',
         *     'default'                       : 'handleOtherRoutes'
         * }
         * @member {Object} routes_={}
         */
        routes_: {}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].on('change', this.onHashChange, this)
    }

    /**
     * Triggered after the routes config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetRoutes(value, oldValue){
        let me        = this,
            routeKeys = Object.keys(value);

         me.routes = routeKeys.sort(me.#sortRoutes).reduce((obj, key) => {
             obj[key] = value[key];
             return obj
         }, {});

        me.handleRoutes = {};

        routeKeys.forEach(key => {
            if (key.toLowerCase() === 'default'){
                me.defaultRoute = value[key]
            } else {
                me.handleRoutes[key] = new RegExp(key.replace(routeParamRegex, '([\\w-.]+)')+'$')
            }
        })
    }

    /**
     * @param args
     */
    destroy(...args) {
        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].un('change', this.onHashChange, this);

        super.destroy(...args)
    }

    /**
     *
     */
    async onConstructed() {
        let me                      = this,
            {defaultHash, windowId} = me,
            currentHash             = _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].first(windowId);

        // get outside the construction chain => a related cmp & vm has to be constructed too
        await me.timeout(1);

        if (currentHash) {
            if (currentHash.windowId === windowId) {
                await me.onHashChange(currentHash, null)
            }
        } else {
            /*
             * worker.App: onLoadApplication() will push config.hash into the HashHistory with a 5ms delay.
             * We only want to set a default route, in case the HashHistory is empty and there is no initial
             * value that will get consumed.
             */
            !Neo.config.hash && defaultHash && Neo.Main.setRoute({value: defaultHash, windowId})
        }
    }

    /**
     * Placeholder method which gets triggered when the hash inside the browser url changes
     * @param {Object} value
     * @param {Object} oldValue
     */
    async onHashChange(value, oldValue) {
        // We only want to trigger hash changes for the same browser window (SharedWorker context)
        if (value.windowId !== this.windowId) {
            return
        }

        let me                     = this,
            counter                = 0,
            hasRouteBeenFound      = false,
            {handleRoutes, routes} = me,
            routeKeys              = Object.keys(handleRoutes),
            routeKeysLength        = routeKeys.length,
            arrayParamIds, arrayParamValues, handler, key, paramObject, preHandler, responsePreHandler, result, route;

        while (routeKeysLength > 0 && counter < routeKeysLength && !hasRouteBeenFound) {
            key                = routeKeys[counter];
            handler            = null;
            preHandler         = null;
            responsePreHandler = null;
            paramObject        = {};
            result             = value.hashString.match(handleRoutes[key]);

            if (result) {
                arrayParamIds    = key.match(routeParamRegex);
                arrayParamValues = result.splice(1, result.length - 1);

                if (arrayParamIds && arrayParamIds.length !== arrayParamValues.length) {
                    throw 'Number of IDs and number of Values do not match'
                }

                for (let i = 0; arrayParamIds && i < arrayParamIds.length; i++) {
                    paramObject[arrayParamIds[i].substring(1, arrayParamIds[i].length - 1)] = arrayParamValues[i]
                }

                route = routes[key];

                if (Neo.isString(route)) {
                    handler            = route;
                    responsePreHandler = true
                } else if (Neo.isObject(route)) {
                    handler    = route.handler;
                    preHandler = route.preHandler
                }

                hasRouteBeenFound = true
            }

            counter++
        }

        // execute
        if (hasRouteBeenFound) {
            if (preHandler) {
                responsePreHandler = await me[preHandler]?.call(me, paramObject, value, oldValue)
            } else {
                responsePreHandler = true
            }

            if (responsePreHandler) {
                await me[handler]?.call(me, paramObject, value, oldValue)
            }
        }

        if (routeKeys.length > 0 && !hasRouteBeenFound) {
            if (me.defaultRoute) {
                me[me.defaultRoute]?.(value, oldValue)
            } else {
                me.onNoRouteFound(value, oldValue)
            }
        }
    }

    /**
     * Placeholder method which gets triggered when an invalid route is called
     * @param {Object} value
     * @param {Object} oldValue
     */
    onNoRouteFound(value, oldValue) {

    }

    /**
     * Internal helper method to sort routes by their amount of slashes
     * @param {String} route1
     * @param {String} route2
     * @returns {Number}
     */
    #sortRoutes(route1, route2) {
        return (route1.match(amountSlashesRegex) || []).length - (route2.match(amountSlashesRegex)|| []).length
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/core/Base.mjs":
/*!***************************!*\
  !*** ./src/core/Base.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");



const configSymbol       = Symbol.for('configSymbol'),
      forceAssignConfigs = Symbol('forceAssignConfigs'),
      isInstance         = Symbol('isInstance');

/**
 * The base class for (almost) all classes inside the Neo namespace
 * Exceptions are e.g. core.IdGenerator, vdom.VNode
 * @class Neo.core.Base
 */
class Base {
    /**
     * You can define methods which should get delayed.
     * Types are buffer, debounce & throttle.
     * @example
     *  delayable: {
     *      fireChangeEvent: {
     *          type : 'debounce',
     *          timer: 300
     *      }
     *  }
     * @member {Object} delayable={}
     * @protected
     * @static
     */
    static delayable = {}
    /**
     * Flag which will get set to true once manager.Instance got created
     * @member {Boolean} instanceManagerAvailable=false
     * @static
     */
    static instanceManagerAvailable = false
    /**
     * Regex to grab the MethodName from an error
     * which is a second generation function
     * @member {RegExp} methodNameRegex
     * @static
     */
    static methodNameRegex = /\n.*\n\s+at\s+.*\.(\w+)\s+.*/
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=false
     * @static
     */
    static observable = false
    /**
     * Keep the overwritten methods
     * @member {Object} overwrittenMethods={}
     * @protected
     * @static
     */
    static overwrittenMethods = {}
    /**
     * Set this one to false in case you don't want to stick
     * to the "anti-pattern" to apply classes to the global Neo or App namespace
     * @member {Boolean} registerToGlobalNs=true
     * @protected
     * @static
     */
    static registerToGlobalNs = true
    /**
     * Configs will get merged throughout the class hierarchy
     * @returns {Object} config
     * @tutorial 02_ClassSystem
     */
    static config = {
        /**
         * The class name which will get mapped into the Neo or app namespace
         * @member {String} className='Neo.core.Base'
         * @protected
         */
        className: 'Neo.core.Base',
        /**
         * The class shortcut-name to use for e.g. creating child components inside a JSON-format
         * @member {String} ntype='base'
         * @protected
         */
        ntype: 'base',
        /**
         * While it is recommended to change the static delayable configs on class level,
         * you can change it on instance level too. If not null, we will do a deep merge.
         * @member {Object} delayable=null
         */
        delayable: null,
        /**
         * The unique component id
         * @member {String|null} id_=null
         */
        id_: null,
        /**
         * Neo.create() will change this flag to true after the onConstructed() chain is done.
         * @member {Boolean} isConstructed=false
         * @protected
         */
        isConstructed: false,
        /**
         * Add mixins as an array of classNames, imported modules or a mixed version
         * @member {String[]|Neo.core.Base[]|null} mixins=null
         */
        mixins: null,
        /**
         * You can create a new instance by passing an imported class (JS module default export)
         * @member {Class} module=null
         * @protected
         */
        module: null
    }

    /**
     * Internal cache for all timeout ids when using this.timeout()
     * @member {Number[]} timeoutIds=[]
     * @private
     */
    #timeoutIds = []

    /**
     * Applies the observable mixin if needed, grants remote access if needed.
     * @param {Object} config={}
     */
    construct(config={}) {
        let me = this;

        Object.defineProperties(me, {
            [configSymbol]: {
                configurable: true,
                enumerable  : false,
                value       : {},
                writable    : true
            },
            [isInstance]: {
                enumerable: false,
                value     : true
            }
        });

        me.createId(config.id || me.id);
        delete config.id;

        if (me.constructor.config) {
            delete me.constructor.config.id;
        }

        me.getStaticConfig('observable') && me.initObservable(config);

        // assign class field values prior to configs
        config = me.setFields(config);

        me.initConfig(config);

        Object.defineProperty(me, 'configsApplied', {
            enumerable: false,
            value     : true
        });

        me.applyDelayable();

        /*
         * We do not want to force devs to check for the `isDestroyed` flag in every possible class extension.
         * So, we are intercepting the top-most `destroy()` call to check for the flag there.
         * Rationale: `destroy()` must only get called once.
         */
        (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.intercept)(me, 'destroy', me.isDestroyedCheck, me);

        me.remote && setTimeout(me.initRemote.bind(me), 1)
    }

    /**
     * Triggered after the id config got changed.
     * You can dynamically change instance ids if needed. They need to stay unique at any given point.
     * Use case: e.g. component based lists, where you want to re-use item instances.
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me         = this,
            hasManager = Base.instanceManagerAvailable === true;

        if (oldValue) {
            if (hasManager) {
                Neo.manager.Instance.unregister(oldValue)
            } else {
                delete Neo.idMap[oldValue]
            }
        }

        if (hasManager) {
            Neo.manager.Instance.register(me);
        } else {
            Neo.idMap = Neo.idMap || {};
            Neo.idMap[me.id] = me
        }
    }

    /**
     * Adjusts all methods inside static delayable
     */
    applyDelayable() {
        let me            = this,
            ctorDelayable = me.constructor.delayable,
            delayable     = me.delayable ? Neo.merge({}, me.delayable, ctorDelayable) : ctorDelayable;

        Object.entries(delayable).forEach(([key, value]) => {
            if (value) {
                let map = {
                    buffer()   {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.buffer(me[key],   me, value.timer)},
                    debounce() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce(me[key], me, value.timer)},
                    throttle() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.throttle(me[key], me, value.timer)}
                };

                map[value.type]?.()
            }
        })
    }

    /**
     * Applying overwrites and adding overwrittenMethods to the class constructors
     * @param {Object} cfg
     * @protected
     */
    static applyOverwrites(cfg) {
        let overwrites = Neo.ns(cfg.className, false, Neo.overwrites),
            cls, item;

        if (overwrites) {
            // Apply all methods
            for (item in overwrites) {
                if (Neo.isFunction(overwrites[item])) {
                    // Already existing ones
                    cls = this.prototype;

                    if (cls[item]) {
                        // add to overwrittenMethods
                        cls.constructor.overwrittenMethods[item] = cls[item]
                    }
                }
            }

            // Apply configs to prototype
            Object.assign(cfg, overwrites)
        }
    }

    /**
     * Convenience method for beforeSet functions which test if a given value is inside a static array
     * @param {String|Number} value
     * @param {String|Number} oldValue
     * @param {String} name config name
     * @param {Array|String} [staticName=name + 's'] name of the static config array
     * @returns {String|Number} value or oldValue
     */
    beforeSetEnumValue(value, oldValue, name, staticName = name + 's') {
        let values = Array.isArray(staticName) ? staticName : this.getStaticConfig(staticName);

        if (!values.includes(value)) {
            console.error(`Supported values for ${name} are:`, ...values, this);
            return oldValue
        }

        return value
    }

    /**
     * From within an overwrite, a method can call a parent method, by using callOverwritten.
     *
     * @example
     *    afterSetHeight(value, oldValue) {
     *        // do the standard
     *        this.callOverwritten(...arguments);
     *        // do you own stuff
     *    }
     *
     * We create an error to get the caller.name and then run that method on the constructor.
     * This is based on the following error structure, e.g. afterSetHeight.
     *
     *     Error
     *         at Base.callOverwritten (Base.mjs:176:21)
     *         at Base.afterSetHeight (Overrides.mjs:19:26)
     *
     * @param args
     */
    callOverwritten(...args) {
        let stack      = new Error().stack,
            regex      = Base.methodNameRegex,
            methodName = stack.match(regex)[1];

        this.__proto__.constructor.overwrittenMethods[methodName].call(this, ...args)
    }

    /**
     * Uses the IdGenerator to create an id if a static one is not explicitly set.
     * Registers the instance to manager.Instance if this one is already created,
     * otherwise stores it inside a tmp map.
     * @param {String} id
     */
    createId(id) {
        this.id = id || _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getId(this.getIdKey())
    }

    /**
     * Unregisters this instance from Neo.manager.Instance
     * and removes all object entries from this instance
     */
    destroy() {
        let me = this;

        me.#timeoutIds.forEach(id => {
            clearTimeout(id)
        });

        if (Base.instanceManagerAvailable === true) {
            Neo.manager.Instance.unregister(me)
        } else if (Neo.idMap) {
            delete Neo.idMap[me.id]
        }

        Object.keys(me).forEach(key => {
            if (Object.getOwnPropertyDescriptor(me, key).writable) {
                // We must not delete the custom destroy() interceptor
                if (key !== 'destroy' && key !== '_id') {
                    delete me[key]
                }
            }
        });

        // We do want to prevent delayed event calls after an observable instance got destroyed.
        if (Neo.isFunction(me.fire)) {
            me.fire = Neo.emptyFn
        }

        me.isDestroyed = true
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * Override this method as needed.
     * @returns {String}
     */
    getIdKey() {
        return this.ntype
    }

    /**
     * Returns the value of a static config key or the staticConfig object itself in case no value is set
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @returns {*}
     */
    getStaticConfig(key) {
        return this.constructor[key]
    }

    /**
     * Check if a given ntype exists inside the proto chain, including the top level class
     * @param {String} ntype
     * @returns {Boolean}
     */
    hasNtype(ntype) {
        return this.constructor.ntypeChain.includes(ntype)
    }

    /**
     * Gets triggered after onConstructed() is done
     * @see {@link Neo.core.Base#onConstructed onConstructed}
     * @tutorial 02_ClassSystem
     */
    init() {}

    /**
     * Applies all class configs to this instance
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @protected
     */
    initConfig(config, preventOriginalConfig) {
        let me = this;

        me.isConfiguring = true;
        Object.assign(me[configSymbol], me.mergeConfig(config, preventOriginalConfig));
        me.processConfigs()
        me.isConfiguring = false;
    }

    /**
     * Does get triggered with a delay to ensure that Neo.workerId & Neo.worker.Manager are defined
     * Remote method access via promises
     * @protected
     */
    initRemote() {
        let me                  = this,
            {className, remote} = me,
            {currentWorker}     = Neo;

        if (!me.singleton && !me.isMainThreadAddon) {
            throw new Error('Remote method access is only functional for Singleton classes ' + className)
        }

        if (!Neo.config.unitTestMode && Neo.isObject(remote)) {
            if (Neo.workerId !== 'main' && currentWorker.isSharedWorker && !currentWorker.isConnected) {
                currentWorker.on('connected', () => {
                    Base.sendRemotes(className, remote)
                }, me, {once: true})
            } else {
                Base.sendRemotes(className, remote)
            }
        }
    }

    /**
     * Intercepts destroy() calls to ensure they will only get called once
     * @returns {Boolean}
     */
    isDestroyedCheck() {
        return !this.isDestroyed
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     * @protected
     */
    mergeConfig(config, preventOriginalConfig) {
        let me   = this,
            ctor = me.constructor;

        if (!ctor.config) {
            throw new Error('Neo.applyClassConfig has not been run on ' + me.className)
        }

        if (!preventOriginalConfig) {
            me.originalConfig = Neo.clone(config, true, true)
        }

        return {...ctor.config, ...config}
    }

    /**
     *
     */
    onAfterConstructed() {
        let me = this;

        me.isConstructed = true;

        // We can only fire the event in case the Observable mixin is included.
        me.getStaticConfig('observable') && me.fire('constructed', me)
    }

    /**
     * Gets triggered after all constructors are done
     * @tutorial 02_ClassSystem
     */
    onConstructed() {}

    /**
     * Helper method to replace string based values containing "@config:" with the matching config value
     * of this instance.
     * @param {Object|Object[]} items
     */
    parseItemConfigs(items) {
        let me = this,
            ns, nsArray, nsKey, symbolNs;

        if (items) {
            if (!Array.isArray(items)) {
                items = [items]
            }

            items.forEach(item => {
                item && Object.entries(item).forEach(([key, value]) => {
                    if (Array.isArray(value)) {
                        me.parseItemConfigs(value);
                    } else if (typeof value === 'string' && value.startsWith('@config:')) {
                        nsArray = value.substring(8).trim().split('.');
                        nsKey   = nsArray.pop();
                        ns      = Neo.ns(nsArray, false, me);

                        if (ns[nsKey] === undefined) {
                            console.error('The used @config does not exist:', nsKey, nsArray.join('.'))
                        } else {
                            symbolNs = Neo.ns(nsArray, false, me[configSymbol]);

                            // The config might not be processed yet, especially for configs
                            // not ending with an underscore, so we need to check the configSymbol first.
                            if (symbolNs && Object.hasOwn(symbolNs, nsKey)) {
                                item[key] = symbolNs[nsKey]
                            } else {
                                item[key] = ns[nsKey]
                            }
                        }
                    }
                })
            })
        }
    }

    /**
     * When using set(), configs without a trailing underscore can already be assigned,
     * so the hasOwnProperty() check will return true
     * @param {Boolean} [forceAssign=false]
     * @protected
     */
    processConfigs(forceAssign=false) {
        let me   = this,
            keys = Object.keys(me[configSymbol]);

        me[forceAssignConfigs] = forceAssign;

        // We do not want to iterate over the keys, since 1 config can remove more than 1 key (beforeSetX, afterSetX)
        if (keys.length > 0) {
            // The hasOwnProperty check is intended for configs without a trailing underscore
            // => they could already have been assigned inside an afterSet-method
            if (forceAssign || !me.hasOwnProperty(keys[0])) {
                me[keys[0]] = me[configSymbol][keys[0]]
            }

            // there is a delete-call inside the config getter as well (Neo.mjs => autoGenerateGetSet())
            // we need to keep this one for configs, which do not use getters (no trailing underscore)
            delete me[configSymbol][keys[0]];

            me.processConfigs(forceAssign)
        }
    }

    /**
     * @param {String} className
     * @param {Object} remote
     * @protected
     */
    static sendRemotes(className, remote) {
        let origin;

        Object.entries(remote).forEach(([worker, methods]) => {
            if (Neo.workerId !== worker) {
                origin = Neo.workerId === 'main' ? Neo.worker.Manager : Neo.currentWorker;

                origin.sendMessage(worker, {
                    action: 'registerRemote',
                    className,
                    methods
                })
            }
        })
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     */
    set(values={}) {
        let me = this;

        values = me.setFields(values);

        // If the initial config processing is still running,
        // finish this one first before dropping new values into the configSymbol.
        // see: https://github.com/neomjs/neo/issues/2201
        if (me[forceAssignConfigs] !== true && Object.keys(me[configSymbol]).length > 0) {
            me.processConfigs()
        }

        Object.assign(me[configSymbol], values);

        me.processConfigs(true)
    }

    /**
     * We want to assign class fields first and remove them from the config object,
     * so that afterSet(), beforeGet() and beforeSet() methods can get the new values right away
     * @param {Object} config
     * @returns {Object}
     * @protected
     */
    setFields(config) {
        let me          = this,
            configNames = me.constructor.config;

        Object.entries(config).forEach(([key, value]) => {
            if (!configNames.hasOwnProperty(key) && !Neo.hasPropertySetter(me, key)) {
                me[key] = value;
                delete config[key]
            }
        })

        return config
    }

    /**
     * Sets the value of a static config by a given key
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @param {*} value
     * @returns {Boolean} true in case the config exists and got changed
     */
    setStaticConfig(key, value) {
        let staticConfig = this.constructor.staticConfig;

        if (staticConfig.hasOwnProperty(key)) {
            staticConfig[key] = value;
            return true
        }

        return false
    }

    /**
     * Stores timeoutIds internally, so that destroy() can clear them if needed
     * @param {Number} time in milliseconds
     * @returns {Promise<any>}
     */
    timeout(time) {
        return new Promise(resolve => {
            let timeoutIds = this.#timeoutIds,
                timeoutId  = setTimeout(() => {timeoutIds.splice(timeoutIds.indexOf(timeoutId, 1)); resolve()}, time);

            timeoutIds.push(timeoutId)
        })
    }

    /**
     * <p>Enhancing the toString() method, e.g.</p>
     * `Neo.create('Neo.button.Base').toString() => "[object Neo.button.Base (neo-button-1)]"`
     * @returns {String}
     */
    get [Symbol.toStringTag]() {
        return `${this.className} (id: ${this.id})`
    }

    /**
     * <p>Enhancing the instanceof method. Without this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => true`
     * <p>With this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => false`<br>
     * `Neo.create(Neo.collection.Base) instanceof Neo.core.Base => true`
     * @returns {Boolean}
     */
    static [Symbol.hasInstance](instance) {
        if (!instance) {
            return false
        }

        return instance[isInstance] === true ? super[Symbol.hasInstance](instance) : false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/core/Compare.mjs":
/*!******************************!*\
  !*** ./src/core/Compare.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.core.Compare
 * @extends Neo.core.Base
 */
class Compare extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.core.Compare'
         * @protected
         */
        className: 'Neo.core.Compare'
    }

    /**
     * @param {*} item1
     * @param {*} item2
     * @returns {Boolean}
     */
    static isEqual(item1, item2) {
        if (item1 === item2) {
            return true;
        }

        let type1 = Neo.typeOf(item1),
            type2 = Neo.typeOf(item2),
            key;

        if (type1 !== type2) {
            return false;
        }

        switch (type1) {
            case 'Array': {
                if (item1.length !== item2.length) {
                    return false;
                }

                for (const [i, v] of item1.entries()) {
                    if (!Compare.isEqual(v, item2[i])) {
                        return false;
                    }
                }

                break;
            }

            case 'Date': {
                return item1.valueOf() === item2.valueOf();
            }

            case 'Function': {
                if (item1.name !== item2.name) {
                    return false;
                }

                return item1.toString() === item2.toString();
            }

            case 'Map': {
                if (item1.size !== item2.size) {
                    return false;
                }

                let val2;

                for (const [key, val] of item1) {
                    val2 = item2.get(key);

                    if (val2 !== val || val2 === undefined && !item2.has(key)) {
                        return false;
                    }
                }

                break;
            }

            case 'NeoInstance': {
                if (item1.id !== item2.id) {
                    return false;
                }

                break;
            }

            case 'Object': {
                if (Object.keys(item1).length !== Object.keys(item2).length) {
                    return false;
                }

                for (key in item1) {
                    if (!Compare.isEqual(item1[key], item2[key])) {
                        return false;
                    }
                }

                break;
            }

            case 'RegExp': {
                if (item1.toString() !== item2.toString()) {
                    return false;
                }

                break;
            }

            case 'Set': {
                if (item1.size !== item2.size) {
                    return false;
                }

                for (key of item1) {
                    if (!item2.has(key)) {
                        return false;
                    }
                }

                break;
            }

            default: {
                return item1 === item2;
            }
        }

        return true;
    }
}

Compare = Neo.setupClass(Compare);

// alias
Neo.isEqual = Compare.isEqual;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Compare);


/***/ }),

/***/ "./src/core/IdGenerator.mjs":
/*!**********************************!*\
  !*** ./src/core/IdGenerator.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This class gets used by core.Base, so it can not extend it.
 * It could get simplified to just being an object (needs to manually get put into the Neo namespace in this case).
 * @class Neo.core.IdGenerator
 * @singleton
 */
class IdGenerator {
    /**
     * Set this one to false in case you don't want to stick
     * to the "anti-pattern" to apply classes to the global Neo or App namespace
     * @member {Boolean} registerToGlobalNs=true
     * @protected
     * @static
     */
    static registerToGlobalNs = true

    static config = {
        /**
         * @member {String} className='Neo.core.IdGenerator'
         * @protected
         */
        className: 'Neo.core.IdGenerator',
        /**
         * @member {String} ntype='id-generator'
         * @protected
         */
        ntype: 'id-generator',
        /**
         * The default prefix for neo instance ids
         * @member {String} base='neo-'
         */
        base: 'neo-',
        /**
         * @member {Boolean} singleton='true
         * @protected
         */
        singleton: true
    }

    /**
     * @param config
     */
    construct(config) {
        let me = this;

        me.idCounter = {};

        // alias
        Neo.getId = me.getId.bind(me);
    }

    /**
     * @param name
     * @returns {string}
     */
    getId(name) {
        name = name || 'neo';

        let me      = this,
            counter = me.idCounter,
            count   = counter[name] || 0;

        counter[name] = ++count;

        return me.base + (name === 'neo' ? '' : name + '-') + count;
    }

    init() {}

    onAfterConstructed() {}

    onConstructed() {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(IdGenerator));


/***/ }),

/***/ "./src/core/Observable.mjs":
/*!*********************************!*\
  !*** ./src/core/Observable.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.core.Observable
 * @extends Neo.core.Base
 */
class Observable extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.core.Observable'
         * @protected
         */
        className: 'Neo.core.Observable',
        /**
         * @member {String} ntype='mixin-observable'
         * @protected
         */
        ntype: 'mixin-observable',
        /**
         * @member {Boolean} mixin=true
         * @protected
         */
        mixin: true
    }

    /**
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number|String} [order]
     * @returns {String|null} eventId null in case an object gets passed as the name (multiple ids)
     */
    addListener(name, opts, scope, eventId, data, order) {
        let me            = this,
            delay         = 0,
            eventIdObject = typeof eventId === 'object',
            nameObject    = typeof name    === 'object',
            once          = false,
            optsType      = typeof opts,
            listener, existing, eventConfig;

        /*
         * let us support the following format too:
         *
         * currentWorker.on('connected', () => {
         *     Base.sendRemotes(className, remote)
         * }, me, {once: true})
         */
        if (eventIdObject && optsType === 'function') {
            eventId.fn = opts;
            opts     = eventId;
            optsType = 'object';
            eventId  = null;
        }

        if (nameObject) {
            if (name.hasOwnProperty('delay')) {
                delay = name.delay;
                delete name.delay
            }

            if (name.hasOwnProperty('once')) {
                once = name.once;
                delete name.once
            }

            if (name.hasOwnProperty('scope')) {
                scope = name.scope;
                delete name.scope
            }

            Object.entries(name).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    me.addListener(key, {delay, once, scope, ...value})
                } else {
                    me.addListener(key, {delay, fn: value, once, scope})
                }
            })
        } else if (optsType === 'object') {
            delay    = delay   || opts.delay;
            eventId  = eventId || opts.eventId;
            listener = opts.fn;
            once     = once    || opts.once;
            order    = order   || opts.order;
            scope    = scope   || opts.scope
        } else if (optsType === 'function') {
            listener = opts
        } else if (optsType === 'string') {
            listener = opts // VC hook, can get parsed after onConstructed in case the view uses the parent VC
        } else {
            throw new Error('Invalid addListener call: ' + name)
        }

        if (!nameObject) {
            eventConfig = {
                data,
                delay,
                fn: listener,
                id: eventId || Neo.getId('event'),
                once,
                scope
            };

            if (existing = me.listeners?.[name]) {
                existing.forEach(cfg => {
                    if (cfg.id === eventId || (cfg.fn === listener && cfg.scope === scope)) {
                        console.error('Duplicate event handler attached:', name, me)
                    }
                });

                if (typeof order === 'number') {
                    existing.splice(order, 0, eventConfig)
                } else if (order === 'before') {
                    existing.unshift(eventConfig)
                } else {
                    existing.push(eventConfig)
                }
            } else {
                me.listeners[name] = [eventConfig]
            }

            return eventConfig.id
        }

        return null
    }

    /**
     * Call the passed function, or a function by *name* which exists in the passed scope's
     * or this component's ownership chain.
     * @param {Function|String} fn A function, or the name of a function to find in the passed scope object/
     * @param {Object} scope The scope to find the function in if it is specified as a string.
     * @param {Array} args Arguments to pass to the callback.
     */
    callback(fn, scope=this, args) {
        if (fn) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(fn, scope);
            handler.fn.apply(handler.scope, args)
        }
    }

    /**
     * Internal helper method for events which use the delay option
     * @param {Object} cb
     * @param {Array} args
     * @param {Number} delay
     */
    delayedCallback(cb, args, delay) {
        this.timeout(delay).then(() => {
            cb.fn.apply(cb.scope, args)
        })
    }

    /**
     * @param name
     */
    fire(name) {
        let me        = this,
            args      = [].slice.call(arguments, 1),
            listeners = me.listeners,
            delay, handler, handlers, i, len;

        if (listeners && listeners[name]) {
            handlers = [...listeners[name]];
            len      = handlers.length;

            for (i = 0; i < len; i++) {
                handler = handlers[i];
                delay   = handler.delay;

                // Resolve function name on the scope (or me), or, if it starts with 'up.'
                // look in the ownership hierarchy from me.
                const cb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handler.fn, handler.scope || me);

                // remove the listener if the scope no longer exists
                if (cb.scope && !cb.scope.id) {
                    listeners[name].splice(i, 1)
                } else {
                    if (!me.suspendEvents) {
                        // Object event format. Inject firer reference in as 'source'
                        if (args.length === 1 && Neo.isObject(args[0])) {
                            args[0].source = me.id
                        }

                        // remove the listener if it has the once flag
                        handler.once && listeners[name].splice(i, 1)

                        if (Neo.isNumber(delay) && delay > 0) {
                            me.delayedCallback(cb, handler.data ? args.concat(handler.data) : args, delay)
                        } else {
                            cb.fn.apply(cb.scope, handler.data ? args.concat(handler.data) : args)
                        }
                    }
                }
            }
        }
    }

    /**
     * @param {Object} config
     */
    initObservable(config) {
        let me = this,
            proto = me.__proto__,
            ctor  = proto.constructor,
            listeners;

        if (config.listeners) {
            me.listeners = config.listeners;
            delete config.listeners
        }

        listeners = me.listeners;

        me.listeners = {};

        if (listeners) {
            if (Neo.isObject(listeners)) {
                listeners = {...listeners}
            }

            me.addListener(listeners);
        }

        while (proto?.constructor.isClass) {
            ctor = proto.constructor;

            if (ctor.observable && !ctor.listeners) {
                Object.assign(ctor, {
                    addListener   : me.addListener,
                    fire          : me.fire,
                    listeners     : {},
                    on            : me.on,
                    removeListener: me.removeListener,
                    un            : me.un
                })
            }

            proto = proto.__proto__
        }
    }

    /**
     * Alias for addListener
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number} [order]
     * @returns {String} eventId
     */
    on(...args) {
        return this.addListener(...args)
    }

    /**
     * There are different syntax's how you can use this method.
     * Using the eventId:
     * ```
     * this.removeListener('change', 'neo-event-7');
     * ```
     * Passing the handler method:
     * ```
     * this.removeListener('change', this.onChange, this);
     * ```
     * Passing an object:
     * ```
     * me.field.un({
     *     change                    : me.onFieldChange,
     *     changeClearToOriginalValue: me.onFieldChange,
     *     scope                     : me
     * });
     * ```
     * @param {Object|String} name
     * @param {Function|String} [eventId]
     * @param {Neo.core.Base} [scope]
     */
    removeListener(name, eventId, scope) {
        let me = this,
            i, len, listener, listeners, match;

        if (Neo.isFunction(eventId)) {
            me.removeListener({[name]: eventId, scope});
            return
        }

        if (Neo.isObject(name)) {
            if (name.scope) {
                scope = name.scope;
                delete name.scope;
            }

            Object.entries(name).forEach(([key, value]) => {
                listeners = me.listeners[key] || [];
                i         = 0;
                len       = listeners.length;

                for (; i < len; i++) {
                    listener = listeners[i];

                    if (
                        listener.fn.name === (Neo.isString(value) ? value : value.name) &&
                        listener.scope   === scope
                    ) {
                        listeners.splice(i, 1);
                        break
                    }
                }
            });
        } else if (Neo.isString(eventId)) {
            listeners = me.listeners[name];
            match     = false;

            listeners.forEach((eventConfig, idx) => {
                if (eventConfig.id === eventId) {
                    return match = idx
                }
            });

            if (match !== false) {
                listeners.splice(match, 1)
            }
        }
    }

    // removeAllListeners: function(name) {

    // },

    // suspendListeners: function(queue) {

    // },

    // resumeListeners: function() {

    // }

    /**
     * Alias for removeListener
     * @param {Object|String} name
     * @param {String} [eventId]
     */
    un(...args) {
        this.removeListener(...args);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Observable));


/***/ }),

/***/ "./src/core/Util.mjs":
/*!***************************!*\
  !*** ./src/core/Util.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.core.Util
 * @extends Neo.core.Base
 */
class Util extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * A regex to remove camel case syntax
     * @member {RegExp} decamelRegEx=/([a-z])([A-Z])/g
     * @protected
     * @static
     */
    static decamelRegEx = /([a-z])([A-Z])/g

    static config = {
        /**
         * @member {String} className='Neo.core.Util'
         * @protected
         */
        className: 'Neo.core.Util',
        /**
         * @member {String} ntype='core-util'
         * @protected
         */
        ntype: 'core-util'
    }

    /**
     * @param {Object} scope
     * @param {String[]} values
     */
    static bindMethods(scope, values) {
        values.forEach(value => {
            scope[value] = scope[value].bind(scope)
        })
    }

    /**
     * Transforms a styles string into a styles object using camelcase syntax
     * @param {String} string The styles string to parse
     * @returns {Object} The camelcase styles object
     */
    static createStyleObject(string) {
        let parts;

        // split(';') does fetch semicolons inside brackets
        // -> background-image: "url('data:image/png;base64,...

        // TODO: Cache all regex
        return string.split(/;(?=[^\)]*(?:\(|$))/g).reduce((obj, el) => {
            // we have to split by the first colon only
            // -> background-image: url('http://example.com/image.png')
            parts = el.split((/:(.+)/)).map(function (x) {
                let num = parseFloat(x);

                return x == num ? num : x.trim()
            });

            if (parts[0] !== '') {
                parts[0] = parts[0].replace(/-([a-z])/g, (str, letter) => {
                    return letter.toUpperCase()
                });

                obj[parts[0]] = parts[1]
            }
            return obj
        }, {})
    }

    /**
     * Converts a styles object which can use camelcase syntax into a styles string
     * @param {Object} styles The styles object
     * @returns {String} The styles string (DOM ready)
     */
    static createStyles(styles) {
        let style = '';

        Object.entries(styles).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
                style += Util.decamel(key) + ':' + value + ';'
            }
        });

        return style
    }

    /**
     * Transforms all uppercase characters of a string into -lowercase.
     * Does not touch special characters.
     * @param {String} value The input containing uppercase characters
     * @returns {String} The lowercase output
     */
    static decamel(value) {
        return value.replace(Util.decamelRegEx, '$1-$2').toLowerCase()
    }

    /**
     * Returns true if the passed value is an array
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isArray(value) {
        return Array.isArray(value)
    }

    /**
     * Returns true if the passed value is a boolean
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isBoolean(value) {
        return typeof value === 'boolean'
    }

    /**
     * Returns true if the passed value is not undefined
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isDefined(value) {
        return typeof value !== 'undefined'
    }

    /**
     * Returns true if the passed value is an empty Array, Object or String
     * @param {Array|Object|String} value The value to test
     * @returns {Boolean}
     */
    static isEmpty(value) {
        if (value === null || value === undefined) {
            return true
        }

        if (Array.isArray(value)) {
            return value.length === 0
        }

        if (value instanceof Date) {
            return false
        }

        if (Util.isObject(value)) {
            return Object.keys(value).length === 0
        }

        if (Util.isString(value)) {
            return value === ''
        }

        return false
    }

    /**
     * Returns true if the passed value is a function
     * @param {Function} value The value to test
     * @returns {Boolean}
     */
    static isFunction(value) {
        return typeof value === 'function'
    }

    /**
     * Returns true if the passed value is a number. Returns false for non-finite numbers
     * @param {Number} value The value to test
     * @returns {Boolean}
     */
    static isNumber(value){
        return typeof value === 'number' && isFinite(value)
    }

    /**
     * Returns true if the passed value is an object
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isObject(value) {
        return value?.constructor?.name === 'Object' || false
    }

    /**
     * Returns true if the passed value is a neo data record
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isRecord(value) {
        return value?.constructor?.name === 'Record' || false
    }

    /**
     * Returns true if the passed value is a string
     * @param {String} value The value to test
     * @returns {Boolean}
     */
    static isString(value) {
        return typeof value === 'string'
    }

    /**
     * Converts any iterable (strings, numeric indices and a length property) into a true array
     * @param {Object|String} iterable
     * @param {Number} [start=0] start index
     * @param {Number} [end=iterable.length] end index
     * @returns {Array}
     */
    static toArray(iterable, start, end) {
        let len;

        if (!iterable || !(len = iterable.length)) {
            return []
        }

        if (typeof iterable === 'string') {
            return iterable.split('')
        }

        return Array.prototype.slice.call(iterable, start || 0, end || len)
    }
}

Util = Neo.setupClass(Util);

// aliases
Neo.applyFromNs(Neo, Util, {
    bindMethods      : 'bindMethods',
    createStyleObject: 'createStyleObject',
    createStyles     : 'createStyles',
    decamel          : 'decamel',
    isArray          : 'isArray',
    isBoolean        : 'isBoolean',
    isDefined        : 'isDefined',
    isEmpty          : 'isEmpty',
    isFunction       : 'isFunction',
    isNumber         : 'isNumber',
    isObject         : 'isObject',
    isRecord         : 'isRecord',
    isString         : 'isString',
    toArray          : 'toArray'
}, true);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Util);


/***/ }),

/***/ "./src/core/_export.mjs":
/*!******************************!*\
  !*** ./src/core/_export.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* reexport safe */ _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Compare: () => (/* reexport safe */ _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   IdGenerator: () => (/* reexport safe */ _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Observable: () => (/* reexport safe */ _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Util: () => (/* reexport safe */ _Util_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Compare.mjs */ "./src/core/Compare.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");
/* harmony import */ var _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Util_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Util.mjs */ "./src/core/Util.mjs");









/***/ }),

/***/ "./src/manager/Base.mjs":
/*!******************************!*\
  !*** ./src/manager/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");


/**
 * Abstract base class for the other manager classes
 * @class Neo.manager.Base
 * @extends Neo.collection.Base
 */
class Base extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]{
    static config = {
        /**
         * @member {String} className='Neo.manager.Base'
         * @protected
         */
        className: 'Neo.manager.Base'
    }

    /**
     * @param {Number|String} id
     * @returns {Object}
     */
    getById(id) {
        return id && this.get(id) || null
    }

    /**
     * @param {Object} item
     */
    register(item) {
        let me = this;

        if (me.get(item.id)) {
            Neo.logError('Trying to create an item with an already existing id', item, me.get(item.id))
        } else {
            me.push(item)
        }
    }

    /**
     * Removes a collection item passed by reference or key
     * @param {Object|String} item
     */
    unregister(item) {
        this.remove(item)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/manager/Component.mjs":
/*!***********************************!*\
  !*** ./src/manager/Component.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");



/**
 * @class Neo.manager.Component
 * @extends Neo.manager.Base
 * @singleton
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Component'
         * @protected
         */
        className: 'Neo.manager.Component',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.first        = me.getFirst.bind(me); // alias
        Neo.getComponent = me.getById.bind(me)   // alias
    }

    /**
     * Returns the first component which matches the config-selector moving down the component items tree.
     * Use returnFirstMatch=false to get an array of all matching items instead.
     * If no match is found, returns null in case returnFirstMatch === true, otherwise an empty Array.
     * @param {Neo.component.Base|String} component
     * @param {Object|String|null} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|Neo.component.Base[]|null}
     */
    down(component, config, returnFirstMatch=true) {
        if (Neo.isString(component)) {
            component = this.getById(component);
        }

        let me          = this,
            matchArray  = [],
            returnValue = null,
            i           = 0,
            returnArray = [],
            childItems, configArray, configLength, len;

        if (Neo.isString(config)) {
            config = {
                ntype: config
            }
        } else if (!config) {
            config = {}
        }

        configArray  = Object.entries(config);
        configLength = configArray.length;

        configArray.forEach(([key, value]) => {
            if ((component[key] === value)
                || (key === 'ntype' && me.hasPrototypePropertyValue(component, key, value)))
            {
                matchArray.push(true)
            }
        });

        if (matchArray.length === configLength) {
            if (returnFirstMatch) {
                return component
            }

            returnArray.push(component)
        }

        childItems = me.find({parentId: component.id});
        len        = childItems.length;

        for (; i < len; i++) {
            returnValue = me.down(childItems[i], config, returnFirstMatch);

            if (returnFirstMatch) {
                if (returnValue !== null) {
                    return returnValue
                }
            } else if (returnValue.length > 0) {
                returnArray.push(...returnValue)
            }
        }

        return returnFirstMatch ? null: returnArray
    }

    /**
     * @param {Array} path
     * @returns {String|null} the component id in case there is a match
     */
    findParentComponent(path) {
        let me  = this,
            i   = 0,
            len = path?.length || 0,
            id;

        for (; i < len; i++) {
            id = path[i];

            if (id && me.has(id)) {
                return id
            }
        }

        return null
    }

    /**
     * Returns all child components which are recursively matched via their parentId
     * @param {Neo.component.Base} component
     * @returns {Neo.component.Base[]} childComponents
     */
    getChildComponents(component) {
        let me             = this,
            directChildren = me.find('parentId', component.id) || [],
            components     = [],
            childComponents;

        directChildren.forEach(item => {
            components.push(item);

            childComponents = me.getChildComponents(item);

            childComponents && components.push(...childComponents)
        });

        return components
    }

    /**
     * todo: replace all calls of this method to calls using the util.VNode class
     * Get the ids of all child nodes of the given vnode
     * @param vnode
     * @param childIds
     * @returns {Array} childIds
     */
    getChildIds(vnode, childIds) {
        return _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildIds(vnode, childIds)
    }

    /**
     * Returns all child components found inside the vnode tree
     * @param {Neo.component.Base} component
     * @returns {Neo.component.Base[]} childComponents
     */
    getChildren(component) {
        let childComponents = [],
            childNodes      = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildIds(component.vnode),
            childComponent;

        childNodes.forEach(node => {
            childComponent = this.get(node);

            if (childComponent) {
                childComponents.push(childComponent)
            }
        });

        return childComponents
    }

    /**
     * !! For debugging purposes only !!
     *
     * Get the first component based on the ntype or other properties
     *
     * @param {String|Object|Array} componentDescription
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null|Neo.component.Base[]}
     *
     * @example
            // as String: ntype[comma separated propterties]
            Neo.first('toolbar button[text=Try me,icon=people]')
            // as Object: Add properties. ntype is optional
            Neo.first({
                icon: 'people'
            })
            // as Array: An Array of Objects. No Strings allowed
            Neo.first([{
                ntype: 'toolbar'
            },{
                ntype: 'button', text: 'Try me', icon: 'people
            }])

     * The returnFirstMatch flag allows to return all items and
     * not stop after the first result.
     *
     * @example
            Neo.first('button', false) // => [Button, Button, Button]
     */
    getFirst(componentDescription, returnFirstMatch = true) {
        let objects = [],
            app     = Neo.apps[Object.keys(Neo.apps)[0]],
            root    = app.mainView;

        /* create an array of objects from string */
        if (Neo.isString(componentDescription)) {
            const regex = /(\w*)(\[[^\]]*\])|(\w*)/g;
            let match;

            /* generate objects which contain the information */
            while (match = regex.exec(componentDescription)) {
                let [, ntype, pairs, ntypeOnly] = match, obj;

                ntype = ntype || ntypeOnly;
                obj = {ntype};

                if (pairs) {
                    const pairsRegex = /\[(.*?)\]/,
                        pairsMatch = pairs.match(pairsRegex);

                    if (pairsMatch) {
                        const pairs = pairsMatch[1].split(',');
                        pairs.forEach((pair) => {
                            const [key, value] = pair.split('=');
                            obj[key] = value.replace(/"/g, '')
                        });
                    }
                }
                objects.push(obj);

                regex.lastIndex++
            }
        } else if (Neo.isObject(componentDescription)){
            objects.push(componentDescription)
        } else if (Neo.isArray(componentDescription)) {
            objects = componentDescription
        }

        /* find the correct child using down() */
        const result = objects.reduce((acc, key) => {
            if (acc) {
                let child = acc.down(key, returnFirstMatch);

                if (!!child) {
                    return child
                }
            }

            return null
        }, root);

        return result
    }

    /**
     * Returns an Array containing the ids of all parent components for a given component
     * @param {Neo.component.Base} component
     * @returns {String[]} parentIds
     */
    getParentIds(component) {
        let parentIds = [];

        while (component?.parentId) {
            component = this.getById(component.parentId);

            if (component) {
                parentIds.push(component.id)
            }
        }

        return parentIds
    }

    /**
     * @param {Array} path
     * @returns {Array}
     */
    getParentPath(path) {
        let me            = this,
            componentPath = [],
            i             = 0,
            len           = path?.length || 0;

        for (; i < len; i++) {
            if (me.has(path[i])) {
                componentPath.push(path[i])
            }
        }

        return componentPath
    }

    /**
     * Returns an Array containing all parent components for a given component or component id
     * @param {Neo.component.Base|String} component
     * @returns {Neo.component.Base[]} parents
     */
    getParents(component) {
        if (Neo.isString(component)) {
            component = this.getById(component)
        }

        let parents = [];

        while (component?.parentId) {
            component = this.getById(component.parentId);

            if (component) {
                parents.push(component)
            }
        }

        return parents
    }

    /**
     * Check if the component had a property of any value somewhere in the Prototype chain
     *
     * @param {Neo.component.Base} component
     * @param {String} property
     * @param {*} value
     * @returns {boolean}
     */
    hasPrototypePropertyValue(component, property, value) {
        while (component !== null) {
            if (component.hasOwnProperty(property) && component[property] === value) {
                return true
            }

            component = component.__proto__
        }

        return false
    }

    /**
     * Returns the first component which matches the config-selector.
     * Use returnFirstMatch=false to get an array of all matching items instead.
     * If no match is found, returns null in case returnFirstMatch === true, otherwise an empty Array.
     * @param {String} componentId
     * @param {Object|String|null} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|Neo.component.Base[]|null}
     */
    up(componentId, config, returnFirstMatch=true) {
        let component   = this.getById(componentId),
            returnArray = [],
            configArray, configLength, matchArray;

        if (Neo.isString(config)) {
            config = {
                ntype: config
            }
        } else if (!config) {
            config = {}
        }

        configArray  = Object.entries(config);
        configLength = configArray.length;

        while (component?.parentId) {
            component = this.getById(component.parentId);

            if (!component) {
                return returnFirstMatch ? null : returnArray
            }

            matchArray = [];

            configArray.forEach(([key, value]) => {
                if (component[key] === value) {
                    matchArray.push(true)
                }
            });

            if (matchArray.length === configLength) {
                if (returnFirstMatch) {
                    return component
                }

                returnArray.push(component)
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/manager/DomEvent.mjs":
/*!**********************************!*\
  !*** ./src/manager/DomEvent.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _Focus_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Focus.mjs */ "./src/manager/Focus.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");








const eventConfigKeys = [
    'bubble',
    'delegate',
    'local',
    'scope',
    'vnodeId'
];

const globalDomEvents = [
    'change',
    'click',
    'contextmenu',
    'dblclick',
    'drag:end',
    'drag:move',
    'drag:start',
    'focusin',
    'focusout',
    'input',
    'intersect',
    'keydown',
    'keyup',
    'mousedown',
    'mouseenter',
    'mouseleave',
    'mouseup',
    'neonavigate',
    'scroll',
    'selectionchange',
    'touchmove',
    'wheel'
];

/**
 * @class Neo.manager.DomEvent
 * @extends Neo.core.Base
 * @singleton
 */
class DomEvent extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.DomEvent'
         * @protected
         */
        className: 'Neo.manager.DomEvent',
        /**
         * @member {Object} items={}
         * @protected
         */
        items: {},
        /**
         * @member {Object} map={}
         * @protected
         */
        map: {},
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     *
     * @param {Neo.component.Base} component
     * @param {data} event
     */
    addResizeObserver(component, event) {
        if (!Neo.main.addon.ResizeObserver) {
            console.error('For using resize domListeners, you must include main.addon.ResizeObserver.', event)
        }

        let {id, windowId} = component;

        Neo.main.addon.ResizeObserver.register({id, windowId})
    }

    /**
     * @param {Object} event
     * @protected
     */
    fire(event) {
        let me          = this,
            bubble      = true,
            data        = event.data || {},
            {eventName} = event,
            i           = 0,
            listeners   = null,
            pathIds     = data.path.map(e => e.id),
            path        = _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParentPath(pathIds),
            len         = path.length,
            component, delegationTargetId, id, preventFire;

        for (; i < len; i++) {
            id        = path[i];
            component = Neo.getComponent(id);

            if (!component || component.disabled) {
                break
            }

            listeners = me.items[id]?.[eventName];

            if (listeners) {
                // console.log('fire', eventName, data, listeners, path);

                if (Array.isArray(listeners)) {
                    // Stop iteration if a handler returns false
                    listeners.every(listener => {
                        let result;

                        if (listener && listener.fn) {
                            if (eventName === 'resize') {
                                // we do not want delegation for custom main.addon.ResizeObserver events
                                delegationTargetId = data.id === component.id ? data.id : false
                            } else {
                                delegationTargetId = me.verifyDelegationPath(listener, data.path)
                            }

                            if (delegationTargetId !== false) {
                                preventFire = false;

                                // we only want mouseenter & leave to fire on their top level nodes, not for children
                                if (eventName === 'mouseenter' || eventName === 'mouseleave') {
                                    preventFire = !DomEvent.verifyMouseEnterLeave(component, data, delegationTargetId, eventName)
                                }

                                if (!preventFire) {
                                    // multiple listeners would change the reference of data.component
                                    data = Neo.clone(data, true, true);

                                    data.component = component;

                                    // Handler needs to know which actual target matched the delegate
                                    data.currentTarget = delegationTargetId;

                                    result = listener.fn.apply(listener.scope || globalThis, [data]);

                                    if (!listener.bubble) {
                                        bubble = false
                                    }
                                }
                            }
                        }
                        // If a listener returns false, we stop iterating the listeners
                        return result !== false
                    })
                }
            }

            // we do want to trigger the FocusManager after normal domListeners on these events got executed
            if (eventName === 'focusin' || eventName === 'focusout') {
                _Focus_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]['on' + Neo.capitalize(eventName)]({
                    componentPath: path,
                    data
                });

                break
            }

            // Honor the Event cancelBubble property
            if (!bubble || data.cancelBubble) {
                break
            }
        }

        if (eventName.startsWith('drop')) {
            let dragZone = data.dragZoneId && Neo.get(data.dragZoneId);

            if (dragZone) {
                dragZone.fire(eventName, data);
                dragZone[{
                    'drop'      : 'onDrop',
                    'drop:enter': 'onDropEnter',
                    'drop:leave': 'onDropLeave',
                }[eventName]].call(dragZone, data)
            }
        }
    }

    /**
     * @param config
     * @param scope
     * @returns {Object}
     */
    generateListenerConfig(config, scope) {
        return {
            bubble   : config.bubble,
            delegate : config.delegate,
            eventName: config.eventName,
            id       : scope.id,
            opts     : config,
            priority : config.priority,
            scope    : config.scope   || scope,
            vnodeId  : config.vnodeId || scope.id
        };
    }

    getEventName(config) {
        let eventName = null;

        if (Neo.isObject(config)) {
            Object.keys(config).forEach(key => {
                if (!eventConfigKeys.includes(key)) {
                    eventName = key
                }
            })
        }

        return eventName
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.delegate
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Object} config.opts
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @returns {Object}
     */
    getListener(config) {
        let listeners = this.items,
            event;

        if (listeners?.[config.id]) {
            event = listeners[config.id][config.eventName];

            return event || null
        }
    }

    /**
     * Mounts local domEvent listeners for a given component
     * @param {Neo.component.Base} component
     * @protected
     */
    mountDomListeners(component) {
        let listeners   = this.items[component.id],
            localEvents = [];

        if (listeners) {
            Object.entries(listeners).forEach(([eventName, value]) => {
                value.forEach(event => {
                    eventName = event.eventName;

                    if (eventName === 'resize') {
                        this.addResizeObserver(component, event)
                    } else if (eventName && (event.local || !globalDomEvents.includes(eventName))) {
                        localEvents.push({
                            name   : eventName,
                            handler: 'domEventListener',
                            vnodeId: event.vnodeId
                        })
                    }
                })
            });

            if (localEvents.length > 0) {
                Neo.worker.App.promiseMessage('main', {
                    action  : 'addDomListener',
                    appName : component.appName,
                    events  : localEvents,
                    windowId: component.windowId
                }).then(data => {
                    // console.log('added domListener', data);
                }).catch(err => {
                    console.log('App: Got error attempting to add a domListener', err)
                })
            }
        }
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.delegate
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Boolean} config.local
     * @param {Number} config.opts
     * @param {Number} config.originalConfig
     * @param {String} config.ownerId
     * @param {Number} config.priority=1
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @returns {Boolean} true if the listener got registered successfully (false in case it was already there)
     */
    register(config) {
        let me                           = this,
            alreadyRegistered            = false,
            {eventName, id, opts, scope} = config,
            listeners                    = me.items,
            fnType                       = typeof opts,
            fn, listener, listenerConfig, listenerId;

        if (fnType === 'function') {
            fn = opts
        } else if (fnType === 'string') {
            fn = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_5__.resolveCallback)(opts, scope).fn
        } else {
            fn    = opts.fn;
            scope = opts.scope || scope
        }

        if (!listeners[id]) {
            listeners[id] = {}
        }

        if (listeners[id][eventName]) {
            listener = listeners[id][eventName];

            Object.keys(listener).forEach(key => {
                if (
                    listener[key].fn.toString() === fn.toString() && // todo: add a better check
                    listener[key].scope         === scope &&
                    listener[key].delegate      === config.delegate
                ) {
                    alreadyRegistered = true
                }
            })
        } else {
            listeners[id][eventName] = []
        }

        if (alreadyRegistered === true) {
            return false
        }

        // console.log('manager.DomEvent register', eventName, config);

        listenerId = Neo.getId('dom-event');

        config.listenerId = listenerId;

        listenerConfig = {
            bubble        : config.hasOwnProperty('bubble') ? config.bubble : opts.hasOwnProperty('bubble') ? opts.bubble : true,
            delegate      : config.delegate,
            eventName,
            fn,
            id            : listenerId,
            mounted       : !config.local && globalDomEvents.includes(eventName),
            originalConfig: config.originalConfig,
            ownerId       : config.ownerId,
            priority      : config.priority || opts.priority || 1,
            scope,
            vnodeId       : config.vnodeId
        };

        me.map[listenerId] = listenerConfig;

        listeners[id][eventName].push(listenerConfig);

        listeners[id][eventName].sort((a, b) => b.priority - a.priority);

        return true
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Object} config.opts
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @param {Object} scope
     * @returns {Boolean} true in case the listener did exist and got removed
     */
    unregister(config, scope) {
        // todo
        console.log('unregister', config);
        console.log(this.generateListenerConfig(config, scope));
        return;

        let listener = this.getListener(config);

        if (listener) {
            console.log('listener found', listener)
        }
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Object[]} domListeners
     * @param {Object[]} oldDomListeners
     */
    updateDomListeners(component, domListeners, oldDomListeners) {
        let me                  = this,
            registeredListeners = me.items[component.id] || {},
            i, len, listeners;

        if (Array.isArray(domListeners)) {
            if (Array.isArray(oldDomListeners)) {
                oldDomListeners.forEach(oldDomListener => {
                    // find & remove no longer existing listeners
                    if (!domListeners.includes(oldDomListener)) {
                        listeners = registeredListeners[me.getEventName(oldDomListener)] || [];
                        i         = 0;
                        len       = listeners.length;

                        for (; i < len; i++) {
                            if (listeners[i].originalConfig === oldDomListener) {
                                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(listeners, listeners[i]);
                                break
                            }
                        }
                    }
                })
            }

            // add new listeners
            domListeners.forEach(domListener => {
                Object.entries(domListener).forEach(([key, value]) => {
                    if (!eventConfigKeys.includes(key)) {
                        me.register({
                            bubble        : domListener.bubble   || value.bubble,
                            delegate      : domListener.delegate || value.delegate || '#' + component.id,
                            eventName     : key,
                            id            : component.id,
                            opts          : value,
                            originalConfig: domListener,
                            ownerId       : component.id,
                            priority      : domListener.priority || value.priority || 1,
                            scope         : domListener.scope    || component,
                            vnodeId       : domListener.vnodeId  || value.vnodeId  || component.id
                        })
                    }
                })
            });

            if (component.mounted && domListeners?.length > 0) {
                me.timeout(100).then(() => {
                    me.mountDomListeners(component)
                })
            }
        } else {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Component.domListeners have to be an array', component)
        }
    }

    /**
     * @param {Object} listener
     * @param {Array} path
     * @returns {Boolean|String} true in case the delegation string matches the event path
     */
    verifyDelegationPath(listener, path) {
        let {delegate} = listener,
            j          = 0,
            pathLen    = path.length,
            targetId;

        if (typeof delegate === 'function') {
            j = delegate(path);

            if (j != null) {
                targetId = path[j].id
            }
        }
        else {
            let delegationArray = delegate.split(' '),
                len             = delegationArray.length,
                hasMatch, i, item, isId;

            for (i=len-1; i >= 0; i--) {
                hasMatch = false;
                item     = delegationArray[i];
                isId     = item.startsWith('#');

                if (isId || item.startsWith('.')) {
                    item = item.substr(1)
                }

                for (; j < pathLen; j++) {
                    if (
                        (isId && path[j].id === item) ||
                        path[j].cls.includes(item)
                    ) {
                        hasMatch = true;
                        targetId = path[j].id;
                        break
                    }
                }

                if (!hasMatch) {
                    return false
                }
            }
        }

        // ensure the delegation path is a child of the owner components root node
        for (; j < pathLen; j++) {
            if (path[j].id === listener.vnodeId) {
                return targetId
            }
        }

        return false
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Object} data
     * @param {String} delegationTargetId
     * @param {String} eventName
     * @returns {Boolean}
     */
    static verifyMouseEnterLeave(component, data, delegationTargetId, eventName) {
        let targetId = eventName === 'mouseenter' ? data.fromElementId : data.toElementId,
            delegationVdom;

        if (targetId && targetId !== delegationTargetId) {
            delegationVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].findVdomChild(component.vdom, delegationTargetId);

            // delegationVdom can be undefined when dragging a proxy over the node.
            // see issues/1137 for details.
            if (!delegationVdom || delegationVdom.vdom && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].findVdomChild(delegationVdom.vdom, targetId)) {
                return false
            }
        }

        return true
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvent));


/***/ }),

/***/ "./src/manager/Focus.mjs":
/*!*******************************!*\
  !*** ./src/manager/Focus.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.manager.Focus
 * @extends Neo.core.Base
 * @singleton
 */
class Focus extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Focus'
         * @protected
         */
        className: 'Neo.manager.Focus',
        /**
         * An array containing opts objects.
         * opts.componentPath
         * opts.data
         * @member {Object[]} history=[]
         */
        history: [],
        /**
         * The Date object when the last focusin event has occurred
         * @member {Date|null} lastFocusInDate=null
         * @protected
         */
        lastFocusInDate: null,
        /**
         * The Date object when the last focusout event has occurred
         * @member {Date|null} lastFocusInDate=null
         * @protected
         */
        lastFocusOutDate: null,
        /**
         * The amount of time for a focusIn to occur after the last focusOut
         * to get combined into a focusmove event.
         * @member {Number} maxFocusInOutGap=10
         */
        maxFocusInOutGap: 10,
        /**
         * The maximum amount of items stored inside the history array
         * @member {Number} maxHistoryLength=20
         */
        maxHistoryLength: 20,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    addToHistory(opts) {
        let history = this.history;

        history.unshift(opts);
        history.length >= this.maxHistoryLength && history.pop()
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusEnter(opts) {
        this.setComponentFocus(opts, true);
        this.addToHistory(opts)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusLeave(opts) {
        this.setComponentFocus(opts, false)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusMove(opts) {
        let me               = this,
            {history}        = me,
            newComponentPath = opts.componentPath,
            oldComponentPath = history[0].componentPath,
            focusEnter       = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(newComponentPath, oldComponentPath),
            focusLeave       = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(oldComponentPath, newComponentPath),
            focusMove        = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].intersection(newComponentPath, oldComponentPath),
            component, data;

        me.setComponentFocus({componentPath: focusLeave, data: opts.data}, false);
        me.setComponentFocus({componentPath: focusEnter, data: opts.data}, true);

        focusMove.forEach(id => {
            component = Neo.getComponent(id);

            if (component) {
                data = {
                    component,
                    path   : opts.data.path,
                    oldPath: history[0].data.path
                };

                component.onFocusMove?.(data);
                component.fire('focusMove', data);

                component.onFocusChange?.(data);
                component.fire('focusChange', data)
            }
        });

        me.addToHistory(opts)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    onFocusin(opts) {
        let me = this;

        me.lastFocusInDate = new Date();

        if (me.lastFocusOutDate && me.lastFocusInDate - me.lastFocusOutDate < me.maxFocusInOutGap) {
            me.focusMove(opts)
        } else {
            me.focusEnter(opts)
        }
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    onFocusout(opts) {
        let me = this;

        me.lastFocusOutDate = new Date();

        me.timeout(me.maxFocusInOutGap).then(() => {
            if (me.lastFocusOutDate > me.lastFocusInDate) {
                me.focusLeave(opts)
            }
        })
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @param {Boolean} containsFocus
     * @protected
     */
    setComponentFocus(opts, containsFocus) {
        let data = {
                relatedTarget: opts.data.relatedTarget
            },
            components = opts.componentPath.map(id => Neo.getComponent(id)),
            handler;

        components.forEach(component => {
            if (component) {
                component.containsFocus = containsFocus
            }
        });

        components.forEach(component => {
            if (component) {
                data.component = component;

                data[containsFocus ? 'path' : 'oldPath'] = opts.data.path

                handler = containsFocus ? 'onFocusEnter' : 'onFocusLeave';
                component[handler]?.(data);

                component.fire(containsFocus ? 'focusEnter' : 'focusLeave', data);

                component.onFocusChange?.(data);
                component.fire('focusChange', data)
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Focus));


/***/ }),

/***/ "./src/manager/Instance.mjs":
/*!**********************************!*\
  !*** ./src/manager/Instance.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");



/**
 * @class Neo.manager.Instance
 * @extends Neo.manager.Base
 * @singleton
 */
class Instance extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Instance'
         * @protected
         */
        className: 'Neo.manager.Instance',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        _core_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].instanceManagerAvailable = true;

        me.consumeNeoIdMap();

        Neo.find      = me.find     .bind(me); // alias
        Neo.findFirst = me.findFirst.bind(me); // alias
        Neo.get       = me.get      .bind(me); // alias
    }

    /**
     * Register all ids which got applied to the Neo namespace before this instance got created
     * @protected
     */
    consumeNeoIdMap() {
        if (Neo.idMap) {
            this.add(Object.values(Neo.idMap));
            delete Neo.idMap
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Instance));


/***/ }),

/***/ "./src/util/Array.mjs":
/*!****************************!*\
  !*** ./src/util/Array.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Array
 * @extends Neo.core.Base
 */
class NeoArray extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Array'
         * @protected
         */
        className: 'Neo.util.Array'
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     * @returns {Array}
     */
    static add(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.push(item);
            }
        });

        return arr
    }

    /**
     * Returns an array of items which are present in array1, but not in array2
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static difference(array1=[], array2=[]) {
        return array1.filter(item => !array2.includes(item))
    }

    /**
     * Checks if the item is included by reference inside the array
     * @param {Array} arr
     * @param {*} item
     */
    static hasItem(arr, item) {
        return arr.includes(item)
    }

    /**
     * Inserts an item or Array of items to an array in case it does not already exist.
     * Duplicates will only get matched by reference.
     * @param {Array} arr
     * @param {Number} index
     * @param {*} items
     * @returns {Array}
     */
    static insert(arr, index, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let len = items.length -1,
            i   = len,
            currentIndex, item;

        // Iterate backwards
        for (; i > -1; i--) {
            item = items[i];

            currentIndex = arr.indexOf(item);

            if (index !== currentIndex) {
                if (currentIndex > -1) {
                    this.move(arr, currentIndex, index)
                } else {
                    arr.splice(index, 0, item)
                }
            }
        }

        return arr
    }

    /**
     * Returns an array of items which are present in array1 and array2
     * Only supports primitive items
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static intersection(array1=[], array2=[]) {
        return array1.filter(item => array2.includes(item))
    }

    /**
     * Moves an item inside arr from fromIndex to toIndex
     * @param {Array} arr
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    static move(arr, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return arr
        }

        if (fromIndex >= arr.length) {
            fromIndex = arr.length - 1
        }

        arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);
        return arr
    }

    /**
     * Removes an item or array of items from an array. Only primitive items will get found
     * @param {Array} arr
     * @param {*} items
     */
    static remove(arr, items) {
        let index;

        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            index = arr.indexOf(item);

            index > -1 && arr.splice(index, 1)
        });

        return arr
    }

    /**
     * Convenience method to combine add & remove in one call.
     * You can pass single items or an array of items to add or to remove.
     * @param {Array} arr
     * @param {*} removeItems
     * @param {*} addItems
     */
    static removeAdd(arr, removeItems, addItems) {
        this.remove(arr, removeItems);
        return this.add(arr, addItems)
    }

    /**
     * Removes an item from an array in case it does exist, otherwise adds it
     * @param {Array} arr
     * @param {*} item
     * @param {Boolean} [add]
     */
    static toggle(arr, item, add = !this.hasItem(arr, item)) {
        return this[add ? 'add' : 'remove'](arr, item);
    }

    /**
     * Returns an array of items which are present in the passed arrays.
     * Multiple arrays may be passed.
     * Only supports primitive items
     * @returns {Array}
     */
    static union() {
        return [...new Set(Array.prototype.concat(...arguments))]
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static unshift(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.unshift(item)
            }
        });

        return arr
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(NeoArray));


/***/ }),

/***/ "./src/util/ClassSystem.mjs":
/*!**********************************!*\
  !*** ./src/util/ClassSystem.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.ClassSystem
 * @extends Neo.core.Base
 */
class ClassSystem extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.ClassSystem'
         * @protected
         */
        className: 'Neo.util.ClassSystem'
    }

    /**
     * can get used inside beforeSet methods in case you want to create instances like stores
     * @param {Object|Neo.core.Base|null} config
     * @param {Neo.core.Base|String} [DefaultClass=null]
     * @param {Object} [defaultValues={}]
     * @returns {Neo.core.Base} instance
     */
    static beforeSetInstance(config, DefaultClass=null, defaultValues={}) {
        let isInstance = config instanceof Neo.core.Base;

        if (Neo.isString(DefaultClass)) {
            DefaultClass = Neo.ns(DefaultClass)
        }

        if (!config && DefaultClass) {
            config = Neo.create(DefaultClass, defaultValues)
        } else if (config?.isClass) {
            config = Neo.create(config, defaultValues)
        } else if (Neo.isObject(config) && !isInstance) {
            if (config.ntype) {
                config = Neo.ntype({
                    ...defaultValues,
                    ...config
                })
            } else {
                let newConfig = {};

                if (DefaultClass) {
                    newConfig.module = DefaultClass
                }

                Object.assign(newConfig, {
                    ...defaultValues,
                    ...config
                });

                config = Neo.create(newConfig)
            }
        } else if (isInstance) {
            if (defaultValues?.listeners) {
                config.on(defaultValues.listeners)
            }
        }

        return config
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ClassSystem));


/***/ }),

/***/ "./src/util/Function.mjs":
/*!*******************************!*\
  !*** ./src/util/Function.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bindAppend: () => (/* binding */ bindAppend),
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   createInterceptor: () => (/* binding */ createInterceptor),
/* harmony export */   createSequence: () => (/* binding */ createSequence),
/* harmony export */   debounce: () => (/* binding */ debounce),
/* harmony export */   intercept: () => (/* binding */ intercept),
/* harmony export */   resolveCallback: () => (/* binding */ resolveCallback),
/* harmony export */   throttle: () => (/* binding */ throttle)
/* harmony export */ });
/**
 * Append args instead of prepending them
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function bindAppend(fn, scope) {
    const args = [].slice.call(arguments).slice(2);

    return function() {
        return fn.apply(scope, [].slice.call(arguments).concat(args))
    }
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function buffer(callback, scope, delay=300) {
    let timeoutId;

    const wrapper = function(...args) {
        // callback invocation comes "delay" ms after the last call to wrapper
        // so cancel any pending invocation.
        clearTimeout(timeoutId);

        wrapper.isPending = true;

        timeoutId = setTimeout(() => {
            timeoutId = 0;
            wrapper.isPending = false;
            callback.apply(scope, args)
        }, delay)
    };

    wrapper.cancel = () => {
        wrapper.isPending = false;
        clearTimeout(timeoutId)
    };

    return wrapper
}

/**
 * Intended for functions with 1 param where the interceptor can change the value
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @returns {Function}
 */
function createInterceptor(target, targetMethodName, interceptFunction, scope) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function(value) {
        return targetMethod.call(target, interceptFunction.call(scope || target, value))
    })
}

/**
 * @param {Neo.core.Base} target
 * @param {String} methodName
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function createSequence(target, methodName, fn, scope) {
    let method = target[methodName] || Neo.emptyFn;

    return (target[methodName] = function() {
        method.apply(this, arguments);
        return fn.apply(scope || this, arguments)
    })
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function debounce(callback, scope, delay=300) {
    let debounceTimer;

    return function(...args) {
        // leading edge => trigger the first call right away
        if (!Neo.isNumber(debounceTimer)) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            // we still want to start a timer to delay the 2nd+ update
            debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
        } else {
            clearTimeout(debounceTimer);

            debounceTimer = setTimeout(() => {
                // we need to check if the scope (instance) did not get destroyed yet
                scope?.id && callback.apply(scope, args);
                debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
            },  delay)
        }
    }
}

/**
 * The interceptor can prevent the targetMethod from getting executed in case it returns false.
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @param {*} preventedReturnValue=null The value to return in case the interceptFunction returns false
 * @returns {Function}
 */
function intercept(target, targetMethodName, interceptFunction, scope, preventedReturnValue=null) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function() {
        return (interceptFunction.apply(scope || target, arguments) === false)
            ? preventedReturnValue
            : targetMethod.apply(target, arguments)
    })
}

/**
 * Locate a callable function by name in the passed scope.
 *
 * If the name starts with 'up.', the parent Component chain is searched.
 *
 * This is used by manager.DomEvents & core.Observable.fire and by 'handler' function calls to resolve
 * string function names in the Component's own hierarchy.
 * @param {Function|String} fn A function, or the name of a function to find in the passed scope object/
 * @param {Object} scope=this The scope to find the function in if it is specified as a string.
 * @returns {Object}
 */
function resolveCallback(fn, scope=this) {
    if (typeof fn === 'string') {
        if (!scope[fn] && fn.startsWith('up.')) {
            fn = fn.slice(3);
            while (!scope[fn] && (scope = scope.parent));
        }

        fn = scope[fn]
    }

    return {fn, scope}
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function throttle(callback, scope, delay=300) {
    let lastRanDate, timeoutId;

    return function(...args) {
        if (!lastRanDate) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            lastRanDate = Date.now()
        } else {
            clearTimeout(timeoutId)

            timeoutId = setTimeout(function() {
                if ((Date.now() - lastRanDate) >= delay) {
                    // we need to check if the scope (instance) did not get destroyed yet
                    scope?.id && callback.apply(scope, args);

                    lastRanDate = Date.now()
                }
            }, delay - (Date.now() - lastRanDate))
        }
    }
}


/***/ }),

/***/ "./src/util/HashHistory.mjs":
/*!**********************************!*\
  !*** ./src/util/HashHistory.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.util.HashHistory
 * @extends Neo.core.Base
 * @singleton
 */
class HashHistory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.util.HashHistory'
         * @protected
         */
        className: 'Neo.util.HashHistory',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Number} maxItems=50
         * @protected
         */
        maxItems: 50,
        /**
         * Storing one stack per windowId
         * @member {Object} stacks={}
         * @protected
         */
        stacks: {}
    }

    /**
     * Convenience shortcut
     * @param {Number} [windowId]
     * @returns {Object}
     */
    first(windowId) {
        return this.getAt(0, windowId)
    }

    /**
     * @param {Number} index
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getAt(index, windowId) {
        return this.getStack(windowId)[index]
    }

    /**
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getCount(windowId) {
        return this.getStack(windowId).length
    }

    /**
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getStack(windowId) {
        let me       = this,
            {stacks} = me,
            stackId  = windowId || Object.keys(stacks)[0],
            stack    = stacks[stackId];

        if (!stack) {
            stacks[stackId] = stack = []
        }

        return stack
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Object} data.hash
     * @param {String} data.hashString
     * @param {Number} data.windowId
     */
    push(data) {
        let me         = this,
            {windowId} = data,
            stack      = me.getStack(windowId);

        if (stack[0]?.hashString !== data.hashString) {
            delete data[windowId];
            stack.unshift(data);

            if (stack.length > me.maxItems) {
                stack.pop()
            }

            me.fire('change', data, stack[1] || null)
        }
    }

    /**
     * Convenience shortcut
     * @param {Number} [windowId]
     * @returns {Object}
     */
    second(windowId) {
        return this.getAt(0, windowId)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HashHistory));


/***/ }),

/***/ "./src/util/Logger.mjs":
/*!*****************************!*\
  !*** ./src/util/Logger.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Logger
 * @extends Neo.core.Base
 * @singleton
 */
class Logger extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Logger'
         * @protected
         */
        className: 'Neo.util.Logger',
        /**
         * Set the minimum level, which you want to output.
         * Change this at any time using a value of logLevels: ['info', 'log', 'warn', 'error']
         *
         *     Neo.util.Logger.level = 'error'
         *
         * @member {String} level='info'
         * @protected
         */
        level_: 'info',
        /**
         * @member {Boolean} enableLogs=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Object} logChar
     */
    logChars  = {
        error: 'E',
        info : 'I',
        log  : 'L',
        warn : 'W'
    }
    /**
     * @member {Object} colors
     */
    logColors = {
        error: 'indianred',
        info : '#acacac',
        log  : '#448888',
        warn : '#6d6d00'
    }
    /**
     * LogLevels
     * @member {String[]} logLevels
     */
    logLevels = ['info', 'log', 'warn', 'error']

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // aliases
        Neo.applyFromNs(Neo, me, {
            error   : 'error',
            info    : 'info',
            log     : 'log',
            logError: 'logError',
            warn    : 'warn'
        }, true);

        me.timeout(50).then(() => {
            if (!Neo.config.enableLogsInProduction && Neo.config.environment === 'dist/production') {
                me.write = Neo.emptyFn
            }
        })
    }

    /**
     * Ctrl-Right-Click will show the current component
     * @param {Neo.component.Base} view
     */
    addContextMenuListener(view) {
        view.addDomListeners({
            contextmenu: this.onContextMenu,
            scope      : this
        })
    }

    /**
     * Set level to number based on position in logLevels
     * @param {String} value
     * @param {String|Number} oldValue
     * @returns {Number}
     */
    beforeSetLevel(value, oldValue) {
        return this.logLevels.indexOf(value)
    }

    /**
     * @param {String} value
     */
    error(value) {
        throw new Error(value)
    }

    /**
     * internal helper to catch caller
     * no known native way in modern JS to know what file that triggered the current method
     * therefore we use Error, we can get the caller file from the stack trace string.
     * @protected
     * @returns {String}
     */
    getCaller() {
        let caller_path = undefined,
            err         = new Error(),
            stack_lines = err.stack.split('\n'),
            found_this  = false,
            i, line;

        for (i in stack_lines) {
            line = stack_lines[i];

            if (!found_this && /Logger\.mjs/.test(line)) {
                found_this = true
            } else if (found_this) {
                if (!/Logger\.mjs/.test(line)) {
                    // remove the closing )
                    line        = line.replace(')', '');
                    // get the part after the last /
                    caller_path = line.match(/([^\/]+)$/)[1].match(/([^ ]+)$/)[1];

                    break
                }
            }
        }

        return caller_path
    }

    /**
     * @param args
     */
    info(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'info')
    }

    /**
     * @param args
     */
    log(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'log')
    }

    /**
     * @param args
     */
    logError(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'error')
    }

    /**
     * @param {Object} data
     */
    onContextMenu(data) {
        let {config} = Neo;

        if (
            data.ctrlKey
            && config.enableComponentLogger
            && !(config.env === 'dist/production' && config.enableLogsInProduction)
        ) {
            let isGroupSet = false,
                component;

            data.path.forEach(item => {
                component = Neo.getComponent(item.id);

                if (component) {
                    if (!isGroupSet) {
                        isGroupSet = true;
                        console.group(item.id)
                    }

                    console.log(component)
                }
            });

            isGroupSet && console.groupEnd()
        }
    }

    /**
     * Internal helper for args
     * @param {Array} args
     * @returns {Object}
     * @protected
     */
    resolveArgs(...args) {
        let identifier = args[0],
            argsObject = {};

        if (args.length === 1) {
            if (Neo.isString(identifier)) {
                argsObject.msg = args[0]
            } else if (Neo.isObject(identifier)) {
                argsObject = identifier
            }
        } else if (args.length > 2) {
            argsObject.msg  = args[0];
            argsObject.data = args.slice(1)
        }

        return argsObject
    }

    /**
     * @param args
     */
    warn(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'warn')
    }

    /**
     * Output method
     * @param {Object} args
     * @param {String} level
     * @protected
     */
    write(args, level) {
        let me = this;

        if (me.beforeSetLevel(level) < me.level) {
            return
        }

        console.log('#', args.msg, level);

        let logColor = me.logColors[level],
            logChar  = me.logChars[level],
            bg       = `background-color:${logColor}; color: white; font-weight: 900;`,
            color    = `color:${logColor};`,
            msg      = `[${me.getCaller()}] ${args.msg}`;

        if (args.data) {
            console.groupCollapsed(`%c ${logChar} %c ${msg}`, bg, color)
            console.log(args.data);
            console.groupEnd()
        } else {
            console.log(`%c ${logChar} %c ${msg}`, bg, color)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Logger));


/***/ }),

/***/ "./src/util/VDom.mjs":
/*!***************************!*\
  !*** ./src/util/VDom.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.VDom
 * @extends Neo.core.Base
 */
class VDom extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.VDom'
         * @protected
         */
        className: 'Neo.util.VDom'
    }

    /**
     * @param {Object} vdom
     * @param {Boolean} removeIds=true
     * @returns {Object} cloned vdom
     */
    static clone(vdom, removeIds=true) {
        let clone = Neo.clone(vdom, true);

        if (removeIds) {
            delete clone.id
        }

        if (clone.cn) {
            clone.cn.forEach((item, index) => {
                clone.cn[index] = VDom.clone(item, removeIds)
            })
        }

        return clone
    }

    /**
     * Search vdom child nodes by id or opts object for a given vdom tree
     * @param {Object} vdom
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @param {Number} [index] Internal flag, do not use it
     * @param {Object} [parentNode] Internal flag, do not use it
     * @returns {Object}
     *     {Number} index
     *     {String} parentId
     *     {Object} vdom
     */
    static findVdomChild(vdom, opts, index, parentNode) {
        index = index || 0;
        opts  = !Neo.isString(opts) ? opts : {id: opts};

        let child      = null,
            matchArray = [],
            styleMatch = true,
            i          = 0,
            len        = vdom.cn?.length,
            optsArray  = Object.entries(opts),
            optsLength = optsArray.length,
            subChild;

        optsArray.forEach(([key, value]) => {
            if (vdom.hasOwnProperty(key)) {
                switch(key) {
                    case 'cls':
                        if (typeof value === 'string' && Neo.isArray(vdom[key])) {
                            if (vdom[key].includes(value)) {
                                matchArray.push(true)
                            }
                        } else if (typeof value === 'string' && typeof vdom[key] === 'string') {
                            if (vdom[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isArray(value) && Neo.isArray(vdom[key])) {
                            // todo: either search the vdom array for all keys or compare if the arrays are equal.
                            throw new Error('findVdomChild: cls matching not supported for target & source types of Arrays')
                        }
                        break
                    case 'style':
                        if (typeof value === 'string' && typeof vdom[key] === 'string') {
                            if (vdom[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isObject(value) && Neo.isObject(vdom[key])) {
                            Object.entries(value).forEach(([styleKey, styleValue]) => {
                                if (!(vdom[key].hasOwnProperty(styleKey) && vdom[key][styleKey] === styleValue)) {
                                    styleMatch = false
                                }
                            });

                            if (styleMatch) {
                                matchArray.push(true)
                            }
                        } else {
                            throw new Error('findVdomChild: style matching not supported for mixed target & source types (Object VS String)')
                        }
                        break
                    default:
                        if (vdom[key] === value) {
                            matchArray.push(true)
                        }
                        break
                }
            }
        });

        if (matchArray.length === optsLength) {
            return {index, parentNode, vdom}
        }

        if (vdom.cn) {
            for (; i < len; i++) {
                if (vdom.cn[i]) {
                    subChild = VDom.findVdomChild(vdom.cn[i], opts, i, vdom);

                    if (subChild) {
                        child = {
                            index     : subChild.index,
                            parentNode: subChild.parentNode,
                            vdom      : subChild.vdom
                        };
                        break
                    }
                }
            }
        }

        return child
    }

    /**
     * Convenience shortcut for findVdomChild(vdom, {flag: flag});
     * @param {Object} vdom
     * @param {String} flag The flag reference specified on the target vdom child node
     * @returns {Object} vdom
     */
    static getByFlag(vdom, flag) {
        let node = VDom.findVdomChild(vdom, {flag});
        return node?.vdom
    }

    /**
     * Get the ids of all child nodes of the given vdom tree
     * @param vdom
     * @param [childIds=[]]
     * @returns {Array} childIds
     */
    static getChildIds(vdom, childIds=[]) {
        let childNodes = vdom?.cn || [];

        childNodes.forEach(childNode => {
            if (childNode.id) {
                childIds.push(childNode.id)
            }

            childIds = VDom.getChildIds(childNode, childIds)
        });

        return childIds
    }

    /**
     * @param {Object} vdom
     * @param {Number} index
     * @returns {Array}
     */
    static getColumnNodes(vdom, index) {
        let columnNodes = [];

        vdom.cn?.forEach(row => {
            if (row.cn?.[index]) {
                columnNodes.push(row.cn[index])
            }
        })

        return columnNodes
    }

    /**
     * @param {Object} vdom
     * @param {Number} index
     * @returns {Array}
     */
    static getColumnNodesIds(vdom, index) {
        return VDom.getColumnNodes(vdom, index).map(e => e.id)
    }

    /**
     * @param {Object} vdom
     * @param {String} flag
     * @param {Array} [matchArray]
     * @returns {Array} an array of vdom nodes which match the flag
     */
    static getFlags(vdom, flag, matchArray) {
        if (!matchArray) {
            matchArray = [];

            if (vdom.flag === flag) {
                matchArray.push(vdom)
            }
        }

        (vdom?.cn || []).forEach(childNode => {
            if (childNode.flag === flag) {
                matchArray.push(childNode)
            }

            matchArray = VDom.getFlags(childNode, flag, matchArray)
        });

        return matchArray
    }

    /**
     * @param {Object} vdom
     * @param {String} id
     * @param {Boolean} topLevel=true Internal flag, do not use it
     * @returns {Array}
     */
    static getParentNodes(vdom, id, topLevel=true) {
        let parents = null,
            i       = 0,
            len     = vdom.cn?.length || 0;

        if (vdom.id === id) {
            return []
        }

        for (; i < len; i++) {
            parents = VDom.getParentNodes(vdom.cn[i], id, false);

            if (parents) {
                parents.push(vdom.cn[i]);
                break
            }
        }

        if (topLevel && parents) {
            parents.push(vdom)
        }

        return parents
    }

    /**
     * Insert a given nodeToInsert after a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @returns {Boolean}
     */
    static insertAfterNode(vdom, nodeToInsert, targetNodeId) {
        return VDom.insertNode(vdom, nodeToInsert, targetNodeId, false)
    }

    /**
     * Insert a given nodeToInsert before a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @returns {Boolean}
     */
    static insertBeforeNode(vdom, nodeToInsert, targetNodeId) {
        return VDom.insertNode(vdom, nodeToInsert, targetNodeId, true)
    }

    /**
     * Insert a given nodeToInsert before a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @param {Boolean} insertBefore true inserts the new node at the same index, index+1 otherwise
     * @returns {Boolean}
     */
    static insertNode(vdom, nodeToInsert, targetNodeId, insertBefore) {
        if (Neo.isObject(targetNodeId)) {
            targetNodeId = targetNodeId.id
        }

        let targetNode = VDom.findVdomChild(vdom, {id: targetNodeId}),
            index;

        if (targetNode) {
            index = insertBefore ? targetNode.index : targetNode.index + 1;
            targetNode.parentNode.cn.splice(index, 0, nodeToInsert);
            return true
        }

        return false
    }

    /**
     * Search vdom child nodes by id or opts object for a given vdom tree
     * @param {Object} [vdom]
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @returns {Boolean} true in case the node was found & removed
     */
    static removeVdomChild(vdom, opts) {
        let child = VDom.findVdomChild(vdom, opts);

        if (child) {
            child.parentNode.cn.splice(child.index, 1);
            return true
        }

        return false
    }

    /**
     * Replaces a child node inside a vdom tree by a given id
     * @param {Object} vdom
     * @param {String} id
     * @param {Object} newChildNode
     * @returns {Boolean} true in case the node was found and replaced
     */
    static replaceVdomChild(vdom, id, newChildNode) {
        let cn  = vdom.cn || [],
            i   = 0,
            len = cn.length,
            childNode;

        if (vdom.id === id) {
            throw new Error('replaceVdomChild: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = cn[i];

            if (childNode.id === id) {
                cn[i] = newChildNode;
                return true
            }

            if (VDom.replaceVdomChild(childNode, id, newChildNode)) {
                return true
            }
        }

        return false;
    }

    /**
     * Neo.vdom.Helper will create ids for each vnode which does not already have one,
     * so we need to sync them into the vdom.
     * @param {Neo.vdom.VNode} vnode
     * @param {Object} vdom
     * @param {Boolean} force=false The force param will enforce overwriting different ids
     */
    static syncVdomIds(vnode, vdom, force=false) {
        if (vnode && vdom) {
            let childNodes = vdom.cn,
                cn, i, len;

            if (force) {
                if (vnode.id && vdom.id !== vnode.id) {
                    vdom.id = vnode.id
                }
            } else {
                // we only want to change vdom ids in case there is not already an own id
                // (think of adding & removing nodes in parallel)
                if (!vdom.id && vnode.id) {
                    vdom.id = vnode.id
                }
            }

            if (childNodes) {
                cn   = childNodes.filter(item => item.removeDom !== true);
                i    = 0;
                len  = cn?.length || 0;

                for (; i < len; i++) {
                    if (vnode.childNodes) {
                        VDom.syncVdomIds(vnode.childNodes[i], cn[i], force)
                    }
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VDom));


/***/ }),

/***/ "./src/util/VNode.mjs":
/*!****************************!*\
  !*** ./src/util/VNode.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.VNode
 * @extends Neo.core.Base
 */
class VNode extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.VNode'
         * @protected
         */
        className: 'Neo.util.VNode'
    }

    /**
     * Search vnode child nodes by id or opts object for a given vdom tree
     * @param {Object} vnode
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @param {Number} [index] Internal flag, do not use it
     * @param {Object} [parentNode] Internal flag, do not use it
     * @returns {Object}
     *     {Number} index
     *     {String} parentId
     *     {Object} vnode
     */
    static findChildVnode(vnode, opts, index, parentNode) {
        index = index || 0;
        opts  = typeof opts !== 'string' ? opts : {id: opts};

        let attrMatch  = true,
            matchArray = [],
            styleMatch = true,
            i          = 0,
            len        = vnode.childNodes?.length || 0,
            optsArray, optsLength, subChild;

        optsArray  = Object.entries(opts);
        optsLength = optsArray.length;

        optsArray.forEach(([key, value]) => {
            if (vnode.hasOwnProperty(key)) {
                switch(key) {
                    case 'attributes':
                        if (Neo.isObject(value) && Neo.isObject(vnode[key])) {
                            Object.entries(value).forEach(([attrKey, attrValue]) => {
                                if (!(vnode[key].hasOwnProperty(attrKey) && vnode[key][attrKey] === attrValue)) {
                                    attrMatch = false
                                }
                            });

                            if (attrMatch) {
                                matchArray.push(true)
                            }
                        }
                        break
                    case 'className':
                        if (typeof value === 'string' && Neo.isArray(vnode[key])) {
                            if (vnode[key].includes(value)) {
                                matchArray.push(true)
                            }
                        } else if (typeof value === 'string' && typeof vnode[key] === 'string') {
                            if (vnode[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isArray(value) && Neo.isArray(vnode[key])) {
                            // todo: either search the vnode array for all keys or compare if the arrays are equal.
                            throw new Error('findChildVnode: cls matching not supported for target & source types of Arrays')
                        }
                        break
                    case 'style':
                        if (Neo.isObject(value) && Neo.isObject(vnode[key])) {
                            Object.entries(value).forEach(([styleKey, styleValue]) => {
                                if (!(vnode[key].hasOwnProperty(styleKey) && vnode[key][styleKey] === styleValue)) {
                                    styleMatch = false
                                }
                            });

                            if (styleMatch) {
                                matchArray.push(true)
                            }
                        }
                        break
                    default:
                        if (vnode[key] === value) {
                            matchArray.push(true)
                        }
                        break
                }
            }
        });

        if (matchArray.length === optsLength) {
            return {index, parentNode, vnode}
        }

        for (; i < len; i++) {
            subChild = VNode.findChildVnode(vnode.childNodes[i], opts, i, vnode);

            if (subChild) {
                return subChild
            }
        }

        return null
    }

    /**
     * Finds a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String|null} id
     * @returns {Object|null} child vnode or null
     */
    static findChildVnodeById(vnode, id) {
        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            return vnode
        }

        for (; i < len; i++) {
            childNode = childNodes[i];

            if (childNode.id === id) {
                return childNode
            }

            childNode = VNode.findChildVnodeById(childNode, id);

            if (childNode) {
                return childNode
            }
        }

        return null
    }

    /**
     * Get the ids of all child nodes of the given vnode
     * @param vnode
     * @param [childIds=[]]
     * @returns {Array} childIds
     */
    static getChildIds(vnode, childIds=[]) {
        let childNodes = vnode && vnode.childNodes || [];

        childNodes.forEach(childNode => {
            if (childNode.id) {
                childIds.push(childNode.id)
            }

            childIds = VNode.getChildIds(childNode, childIds)
        });

        return childIds
    }

    /**
     * Removes a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String} id
     * @returns {Boolean} true in case the node was found and removed
     */
    static removeChildVnode(vnode, id) {
        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            throw new Error('removeChildVnode: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = childNodes[i];

            if (childNode.id === id) {
                childNodes.splice(i, 1);
                return true
            }

            if (VNode.removeChildVnode(childNode, id)) {
                return true
            }
        }

        return false
    }

    /**
     * Replaces a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String} id
     * @param {Object} newChildVnode
     * @returns {Boolean} true in case the node was found and replaced
     */
    static replaceChildVnode(vnode, id, newChildVnode) {
        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            throw new Error('replaceChildVnode: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = childNodes[i];

            if (childNode.id === id) {
                childNodes[i] = newChildVnode;
                return true
            }

            if (VNode.replaceChildVnode(childNode, id, newChildVnode)) {
                return true
            }
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VNode));


/***/ }),

/***/ "./src/worker/Base.mjs":
/*!*****************************!*\
  !*** ./src/worker/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Message_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Message.mjs */ "./src/worker/Message.mjs");
/* harmony import */ var _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mixin/RemoteMethodAccess.mjs */ "./src/worker/mixin/RemoteMethodAccess.mjs");





/**
 * The abstract base class for the App, Data & VDom worker
 * @class Neo.worker.Base
 * @extends Neo.core.Base
 * @abstract
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.Base'
         * @protected
         */
        className: 'Neo.worker.Base',
        /**
         * @member {String[]|Neo.core.Base[]|null} mixins=[Observable,RemoteMethodAccess]
         */
        mixins: [_core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]],
        /**
         * @member {String|null} workerId=null
         * @protected
         */
        workerId: null
    }

    /**
     * @member {Object|null} channelPorts=null
     * @protected
     */
    channelPorts = null
    /**
     * Only needed for SharedWorkers
     * @member {Boolean} isConnected=false
     * @protected
     */
    isConnected = false
    /**
     * @member {Boolean} isSharedWorker=false
     * @protected
     */
    isSharedWorker = false
    /**
     * Only needed for SharedWorkers
     * @member {Array|null} ports=null
     */
    ports = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this,
            gt = globalThis;

        Object.assign(me, {
            channelPorts  : {},
            isSharedWorker: gt.toString() === '[object SharedWorkerGlobalScope]',
            ports         : [],
            promises      : {}
        });

        if (me.isSharedWorker) {
            gt.onconnect = me.onConnected.bind(me)
        } else {
            gt.onmessage = me.onMessage.bind(me)
        }

        Neo.currentWorker = me;
        Neo.workerId      = me.workerId
    }

    /**
     * Entry point for dedicated and shared workers
     */
    afterConnect() {}

    /**
     * @param {Object} opts
     * @returns {Object|null}
     */
    getPort(opts) {
        let returnPort = null,
            hasMatch;

        this.ports.forEach(port => {
            hasMatch = true;

            Object.entries(opts).forEach(([key, value]) => {
                if (value !== port[key]) {
                    hasMatch = false
                }
            });

            if (hasMatch) {
                returnPort = port
            }
        });

        return returnPort
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} data
     */
    async onConnect(data) {
        // short delay to ensure app VCs are in place
        await this.timeout(10);

        let {appName, windowId} = data;
        this.fire('connect', {appName, windowId})
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} e
     */
    onConnected(e) {
        let me = this,
            id = Neo.getId('port');

        me.isConnected = true;

        me.ports.push({
            appName : null,
            id,
            port    : e.ports[0],
            windowId: null
        });

        me.ports[me.ports.length - 1].port.onmessage = me.onMessage.bind(me);

        // core.Base: initRemote() subscribes to this event for the SharedWorkers context
        me.fire('connected');

        me.sendMessage('main', {action: 'workerConstructed', port: id});

        me.afterConnect()
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (!me.isSharedWorker) {
            me.sendMessage('main', {action: 'workerConstructed'});
            me.afterConnect()
        }
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} data
     */
    onDisconnect(data) {
        let {appName, windowId} = data;
        this.fire('disconnect', {appName, windowId})
    }

    /**
     * @param {Object} e
     */
    onMessage(e) {
        let me                = this,
            {data}            = e,
            {action, replyId} = data,
            promise;

        if (!action) {
            throw new Error('Message action is missing: ' + data.id)
        }

        if (action !== 'reply') {
            me['on' + Neo.capitalize(action)](data);
        } else if (promise = action === 'reply' && me.promises[replyId]) {
            if (data.reject) {
                promise.reject(data.data)
            } else {
                promise.resolve(data.data)
            }

            delete me.promises[replyId]
        }
    }

    /**
     * @param {Object} msg
     */
    onPing(msg) {
        this.resolve(msg, {originMsg: msg})
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} msg
     * @param {String} msg.appName
     */
    onRegisterApp(msg) {
        let me        = this,
            {appName} = msg,
            port;

        for (port of me.ports) {
            if (!port.appName) {
                port.appName = appName;
                me.onConnect({appName, windowId: port.windowId});
                break
            }
        }
    }

    /**
     * @param {Object} msg
     */
    onRegisterNeoConfig(msg) {
        Neo.config = Neo.config || {};

        let me         = this,
            {windowId} = msg.data,
            port;

        for (port of me.ports) {
            if (!port.windowId) {
                port.windowId = windowId;
                break
            }
        }

        Object.assign(Neo.config, msg.data)
    }

    /**
     * @param {String} dest app, data, main or vdom (excluding the current worker)
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Promise<any>}
     */
    promiseMessage(dest, opts, transfer) {
        let me = this;

        return new Promise(function(resolve, reject) {
            let message = me.sendMessage(dest, opts, transfer),
                msgId   = message?.id;

            if (!msgId) {
                // a window got closed and the message port no longer exist (SharedWorkers)
                reject()
            } else {
                me.promises[msgId] = {reject, resolve}
            }
        })
    }

    /**
     * @param {String} dest app, canvas, data, main or vdom (excluding the current worker)
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Neo.worker.Message}
     * @protected
     */
    sendMessage(dest, opts, transfer) {
        opts.destination = dest;

        let me = this,
            message, port, portObject;

        if (me.channelPorts[dest]) {
            port = me.channelPorts[dest]
        } else if (!me.isSharedWorker) {
            port = globalThis
        } else {
            if (opts.port) {
                port = me.getPort({id: opts.port}).port
            } else if (opts.windowId) {
                portObject = me.getPort({windowId: opts.windowId});
                port       = portObject?.port;

                opts.port = portObject?.id
            }  else if (opts.appName) {
                portObject = me.getPort({appName: opts.appName});
                port       = portObject?.port;

                opts.port = portObject?.id
            } else {
                port = me.ports[0].port
            }
        }

        if (port) {
            message = new _Message_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](opts);
            port.postMessage(message, transfer);
        }

        return message
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/worker/Message.mjs":
/*!********************************!*\
  !*** ./src/worker/Message.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/IdGenerator.mjs */ "./src/core/IdGenerator.mjs");


/**
 * A wrapper for worker post messages sent between the App, Data, VDom worker & the main thread.
 * You can add optional params as needed.
 * @class Neo.worker.Message
 */
class Message {
    /**
     * @param {Object} config
     */
    constructor(config) {
        /**
         * @member {String} action
         */

        /**
         * @member {String} destination='main'
         */

        /**
         * @member {String} id=IdGenerator.getId(Neo.workerId)
         */

        /**
         * @member {String} origin=Neo.workerId
         */

        config.destination = config.destination || 'main';
        config.id          = config.id          || _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getId(Neo.workerId);
        config.origin      = config.origin      || Neo.workerId;

        Object.assign(this, config)
    }
}

const ns = Neo.ns('Neo.worker', true);
ns['Message'] = Message;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Message);


/***/ }),

/***/ "./src/worker/mixin/RemoteMethodAccess.mjs":
/*!*************************************************!*\
  !*** ./src/worker/mixin/RemoteMethodAccess.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.worker.mixin.RemoteMethodAccess
 * @extends Neo.core.Base
 */
class RemoteMethodAccess extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.mixin.RemoteMethodAccess'
         * @protected
         */
        className: 'Neo.worker.mixin.RemoteMethodAccess',
        /**
         * @member {Boolean} mixin=true
         * @protected
         */
        mixin: true
    }

    /**
     * @param {Object} source
     * @param {Object} target
     */
    assignPort(source, target) {
        if (source) {
            const {appName, port, windowId} = source;
            Object.assign(target, {appName, port, windowId})
        }
    }

    /**
     * @param {Object} remote
     * @param method
     * @returns {function(*=, *=): Promise<any>}
     */
    generateRemote(remote, method) {
        let me       = this,
            {origin} = remote;

        return function(data, buffer) {
            let opts = {
                action         : 'remoteMethod',
                data,
                destination    : origin,
                remoteClassName: remote.className,
                remoteMethod   : method
            };

            me.isSharedWorker && me.assignPort(data, opts);

            return me.promiseMessage(origin, opts, buffer)
        }
    }

    /**
     * @param {Object} remote
     */
    onRegisterRemote(remote) {
        if (remote.destination === Neo.workerId) {
            let me                   = this,
                {className, methods} = remote,
                pkg                  = Neo.ns(className, true);

            methods.forEach(method => {
                if (remote.origin !== 'main' && pkg[method]) {
                    throw new Error('Duplicate remote method definition ' + className + '.' + method)
                }

                pkg[method] ??= me.generateRemote(remote, method)
            })
        }
    }

    /**
     * @param {Object} msg
     */
    onRemoteMethod(msg) {
        let me  = this,
            pkg = Neo.ns(msg.remoteClassName),
            out, method;

        if (!pkg) {
            throw new Error('Invalid remote namespace "' + msg.remoteClassName + '"')
        }

        method = pkg[msg.remoteMethod];

        if (!method) {
            throw new Error('Invalid remote method name "' + msg.remoteMethod + '"')
        }

        if (Array.isArray(msg.data)) {
            out = method.call(pkg, ...msg.data)
        } else {
            out = method.call(pkg, msg.data)
        }

        if (out instanceof Promise) {
            out
                .catch(err => {me.reject(msg, err)})
                .then(data => {me.resolve(msg, data)})
        } else {
            me.resolve(msg, out)
        }
    }

    /**
     * Gets called when promiseMessage gets rejected
     * @param {Object} msg
     * @param {Object} data
     */
    reject(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            reject : true,
            replyId: msg.id
        };

        me.isSharedWorker && me.assignPort(msg, opts);
        me.sendMessage(msg.origin, opts)
    }

    /**
     * Gets called when promiseMessage gets resolved
     * @param {Object} msg
     * @param {Object} data
     */
    resolve(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            replyId: msg.id
        };

        me.isSharedWorker && me.assignPort(msg, opts);
        me.sendMessage(msg.origin, opts)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RemoteMethodAccess));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "chunks/app/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"app": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!****************************!*\
  !*** ./src/worker/App.mjs ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Neo.mjs */ "./src/Neo.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/worker/Base.mjs");
/* harmony import */ var _core_export_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/_export.mjs */ "./src/core/_export.mjs");
/* harmony import */ var _controller_Application_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controller/Application.mjs */ "./src/controller/Application.mjs");
/* harmony import */ var _manager_Instance_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../manager/Instance.mjs */ "./src/manager/Instance.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");








/**
 * The App worker contains most parts of the framework as well as all apps which get created.
 * See the tutorials for further infos.
 * @class Neo.worker.App
 * @extends Neo.worker.Base
 * @singleton
 */
class App extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.App'
         * @protected
         */
        className: 'Neo.worker.App',
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            main: [
                'createNeoInstance',
                'destroyNeoInstance',
                'fireEvent',
                'getConfigs',
                'setConfigs'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {String} workerId='app'
         * @protected
         */
        workerId: 'app'
    }

    /**
     * @member {Object|null} data=null
     * @protected
     */
    data = null
    /**
     * @member {Boolean} isUsingViewModels=false
     * @protected
     */
    isUsingViewModels = false
    /**
     * We are storing the params of insertThemeFiles() calls here, in case the method does get triggered
     * before the json theme structure got loaded.
     * @member {Array[]} themeFilesCache=[]
     * @protected
     */
    themeFilesCache = []

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // convenience shortcuts
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].applyDeltas    = me.applyDeltas   .bind(me);
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].setCssVariable = me.setCssVariable.bind(me)
    }

    /**
     * @param {String} appName
     * @param {Array|Object} deltas
     * @returns {Promise<*>}
     */
    applyDeltas(appName, deltas) {
         return this.promiseMessage('main', {action: 'updateDom', appName, deltas})
    }

    /**
     * Remote method to use inside main threads for creating neo based class instances.
     * Be aware that you can only pass configs which can get converted into pure JSON.
     *
     * Rendering a component into the document.body
     * @example:
     *     Neo.worker.App.createNeoInstance({
     *         ntype     : 'button',
     *         autoMount : true,
     *         autoRender: true
     *         text      : 'Hi Nige!'
     *     }).then(id => console.log(id))
     *
     * Inserting a component into a container
     * @example:
     *     Neo.worker.App.createNeoInstance({
     *         ntype      : 'button',
     *         parentId   : 'neo-container-3',
     *         parentIndex: 0
     *         text       : 'Hi Nige!'
     *     }).then(id => console.log(id))
     *
     * @param {Object} config
     * @param {String} [config.importPath] you can lazy load missing classes via this config. dev mode only.
     * @param {String} [config.parentId] passing a parentId will put your instance into a container
     * @param {Number} [config.parentIndex] if a parentId is passed, but no index, neo will use add()
     * @returns {String} the instance id
     */
    async createNeoInstance(config) {
        if (config.importPath) {
            await import(/* webpackIgnore: true */ config.importPath);
            delete config.importPath
        }

        let appName   = Object.keys(_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps)[0], // fallback in case no appName was provided
            Container = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].container?.Base,
            index, instance, parent;

        config = {appName, ...config};

        if (config.parentId) {
            parent = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(config.parentId);

            if (Container && parent && parent instanceof Container) {
                index = config.parentIndex;

                delete config.parentId;
                delete config.parentIndex;

                if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(index)) {
                    instance = parent.insert(index, config)
                } else {
                    instance = parent.add(config)
                }
            }
        } else {
            // default parentId='document.body' => we want it to get shown
            config.autoMount  = true;
            config.autoRender = true;

            instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"][config.ntype ? 'ntype' : 'create'](config)
        }

        return instance.id
    }

    /**
     * @param {Object} data
     */
    createThemeMap(data) {
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns('Neo.cssMap.fileInfo', true);
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap.fileInfo = data;
        this.resolveThemeFilesCache()
    }

    /**
     * Remote method to use inside main threads for destroying neo based class instances.
     *
     * @example:
     *     Neo.worker.App.destroyNeoInstance('neo-button-3').then(success => console.log(success))
     *
     * @param {String} id
     * @returns {Boolean} returns true, in case the instance was found
     */
    destroyNeoInstance(id) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(id),
            parent;

        if (instance) {
            if (instance.parentId) {
                parent = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(instance.parentId);

                if (parent) {
                    parent.remove(instance);
                    return true
                }
            }

            instance.destroy(true, true);
            return true
        }

        return false
    }

    /**
     * Fires a custom event based on core.Observable on any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.name
     */
    fireEvent(data) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id),
            name;

        if (instance) {
            name = data.name;

            delete data.id;
            delete data.name;

            instance.fire(name, data);

            return true
        }

        return false
    }

    /**
     * Only needed for the SharedWorkers context
     * @param {String} eventName
     * @param {Object} data
     */
    fireMainViewsEvent(eventName, data) {
        this.ports.forEach(port => {
            _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps[port.appName].mainView.fire(eventName, data)
        })
    }

    /**
     * Get configs of any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     * @param {String|String[]} data.keys
     * Returns an array of configs if a keys array was passed.
     * Returns the value of a given config directly, in case no array was passed
     * Returns false, in case no instance got found.
     * @returns {*}
     */
    getConfigs(data) {
        let instance    = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id),
            {keys}      = data,
            returnArray = [];

        if (instance) {
            if (!Array.isArray(keys)) {
                return instance[keys]
            }

            keys.forEach(key => {
                returnArray.push(instance[key])
            });

            return returnArray
        }

        return false
    }

    /**
     * @param {String} path
     * @returns {Promise}
     */
    importApp(path) {
        if (path.endsWith('.mjs')) {
            path = path.slice(0, -4)
        }

        return __webpack_require__("./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$")(`./${path}.mjs`)
    }

    /**
     * In case you don't want to include prototype based CSS files, use the className param instead
     * @param {Number} windowId
     * @param {Neo.core.Base} [proto]
     * @param {String} [className]
     */
    insertThemeFiles(windowId, proto, className) {
        if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config.themes.length > 0) {
            className = className || proto.className;
            //console.log(windowId, className);
            let me     = this,
                cssMap = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap,
                parent = proto?.__proto__,
                classPath, classRoot, fileName, lClassRoot, mapClassName, ns, themeFolders;

            if (!cssMap) {
                me.themeFilesCache.push([windowId, proto])
            } else {
                // we need to modify app related class names
                if (!className.startsWith('Neo.')) {
                    className  = className.split('.');
                    classRoot  = className.shift();
                    lClassRoot = classRoot.toLowerCase();

                    className[0] === 'view' && className.shift();

                    mapClassName = `apps.${_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps[classRoot]?.appThemeFolder || lClassRoot}.${className.join('.')}`;
                    className    = `apps.${lClassRoot}.${className.join('.')}`;
                }

                if (parent && parent !== _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].core.Base.prototype) {
                    if (!_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${parent.className}`, false, cssMap)) {
                        me.insertThemeFiles(windowId, parent)
                    }
                }

                themeFolders = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(mapClassName || className, false, cssMap.fileInfo);
                //console.log(cssMap);
                if (themeFolders && !_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${className}`, false, cssMap)) {
                    classPath = className.split('.');
                    fileName  = classPath.pop();
                    classPath = classPath.join('.');
                    ns        = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${classPath}`, true, cssMap);

                    ns[fileName] = true;

                    _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].main.addon.Stylesheet.addThemeFiles({
                        className: mapClassName || className,
                        folders  : themeFolders,
                        windowId
                    })
                }
            }
        }
    }

    /**
     * Every dom event will get forwarded as a worker message from main and ends up here first
     * @param {Object} data useful event properties, differs for different event types. See Neo.main.DomEvents.
     */
    onDomEvent(data) {
        _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].fire(data)
    }

    /**
     * Every URL hash-change will create a post message in main and end up here first.
     * @param {Object} data parsed key-value pairs for each hash value
     */
    onHashChange(data) {
        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].push(data.data)
    }

    /**
     * The starting point for apps
     * @param {Object} data
     */
    onLoadApplication(data) {
        let me       = this,
            {config} = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            app, path;

        if (data) {
            me.data = data;
            config.resourcesPath = data.resourcesPath
        }

        path = me.data.path;

        if (config.environment !== 'development') {
            path = path.startsWith('/') ? path.substring(1) : path
        }

        me.importApp(path).then(module => {
            app = module.onStart();

            // short delay to ensure Component Controllers are ready
            config.hash && me.timeout(5).then(() => {
                _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].push(config.hash);
                // apps which will get created later must not use outdated hash values
                delete config.hash
            })
        })
    }
    /**
     * Triggered in case a connected ServiceWorker receives a new version.
     * Especially inside dist envs, a reload of the connecting window is required,
     * since the SW will clear its caches and the app can receive conflicting bundle versions.
     * @param {Object} data
     * @param {String} data.newVersion
     * @param {String} data.oldVersion
     */
    onNewVersion(data) {
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].Main.reloadWindow({});
    }

    /**
     * Fire event on all apps
     * @param {Object} data
     * @param {Number} data.angle
     * @param {String} data.layout landscape|portrait
     * @param {String} data.type landscape-primary|landscape-secondary|portrait-primary|portrait-secondary
     */
    onOrientationChange(data) {
        Object.values(_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps).forEach(app => {
            app.fire('orientationchange', data.data)
        })
    }

    /**
     * @param {Object} msg
     */
    onRegisterNeoConfig(msg) {
        super.onRegisterNeoConfig(msg);

        let config = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config,
            {data} = msg,
            url    = 'resources/theme-map.json';

        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs || {};

        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs[data.windowId] = data;

        if (config.environment === 'development') {
            url = `../../${url}`
        }

        if (config.workerBasePath?.includes('node_modules')) {
            url = `../../${url}`
        }

        if (url[0] !== '.') {
            url = `./${url}`
        }

        fetch(url)
            .then(response => response.json())
            .then(data => {this.createThemeMap(data)});

        config.remotesApiUrl  && __webpack_require__.e(/*! import() */ "src_remotes_Api_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../remotes/Api.mjs */ "./src/remotes/Api.mjs")).then(module => module.default.load());
        !config.useVdomWorker && __webpack_require__.e(/*! import() */ "vendors-src_vdom_Helper_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../vdom/Helper.mjs */ "./src/vdom/Helper.mjs"))
    }

    /**
     * @param {Object} msg
     */
    onRegisterPort(msg) {
        let me   = this,
            port = msg.transfer;

        port.onmessage = me.onMessage.bind(me);

        me.channelPorts[msg.origin] = port
    }

    /**
     * @param {Object} data
     */
    onWindowPositionChange(data) {
        this.fireMainViewsEvent('windowPositionChange', data.data)
    }

    /**
     * Only needed for SharedWorkers
     * @param {String} appName
     */
    registerApp(appName) {
        // register the name as fast as possible
        this.onRegisterApp({ appName });
        this.sendMessage('main', {action: 'registerAppName', appName})
    }

    /**
     * Unregister the app from the CSS map
     * Only needed for SharedWorkers
     * @param {String} appName
     */
    removeAppFromThemeMap(appName) {
        delete _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap[appName.toLowerCase()]
    }

    /**
     * @private
     */
    resolveThemeFilesCache() {
        let me = this;

        me.themeFilesCache.forEach(item => {
            me.insertThemeFiles(...item)
        });

        me.themeFilesCache = []
    }

    /**
     * Set configs of any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     */
    setConfigs(data) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id);

        if (instance) {
            delete data.id;
            instance.set(data);

            return true
        }

        return false
    }

    /**
     * @param {Object} data
     * @param {String} data.key
     * @param {String} [data.priority] optionally pass 'important'
     * @param {String} data.theme=Neo.config.themes[0]
     * @param {String} data.value
     * @returns {Promise<any>}
     */
    setCssVariable(data) {
        let addon = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].main?.addon?.Stylesheet,
            theme = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config.themes?.[0];

        if (!addon) {
            return Promise.reject('Neo.main.addon.Stylesheet not imported')
        } else {
            if (theme.startsWith('neo-')) {
                theme = theme.substring(4)
            }

            return addon.setCssVariable({theme, ...data})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].setupClass(App));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwd29ya2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDNTJDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RyxnQkFBZ0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi8uLyBsYXp5IF5cXC5cXC8uKlxcLm1qcyQgaW5jbHVkZTogKCIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL0RlZmF1bHRDb25maWcubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvTmVvLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbGxlY3Rpb24vQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb2xsZWN0aW9uL0ZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb2xsZWN0aW9uL1NvcnRlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250cm9sbGVyL0FwcGxpY2F0aW9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRyb2xsZXIvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9Db21wYXJlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvSWRHZW5lcmF0b3IubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9PYnNlcnZhYmxlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvVXRpbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL19leHBvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvRG9tRXZlbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9Gb2N1cy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL0luc3RhbmNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvQXJyYXkubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9DbGFzc1N5c3RlbS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0Z1bmN0aW9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvSGFzaEhpc3RvcnkubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9Mb2dnZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9WRG9tLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvVk5vZGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvd29ya2VyL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvd29ya2VyL01lc3NhZ2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvd29ya2VyL21peGluL1JlbW90ZU1ldGhvZEFjY2Vzcy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvZ2V0IGphdmFzY3JpcHQgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9pbXBvcnRTY3JpcHRzIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvQXBwLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFwID0ge1xuXHRcIi4vYXBwcy9jb2xvcnMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvY29sb3JzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbW9kZWxfQ29tcG9uZW50X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2NvbG9yc19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvY29sb3JzL2NoaWxkYXBwcy93aWRnZXQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvY29sb3JzL2NoaWxkYXBwcy93aWRnZXQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImFwcHNfY29sb3JzX2NoaWxkYXBwc193aWRnZXRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL2NvdmlkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL2NvdmlkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbW9kZWxfQ29tcG9uZW50X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFiX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19jb3ZpZF9hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvZm9ybS9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9mb3JtL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19mb3JtX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9rcmF1c2VzdC9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9rcmF1c2VzdC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19rcmF1c2VzdF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvcG9ydGFsL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3BvcnRhbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19sYXlvdXRfQ3ViZV9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19wb3J0YWxfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3BvcnRhbC9jaGlsZGFwcHMvcHJldmlldy9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9wb3J0YWwvY2hpbGRhcHBzL3ByZXZpZXcvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImFwcHNfcG9ydGFsX2NoaWxkYXBwc19wcmV2aWV3X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yZWFsd29ybGQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvcmVhbHdvcmxkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfcmVhbHdvcmxkX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yZWFsd29ybGQyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3JlYWx3b3JsZDIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0dhbGxlcnlfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9WaWV3cG9ydF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfTWFpbkNvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19yZWFsd29ybGQyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yb3V0ZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9yb3V0ZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfcm91dGVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbW9kZWxfQ29tcG9uZW50X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFiX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19zaGFyZWRjb3ZpZF9hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvc2hhcmVkY292aWQvY2hpbGRhcHBzL3NoYXJlZGNvdmlkY2hhcnQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvc2hhcmVkY292aWQvY2hpbGRhcHBzL3NoYXJlZGNvdmlkY2hhcnQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImFwcHNfc2hhcmVkY292aWRfY2hpbGRhcHBzX3NoYXJlZGNvdmlkY2hhcnRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2NoaWxkYXBwcy9zaGFyZWRjb3ZpZGdhbGxlcnkvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvc2hhcmVkY292aWQvY2hpbGRhcHBzL3NoYXJlZGNvdmlkZ2FsbGVyeS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiYXBwc19zaGFyZWRjb3ZpZF9jaGlsZGFwcHNfc2hhcmVkY292aWRnYWxsZXJ5X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRoZWxpeC9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRoZWxpeC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiYXBwc19zaGFyZWRjb3ZpZF9jaGlsZGFwcHNfc2hhcmVkY292aWRoZWxpeF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvc2hhcmVkY292aWQvY2hpbGRhcHBzL3NoYXJlZGNvdmlkbWFwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2NoaWxkYXBwcy9zaGFyZWRjb3ZpZG1hcC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiYXBwc19zaGFyZWRjb3ZpZF9jaGlsZGFwcHNfc2hhcmVkY292aWRtYXBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3NoYXJlZGRpYWxvZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9zaGFyZWRkaWFsb2cvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RpYWxvZ19CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX3NoYXJlZGRpYWxvZ19hcHBfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvc2hhcmVkZGlhbG9nL2NoaWxkYXBwcy9zaGFyZWRkaWFsb2cyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGRpYWxvZy9jaGlsZGFwcHMvc2hhcmVkZGlhbG9nMi9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfc2hhcmVkZGlhbG9nX2NoaWxkYXBwc19zaGFyZWRkaWFsb2cyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZG9jcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZG9jcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFiX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RyYWdnYWJsZV9EcmFnWm9uZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RyZWVfTGlzdF9tanNcIixcblx0XHRcInZlbmRvcnMtZG9jc19hcHBfdmlld19NYWluQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1kb2NzX2FwcF9tanMtc3JjX2NvbnRhaW5lcl9WaWV3cG9ydF9tanMtc3JjX2NvbnRyb2xsZXJfQ29tcG9uZW50X21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9idXR0b24vYmFzZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvYnV0dG9uL2Jhc2UvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfYnV0dG9uX2Jhc2VfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9idXR0b24vc3BsaXQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2J1dHRvbi9zcGxpdC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19idXR0b25fc3BsaXRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY2FsZW5kYXIvYmFzaWMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbW9kZWxfQ29tcG9uZW50X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UaW1lX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY2FsZW5kYXJfdmlld19NYWluQ29udGFpbmVyTW9kZWxfbWpzLXNyY19jb250YWluZXJfVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NhbGVuZGFyX2Jhc2ljX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY2FsZW5kYXIvd2Vla3ZpZXcvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NhbGVuZGFyL3dlZWt2aWV3L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbW9kZWxfQ29tcG9uZW50X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY2FsZW5kYXJfdmlld193ZWVrX0NvbXBvbmVudF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NhbGVuZGFyX3ZpZXdfTWFpbkNvbnRhaW5lck1vZGVsX21qcy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY2FsZW5kYXJfd2Vla3ZpZXdfYXBwX21qcy1zcmNfdXRpbF9EYXRlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jaGFydHMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NoYXJ0cy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY2hhcnRzX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2NhbnZhcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2NhbnZhcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9jYW52YXNfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2Fyb3VzZWwvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jYXJvdXNlbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9jYXJvdXNlbF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jaGlwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2hpcC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9jaGlwX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2NpcmNsZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2NpcmNsZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0NpcmNsZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2NpcmNsZV9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jbG9jay9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2Nsb2NrL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UaW1lX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfY2xvY2tfYXBwX21qcy1zcmNfZm9ybV9maWVsZF9QaWNrZXJfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jb3JvbmFHYWxsZXJ5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY29yb25hR2FsbGVyeS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfR2FsbGVyeV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2Nvcm9uYUdhbGxlcnlfVmlld3BvcnRfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfY29yb25hR2FsbGVyeV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jb3JvbmFIZWxpeC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2Nvcm9uYUhlbGl4L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfY29yb25hSGVsaXhfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZGF0ZVNlbGVjdG9yL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZGF0ZVNlbGVjdG9yL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2RhdGVTZWxlY3Rvcl9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9nYWxsZXJ5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZ2FsbGVyeS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfR2FsbGVyeV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfTWFpbkNvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfYXBwX21qcy1zcmNfY29udGFpbmVyX1BhbmVsX21qcy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qcy1iZDU2OGFcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2hlbGl4L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvaGVsaXgvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9IZWxpeF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanMtc3JjX2Zvcm1fZmllbGRfUmFuZ2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9WaWV3cG9ydF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tdWx0aVdpbmRvd0Nvcm9uYUdhbGxlcnkvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tdWx0aVdpbmRvd0Nvcm9uYUdhbGxlcnkvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0dhbGxlcnlfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9jb3JvbmFHYWxsZXJ5X1ZpZXdwb3J0X21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X211bHRpV2luZG93Q29yb25hR2FsbGVyeV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tdWx0aVdpbmRvd0Nvcm9uYUdhbGxlcnkvY2hpbGRhcHAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tdWx0aVdpbmRvd0Nvcm9uYUdhbGxlcnkvY2hpbGRhcHAvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9tdWx0aVdpbmRvd0Nvcm9uYUdhbGxlcnlfY2hpbGRhcHBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dIZWxpeC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L211bHRpV2luZG93SGVsaXgvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9IZWxpeF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanMtc3JjX2Zvcm1fZmllbGRfUmFuZ2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9WaWV3cG9ydF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X211bHRpV2luZG93SGVsaXhfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dIZWxpeC9jaGlsZGFwcC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L211bHRpV2luZG93SGVsaXgvY2hpbGRhcHAvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9tdWx0aVdpbmRvd0hlbGl4X2NoaWxkYXBwX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L213Yy9idXR0b24vYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvYnV0dG9uL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X213Y19idXR0b25fYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXdjL2J1dHRvbnMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvYnV0dG9ucy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfbXdjX2J1dHRvbnNfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXdjL3RleHRGaWVsZC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L213Yy90ZXh0RmllbGQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X213Y190ZXh0RmllbGRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXdjL3RleHRGaWVsZHMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvdGV4dEZpZWxkcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfbXdjX3RleHRGaWVsZHNfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvcHJvY2Vzcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3Byb2Nlc3MvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9wcm9jZXNzX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3Byb2Nlc3MvcmVhbFdvcmxkRXhhbXBsZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3Byb2Nlc3MvcmVhbFdvcmxkRXhhbXBsZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfVG9hc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9wcm9jZXNzX3JlYWxXb3JsZEV4YW1wbGVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvcHJvZ3Jlc3MvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9wcm9ncmVzcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X3Byb2dyZXNzX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3NwbGl0dGVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvc3BsaXR0ZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kcmFnZ2FibGVfRHJhZ1pvbmVfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfc3BsaXR0ZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvc3RhdHVzYmFkZ2UvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9zdGF0dXNiYWRnZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3N0YXR1c2JhZGdlX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3RpbWVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvdGltZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3RpbWVyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3RvYXN0L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvdG9hc3QvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9Ub2FzdF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3RvYXN0X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3ZpZGVvL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvdmlkZW8vYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X1RvYXN0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfdmlkZW9fYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9jZXNpdW1KUy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3dyYXBwZXIvY2VzaXVtSlMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfd3JhcHBlcl9jZXNpdW1KU19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC93cmFwcGVyL2dvb2dsZU1hcHMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC93cmFwcGVyL2dvb2dsZU1hcHMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGlhbG9nX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF93cmFwcGVyX2dvb2dsZU1hcHNfYXBwX21qcy1zcmNfY29udGFpbmVyX1BhbmVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9tb25hY29FZGl0b3IvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC93cmFwcGVyL21vbmFjb0VkaXRvci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF93cmFwcGVyX01vbmFjb0VkaXRvcl9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF93cmFwcGVyX21vbmFjb0VkaXRvcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbnRhaW5lci9hY2NvcmRpb24vYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbnRhaW5lci9hY2NvcmRpb24vYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbnRhaW5lcl9hY2NvcmRpb25fYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb250YWluZXIvYmFzZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29udGFpbmVyL2Jhc2UvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29udGFpbmVyX2Jhc2VfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb3JlL2NvbmZpZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29yZS9jb25maWcvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb3JlX2NvbmZpZ19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Rhc2hib2FyZC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZGFzaGJvYXJkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19kYXNoYm9hcmRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9kYXRlL3NlbGVjdG9yQ29udGFpbmVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9kYXRlL3NlbGVjdG9yQ29udGFpbmVyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbW9kZWxfQ29tcG9uZW50X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZGF0ZV9zZWxlY3RvckNvbnRhaW5lcl9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2RpYWxvZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZGlhbG9nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RpYWxvZ19CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19kaWFsb2dfYXBwX21qcy1zcmNfY29udGFpbmVyX1BhbmVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9maWVsZFdpdGhQcmVmaXgvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2ZpZWxkV2l0aFByZWZpeC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19maWVsZFdpdGhQcmVmaXhfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9maWVsZHMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2ZpZWxkcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfRGF0ZVNlbGVjdG9yX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RpbWVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2ZpZWxkc19hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY2hlY2tib3gvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY2hlY2tib3gvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19mb3JtX2ZpZWxkX2NoZWNrYm94X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9jaGlwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL2NoaXAvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfY2hpcF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY29sb3IvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY29sb3IvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9jb2xvcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY29tYm9ib3gvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY29tYm9ib3gvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9jb21ib2JveF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvZGF0ZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9kYXRlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9kYXRlX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9lbWFpbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9lbWFpbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfZW1haWxfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL2ZpbGV1cGxvYWQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvZmlsZXVwbG9hZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19mb3JtX2ZpZWxkX2ZpbGV1cGxvYWRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL251bWJlci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9udW1iZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19mb3JtX2ZpZWxkX251bWJlcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvcGlja2VyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3BpY2tlci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9waWNrZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3JhZGlvL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3JhZGlvL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfZm9ybV9maWVsZF9yYWRpb19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvc3dpdGNoL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3N3aXRjaC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfc3dpdGNoX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90ZXh0L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3RleHQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGV4dF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGV4dGFyZWEvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGV4dGFyZWEvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGV4dGFyZWFfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3RpbWUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGltZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RpbWVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGltZV9hcHBfbWpzLXNyY19mb3JtX2ZpZWxkX1BpY2tlcl9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90cmlnZ2VyL2NvcHlUb0NsaXBib2FyZC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90cmlnZ2VyL2NvcHlUb0NsaXBib2FyZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF90cmlnZ2VyX2NvcHlUb0NsaXBib2FyZF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdXJsL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3VybC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfdXJsX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZHNldC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZHNldC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19mb3JtX2ZpZWxkc2V0X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZ3JpZC9jb250YWluZXIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2dyaWQvY29udGFpbmVyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19ncmlkX2NvbnRhaW5lcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2dyaWQvY292aWQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2dyaWQvY292aWQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19ncmlkX2NvdmlkX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbGF5b3V0L2NhcmQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xheW91dC9jYXJkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfbGF5b3V0X2NhcmRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9sYXlvdXQvY3ViZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbGF5b3V0L2N1YmUvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19sYXlvdXRfQ3ViZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbGF5b3V0X2N1YmVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9sYXlvdXQvZm9ybS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbGF5b3V0L2Zvcm0vYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbGF5b3V0X2Zvcm1fYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9saXN0L2FuaW1hdGUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xpc3QvYW5pbWF0ZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19saXN0X2FuaW1hdGVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9saXN0L2Jhc2UvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xpc3QvYmFzZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19saXN0X2Jhc2VfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9saXN0L2NoaXAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xpc3QvY2hpcC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2xpc3RfY2hpcF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2xpc3QvY2lyY2xlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9saXN0L2NpcmNsZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQ2lyY2xlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19saXN0X2NpcmNsZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2xpc3QvY29sb3IvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xpc3QvY29sb3IvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfbGlzdF9jb2xvcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL21lbnUvbGlzdC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbWVudS9saXN0L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWVudV9MaXN0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfbWVudV9saXN0X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbWVudS9wYW5lbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbWVudS9wYW5lbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21lbnVfTGlzdF9tanNcIixcblx0XHRcImV4YW1wbGVzX21lbnVfcGFuZWxfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9tb2RlbC9hZHZhbmNlZC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbW9kZWwvYWR2YW5jZWQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbW9kZWxfQ29tcG9uZW50X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19tb2RlbF9hZHZhbmNlZF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL21vZGVsL2RpYWxvZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbW9kZWwvZGlhbG9nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21vZGVsX0NvbXBvbmVudF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbW9kZWxfZGlhbG9nX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbW9kZWwvZXh0ZW5kZWRDbGFzcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbW9kZWwvZXh0ZW5kZWRDbGFzcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX21vZGVsX2V4dGVuZGVkQ2xhc3NfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9tb2RlbC9pbmxpbmUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL21vZGVsL2lubGluZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX21vZGVsX2lubGluZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL21vZGVsL2lubGluZU5vTW9kZWwvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL21vZGVsL2lubGluZU5vTW9kZWwvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19tb2RlbF9pbmxpbmVOb01vZGVsX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbW9kZWwvbXVsdGlXaW5kb3cvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL21vZGVsL211bHRpV2luZG93L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX21vZGVsX211bHRpV2luZG93X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbW9kZWwvbXVsdGlXaW5kb3cyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9tb2RlbC9tdWx0aVdpbmRvdzIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX21vZGVsX211bHRpV2luZG93Ml9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL21vZGVsL25lc3RlZERhdGEvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL21vZGVsL25lc3RlZERhdGEvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbW9kZWxfQ29tcG9uZW50X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19tb2RlbF9uZXN0ZWREYXRhX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbW9kZWwvdGFibGUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL21vZGVsL3RhYmxlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tb2RlbF9Db21wb25lbnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX21vZGVsX3RhYmxlX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbW9kZWwvdHdvV2F5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9tb2RlbC90d29XYXkvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21vZGVsX0NvbXBvbmVudF9tanNcIixcblx0XHRcImV4YW1wbGVzX21vZGVsX3R3b1dheV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3BhbmVsL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9wYW5lbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3BhbmVsX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvcG9wb3Zlci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvcG9wb3Zlci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX3BvcG92ZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9wcmVsb2FkaW5nQXNzZXRzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9wcmVsb2FkaW5nQXNzZXRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3ByZWxvYWRpbmdBc3NldHNfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9yZW1vdGVzQXBpL2Jhc2ljL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9yZW1vdGVzQXBpL2Jhc2ljL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfcmVtb3Rlc0FwaV9iYXNpY19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3NpdGVtYXAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3NpdGVtYXAvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3NpdGVtYXBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90YWIvY29udGFpbmVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWIvY29udGFpbmVyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFiX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdGFiX2NvbnRhaW5lcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RhYmxlL2NvbnRhaW5lci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdGFibGUvY29udGFpbmVyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYmxlX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfUmFkaW9fbWpzLXNyY19zZWxlY3Rpb25fdGFibGVfQ2VsbENvbHVtbk1vZGVsX21qcy1zcmNfc2VsZWN0aW9uX3RhYmxlXy1jNTA4M2ZcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdGFibGVfY29udGFpbmVyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGUvY292aWQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYmxlL2NvdmlkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYmxlX2NvdmlkX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGVGaWx0ZXJpbmcvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYmxlRmlsdGVyaW5nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdGFibGVGaWx0ZXJpbmdfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90YWJsZVBlcmZvcm1hbmNlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWJsZVBlcmZvcm1hbmNlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYmxlX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdGFibGVQZXJmb3JtYW5jZV9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RhYmxlU3RvcmUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYmxlU3RvcmUvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1JhZGlvX21qcy1zcmNfc2VsZWN0aW9uX3RhYmxlX0NlbGxDb2x1bW5Nb2RlbF9tanMtc3JjX3NlbGVjdGlvbl90YWJsZV8tYzUwODNmXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYmxlU3RvcmVfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90YWJzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWJzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYnNfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90b2RvTGlzdC92ZXJzaW9uMS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdG9kb0xpc3QvdmVyc2lvbjEvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc190b2RvTGlzdF92ZXJzaW9uMV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RvZG9MaXN0L3ZlcnNpb24yL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90b2RvTGlzdC92ZXJzaW9uMi9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190b2RvTGlzdF92ZXJzaW9uMl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3Rvb2xiYXIvYnJlYWRjcnVtYi9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdG9vbGJhci9icmVhZGNydW1iL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3Rvb2xiYXJfYnJlYWRjcnVtYl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3Rvb2xiYXIvcGFnaW5nL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90b29sYmFyL3BhZ2luZy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21vZGVsX0NvbXBvbmVudF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYmxlX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdG9vbGJhcl9wYWdpbmdfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90cmVlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90cmVlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RyZWVfTGlzdF9tanNcIixcblx0XHRcImV4YW1wbGVzX3RyZWVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90cmVlQWNjb3JkaW9uL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90cmVlQWNjb3JkaW9uL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21vZGVsX0NvbXBvbmVudF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RyZWVfTGlzdF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdHJlZUFjY29yZGlvbl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3ZpZGVvTW92ZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdmlkZW9Nb3ZlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX3ZpZGVvTW92ZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3ZpZXdwb3J0L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy92aWV3cG9ydC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc192aWV3cG9ydF9hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3dvcmtlci90YXNrL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy93b3JrZXIvdGFzay9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc193b3JrZXJfdGFza19hcHBfbWpzXCJcblx0XSxcblx0XCIuL3Rlc3QvY29tcG9uZW50cy9hcHAubWpzXCI6IFtcblx0XHRcIi4vdGVzdC9jb21wb25lbnRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtdGVzdF9jb21wb25lbnRzX2FwcF9tanNcIlxuXHRdXG59O1xuZnVuY3Rpb24gd2VicGFja0FzeW5jQ29udGV4dChyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH0pO1xuXHR9XG5cblx0dmFyIGlkcyA9IG1hcFtyZXFdLCBpZCA9IGlkc1swXTtcblx0cmV0dXJuIFByb21pc2UuYWxsKGlkcy5zbGljZSgxKS5tYXAoX193ZWJwYWNrX3JlcXVpcmVfXy5lKSkudGhlbigoKSA9PiB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xuXHR9KTtcbn1cbndlYnBhY2tBc3luY0NvbnRleHQua2V5cyA9ICgpID0+IChPYmplY3Qua2V5cyhtYXApKTtcbndlYnBhY2tBc3luY0NvbnRleHQuaWQgPSBcIi4vLiBsYXp5IHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qXFxcXC5tanMkIGluY2x1ZGU6ICg/OlxcXFwvJTdDXFxcXFxcXFwpYXBwLm1qcyRcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0FzeW5jQ29udGV4dDsiLCJjb25zdCBOZW8gPSBnbG9iYWxUaGlzLk5lbyB8fCB7fTtcblxuTmVvLmNvbmZpZyA9IE5lby5jb25maWcgfHwge307XG5cbi8qKlxuICogQ29uZmlnIG9iamVjdCBmb3IgdGhlIG5lby5tanMgZnJhbWV3b3JrIHdoaWNoIHdpbGwgZ2V0IHBhc3NlZCB0byBhbGwgd29ya2Vyc1xuICogWW91IGNhbiBjaGFuZ2UgdGhlIGNvbmZpZ3MsIGUuZy4gaW5zaWRlIHRoZSBpbmRleC5odG1sIG9mIHlvdXIgYXBwXG4gKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICogQG5hbWUgY29uZmlnXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xuY29uc3QgRGVmYXVsdENvbmZpZyA9IHtcbiAgICAvKipcbiAgICAgKiB0cnVlIHdpbGwgYXBwbHkgJ25lby1ib2R5JyB0byB0aGUgZG9jdW1lbnQuYm9keSBjbGFzc0xpc3RcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmFwcGx5Qm9keUNsc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGF0aCB0byB5b3VyIGFwcC5tanMgZmlsZS4gWW91IGNhbiBjcmVhdGUgbXVsdGlwbGUgYXBwcyB0aGVyZSBpZiBuZWVkZWQuXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5hcHBQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBhcHBQYXRoOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFBhdGggdG8gdGhlIG5lby5tanMgZGlyZWN0b3J5XG4gICAgICogQGRlZmF1bHQgJy4vJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5iYXNlUGF0aFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGJhc2VQYXRoOiAnLi8nLFxuICAgIC8qKlxuICAgICAqIFBhc3MgYSB0b2tlbiBpbiBjYXNlIHlvdSBhcmUgdXNpbmcgdGhlIENlc2l1bUpTIG1haW4gdGhyZWFkIGFkZG9uXG4gICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9ibG9iL2Rldi9zcmMvbWFpbi9hZGRvbi9DZXNpdW1KUy5tanNcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmNlc2l1bUpzVG9rZW5cbiAgICAgKiBAdHlwZSBTdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIGNlc2l1bUpzVG9rZW46IG51bGwsXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgY29uZmlnIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhlIGNvbXBvbmVudCBsb2dnaW5nIHVzaW5nIEN0cmwtUmlnaHQtQ2xpY2tcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmVuYWJsZUNvbXBvbmVudExvZ2dlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBlbmFibGVDb21wb25lbnRMb2dnZXI6IHRydWUsXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgdG8gZW5hYmxlIHV0aWwuTG9nZ2VyIChOZW8ubG9nKCkpIGJhc2VkIGxvZ3MgaW4gcHJvZHVjdGlvblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmVuYWJsZUxvZ3NJblByb2R1Y3Rpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgZW5hYmxlTG9nc0luUHJvZHVjdGlvbjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFZhbGlkIHZhbHVlczogJ2RldmVsb3BtZW50JywgJ2Rpc3QvZGV2ZWxvcG1lbnQnLCAnZGlzdC9wcm9kdWN0aW9uJ1xuICAgICAqIFRoaXMgY29uZmlnIHdpbGwgZ2V0IGF1dG8tZ2VuZXJhdGVkXG4gICAgICogQGRlZmF1bHQgJ2Rpc3QvcHJvZHVjdGlvbidcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZW52aXJvbm1lbnRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBlbnZpcm9ubWVudDogJ2Rpc3QvcHJvZHVjdGlvbicsXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3UgYXJlIHVzaW5nIHRoZSBHb29nbGVNYXBzIG1haW4gdGhyZWFkIGFkZG9uLCB5b3UgY2FuIHBhc3MgdGhlIEFQSSBrZXkgaGVyZS5cbiAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5nb29nbGVNYXBzQXBpS2V5XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgZ29vZ2xlTWFwc0FwaUtleTogJycsXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3UgYXJlIHVzaW5nIHRoZSBHb29nbGVBbmFseXRpY3MgbWFpbiB0aHJlYWQgYWRkb24gb3IgdXNlR29vZ2xlQW5hbHl0aWNzOiB0cnVlLFxuICAgICAqIHlvdSBjYW4gY2hhbmdlIHRoZSBndGFnIGlkIGhlcmUuIFJlcXVpcmVkIGZvciB0aGUgb25saW5lIGV4YW1wbGVzIChnaCBwYWdlcylcbiAgICAgKiBAZGVmYXVsdCAnRy1ESjEzMDcxQzU1J1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5ndGFnSWRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBndGFnSWQ6ICdHLURKMTMwNzFDNTUnLFxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHJ1bm5pbmcgb24gaHR0cHM6Ly9uZW9tanMuZ2l0aHViLmlvL3BhZ2VzL1xuICAgICAqID0+IHRvIHVzZSBsb2NhbCBpbWFnZXMgcGF0aHMgaW5zdGVhZCBvZiByYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuaXNHaXRIdWJQYWdlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0dpdEh1YlBhZ2VzOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHJ1bm5pbmcgdGhlIE5lbyBtYWluIHRocmVhZCBpbnNpZGUgYW4gaWZyYW1lIChTaWVzdGEgQnJvd3NlciBIYXJuZXNzKVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmlzSW5zaWRlU2llc3RhXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGlzSW5zaWRlU2llc3RhOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBkZWxheSBpbiBtcyBmb3IgdGhlIHdvcmtlci5NYW5hZ2VyOmxvYWRBcHBsaWNhdGlvbigpIGNhbGxcbiAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5sb2FkQXBwbGljYXRpb25EZWxheVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGxvYWRBcHBsaWNhdGlvbkRlbGF5OiAyMCxcbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IEludGwuRGF0ZVRpbWVGb3JtYXQsIGZvciBkZXRhaWxzIHRha2UgYSBsb29rIGF0OlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAgICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvY2FsZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGxvY2FsZTogJ2RlZmF1bHQnLFxuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBsb2cgdGhlIGRlbHRhIHVwZGF0ZXMgaW5zaWRlIHRoZSBtYWluIHRocmVhZChzKSBhcyB3ZWxsIGFzIHRoZSByZXF1ZXN0QW5pbWF0aW9uIGZyYW1lc1xuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvZ0RlbHRhVXBkYXRlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBsb2dEZWx0YVVwZGF0ZXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBsb2cgY29uc29sZSB3YXJuaW5ncywgaW4gY2FzZSBhIGNvbXBvbmVudCB0cmllcyB0byB1cGRhdGUoKSB3aGlsZSBhIHBhcmVudCB1cGRhdGUgaXMgcnVubmluZy5cbiAgICAgKiBBIHBhcmVudCB1cGRhdGUgcmVzdWx0cyBpbiBhIHNob3J0IGRlbGF5LCBzbyB5b3UgbWlnaHQgd2FudCB0byByZXNvbHZlIHRoZXNlIGNvbGxpc2lvbnMuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgbG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFkZCBhZGRvbnMgZm9yIHRoZSBtYWluIHRocmVhZFxuICAgICAqIC4vc3JjL21haW4vYWRkb24vIGNvbnRhaW5zIGFsbCBmcmFtZXdvcmsgcmVsYXRlZCBvcHRpb25zLlxuICAgICAqIFlvdSBjYW4gYWxzbyBjcmVhdGUgeW91ciBvd24gYWRkb25zIHdpdGhpbiB5b3VyIHdvcmtzcGFjZSBzY29wZS4gTWFrZSBzdXJlIHRvIHB1dCB0aGVtIGluc2lkZSAnc3JjL21haW4vYWRkb24vJ1xuICAgICAqIGFuZCBwcmVmaXggdGhlbSB3aXRoICdXUy8nIGluc2lkZSB5b3VyIG5lby1jb25maWcuanNvbiBmaWxlLlxuICAgICAqIEV4YW1wbGU6IFsnRHJhZ0Ryb3AnLCAnU3R5bGVzaGVldCcsICdXUy9NeUFkZG9uJ11cbiAgICAgKiBAZGVmYXVsdCBbJ0RyYWdEcm9wJywgJ05hdmlnYXRvcicsICdTdHlsZXNoZWV0J11cbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubWFpblRocmVhZEFkZG9uc1xuICAgICAqIEB0eXBlIFN0cmluZ1tdXG4gICAgICovXG4gICAgbWFpblRocmVhZEFkZG9uczogWydEcmFnRHJvcCcsICdOYXZpZ2F0b3InLCAnU3R5bGVzaGVldCddLFxuICAgIC8qKlxuICAgICAqIFBhc3MgdGhlIFVSTCBvZiBhIEpTT04tZmlsZSwgd2hpY2ggY29udGFpbnMgdGhlIHNlcnZpY2VzIGFuZCBtZXRob2RzIGZyb20geW91ciBiYWNrZW5kLFxuICAgICAqIHdoaWNoIHlvdSB3YW50IHRvIGV4cG9zZSB0byB0aGUgY2xpZW50LlxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vcHJvamVjdHMvMzJcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnJlbW90ZXNBcGlVcmxcbiAgICAgKiBAdHlwZSBTdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHJlbW90ZXNBcGlVcmw6IG51bGwsXG4gICAgLyoqXG4gICAgICogWW91IGNhbiB2aXN1YWxseSBzaG93IHRoZSBhbW91bnQgb2YgZGVsdGEgdXBkYXRlcyBwZXIgc2Vjb25kIHVzaW5nIHRoaXMgY29uZmlnLlxuICAgICAqIEl0IGV4cGVjdHMgYSBkb20gbm9kZSB3aXRoIHRoZSBpZCBcIm5lby1kZWx0YS11cGRhdGVzXCIgYXMgdGhlIHJlbmRlcmluZyB0YXJnZXQuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcucmVuZGVyQ291bnREZWx0YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgcmVuZGVyQ291bnREZWx0YXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFkZCB0aGVtZXMgeW91IHdhbnQgdG8gdXNlIGhlcmUuIFRoZSBmaXJzdCB0aGVtZSB3aWxsIGdldCBhcHBsaWVkLlxuICAgICAqIEBkZWZhdWx0IFsnbmVvLXRoZW1lLWxpZ2h0JywnbmVvLXRoZW1lLWRhcmsnLCduZW8tdGhlbWUtbmVvLWxpZ2h0J11cbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudGhlbWVzXG4gICAgICogQHR5cGUgU3RyaW5nW11cbiAgICAgKi9cbiAgICB0aGVtZXM6IFsnbmVvLXRoZW1lLWxpZ2h0JywgJ25lby10aGVtZS1kYXJrJywgJ25lby10aGVtZS1uZW8tbGlnaHQnXSxcbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBzdGFuZGFsb25lIFNpZXN0YSBtb2R1bGUgdGVzdHMgPT4gcHJldmVudCByZWdpc3RlclJlbW90ZSB3b3JrZXIgbWVzc2FnZXNcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51bml0VGVzdE1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdW5pdFRlc3RNb2RlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwgZmxhZyBpZiBhbiBvZmZzY3JlZW4gY2FudmFzIHdvcmtlciBzaG91bGQgZ2V0IGNyZWF0ZWQuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlQ2FudmFzV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZUNhbnZhc1dvcmtlcjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogRmxhZyBpZiB2ZG9tIGlkcyBzaG91bGQgZ2V0IG1hcHBlZCBpbnRvIERPTSBlbGVtZW50IGlkcy5cbiAgICAgKiBmYWxzZSB3aWxsIGNvbnZlcnQgdGhlbSBpbnRvIGEgXCJkYXRhLW5lby1pZFwiIGF0dHJpYnV0ZS5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZURvbUlkc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VEb21JZHM6IHRydWUsXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgaW5jbHVkZSB0aGUgc3R5bGVzaGVldFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlRm9udEF3ZXNvbWVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlRm9udEF3ZXNvbWU6IHRydWUsXG4gICAgLyoqXG4gICAgICogSW50ZW5kZWQgZm9yIHRoZSBvbmxpbmUgZXhhbXBsZXMgd2hlcmUgd2UgbmVlZCBhbiBlYXN5IHdheSB0byBhZGQgR0EgdG8gZXZlcnkgZ2VuZXJhdGVkIGFwcFxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZUdvb2dsZUFuYWx5dGljc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VHb29nbGVBbmFseXRpY3M6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFRydWUgd2lsbCBhZGQgdGhlIFNlcnZpY2VXb3JrZXIgbWFpbiB0aHJlYWQgYWRkb24gdG8gc3VwcG9ydCBjYWNoaW5nIG9mIGFzc2V0cyAoUFdBKVxuICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZpY2VfV29ya2VyX0FQSVxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIHVzZSBhIHN0cmluZyB0byBzcGVjaWZ5IHRoZSB0YXJnZXQgZW52aXJvbm1lbnQgPT4gJ2Rpc3QvcHJvZHVjdGlvbidcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VTZXJ2aWNlV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhbnxTdHJpbmdcbiAgICAgKi9cbiAgICB1c2VTZXJ2aWNlV29ya2VyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIEFwcCwgRGF0YSAmIFZEb20gYXMgU2hhcmVkV29ya2Vycy5cbiAgICAgKiBTZXQgdGhpcyBvbmUgdG8gdHJ1ZSBpbiBjYXNlIHlvdSB3YW50IHRvIGNvbm5lY3QgbXVsdGlwbGUgbWFpbiB0aHJlYWRzLlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZVNoYXJlZFdvcmtlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlU2hhcmVkV29ya2VyczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aWxsIGdlbmVyYXRlIGEgbmV3IHRhc2sgd29ya2VyLCB3aGljaCBjYW4gZ2V0IGZpbGxlZCB3aXRoIG93biBleHBlbnNpdmUgcmVtb3RlIG1ldGhvZHNcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VUYXNrV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZVRhc2tXb3JrZXI6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFkZHMgZ2xvYmFsIGRvbSBldmVudCBsaXN0ZW5lcnMgZm9yIG1vYmlsZSByZWxhdGVkIGV2ZW50cyBsaWtlIHJvdGF0ZSwgc3dpcGUsIHRhcFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlVG91Y2hFdmVudHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlVG91Y2hFdmVudHM6IHRydWUsXG4gICAgLyoqXG4gICAgICogRmFsc2Ugd2lsbCBjcmVhdGUgdGhlIHZkb20uSGVscGVyIHdpdGhpbiB0aGUgQXBwIHdvcmtlciAoZXhwZXJpbWVudGFsISlcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZVZkb21Xb3JrZXJcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlVmRvbVdvcmtlcjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBidWlsZFNjcmlwdHMvaW5qZWN0UGFja2FnZVZlcnNpb24ubWpzIHdpbGwgdXBkYXRlIHRoaXMgdmFsdWVcbiAgICAgKiBAZGVmYXVsdCAnNy43LjAnXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnZlcnNpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB2ZXJzaW9uOiAnNy43LjAnXG59O1xuXG5PYmplY3QuYXNzaWduKERlZmF1bHRDb25maWcsIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIHRvIHRoZSB0b3AgbGV2ZWwgbmVvLm1qcyByZXNvdXJjZXMgZm9sZGVyXG4gICAgICogQGRlZmF1bHQgTmVvLmNvbmZpZy5iYXNlUGF0aCArICdyZXNvdXJjZXMvJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5yZXNvdXJjZXNQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgcmVzb3VyY2VzUGF0aDogYCR7TmVvLmNvbmZpZy5iYXNlUGF0aCB8fCBEZWZhdWx0Q29uZmlnLmJhc2VQYXRofXJlc291cmNlcy9gLFxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB3ZWIgd29ya2VyIGVudHJ5IHBvaW50cyAoQXBwLCBEYXRhLCBWZG9tKVxuICAgICAqIEBkZWZhdWx0IE5lby5jb25maWcuYmFzZVBhdGggKyAnc3JjL3dvcmtlci8nXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLndvcmtlckJhc2VQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgd29ya2VyQmFzZVBhdGg6IGAke05lby5jb25maWcuYmFzZVBhdGggfHwgRGVmYXVsdENvbmZpZy5iYXNlUGF0aH1zcmMvd29ya2VyL2AsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdENvbmZpZztcbiIsImltcG9ydCBEZWZhdWx0Q29uZmlnIGZyb20gJy4vRGVmYXVsdENvbmZpZy5tanMnO1xuXG5jb25zdFxuICAgIGNhbWVsUmVnZXggICA9IC8tLi9nLFxuICAgIGNvbmZpZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ2NvbmZpZ1N5bWJvbCcpLFxuICAgIGdldFNldENhY2hlICA9IFN5bWJvbCgnZ2V0U2V0Q2FjaGUnKSxcbiAgICB0eXBlRGV0ZWN0b3IgPSB7XG4gICAgICAgIGZ1bmN0aW9uOiAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucHJvdG90eXBlPy5jb25zdHJ1Y3Rvci5pc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZW9DbGFzcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0OiAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29uc3RydWN0b3IuaXNDbGFzcyAmJiBpdGVtIGluc3RhbmNlb2YgTmVvLmNvcmUuQmFzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTmVvSW5zdGFuY2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4vKipcbiAqIFRoZSBiYXNlIG1vZHVsZSB0byBlbmhhbmNlIGNsYXNzZXMsIGNyZWF0ZSBpbnN0YW5jZXMgYW5kIHRoZSBOZW8gbmFtZXNwYWNlXG4gKiBAbW9kdWxlIE5lb1xuICogQHNpbmdsZXRvblxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5iaW5kTWV0aG9kcyAgICAgICBhcyBiaW5kTWV0aG9kc1xuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5jYXBpdGFsaXplICAgICAgICBhcyBjYXBpdGFsaXplXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmNyZWF0ZVN0eWxlT2JqZWN0IGFzIGNyZWF0ZVN0eWxlT2JqZWN0XG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmNyZWF0ZVN0eWxlcyAgICAgIGFzIGNyZWF0ZVN0eWxlc1xuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5kZWNhbWVsICAgICAgICAgICBhcyBkZWNhbWVsXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzQXJyYXkgICAgICAgICAgIGFzIGlzQXJyYXlcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNCb29sZWFuICAgICAgICAgYXMgaXNCb29sZWFuXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzRGVmaW5lZCAgICAgICAgIGFzIGlzRGVmaW5lZFxuICogQGJvcnJvd3MgTmVvLmNvcmUuQ29tcGFyZS5pc0VxdWFsICAgICAgICBhcyBpc0VxdWFsXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzTnVtYmVyICAgICAgICAgIGFzIGlzTnVtYmVyXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzT2JqZWN0ICAgICAgICAgIGFzIGlzT2JqZWN0XG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzU3RyaW5nICAgICAgICAgIGFzIGlzU3RyaW5nXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLnRvQXJyYXkgICAgICAgICAgIGFzIHRvQXJyYXlcbiAqIEB0dXRvcmlhbCAwMV9Db25jZXB0XG4gKi9cbmxldCBOZW8gPSBnbG9iYWxUaGlzLk5lbyB8fCB7fTtcblxuTmVvID0gZ2xvYmFsVGhpcy5OZW8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBjb250YWluaW5nIG50eXBlcyBhcyBrZXkgYW5kIE5lbyBjbGFzc2VzIG9yIHNpbmdsZXRvbnMgYXMgdmFsdWVzXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIG50eXBlTWFwOiB7fSxcbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIE5lby5jcmVhdGUuIEZhbHNlIGZvciB0aGUgbWFpbiB0aHJlYWQsIHRydWUgZm9yIHRoZSBBcHAsIERhdGEgJiBWZG9tIHdvcmtlclxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgaW5zaWRlV29ya2VyOiB0eXBlb2YgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIG1ldGhvZHMgZnJvbSBvbmUgbmFtZXNwYWNlIHRvIGFub3RoZXIgb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBhbGlhc2VzXG4gICAgICogTmVvLmFwcGx5RnJvbU5zKE5lbywgVXRpbCwge1xuICAgICAqICAgICBjcmVhdGVTdHlsZU9iamVjdDogJ2NyZWF0ZVN0eWxlT2JqZWN0JyxcbiAgICAgKiAgICAgY3JlYXRlU3R5bGVzICAgICA6ICdjcmVhdGVTdHlsZXMnLFxuICAgICAqICAgICBjYXBpdGFsaXplICAgICAgIDogJ2NhcGl0YWxpemUnXG4gICAgICogfSwgdHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBlLmcuIE5lby5jb3JlLlV0aWwuaXNPYmplY3QgPT4gTmVvLmlzT2JqZWN0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge05lb3xOZW8uY29yZS5CYXNlfSB0YXJnZXQgVGhlIHRhcmdldCBjbGFzcyBvciBzaW5nbGV0b24gSW5zdGFuY2Ugb3IgTmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBuYW1lc3BhY2UgVGhlIGNsYXNzIGNvbnRhaW5pbmcgdGhlIG1ldGhvZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYmluZF0gc2V0IHRoaXMgdG8gdHJ1ZSBpbiBjYXNlIHlvdSB3YW50IHRvIGJpbmQgbWV0aG9kcyB0byB0aGUgXCJmcm9tXCIgbmFtZXNwYWNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgYXBwbHlGcm9tTnModGFyZ2V0LCBuYW1lc3BhY2UsIGNvbmZpZywgYmluZCkge1xuICAgICAgICBsZXQgZm5OYW1lO1xuXG4gICAgICAgIGlmICh0YXJnZXQgJiYgTmVvLnR5cGVPZihjb25maWcpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBuYW1lc3BhY2VbdmFsdWVdO1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gYmluZCA/IGZuTmFtZS5iaW5kKG5hbWVzcGFjZSkgOiBmbk5hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hcHMgYSBjbGFzcyB0byB0aGUgZ2xvYmFsIE5lbyBvciBBcHAgbmFtZXNwYWNlLlxuICAgICAqIENhbiBnZXQgY2FsbGVkIGZvciBjbGFzc2VzIGFuZCBzaW5nbGV0b24gaW5zdGFuY2VzXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGNsc1xuICAgICAqL1xuICAgIGFwcGx5VG9HbG9iYWxOcyhjbHMpIHtcbiAgICAgICAgbGV0IHByb3RvID0gdHlwZW9mIGNscyA9PT0gJ2Z1bmN0aW9uJyA/IGNscy5wcm90b3R5cGU6IGNscyxcbiAgICAgICAgICAgIGNsYXNzTmFtZSwgbnNBcnJheSwga2V5LCBucztcblxuICAgICAgICBpZiAocHJvdG8uY29uc3RydWN0b3IucmVnaXN0ZXJUb0dsb2JhbE5zID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcm90by5pc0NsYXNzID8gcHJvdG8uY29uZmlnLmNsYXNzTmFtZSA6IHByb3RvLmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgbnNBcnJheSA9IGNsYXNzTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAga2V5ICAgICA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICBucyAgICAgID0gTmVvLm5zKG5zQXJyYXksIHRydWUpO1xuICAgICAgICAgICAgbnNba2V5XSA9IGNsc1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvcGllcyBhbGwga2V5cyBvZiBkZWZhdWx0cyBpbnRvIHRhcmdldCwgaW4gY2FzZSB0aGV5IGRvbid0IGFscmVhZHkgZXhpc3RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHMgVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXlzIHlvdSB3YW50IHRvIGNvcHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBhc3NpZ25EZWZhdWx0cyh0YXJnZXQsIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgTmVvLnR5cGVPZihkZWZhdWx0cykgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkZWZhdWx0cykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMga2ViYWItY2FzZSBzdHJpbmdzIGludG8gY2FtZWwtY2FzZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB0YXJnZXQgb2JqZWN0XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBjYW1lbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShjYW1lbFJlZ2V4LCBtYXRjaCA9PiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHVwcGVyY2FzZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58U3RyaW5nfSBSZXR1cm5zIGZhbHNlIGZvciBub24gc3RyaW5nIGlucHV0c1xuICAgICAqL1xuICAgIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fCp9IG9ialxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVlcD1mYWxzZSBTZXQgdGhpcyB0byB0cnVlIGluIGNhc2UgeW91IHdhbnQgdG8gY2xvbmUgbmVzdGVkIG9iamVjdHMgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlTmVvSW5zdGFuY2VzPWZhbHNlIHJldHVybnMgZXhpc3RpbmcgaW5zdGFuY2VzIGlmIHNldCB0byB0cnVlXG4gICAgICogQHJldHVybnMge09iamVjdHxBcnJheXwqfSB0aGUgY2xvbmVkIGlucHV0XG4gICAgICovXG4gICAgY2xvbmUob2JqLCBkZWVwPWZhbHNlLCBpZ25vcmVOZW9JbnN0YW5jZXM9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG91dDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQXJyYXkgICAgICA6ICgpID0+ICFkZWVwID8gWy4uLm9ial0gOiBbLi4ub2JqLm1hcCh2YWwgPT4gTmVvLmNsb25lKHZhbCwgZGVlcCwgaWdub3JlTmVvSW5zdGFuY2VzKSldLFxuICAgICAgICAgICAgRGF0ZSAgICAgICA6ICgpID0+IG5ldyBEYXRlKG9iai52YWx1ZU9mKCkpLFxuICAgICAgICAgICAgTWFwICAgICAgICA6ICgpID0+IG5ldyBNYXAob2JqKSwgLy8gc2hhbGxvdyBjb3B5XG4gICAgICAgICAgICBOZW9JbnN0YW5jZTogKCkgPT4gaWdub3JlTmVvSW5zdGFuY2VzID8gb2JqIDogdGhpcy5jbG9uZU5lb0luc3RhbmNlKG9iaiksXG4gICAgICAgICAgICBTZXQgICAgICAgIDogKCkgPT4gbmV3IFNldChvYmopLFxuXG4gICAgICAgICAgICBPYmplY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBvdXQgPSB7fTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtrZXldID0gIWRlZXAgPyB2YWx1ZSA6IE5lby5jbG9uZSh2YWx1ZSwgZGVlcCwgaWdub3JlTmVvSW5zdGFuY2VzKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dFxuICAgICAgICAgICAgfVxuICAgICAgICB9W05lby50eXBlT2Yob2JqKV0/LigpIHx8IG9ialxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBvcmlnaW5hbENvbmZpZyB3aXRob3V0IHRoZSBpZFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfSB0aGUgY2xvbmVkIGluc3RhbmNlXG4gICAgICovXG4gICAgY2xvbmVOZW9JbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICBsZXQgY29uZmlnID0gey4uLmluc3RhbmNlLm9yaWdpbmFsQ29uZmlnfTtcblxuICAgICAgICBkZWxldGUgY29uZmlnLl9pZDtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5pZDtcblxuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZShpbnN0YW5jZS5jbGFzc05hbWUsIGNvbmZpZylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlIE5lby5jcmVhdGUoKSBpbnN0ZWFkIG9mIFwibmV3XCIgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBhbGwgTmVvIGNsYXNzZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uL0Jhc2UubWpzJztcbiAgICAgKlxuICAgICAqIE5lby5jcmVhdGUoQnV0dG9uLCB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG4gICAgICpcbiAgICAgKiBOZW8uY3JlYXRlKHtcbiAgICAgKiAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLmNyZWF0ZSgnTmVvLmJ1dHRvbi5CYXNlJyB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8uY3JlYXRlKHtcbiAgICAgKiAgICAgY2xhc3NOYW1lOiAnTmVvLmJ1dHRvbi5CYXNlJyxcbiAgICAgKiAgICAgaWNvbkNscyAgOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8TmVvLmNvcmUuQmFzZX0gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V8bnVsbH0gVGhlIG5ldyBjbGFzcyBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICAgICAqL1xuICAgIGNyZWF0ZShjbGFzc05hbWUsIGNvbmZpZykge1xuICAgICAgICBsZXQgdHlwZSA9IE5lby50eXBlT2YoY2xhc3NOYW1lKSxcbiAgICAgICAgICAgIGNscywgaW5zdGFuY2U7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgIGNscyA9IGNsYXNzTmFtZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcuY2xhc3NOYW1lICYmICFjb25maWcubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIGNvbnNvbGUuZXJyb3IgaW5zdGVhZCBvZiB0aHJvdyB0byBzaG93IHRoZSBjb25maWcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NsYXNzIGNyZWF0ZWQgd2l0aCBvYmplY3QgY29uZmlndXJhdGlvbiBtaXNzaW5nIGNsYXNzTmFtZSBvciBtb2R1bGUgcHJvcGVydHknLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNvbmZpZy5jbGFzc05hbWUgfHwgY29uZmlnLm1vZHVsZS5wcm90b3R5cGUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4aXN0cyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyAnICsgY2xhc3NOYW1lICsgJyBkb2VzIG5vdCBleGlzdCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNscyA9IE5lby5ucyhjbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjbHMoKTtcblxuICAgICAgICBpbnN0YW5jZS5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgaW5zdGFuY2Uub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICBpbnN0YW5jZS5vbkFmdGVyQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgaW5zdGFuY2UuaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGVtcHR5Rm4oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGVyZSBpcyBhIHNldCBtZXRob2QgZm9yIGEgZ2l2ZW4gcHJvcGVydHkga2V5IGluc2lkZSB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHByb3RvIFRoZSB0b3AgbGV2ZWwgcHJvdG90eXBlIG9mIGEgY2xhc3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBwcm9wZXJ0eSBrZXkgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc1Byb3BlcnR5U2V0dGVyKHByb3RvLCBrZXkpIHtcbiAgICAgICAgbGV0IGRlc2NyaXB0b3I7XG5cbiAgICAgICAgd2hpbGUgKHByb3RvLl9fcHJvdG9fXykge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG8gPSBwcm90by5fX3Byb3RvX19cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWVwLW1lcmdlcyBhIHNvdXJjZSBvYmplY3QgaW50byBhIHRhcmdldCBvYmplY3RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cykge1xuICAgICAgICAgICAgcmV0dXJuIE5lby5tZXJnZShOZW8ubWVyZ2UodGFyZ2V0LCBkZWZhdWx0cyksIHNvdXJjZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gTmVvLm1lcmdlKHRhcmdldFtrZXldIHx8IHt9LCB2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgY2xhc3NOYW1lIHN0cmluZyBpbnRvIGEgZ2l2ZW4gb3IgZ2xvYmFsIG5hbWVzcGFjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLm5zKCdOZW8uYnV0dG9uLkJhc2UnLCB0cnVlKTtcbiAgICAgKiAvLyA9PlxuICAgICAqIC8vIGdsb2JhbFRoaXMuTmVvICAgICAgICAgICAgID0gZ2xvYmFsVGhpcy5OZW8gICAgICAgICAgICAgfHwge307XG4gICAgICogLy8gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uICAgICAgPSBnbG9iYWxUaGlzLk5lby5idXR0b24gICAgICB8fCB7fTtcbiAgICAgKiAvLyBnbG9iYWxUaGlzLk5lby5idXR0b24uQmFzZSA9IGdsb2JhbFRoaXMuTmVvLmJ1dHRvbi5CYXNlIHx8IHt9O1xuICAgICAqIC8vIHJldHVybiBnbG9iYWxUaGlzLk5lby5idXR0b24uQmFzZTtcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG5hbWVzIFRoZSBjbGFzcyBuYW1lIHN0cmluZyBjb250YWluaW5nIGRvdHMgb3IgYW4gQXJyYXkgb2YgdGhlIHN0cmluZyBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NyZWF0ZV0gU2V0IGNyZWF0ZSB0byB0cnVlIHRvIGNyZWF0ZSBlbXB0eSBvYmplY3RzIGZvciBub24tZXhpc3RpbmcgcGFydHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBTZXQgYSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9pbnQgYXMgZ2xvYmFsVGhpc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlZmVyZW5jZSB0byB0aGUgdG9wbGV2ZWwgbmFtZXNwYWNlXG4gICAgICovXG4gICAgbnMobmFtZXMsIGNyZWF0ZSwgc2NvcGUpIHtcbiAgICAgICAgbmFtZXMgPSBBcnJheS5pc0FycmF5KG5hbWVzKSA/IG5hbWVzIDogbmFtZXMuc3BsaXQoJy4nKTtcblxuICAgICAgICByZXR1cm4gbmFtZXMucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoY3JlYXRlICYmICFwcmV2W2N1cnJlbnRdKSB7XG4gICAgICAgICAgICAgICAgcHJldltjdXJyZW50XSA9IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZbY3VycmVudF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2NvcGUgfHwgZ2xvYmFsVGhpcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kZWQgdmVyc2lvbiBvZiBOZW8ubnMoKSB3aGljaCBzdXBwb3J0cyBtYXBwaW5nIGludG8gYXJyYXlzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG5hbWVzIFRoZSBjbGFzcyBuYW1lIHN0cmluZyBjb250YWluaW5nIGRvdHMgb3IgYW4gQXJyYXkgb2YgdGhlIHN0cmluZyBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NyZWF0ZV0gU2V0IGNyZWF0ZSB0byB0cnVlIHRvIGNyZWF0ZSBlbXB0eSBvYmplY3RzIGZvciBub24tZXhpc3RpbmcgcGFydHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBTZXQgYSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9pbnQgYXMgZ2xvYmFsVGhpc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlZmVyZW5jZSB0byB0aGUgdG9wbGV2ZWwgbmFtZXNwYWNlXG4gICAgICovXG4gICAgbnNXaXRoQXJyYXlzKG5hbWVzLCBjcmVhdGUsIHNjb3BlKSB7XG4gICAgICAgIG5hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZSAmJiAhcHJldltjdXJyZW50XSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5TnModHJ1ZSwgY3VycmVudCwgcHJldilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmV2W2N1cnJlbnRdID0ge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcnJheU5zKGZhbHNlLCBjdXJyZW50LCBwcmV2KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2W2N1cnJlbnRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNjb3BlIHx8IGdsb2JhbFRoaXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2VzIG9mIE5lbyBjbGFzc2VzIHVzaW5nIHRoZWlyIG50eXBlIGluc3RlYWQgb2YgdGhlIGNsYXNzIG5hbWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5udHlwZSgnYnV0dG9uJyB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8ubnR5cGUoe1xuICAgICAqICAgICBudHlwZSAgOiAnYnV0dG9uJyxcbiAgICAgKiAgICAgaWNvbkNsczogJ2ZhIGZhLWhvbWUnLFxuICAgICAqICAgICB0ZXh0ICAgOiAnSG9tZSdcbiAgICAgKiB9KTtcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbnR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuQmFzZX1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6TmVvLmNyZWF0ZSBjcmVhdGV9XG4gICAgICovXG4gICAgbnR5cGUobnR5cGUsIGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIG50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uZmlnID0gbnR5cGU7XG5cbiAgICAgICAgICAgIGlmICghY29uZmlnLm50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyBkZWZpbmVkIHdpdGggb2JqZWN0IGNvbmZpZ3VyYXRpb24gbWlzc2luZyBudHlwZSBwcm9wZXJ0eS4gJyArIGNvbmZpZy5udHlwZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbnR5cGUgPSBjb25maWcubnR5cGVcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjbGFzc05hbWUgPSBOZW8ubnR5cGVNYXBbbnR5cGVdO1xuXG4gICAgICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ250eXBlICcgKyBudHlwZSArICcgZG9lcyBub3QgZXhpc3QnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoY2xhc3NOYW1lLCBjb25maWcpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgdXNlZCBhdCB0aGUgZW5kIG9mIGVhY2ggY2xhc3MgLyBtb2R1bGUgZGVmaW5pdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0ge1R9IGNsc1xuICAgICAqIEByZXR1cm5zIHtUfVxuICAgICAqL1xuICAgIHNldHVwQ2xhc3MoY2xzKSB7XG4gICAgICAgIGxldCBiYXNlQ2ZnICAgID0gbnVsbCxcbiAgICAgICAgICAgIG50eXBlQ2hhaW4gPSBbXSxcbiAgICAgICAgICAgIHtudHlwZU1hcH0gPSBOZW8sXG4gICAgICAgICAgICBwcm90byAgICAgID0gY2xzLnByb3RvdHlwZSB8fCBjbHMsXG4gICAgICAgICAgICBucyAgICAgICAgID0gTmVvLm5zKHByb3RvLmNvbnN0cnVjdG9yLmNvbmZpZy5jbGFzc05hbWUsIGZhbHNlKSxcbiAgICAgICAgICAgIHByb3RvcyAgICAgPSBbXSxcbiAgICAgICAgICAgIGNmZywgY29uZmlnLCBjdG9yLCBudHlwZTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJZiB0aGUgbmFtZXNwYWNlIGFscmVhZHkgZXhpc3RzLCBkaXJlY3RseSByZXR1cm4gaXQuXG4gICAgICAgICAqIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHVzaW5nIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBuZW8ubWpzXG4gICAgICAgICAqID0+IEVzcGVjaWFsbHkgc2luZ2xldG9ucyAoSWRHZW5lcmF0b3IpIG11c3Qgc3RheSB1bmlxdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgY2FuIGFsc28gaGFwcGVuIHdoZW4gdXNpbmcgZGlmZmVyZW50IGVudmlyb25tZW50cyBvZiBuZW8ubWpzIGluIHBhcmFsbGVsLlxuICAgICAgICAgKiBFeGFtcGxlOiBjb2RlLkxpdmVQcmV2aWV3IHJ1bm5pbmcgaW5zaWRlIGEgZGlzdC9wcm9kdWN0aW9uIGFwcC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgcmV0dXJuIG5zXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocHJvdG8uX19wcm90b19fKSB7XG4gICAgICAgICAgICBjdG9yID0gcHJvdG8uY29uc3RydWN0b3I7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGN0b3IsICdjbGFzc0NvbmZpZ0FwcGxpZWQnKSkge1xuICAgICAgICAgICAgICAgIGJhc2VDZmcgICAgPSBOZW8uY2xvbmUoY3Rvci5jb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIG50eXBlQ2hhaW4gPSBbLi4uY3Rvci5udHlwZUNoYWluXTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm90b3MudW5zaGlmdChwcm90byk7XG4gICAgICAgICAgICBwcm90byA9IHByb3RvLl9fcHJvdG9fX1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnID0gYmFzZUNmZyB8fCB7fTtcblxuICAgICAgICBwcm90b3MuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGxldCBtaXhpbnM7XG5cbiAgICAgICAgICAgIGN0b3IgPSBlbGVtZW50LmNvbnN0cnVjdG9yO1xuXG4gICAgICAgICAgICBjZmcgPSBjdG9yLmNvbmZpZyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKE5lby5vdmVyd3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgY3Rvci5hcHBseU92ZXJ3cml0ZXM/LihjZmcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNmZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zbGljZSgtMSkgPT09ICdfJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2ZnW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGNmZ1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9HZW5lcmF0ZUdldFNldChlbGVtZW50LCBrZXkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYXBwbHkgcHJvcGVydGllcyB3aGljaCBoYXZlIG5vIHNldHRlcnMgaW5zaWRlIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgICAgICAgICAgICAvLyB0aG9zZSB3aWxsIGdldCBhcHBsaWVkIG9uIGNyZWF0ZSAoTmVvLmNvcmUuQmFzZSAtPiBpbml0Q29uZmlnKVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFOZW8uaGFzUHJvcGVydHlTZXR0ZXIoZWxlbWVudCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZSAgOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGNmZywgJ250eXBlJykpIHtcbiAgICAgICAgICAgICAgICBudHlwZSA9IGNmZy5udHlwZTtcblxuICAgICAgICAgICAgICAgIG50eXBlQ2hhaW4udW5zaGlmdChudHlwZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSdW5uaW5nIHRoZSBkb2NzIGFwcCBpbnNpZGUgYSB3b3Jrc3BhY2UgY2FuIHB1bGwgaW4gdGhlIHNhbWUgY2xhc3NlcyBmcm9tIGRpZmZlcmVudCByb290cyxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSB3YW50IHRvIGNoZWNrIGZvciBkaWZmZXJlbnQgY2xhc3MgbmFtZXMgYXMgd2VsbFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKG50eXBlTWFwLCBudHlwZSkgJiYgY2ZnLmNsYXNzTmFtZSAhPT0gbnR5cGVNYXBbbnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbnR5cGUgY29uZmxpY3QgZm9yICcke250eXBlfScgaW5zaWRlIHRoZSBjbGFzc2VzOlxcbiR7bnR5cGVNYXBbbnR5cGVdfVxcbiR7Y2ZnLmNsYXNzTmFtZX1gKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG50eXBlTWFwW250eXBlXSA9IGNmZy5jbGFzc05hbWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4aW5zID0gT2JqZWN0Lmhhc093bihjb25maWcsICdtaXhpbnMnKSAmJiBjb25maWcubWl4aW5zIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoY3Rvci5vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgICAgbWl4aW5zLnB1c2goJ05lby5jb3JlLk9ic2VydmFibGUnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihjZmcsICdtaXhpbnMnKSAmJiBBcnJheS5pc0FycmF5KGNmZy5taXhpbnMpICYmIGNmZy5taXhpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1peGlucy5wdXNoKC4uLmNmZy5taXhpbnMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaXhpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFwcGx5TWl4aW5zKGN0b3IsIG1peGlucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLm5zKCdOZW8uY29yZS5PYnNlcnZhYmxlJywgZmFsc2UsIGN0b3IucHJvdG90eXBlLm1peGlucykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Rvci5vYnNlcnZhYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGNmZy5taXhpbnM7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLm1peGlucztcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGNmZyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY3Rvciwge1xuICAgICAgICAgICAgICAgIGNsYXNzQ29uZmlnQXBwbGllZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWcgICAgICAgICAgICA6IE5lby5jbG9uZShjb25maWcsIHRydWUpLFxuICAgICAgICAgICAgICAgIGlzQ2xhc3MgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBudHlwZUNoYWluXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgIWNvbmZpZy5zaW5nbGV0b24gJiYgdGhpcy5hcHBseVRvR2xvYmFsTnMoY2xzKVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm90byA9IGNscy5wcm90b3R5cGUgfHwgY2xzO1xuXG4gICAgICAgIG50eXBlQ2hhaW4uZm9yRWFjaChudHlwZSA9PiB7XG4gICAgICAgICAgICBwcm90b1tgaXMke05lby5jYXBpdGFsaXplKE5lby5jYW1lbChudHlwZSkpfWBdID0gdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocHJvdG8uc2luZ2xldG9uKSB7XG4gICAgICAgICAgICBjbHMgPSBOZW8uY3JlYXRlKGNscyk7XG4gICAgICAgICAgICBOZW8uYXBwbHlUb0dsb2JhbE5zKGNscylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbHNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHR5cGVPZihpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlRGV0ZWN0b3JbdHlwZW9mIGl0ZW1dPy4oaXRlbSkgfHwgaXRlbS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgfVxufSwgTmVvKTtcblxuLyoqXG4gKiBMaXN0IG9mIGNsYXNzIHByb3BlcnRpZXMgd2hpY2ggYXJlIG5vdCBzdXBwb3NlZCB0byBnZXQgbWl4ZWQgaW50byBvdGhlciBjbGFzc2VzXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpZ25vcmVNaXhpbiA9IFtcbiAgICAnX25hbWUnLFxuICAgICdjbGFzc0NvbmZpZ0FwcGxpZWQnLFxuICAgICdjbGFzc05hbWUnLFxuICAgICdjb25zdHJ1Y3RvcicsXG4gICAgJ2lzQ2xhc3MnLFxuICAgICdtaXhpbicsXG4gICAgJ250eXBlJyxcbiAgICAnb2JzZXJ2YWJsZScsXG4gICAgJ3JlZ2lzdGVyVG9HbG9iYWxOcydcbl0sXG5cbiAgICBjaGFyc1JlZ2V4ICAgICAgICAgPSAvXFxkKy9nLFxuICAgIGV4dHJhY3RBcnJheXNSZWdleCA9IC9eKFxcdyspXFxzKigoPzpcXFtcXHMqXFxkK1xccypcXF1cXHMqKSopJC87XG5cbi8qKlxuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBjbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1peGluc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlNaXhpbnMoY2xzLCBtaXhpbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWl4aW5zKSkge1xuICAgICAgICBtaXhpbnMgPSBbbWl4aW5zXTtcbiAgICB9XG5cbiAgICBsZXQgaSAgICAgICAgICAgID0gMCxcbiAgICAgICAgbGVuICAgICAgICAgID0gbWl4aW5zLmxlbmd0aCxcbiAgICAgICAgbWl4aW5DbGFzc2VzID0ge30sXG4gICAgICAgIG1peGluLCBtaXhpbkNscywgbWl4aW5Qcm90bztcblxuICAgIGZvciAoO2kgPCBsZW47aSsrKSB7XG4gICAgICAgIG1peGluID0gbWl4aW5zW2ldO1xuXG4gICAgICAgIGlmIChtaXhpbi5pc0NsYXNzKSB7XG4gICAgICAgICAgICBtaXhpblByb3RvID0gbWl4aW4ucHJvdG90eXBlO1xuICAgICAgICAgICAgbWl4aW5DbHMgICA9IE5lby5ucyhtaXhpblByb3RvLmNsYXNzTmFtZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZXhpc3RzKG1peGluKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBtaXhpbiBhbiB1bmRlZmluZWQgY2xhc3M6ICcgKyBtaXhpbiArICcsICcgKyBjbHMucHJvdG90eXBlLmNsYXNzTmFtZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4aW5DbHMgICA9IE5lby5ucyhtaXhpbik7XG4gICAgICAgICAgICBtaXhpblByb3RvID0gbWl4aW5DbHMucHJvdG90eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWl4aW5Qcm90by5jbGFzc05hbWUuc3BsaXQoJy4nKS5yZWR1Y2UobWl4UmVkdWNlKG1peGluQ2xzKSwgbWl4aW5DbGFzc2VzKTtcblxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtaXhpblByb3RvKS5mb3JFYWNoKG1peGluUHJvcGVydHkoY2xzLnByb3RvdHlwZSwgbWl4aW5Qcm90bykpXG4gICAgfVxuXG4gICAgY2xzLnByb3RvdHlwZS5taXhpbnMgPSBtaXhpbkNsYXNzZXMgLy8gdG9kbzogd2Ugc2hvdWxkIGRvIGEgZGVlcCBtZXJnZVxufVxuXG4vKipcbiAqIENyZWF0ZXMgZ2V0IC8gc2V0IG1ldGhvZHMgZm9yIGNsYXNzIGNvbmZpZ3MgZW5kaW5nIHdpdGggYW4gdW5kZXJzY29yZVxuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBwcm90b1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHByaXZhdGVcbiAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICovXG5mdW5jdGlvbiBhdXRvR2VuZXJhdGVHZXRTZXQocHJvdG8sIGtleSkge1xuICAgIGlmIChOZW8uaGFzUHJvcGVydHlTZXR0ZXIocHJvdG8sIGtleSkpIHtcbiAgICAgICAgdGhyb3coJ0NvbmZpZyAnICsga2V5ICsgJ18gKCcgKyBwcm90by5jbGFzc05hbWUgKyAnKSBhbHJlYWR5IGhhcyBhIHNldCBtZXRob2QsIHVzZSBiZWZvcmVHZXQsIGJlZm9yZVNldCAmIGFmdGVyU2V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmICghTmVvW2dldFNldENhY2hlXSkge1xuICAgICAgICBOZW9bZ2V0U2V0Q2FjaGVdID0ge31cbiAgICB9XG5cbiAgICBpZiAoIU5lb1tnZXRTZXRDYWNoZV1ba2V5XSkge1xuICAgICAgICBOZW9bZ2V0U2V0Q2FjaGVdW2tleV0gPSB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUdldCA9IGBiZWZvcmVHZXQke2tleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpfWAsXG4gICAgICAgICAgICAgICAgICAgIGhhc05ld0tleSA9IE9iamVjdC5oYXNPd24obWVbY29uZmlnU3ltYm9sXSwga2V5KSxcbiAgICAgICAgICAgICAgICAgICAgbmV3S2V5ICAgID0gbWVbY29uZmlnU3ltYm9sXVtrZXldLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgPSBoYXNOZXdLZXkgPyBuZXdLZXkgOiBtZVsnXycgKyBrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdpdGVtcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gWy4uLnZhbHVlXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZS52YWx1ZU9mKCkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhc05ld0tleSkge1xuICAgICAgICAgICAgICAgICAgICBtZVtrZXldID0gdmFsdWU7IC8vIHdlIGRvIHdhbnQgdG8gdHJpZ2dlciB0aGUgc2V0dGVyID0+IGJlZm9yZVNldCwgYWZ0ZXJTZXRcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtZVsnXycgKyBrZXldOyAvLyByZXR1cm4gdGhlIHZhbHVlIHBhcnNlZCBieSB0aGUgc2V0dGVyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdW2tleV1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lW2JlZm9yZUdldF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtZVtiZWZvcmVHZXRdKHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIF9rZXkgICAgICA9ICdfJyArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdUtleSAgICAgID0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVNldCA9ICdiZWZvcmVTZXQnICsgdUtleSxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJTZXQgID0gJ2FmdGVyU2V0JyAgKyB1S2V5LFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSAgPSBtZVtfa2V5XTtcblxuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5IHNldCBjYWxsIGhhcyB0byBkZWxldGUgdGhlIG1hdGNoaW5nIHN5bWJvbFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnaXRlbXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLmNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdlIGRvIHdhbnQgdG8gc3RvcmUgdGhlIHZhbHVlIGJlZm9yZSB0aGUgYmVmb3JlU2V0IG1vZGlmaWNhdGlvbiBhcyB3ZWxsLFxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGNvdWxkIGdldCBwdWxsZWQgYnkgb3RoZXIgYmVmb3JlU2V0IG1ldGhvZHMgb2YgZGlmZmVyZW50IGNvbmZpZ3NcbiAgICAgICAgICAgICAgICBtZVtfa2V5XSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZVtiZWZvcmVTZXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWVbYmVmb3JlU2V0XSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgZG9uJ3QgcmV0dXJuIGEgdmFsdWUsIHRoYXQgbWVhbnMgbm8gY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZVtfa2V5XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtZVtfa2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGtleSA9PT0gJ3Zub2RlJyAmJiB2YWx1ZSAhPT0gb2xkVmFsdWUpIHx8IC8vIHZub2RlIHRyZWVzIGNhbiBiZSBodWdlLCBhdm9pZCBhIGRlZXAgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICAhTmVvLmlzRXF1YWwodmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBtZVthZnRlclNldF0/Lih2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBtZS5hZnRlclNldENvbmZpZz8uKGtleSwgdmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywga2V5LCBOZW9bZ2V0U2V0Q2FjaGVdW2tleV0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtCb29sZWFufSBjcmVhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJldlxuICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5TnMoY3JlYXRlLCBjdXJyZW50LCBwcmV2KSB7XG4gICAgbGV0IGFyckRldGFpbHMgPSBwYXJzZUFycmF5RnJvbVN0cmluZyhjdXJyZW50KSxcbiAgICAgICAgaSAgICAgICAgICA9IDEsXG4gICAgICAgIGxlbiAgICAgICAgPSBhcnJEZXRhaWxzLmxlbmd0aCxcbiAgICAgICAgYXJySXRlbSwgYXJyUm9vdDtcblxuICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgcHJldlthcnJEZXRhaWxzWzBdXSA9IGFyclJvb3QgPSBwcmV2W2FyckRldGFpbHNbMF1dIHx8IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyUm9vdCA9IHByZXZbYXJyRGV0YWlsc1swXV1cbiAgICB9XG5cbiAgICBpZiAoIWFyclJvb3QpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhcnJJdGVtID0gcGFyc2VJbnQoYXJyRGV0YWlsc1tpXSk7XG5cbiAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgYXJyUm9vdFthcnJJdGVtXSA9IGFyclJvb3RbYXJySXRlbV0gfHwge31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyclJvb3QgPSBhcnJSb290W2Fyckl0ZW1dXG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclJvb3Rcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGNsYXNzIG5hbWUgZXhpc3RzIGluc2lkZSB0aGUgTmVvIG9yIGFwcCBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXhpc3RzKGNsYXNzTmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIWNsYXNzTmFtZS5zcGxpdCgnLicpLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZbY3VycmVudF1cbiAgICAgICAgfSwgZ2xvYmFsVGhpcylcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gcHJvdG9cbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gbWl4aW5Qcm90b1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWl4aW5Qcm9wZXJ0eShwcm90bywgbWl4aW5Qcm90bykge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKH5pZ25vcmVNaXhpbi5pbmRleE9mKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3RvW2tleV0/Ll9mcm9tKSB7XG4gICAgICAgICAgICBpZiAobWl4aW5Qcm90by5jbGFzc05hbWUgPT09IHByb3RvW2tleV0uX2Zyb20pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01peGluIHNldCBtdWx0aXBsZSB0aW1lcyBvciBhbHJlYWR5IGRlZmluZWQgb24gYSBCYXNlIENsYXNzJywgcHJvdG8uY2xhc3NOYW1lLCBtaXhpblByb3RvLmNsYXNzTmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGAke3Byb3RvLmNsYXNzTmFtZX06IE11bHRpcGxlIG1peGlucyBkZWZpbmluZyBzYW1lIHByb3BlcnR5ICgke21peGluUHJvdG8uY2xhc3NOYW1lfSwgJHtwcm90b1trZXldLl9mcm9tfSkgPT4gJHtrZXl9YFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG9ba2V5XSA9IG1peGluUHJvdG9ba2V5XTtcblxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpLl9mcm9tID0gbWl4aW5Qcm90by5jbGFzc05hbWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm90b1trZXldLl9uYW1lID0ga2V5XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIG1peGluQ2xzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtaXhSZWR1Y2UobWl4aW5DbHMpIHtcbiAgICByZXR1cm4gKHByZXYsIGN1cnJlbnQsIGlkeCwgYXJyKSA9PiB7XG4gICAgICAgIHJldHVybiBwcmV2W2N1cnJlbnRdID0gaWR4ICE9PSBhcnIubGVuZ3RoIC0xID8gcHJldltjdXJyZW50XSB8fCB7fSA6IG1peGluQ2xzXG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXJyYXlGcm9tU3RyaW5nKHN0cikge1xuICAgIHJldHVybiAoZXh0cmFjdEFycmF5c1JlZ2V4LmV4ZWMoc3RyKSB8fCBbbnVsbF0pLnNsaWNlKDEpLnJlZHVjZShcbiAgICAgICAgKGZ1biwgYXJncykgPT4gW2Z1bl0uY29uY2F0KGFyZ3MubWF0Y2goY2hhcnNSZWdleCkpXG4gICAgKVxufVxuXG5OZW8uY29uZmlnID0gTmVvLmNvbmZpZyB8fCB7fTtcblxuTmVvLmFzc2lnbkRlZmF1bHRzKE5lby5jb25maWcsIERlZmF1bHRDb25maWcpO1xuXG5leHBvcnQgZGVmYXVsdCBOZW87XG4iLCJpbXBvcnQgQ29yZUJhc2UgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBGaWx0ZXIgICAgIGZyb20gJy4vRmlsdGVyLm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICBmcm9tICcuLi91dGlsL0xvZ2dlci5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgU29ydGVyICAgICBmcm9tICcuL1NvcnRlci5tanMnO1xuXG5jb25zdCBjb3VudE11dGF0aW9ucyAgID0gU3ltYm9sKCdjb3VudE11dGF0aW9ucycpLFxuICAgICAgaXNGaWx0ZXJlZCAgICAgICA9IFN5bWJvbCgnaXNGaWx0ZXJlZCcpLFxuICAgICAgaXNTb3J0ZWQgICAgICAgICA9IFN5bWJvbCgnaXNTb3J0ZWQnKSxcbiAgICAgIHNpbGVudFVwZGF0ZU1vZGUgPSBTeW1ib2woJ3NpbGVudFVwZGF0ZU1vZGUnKSxcbiAgICAgIHRvQWRkQXJyYXkgICAgICAgPSBTeW1ib2woJ3RvQWRkQXJyYXknKSxcbiAgICAgIHRvUmVtb3ZlQXJyYXkgICAgPSBTeW1ib2woJ3RvUmVtb3ZlQXJyYXknKSxcbiAgICAgIHVwZGF0aW5nSW5kZXggICAgPSBTeW1ib2woJ3VwZGF0aW5nSW5kZXgnKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbGxlY3Rpb24uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb2xsZWN0aW9uLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb2xsZWN0aW9uLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29sbGVjdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb2xsZWN0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gZmlsdGVyaW5nIHRoZSBjb2xsZWN0aW9uIGZvciB0aGUgZmlyc3QgdGltZSwgYWxsSXRlbXMgd2lsbCBiZWNvbWUgYSBuZXcgY29sbGVjdGlvbiBmb3IgdGhlIHVuZmlsdGVyZWRcbiAgICAgICAgICogc3RhdGUsIHVzaW5nIHRoaXMgaWQgYXMgdGhlIHNvdXJjZUNvbGxlY3Rpb25JZFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IGFsbEl0ZW1zPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYWxsSXRlbXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNvcnQgdGhlIGNvbGxlY3Rpb24gaXRlbXMgd2hlbiBhZGRpbmcgLyBpbnNlcnRpbmcgbmV3IG9uZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b1NvcnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1NvcnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgJ3ByaW1pdGl2ZScgZm9yIGRlZmF1bHQgZmlsdGVycywgdXNlICdhZHZhbmNlZCcgZm9yIGZpbHRlcnMgdXNpbmcgYSBmaWx0ZXJCeSBtZXRob2RcbiAgICAgICAgICogd2hpY2ggbmVlZCB0byBpdGVyYXRlIG92ZXIgb3RoZXIgY29sbGVjdGlvbiBpdGVtc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGZpbHRlck1vZGU9J3ByaW1pdGl2ZSdcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlck1vZGU6ICdwcmltaXRpdmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gQXJyYXkgY29udGFpbmluZyBOZW8udXRpbC5GaWx0ZXIgY29uZmlnIG9iamVjdHMgb3IgaW5zdGFuY2VzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBmaWx0ZXJzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W118bnVsbH0gaXRlbXNfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmlxdWUoISkga2V5IHByb3BlcnR5IG9mIGVhY2ggY29sbGVjdGlvbiBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHk9J2lkJ1xuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHk6ICdpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpbmcgbmV3IGl0ZW1zIHdpdGhvdXQgYW4gaWQgKGtleVByb3BlcnR5KSB3aWxsIHVzZSBhIG5lZ2F0aXZlIGluZGV4LCB3aGljaCB3aWxsIGRlY3JlYXNlIGJ5IC0xXG4gICAgICAgICAqIGZvciBlYWNoIG5ldyBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0ga2V5UHJvcGVydHlJbmRleD0tMVxuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHlJbmRleDogLTEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBjb250YWluaW5nIHRoZSBrZXkgJiByZWZlcmVuY2Ugb2YgZWFjaCBjb2xsZWN0aW9uIGl0ZW0gZm9yIGZhc3RlciBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7TWFwfSBtYXBfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWFwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIEFycmF5IG9mIHRoZSBzb3J0IGRpcmVjdGlvbnMgZm9yIGZhc3RlciBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IHNvcnREaXJlY3Rpb25zPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydERpcmVjdGlvbnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlcm5hbCBBcnJheSBvZiB0aGUgc29ydCBwcm9wZXJ0aWVzIGZvciBmYXN0ZXIgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBzb3J0UHJvcGVydGllcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRQcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gQXJyYXkgY29udGFpbmluZyBOZW8udXRpbC5Tb3J0ZXIgY29uZmlnIG9iamVjdHMgb3IgaW5zdGFuY2VzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBzb3J0ZXJzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGVyc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkIG9mIGFub3RoZXIgY29sbGVjdGlvbiBpbnN0YW5jZSB0byB1c2UgYXMgdGhpcyBkYXRhIHNvdXJjZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc291cmNlSWRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvdXJjZUlkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3ltYm9sQ29uZmlnID0ge2VudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZX07XG5cbiAgICAgICAgbWUuaXRlbXMgPSBtZS5pdGVtcyB8fCBbXTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZSwge1xuICAgICAgICAgICAgW2NvdW50TXV0YXRpb25zXSAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW2lzRmlsdGVyZWRdICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW2lzU29ydGVkXSAgICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW3NpbGVudFVwZGF0ZU1vZGVdOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW3RvQWRkQXJyYXldICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW3RvUmVtb3ZlQXJyYXldICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW3VwZGF0aW5nSW5kZXhdICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogMH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1lLmF1dG9Tb3J0ICYmIG1lLl9zb3J0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1lLmRvU29ydCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIGl0ZW1zIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbSBUaGUgaXRlbShzKSB0byBhZGRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119IGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGFkZGVkIGl0ZW1zXG4gICAgICovXG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKG51bGwsIG51bGwsIGl0ZW0pLmFkZGVkSXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZpbHRlciA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmxpc3RlbmVyQXBwbGllZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIub24oJ2NoYW5nZScsIG1lLm9uRmlsdGVyQ2hhbmdlLCBtZSk7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmxpc3RlbmVyQXBwbGllZCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2xkVmFsdWUgJiYgbWUuZmlsdGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXRlbXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtrZXlQcm9wZXJ0eX0gPSBtZSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgICAgID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbaV07XG4gICAgICAgICAgICAgICAgbWUubWFwLnNldChpdGVtW2tleVByb3BlcnR5XSwgaXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFwcGx5U29ydGVyQ29uZmlncygpO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goc29ydGVyID0+IHtcbiAgICAgICAgICAgIGlmIChzb3J0ZXIubGlzdGVuZXJBcHBsaWVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHNvcnRlci5vbignY2hhbmdlJywgbWUub25Tb3J0ZXJDaGFuZ2UsIG1lKTtcbiAgICAgICAgICAgICAgICBzb3J0ZXIubGlzdGVuZXJBcHBsaWVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5hdXRvU29ydCAmJiBtZS5kb1NvcnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U291cmNlSWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc291cmNlID0gTmVvLmdldCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIG1lLl9pdGVtcyA9IFsuLi5zb3VyY2UuX2l0ZW1zXTtcbiAgICAgICAgICAgIG1lLm1hcCAgICA9IG5ldyBNYXAoc291cmNlLm1hcCk7IC8vIGNyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgbWFwXG5cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyc0NvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBtdXRhdGU6IG1lLm9uTXV0YXRlLFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNvdXJjZS5vbihsaXN0ZW5lcnNDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBOZW8uZ2V0KG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzb3VyY2UudW4obGlzdGVuZXJzQ29uZmlnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIHNvcnQgcHJvcGVydHkgJiBkaXJlY3Rpb24gbXVsdGlwbGllciBvZiBlYWNoIHNvcnRlciBpbnNpZGUgMiBhcnJheXMgZm9yIGZhc3RlciBhY2Nlc3Mgd2hlbiBzb3J0aW5nXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFwcGx5U29ydGVyQ29uZmlncygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zb3J0RGlyZWN0aW9ucyA9IFtdO1xuICAgICAgICBtZS5zb3J0UHJvcGVydGllcyA9IFtdO1xuXG4gICAgICAgIG1lLnNvcnRlcnMuZm9yRWFjaChzb3J0ZXIgPT4gey8vY29uc29sZS5sb2coJ2ZvckVhY2gnLCBzb3J0ZXIpO1xuICAgICAgICAgICAgbWUuc29ydERpcmVjdGlvbnMucHVzaChzb3J0ZXIuZGlyZWN0aW9uTXVsdGlwbGllcik7XG4gICAgICAgICAgICBtZS5zb3J0UHJvcGVydGllcy5wdXNoKHNvcnRlci5wcm9wZXJ0eSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyBbdmFsdWVdIDogW11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSBvbGRWYWx1ZSAmJiBvbGRWYWx1ZS5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGhhc01hdGNoLCBpO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWVbaV0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVbaV0uc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjoga2V5Lm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBrZXkucHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgICA6IGtleS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVtpXS5vcGVyYXRvciA9PT0gKGtleS5vcGVyYXRvciB8fCAnPT09JykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldLnByb3BlcnR5ID09PSBrZXkucHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldLnZhbHVlICAgID09PSBrZXkudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gTmVvLmNyZWF0ZShGaWx0ZXIsIGtleSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gb2xkVmFsdWVbaV07XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGxlbi0tXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgb2xkVmFsdWUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGtleS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNYXB8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge01hcHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUgPyBuZXcgTWFwKCkgOiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U29ydGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IFt2YWx1ZV0gOiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxlbiA9IG9sZFZhbHVlPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGhhc01hdGNoLCBpO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICAgICAgbGV0IHtkaXJlY3Rpb24sIHByb3BlcnR5fSA9IGtleTtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlW2ldID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldLnNldCh7ZGlyZWN0aW9uLCBwcm9wZXJ0eX0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlW2ldLnByb3BlcnR5ID09PSBwcm9wZXJ0eSAmJiBvbGRWYWx1ZVtpXS5kaXJlY3Rpb24gPT09IGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IE5lby5jcmVhdGUoU29ydGVyLCBrZXkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IG9sZFZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBsZW4tLVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBvbGRWYWx1ZT8uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5LmRlc3Ryb3koKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWNoZVVwZGF0ZShvcHRzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjYWNoZVVwZGF0ZScsIG9wdHMsIHRoaXNbdG9BZGRBcnJheV0pO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2tleVByb3BlcnR5fSA9IG1lLFxuICAgICAgICAgICAgaW5kZXgsIHRvQWRkTWFwLCB0b1JlbW92ZU1hcDtcblxuICAgICAgICBpZiAoIW1lW3NpbGVudFVwZGF0ZU1vZGVdKSB7XG4gICAgICAgICAgICB0b0FkZE1hcCAgICA9IG1lW3RvQWRkQXJyYXldICAgLm1hcChlID0+IGVba2V5UHJvcGVydHldKTtcbiAgICAgICAgICAgIHRvUmVtb3ZlTWFwID0gbWVbdG9SZW1vdmVBcnJheV0ubWFwKGUgPT4gZVtrZXlQcm9wZXJ0eV0pO1xuXG4gICAgICAgICAgICBvcHRzLmFkZGVkSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPSB0b1JlbW92ZU1hcC5pbmRleE9mKGl0ZW1ba2V5UHJvcGVydHldKSA+IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtZVt0b1JlbW92ZUFycmF5XS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b0FkZE1hcC5pbmRleE9mKGl0ZW1ba2V5UHJvcGVydHldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVbdG9BZGRBcnJheV0ucHVzaChpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvcHRzLnJlbW92ZWRJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9IHRvQWRkTWFwLmluZGV4T2YoaXRlbVtrZXlQcm9wZXJ0eV0pID4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lW3RvQWRkQXJyYXldLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvUmVtb3ZlTWFwLmluZGV4T2YoaXRlbVtrZXlQcm9wZXJ0eV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtZVt0b1JlbW92ZUFycmF5XS5wdXNoKGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGl0ZW1zIGFuZCBjbGVhcnMgdGhlIG1hcFxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnNwbGljZSgwLCB0aGlzLmdldENvdW50KCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjdXJyZW50IGZpbHRlcnMgYW5kIG9wdGlvbmFsbHkgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIG9uZXMgaW4gY2FzZSB0aGV5IGV4aXN0ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVzdG9yZU9yaWdpbmFsRmlsdGVycz1mYWxzZV1cbiAgICAgKi9cbiAgICBjbGVhckZpbHRlcnMocmVzdG9yZU9yaWdpbmFsRmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSByZXN0b3JlT3JpZ2luYWxGaWx0ZXJzID8gTmVvLmNsb25lKHRoaXMub3JpZ2luYWxDb25maWcuZmlsdGVycywgdHJ1ZSwgdHJ1ZSkgOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaXRlbXMgYW5kIGNsZWFycyB0aGUgbWFwLCB3aXRob3V0IGZpcmluZyBhIG11dGF0ZSBldmVudFxuICAgICAqL1xuICAgIGNsZWFyU2lsZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9pdGVtcy5zcGxpY2UoMCwgbWUuZ2V0Q291bnQoKSk7XG4gICAgICAgIG1lLm1hcC5jbGVhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjdXJyZW50IHNvcnRlcnMgYW5kIG9wdGlvbmFsbHkgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIG9uZXMgaW4gY2FzZSB0aGV5IGV4aXN0ZWQuXG4gICAgICogV2l0aG91dCByZXN0b3JlSW5pdGlhbFN0YXRlIGFzIHRydWUgdGhpcyB3aWxsIG5vdCBhZmZlY3QgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVzdG9yZU9yaWdpbmFsU29ydGVycz1mYWxzZV1cbiAgICAgKi9cbiAgICBjbGVhclNvcnRlcnMocmVzdG9yZU9yaWdpbmFsU29ydGVycykge1xuICAgICAgICB0aGlzLnNvcnRlcnMgPSByZXN0b3JlT3JpZ2luYWxTb3J0ZXJzID8gTmVvLmNsb25lKHRoaXMub3JpZ2luYWxDb25maWcuc29ydGVycywgdHJ1ZSwgdHJ1ZSkgOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5jb2xsZWN0aW9uLkJhc2V9IFRoZSBjbG9uZWQgY29sbGVjdGlvblxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgID0gTmVvLmNsb25lKG1lLm9yaWdpbmFsQ29uZmlnLCB0cnVlKSxcbiAgICAgICAgICAgIGZpbHRlcnMgPSBtZS5fZmlsdGVycyB8fCBbXSxcbiAgICAgICAgICAgIHNvcnRlcnMgPSBtZS5fc29ydGVycyB8fCBbXTtcblxuICAgICAgICBkZWxldGUgY29uZmlnLmlkO1xuICAgICAgICBkZWxldGUgY29uZmlnLmZpbHRlcnM7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuaXRlbXM7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuc29ydGVycztcblxuICAgICAgICBpZiAobWUuX2l0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5pdGVtcyA9IFsuLi5tZS5faXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuZmlsdGVycyA9IFtdO1xuICAgICAgICBjb25maWcuc29ydGVycyA9IFtdO1xuXG4gICAgICAgIC8vIHRvZG86IGZpbHRlcnMgJiBzb3J0ZXJzIHNob3VsZCBwdXNoIHRoZWlyIGN1cnJlbnQgc3RhdGUgYW5kIG5vdCB0aGUgb3JpZ2luYWwgb25lXG5cbiAgICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgICAgY29uZmlnLmZpbHRlcnMucHVzaChmaWx0ZXIub3JpZ2luYWxDb25maWcpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvcnRlcnMuZm9yRWFjaChmdW5jdGlvbihzb3J0ZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zb3J0ZXJzLnB1c2goc29ydGVyLm9yaWdpbmFsQ29uZmlnKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZShCYXNlLCBjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBtYXAgJiBpdGVtcyBhcnJheSBiZWZvcmUgdGhlIHN1cGVyIGNhbGxcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9pdGVtcy5zcGxpY2UoMCwgbWUuX2l0ZW1zLmxlbmd0aCk7XG4gICAgICAgIG1lLm1hcC5jbGVhcigpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXM9dGhpcy5faXRlbXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkb1NvcnQoaXRlbXM9dGhpcy5faXRlbXMsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcHJldmlvdXNJdGVtcyAgICAgPSBbLi4uaXRlbXNdLFxuICAgICAgICAgICAge3NvcnRlcnMsIHNvcnREaXJlY3Rpb25zLCBzb3J0UHJvcGVydGllc30gPSBtZSxcbiAgICAgICAgICAgIGNvdW50U29ydGVycyAgICAgID0gc29ydFByb3BlcnRpZXMubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBoYXNTb3J0QnlNZXRob2QgICA9IGZhbHNlLFxuICAgICAgICAgICAgaGFzVHJhbnNmb3JtVmFsdWUgPSBmYWxzZSxcbiAgICAgICAgICAgIGksIG1hcHBlZEl0ZW1zLCBvYmosIHNvcnRlciwgc29ydFByb3BlcnR5LCBzb3J0VmFsdWU7XG5cbiAgICAgICAgaWYgKGNvdW50U29ydGVycyA+IDApIHtcbiAgICAgICAgICAgIHNvcnRlcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc29ydEJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NvcnRCeU1ldGhvZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnVzZVRyYW5zZm9ybVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1RyYW5zZm9ybVZhbHVlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaGFzU29ydEJ5TWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWUuX2l0ZW1zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBjb3VudFNvcnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVyICAgID0gc29ydGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRWYWx1ZSA9IHNvcnRlcltzb3J0ZXIuc29ydEJ5ID8gJ3NvcnRCeScgOiAnZGVmYXVsdFNvcnRCeSddKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydFZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNTb3J0aW5nX3dpdGhfbWFwXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZEl0ZW1zID0gaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0ge2luZGV4fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgICA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY291bnRTb3J0ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGVyc1tpXS51c2VUcmFuc2Zvcm1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbc29ydFByb3BlcnRpZXNbaV1dID0gc29ydGVyc1tpXS50cmFuc2Zvcm1WYWx1ZShpdGVtW3NvcnRQcm9wZXJ0aWVzW2ldXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbc29ydFByb3BlcnRpZXNbaV1dID0gaXRlbVtzb3J0UHJvcGVydGllc1tpXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVkSXRlbXMgPSBpdGVtc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hcHBlZEl0ZW1zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBjb3VudFNvcnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydFByb3BlcnR5ID0gc29ydFByb3BlcnRpZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW3NvcnRQcm9wZXJ0eV0gPiBiW3NvcnRQcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAqIHNvcnREaXJlY3Rpb25zW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW3NvcnRQcm9wZXJ0eV0gPCBiW3NvcnRQcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBzb3J0RGlyZWN0aW9uc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNUcmFuc2Zvcm1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5faXRlbXMgPSBtYXBwZWRJdGVtcy5tYXAoZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zW2VsLmluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lW2lzU29ydGVkXSA9IGNvdW50U29ydGVycyA+IDA7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQgJiYgbWVbdXBkYXRpbmdJbmRleF0gPT09IDApIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3NvcnQnLCB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG1lLl9pdGVtcyxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0l0ZW1zLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgdGhlIGNvbGxlY3Rpb24gZXZlbnRzLlxuICAgICAqIElmIHlvdSBzdGFydGVkIGFuIHVwZGF0ZSB1c2luZyB0aGUgc3RhcnRTaWxlbnRVcGRhdGVNb2RlIGZsYWcsXG4gICAgICogeW91IG11c3QgdXNlIHRoZSBlbmRTaWxlbnRVcGRhdGVNb2RlIHBhcmFtIGZvciB0aGlzIGNhbGwuXG4gICAgICogVXNpbmcgdGhlIGVuZFNpbGVudFVwZGF0ZU1vZGUgcGFyYW0gd2lsbCBub3QgZmlyZSBhIG11dGF0aW9uIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VuZFNpbGVudFVwZGF0ZU1vZGVdXG4gICAgICogQHNlZSB7QGxpbmsgTmVvLmNvbGxlY3Rpb24uQmFzZSNzdGFydFVwZGF0ZSBzdGFydFVwZGF0ZX1cbiAgICAgKi9cbiAgICBlbmRVcGRhdGUoZW5kU2lsZW50VXBkYXRlTW9kZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lW3VwZGF0aW5nSW5kZXhdID4gMCkge1xuICAgICAgICAgICAgbWVbdXBkYXRpbmdJbmRleF0tLVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZFNpbGVudFVwZGF0ZU1vZGUpIHtcbiAgICAgICAgICAgIG1lW3NpbGVudFVwZGF0ZU1vZGVdID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ211dGF0ZScsIHtcbiAgICAgICAgICAgICAgICBhZGRlZEl0ZW1zICA6IG1lW3RvQWRkQXJyYXldLFxuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtczogbWVbdG9SZW1vdmVBcnJheV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZVt0b0FkZEFycmF5XSAgIC5zcGxpY2UoMCwgbWVbdG9BZGRBcnJheV0gICAubGVuZ3RoKTtcbiAgICAgICAgICAgIG1lW3RvUmVtb3ZlQXJyYXldLnNwbGljZSgwLCBtZVt0b1JlbW92ZUFycmF5XS5sZW5ndGgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIHJlbW90ZSBmaWx0ZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgZXhwb3J0RmlsdGVycygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmlsdGVycyA9IFtdLFxuICAgICAgICAgICAgZmlsdGVyO1xuXG4gICAgICAgIG1lLmZpbHRlcnM/LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGZpbHRlciA9IGtleS5leHBvcnQoKTtcblxuICAgICAgICAgICAgZmlsdGVyICYmIGZpbHRlcnMucHVzaChmaWx0ZXIpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciByZW1vdGUgc29ydGluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBleHBvcnRTb3J0ZXJzKCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzb3J0ZXJzID0gW10sXG4gICAgICAgICAgICBzb3J0ZXI7XG5cbiAgICAgICAgbWUuc29ydGVycz8uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgc29ydGVyID0ga2V5LmV4cG9ydCgpO1xuXG4gICAgICAgICAgICBzb3J0ZXIgJiYgc29ydGVycy5wdXNoKHNvcnRlcilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNvcnRlcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZmlsdGVyKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpbHRlcnMgICAgICAgICA9IG1lLl9maWx0ZXJzLFxuICAgICAgICAgICAgY291bnRBbGxGaWx0ZXJzID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICAgICAgICBjb3VudEZpbHRlcnMgICAgPSAwLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICAgID0gbWUuYWxsSXRlbXM/Ll9pdGVtcyB8fCBtZS5faXRlbXMsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgY291bnRJdGVtcyAgICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcyAgID0gW10sXG4gICAgICAgICAgICBuZWVkc1NvcnRpbmcgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG9sZEl0ZW1zICAgICAgICA9IFsuLi5tZS5faXRlbXNdLFxuICAgICAgICAgICAgY29uZmlnLCBpc0luY2x1ZGVkLCBpdGVtLCBqLCB0bXBJdGVtcztcblxuICAgICAgICBmb3IgKDsgaSA8IGNvdW50QWxsRmlsdGVyczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcnNbaV0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjb3VudEZpbHRlcnMrK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvdW50RmlsdGVycyA9PT0gMCAmJiBtZS5hbGxJdGVtcykge1xuICAgICAgICAgICAgaWYgKG1lLnNvcnRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5lZWRzU29ydGluZyA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuY2xlYXJTaWxlbnQoKTtcblxuICAgICAgICAgICAgbWUuaXRlbXMgPSBbLi4ubWUuYWxsSXRlbXMuX2l0ZW1zXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtZS5hbGxJdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHsuLi5tZS5vcmlnaW5hbENvbmZpZ307XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLmZpbHRlcnM7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5pdGVtcztcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLnNvcnRlcnM7XG5cbiAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcyA9IE5lby5jcmVhdGUoQmFzZSwge1xuICAgICAgICAgICAgICAgICAgICAuLi5OZW8uY2xvbmUoY29uZmlnLCB0cnVlLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAga2V5UHJvcGVydHk6IG1lLmtleVByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZCAgIDogbWUuaWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5tYXAuY2xlYXIoKTtcblxuICAgICAgICAgICAgaWYgKG1lLmZpbHRlck1vZGUgPT09ICdwcmltaXRpdmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgZm9yIGxvb3BzIG9uIHB1cnBvc2UgLT4gcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRJdGVtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpdGVtICAgICAgID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGogICAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgY291bnRBbGxGaWx0ZXJzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzW2pdLmlzRmlsdGVyZWQoaXRlbSwgaXRlbXMsIGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5jbHVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm1hcC5zZXQoaXRlbVttZS5rZXlQcm9wZXJ0eV0sIGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5faXRlbXMgPSBmaWx0ZXJlZEl0ZW1zIC8vIHNpbGVudCB1cGRhdGUsIHRoZSBtYXAgaXMgYWxyZWFkeSBpbiBwbGFjZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zID0gWy4uLml0ZW1zXTtcblxuICAgICAgICAgICAgICAgIGZvciAoaj0wOyBqIDwgY291bnRBbGxGaWx0ZXJzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wSXRlbXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRJdGVtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlcnNbal0uaXNGaWx0ZXJlZChmaWx0ZXJlZEl0ZW1zW2ldLCBmaWx0ZXJlZEl0ZW1zLCBpdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBJdGVtcy5wdXNoKGZpbHRlcmVkSXRlbXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zID0gWy4uLnRtcEl0ZW1zXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRJdGVtcyAgICA9IGZpbHRlcmVkSXRlbXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuaXRlbXMgPSBmaWx0ZXJlZEl0ZW1zIC8vIHVwZGF0ZSB0aGUgbWFwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZVtpc0ZpbHRlcmVkXSA9IGNvdW50RmlsdGVycyAhPT0gMDtcblxuICAgICAgICBpZiAobmVlZHNTb3J0aW5nKSB7XG4gICAgICAgICAgICBtZS5kb1NvcnQobWUuaXRlbXMsIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5maXJlKCdmaWx0ZXInLCB7XG4gICAgICAgICAgICBpc0ZpbHRlcmVkOiBtZVtpc0ZpbHRlcmVkXSxcbiAgICAgICAgICAgIGl0ZW1zICAgICA6IG1lLml0ZW1zLFxuICAgICAgICAgICAgb2xkSXRlbXMsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbXMgd2hpY2ggbWF0Y2ggdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFt2YWx1ZV0gT25seSByZXF1aXJlZCBpbiBjYXNlIHRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W119XG4gICAgICogICAgIHJldHVybkZpcnN0TWF0Y2g9ZmFsc2U6IFJldHVybnMgYW4gZW1wdHkgQXJyYXkgaW4gY2FzZSBubyBpdGVtcyBhcmUgZm91bmRcbiAgICAgKiAgICAgcmV0dXJuRmlyc3RNYXRjaD10cnVlOiAgUmV0dXJucyB0aGUgZmlyc3QgZm91bmQgaXRlbSBvciBudWxsXG4gICAgICovXG4gICAgZmluZChwcm9wZXJ0eSwgdmFsdWUsIHJldHVybkZpcnN0TWF0Y2g9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgaXNPYmplY3RQcm9wZXJ0eSA9IG1lLmlzSXRlbShwcm9wZXJ0eSksXG4gICAgICAgICAgICBpdGVtLCBtYXRjaEFycmF5LCBwcm9wZXJ0aWVzQXJyYXksIHByb3BlcnRpZXNMZW5ndGg7XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNBcnJheSAgPSBPYmplY3QuZW50cmllcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzTGVuZ3RoID0gcHJvcGVydGllc0FycmF5Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaXRlbSBvZiBtZS5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0UHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaEFycmF5ID0gW107XG5cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzQXJyYXkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoQXJyYXkubGVuZ3RoID09PSBwcm9wZXJ0aWVzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbVtwcm9wZXJ0eV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuRmlyc3RNYXRjaCA/IG51bGwgOiBpdGVtc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIGZvciB3aGljaCB0aGUgcGFzc2VkIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBydW4gZm9yIGVhY2ggaXRlbSBpbnNpZGUgdGhlIHN0YXJ0LWVuZCByYW5nZS4gUmV0dXJuIHRydWUgZm9yIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZuLml0ZW0gVGhlIGN1cnJlbnQgY29sbGVjdGlvbiBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRoaXMgVGhlIHNjb3BlIGluIHdoaWNoIHRoZSBwYXNzZWQgZnVuY3Rpb24gZ2V0cyBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydD0wIFRoZSBzdGFydCBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQ9dGhpcy5nZXRDb3VudCgpIFRoZSBlbmQgaW5kZXggKHVwIHRvLCBsYXN0IHZhbHVlIGV4Y2x1ZGVkKVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBlbXB0eSBBcnJheSBpbiBjYXNlIG5vIGl0ZW1zIGFyZSBmb3VuZFxuICAgICAqL1xuICAgIGZpbmRCeShmbiwgc2NvcGU9dGhpcywgc3RhcnQ9MCwgZW5kPXRoaXMuZ2V0Q291bnQoKSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgICAgIGkgICAgID0gc3RhcnQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZuLmNhbGwoc2NvcGUsIG1lLml0ZW1zW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobWUuaXRlbXNbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIHdoaWNoIG1hdGNoZXMgdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFt2YWx1ZV0gT25seSByZXF1aXJlZCBpbiBjYXNlIHRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGZpcnN0IGZvdW5kIGl0ZW0gb3IgbnVsbFxuICAgICAqL1xuICAgIGZpbmRGaXJzdChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZChwcm9wZXJ0eSwgdmFsdWUsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSBpbnNpZGUgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgYXNzb2NpYXRlZCB0byB0aGUga2V5LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXQoa2V5KSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBmb3IgYSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldEF0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tpbmRleF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGludGVybmFsIGl0ZW1zIGFycmF5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q291bnRNdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2NvdW50TXV0YXRpb25zXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nIGZpbHRlciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29sbGVjdGlvbi5GaWx0ZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRGaWx0ZXIocHJvcGVydHkpIHtcbiAgICAgICAgbGV0IGZpbHRlcnMgPSB0aGlzLmZpbHRlcnMgfHwgW10sXG4gICAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgPSBmaWx0ZXJzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyc1tpXS5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyc1tpXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBrZXkgZm9yIGEgZ2l2ZW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0S2V5QXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgICAgIHJldHVybiBpdGVtPy5bdGhpcy5rZXlQcm9wZXJ0eV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiB0aGUgaXRlbXMgYXJyYXlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XSBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGJlZ2luIGV4dHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRdIFplcm8tYmFzZWQgaW5kZXggYmVmb3JlIHdoaWNoIHRvIGVuZCBleHRyYWN0aW9uIChleHRyYWN0cyB1cCB0byBidXQgbm90IGluY2x1ZGluZyBlbmQpLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zbGljZVxuICAgICAqL1xuICAgIGdldFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU291cmNlIENvbGxlY3Rpb24gaW4gY2FzZSB0aGUgc291cmNlQ29sbGVjdGlvbklkIGNvbmZpZyB3YXMgc2V0XG4gICAgICogQHJldHVybnMge05lby5jb2xsZWN0aW9uLkJhc2V8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlSWQgJiYgTmVvLmdldCh0aGlzLnNvdXJjZUlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGFzc2VydGluZyB3aGV0aGVyIGEgdmFsdWUgaGFzIGJlZW4gYXNzb2NpYXRlZCB0byB0aGUga2V5IGluIHRoZSBDb2xsZWN0aW9uIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBhc3NlcnRpbmcgd2hldGhlciBhbiBpdGVtIGV4aXN0cyBpbiB0aGUgQ29sbGVjdGlvbiBvciBub3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0l0ZW0oaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGl0ZW1bdGhpcy5rZXlQcm9wZXJ0eV0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggZm9yIGEgZ2l2ZW4ga2V5IG9yIGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8T2JqZWN0fSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpbmRleCAoLTEgaW4gY2FzZSBubyBtYXRjaCBpcyBmb3VuZClcbiAgICAgKi9cbiAgICBpbmRleE9mKGtleSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWUuX2l0ZW1zLmluZGV4T2YobWUuaXNJdGVtKGtleSkgPyBrZXkgOiBtZS5tYXAuZ2V0KGtleSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggZm9yIGEgZ2l2ZW4gaXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMge051bWJlcn0gaW5kZXggKC0xIGluIGNhc2Ugbm8gbWF0Y2ggaXMgZm91bmQpXG4gICAgICovXG4gICAgaW5kZXhPZkl0ZW0oaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IGZvciBhIGdpdmVuIGtleVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge051bWJlcn0gaW5kZXggKC0xIGluIGNhc2Ugbm8gbWF0Y2ggaXMgZm91bmQpXG4gICAgICovXG4gICAgaW5kZXhPZktleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YodGhpcy5tYXAuZ2V0KGtleSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFuIGFycmF5IG9mIGl0ZW1zIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX0gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgYWRkZWQgaXRlbXNcbiAgICAgKi9cbiAgICBpbnNlcnQoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAwLCBpdGVtKS5hZGRlZEl0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgY29sbGVjdGlvbiBpcyBmaWx0ZXJlZFxuICAgICAqL1xuICAgIGlzRmlsdGVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2lzRmlsdGVyZWRdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNGaWx0ZXJlZEl0ZW0oaXRlbSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBmaWx0ZXJzICAgID0gbWUuX2ZpbHRlcnMsXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSBmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGlzRmlsdGVyZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyc1tpXS5pc0ZpbHRlcmVkKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaXNGaWx0ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0ZpbHRlcmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjaGVjayBpZiBhIGdpdmVuIHZhbHVlIGlzIGVpdGhlciBhbiBvYmplY3Qgb3IgYSBuZW8gZGF0YSByZWNvcmRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNJdGVtKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uaXNPYmplY3QodmFsdWUpIHx8IE5lby5pc1JlY29yZCh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBjb2xsZWN0aW9uIGlzIHNvcnRlZFxuICAgICAqL1xuICAgIGlzU29ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tpc1NvcnRlZF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXN0IGl0ZW0gaW5zaWRlIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbdGhpcy5nZXRDb3VudCgpIC0xXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRmlsdGVyQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uTXV0YXRlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob3B0cy5wcmV2ZW50QnViYmxlVXApIHtcbiAgICAgICAgICAgIG1lLnByZXZlbnRCdWJibGVVcCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNwbGljZShudWxsLCBvcHRzLnJlbW92ZWRJdGVtcywgb3B0cy5hZGRlZEl0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU29ydGVyQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgdGhpcy5hcHBseVNvcnRlckNvbmZpZ3MoKTtcbiAgICAgICAgdGhpcy5kb1NvcnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgZWxlbWVudCBmcm9tIHRoZSBpdGVtcyBhcnJheSBhbmQgcmV0dXJucyB0aGlzIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlbW92ZWQgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uOyB1bmRlZmluZWQgaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuXG4gICAgICovXG4gICAgcG9wKCkge1xuICAgICAgICBsZXQgbXV0YXRpb24gPSB0aGlzLnNwbGljZSh0aGlzLmdldENvdW50KCkgLTEsIDEpO1xuICAgICAgICByZXR1cm4gbXV0YXRpb24ucmVtb3ZlZEl0ZW1zWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBpdGVtcyB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBuZXcgaXRlbXMgY291bnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbSBUaGUgaXRlbShzKSB0byBhZGRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY29sbGVjdGlvbiBjb3VudFxuICAgICAqL1xuICAgIHB1c2goaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZ2l2ZW4ga2V5LCBpdGVtIG9yIEFycmF5IGNvbnRhaW5pbmcga2V5c3xpdGVtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xPYmplY3R8QXJyYXl9IGtleVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICB0aGlzLnNwbGljZSgwLCBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBba2V5XSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvdW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgcmVtb3ZlQXQoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGl0ZW1zIGFycmF5IGluIHBsYWNlLlxuICAgICAqIEludGVuZGVkIGZvciBjb2xsZWN0aW9ucyB3aXRob3V0IHNvcnRlcnMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBpdGVtc1xuICAgICAqL1xuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5yZXZlcnNlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGl0ZW1zIGFycmF5IGFuZCByZXR1cm5zIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVtb3ZlZCBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb247IHVuZGVmaW5lZCBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgbGV0IG11dGF0aW9uID0gdGhpcy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi5hZGRlZEl0ZW1zWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBpdGVtLCB0YWtpbmcgdGhyZWUgcGFyYW1ldGVyczpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBjYWxsYmFjay5pdGVtIFRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaXRlbSBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIFtjYWxsYmFjay5pbmRleF0gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGl0ZW0gYmVpbmcgcHJvY2Vzc2VkXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBbY2FsbGJhY2suaXRlbXNdIFRoZSBpdGVtcyBhcnJheSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVmFsdWUgdG8gdXNlIGFzIFwidGhpc1wiIHdoZW4gZXhlY3V0aW5nIHRoZSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBhbnkgY29sbGVjdGlvbiBpdGVtLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBzb21lKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLnNvbWUoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGl0ZW1zIGZyb20gYW5kL29yIGFkZHMgaXRlbXMgdG8gdGhpcyBjb2xsZWN0aW9uXG4gICAgICogSWYgdGhlIHRvUmVtb3ZlQXJyYXkgaXMgdXNlZCwgdGhlbiB0aGUgaW5kZXggaXMgbm90IHVzZWQgZm9yIHJlbW92aW5nLCB0aGUgZW50cmllcyBhcmUgZm91bmQgYnkga2V5IGFuZCByZW1vdmVkIGZyb20gd2hlcmUgdGhleSBhcmUuXG4gICAgICogSWYgaW5kZXggaXMgbm90IHBhc3NlZCwgdG9BZGRBcnJheSBpcyBhcHBlbmRlZCB0byB0aGUgQ29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdFtdfSBbcmVtb3ZlQ291bnRPclRvUmVtb3ZlQXJyYXldXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IFt0b0FkZEFycmF5XVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBhZGRlZEl0ZW1zICYgcmVtb3ZlZEl0ZW1zIGFycmF5c1xuICAgICAqL1xuICAgIHNwbGljZShpbmRleCwgcmVtb3ZlQ291bnRPclRvUmVtb3ZlQXJyYXksIHRvQWRkQXJyYXkpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7a2V5UHJvcGVydHksIG1hcH0gPSBtZSxcbiAgICAgICAgICAgIHNvdXJjZSAgICAgICAgICAgICA9IG1lLmdldFNvdXJjZSgpLFxuICAgICAgICAgICAgYWRkZWRJdGVtcyAgICAgICAgID0gW10sXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgICAgICAgPSBtZS5faXRlbXMsXG4gICAgICAgICAgICByZW1vdmVkSXRlbXMgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHJlbW92ZUNvdW50QXRJbmRleCA9IE5lby5pc051bWJlcihyZW1vdmVDb3VudE9yVG9SZW1vdmVBcnJheSkgPyByZW1vdmVDb3VudE9yVG9SZW1vdmVBcnJheSA6IG51bGwsXG4gICAgICAgICAgICB0b1JlbW92ZUFycmF5ICAgICAgPSBBcnJheS5pc0FycmF5KHJlbW92ZUNvdW50T3JUb1JlbW92ZUFycmF5KSA/IHJlbW92ZUNvdW50T3JUb1JlbW92ZUFycmF5IDogbnVsbCxcbiAgICAgICAgICAgIGksIGl0ZW0sIGtleSwgbGVuLCB0b0FkZE1hcDtcblxuICAgICAgICBpZiAoIU5lby5pc051bWJlcihpbmRleCkgJiYgcmVtb3ZlQ291bnRBdEluZGV4KSB7XG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IobWUuaWQgKyAnOiBJZiBpbmRleCBpcyBub3QgcGFzc2VkLCByZW1vdmVDb3VudEF0SW5kZXggY2Fubm90IGJlIHVzZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgdG9BZGRBcnJheSA9IHRvQWRkQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkodG9BZGRBcnJheSkgPyBbdG9BZGRBcnJheV0gOiB0b0FkZEFycmF5O1xuXG4gICAgICAgIGlmICh0b1JlbW92ZUFycmF5ICYmIChsZW4gPSB0b1JlbW92ZUFycmF5Lmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICBpZiAodG9BZGRBcnJheSAmJiB0b0FkZEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b0FkZE1hcCA9IHRvQWRkQXJyYXkubWFwKGUgPT4gZVtrZXlQcm9wZXJ0eV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdG9SZW1vdmVBcnJheVtpXTtcbiAgICAgICAgICAgICAgICBrZXkgID0gbWUuaXNJdGVtKGl0ZW0pID8gaXRlbVtrZXlQcm9wZXJ0eV0gOiBpdGVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvQWRkTWFwIHx8ICh0b0FkZE1hcCAmJiB0b0FkZE1hcC5pbmRleE9mKGtleSkgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbXMuc3BsaWNlKG1lLmluZGV4T2ZLZXkoa2V5KSwgMSlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmRlbGV0ZShrZXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlQ291bnRBdEluZGV4ICYmIHJlbW92ZUNvdW50QXRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKC4uLml0ZW1zLnNwbGljZShpbmRleCwgcmVtb3ZlQ291bnRBdEluZGV4KSk7XG4gICAgICAgICAgICByZW1vdmVkSXRlbXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGVba2V5UHJvcGVydHldKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b0FkZEFycmF5ICYmIChsZW4gPSB0b0FkZEFycmF5Lmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRvQWRkQXJyYXlbaV07XG4gICAgICAgICAgICAgICAga2V5ICA9IGl0ZW1ba2V5UHJvcGVydHldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtrZXlQcm9wZXJ0eV0gPSBrZXkgPSBtZS5rZXlQcm9wZXJ0eUluZGV4O1xuICAgICAgICAgICAgICAgICAgICBtZS5rZXlQcm9wZXJ0eUluZGV4LS1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hcC5oYXMoa2V5KSAmJiAhbWUuaXNGaWx0ZXJlZEl0ZW0oaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KGtleSwgaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhZGRlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoTmVvLmlzTnVtYmVyKGluZGV4KSA/IGluZGV4IDogaXRlbXMubGVuZ3RoLCAwLCAuLi5hZGRlZEl0ZW1zKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5hdXRvU29ydCAmJiBtZS5fc29ydGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRvU29ydCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuZ2V0U291cmNlKCkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UucHJldmVudEJ1YmJsZVVwID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1lLnByZXZlbnRCdWJibGVVcCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzb3VyY2Ugc3BsaWNlJywgc291cmNlLmlkLCAnYWRkZWQ6JywgLi4udG9BZGRBcnJheSwgJ3JlbW92ZWQ6JywgLi4ucmVtb3ZlZEl0ZW1zKTtcbiAgICAgICAgICAgICAgICBtZS5zdGFydFVwZGF0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc3BsaWNlKG51bGwsIHRvUmVtb3ZlQXJyYXkgfHwgcmVtb3ZlZEl0ZW1zLCB0b0FkZEFycmF5KTtcbiAgICAgICAgICAgICAgICBtZS5lbmRVcGRhdGUodHJ1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZS5wcmV2ZW50QnViYmxlVXBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRlZEl0ZW1zLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1lW2NvdW50TXV0YXRpb25zXSsrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVbdXBkYXRpbmdJbmRleF0gPT09IDApIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ211dGF0ZScsIHtcbiAgICAgICAgICAgICAgICBhZGRlZEl0ZW1zICAgICA6IHRvQWRkQXJyYXksXG4gICAgICAgICAgICAgICAgcHJldmVudEJ1YmJsZVVwOiBtZS5wcmV2ZW50QnViYmxlVXAsXG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zICAgOiB0b1JlbW92ZUFycmF5IHx8IHJlbW92ZWRJdGVtc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICghbWVbc2lsZW50VXBkYXRlTW9kZV0pIHtcbiAgICAgICAgICAgIG1lLmNhY2hlVXBkYXRlKHtcbiAgICAgICAgICAgICAgICBhZGRlZEl0ZW1zLFxuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZVt1cGRhdGluZ0luZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIG1lLnByZXZlbnRCdWJibGVVcFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHthZGRlZEl0ZW1zLCByZW1vdmVkSXRlbXN9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGNvbGxlY3Rpb24gZnJvbSBmaXJpbmcgZXZlbnRzIHVudGlsIGVuZFVwZGF0ZSBnZXRzIGNhbGxlZC5cbiAgICAgKiBJZiB5b3Ugc3RhcnQgYW4gdXBkYXRlIHVzaW5nIHRoZSBzdGFydFNpbGVudFVwZGF0ZU1vZGUgcGFyYW0sXG4gICAgICogdGhlIG11dGF0aW9uIGV2ZW50IHdpbGwgbm90IGZpcmUgYWZ0ZXIgdXNpbmcgZW5kVXBkYXRlKClcbiAgICAgKiAoeW91IG11c3QgdXNlIHRoZSBlbmRTaWxlbnRVcGRhdGVNb2RlIHBhcmFtIGZvciB0aGUgZW5kVXBkYXRlIGNhbGwgaW4gY2FzZSB5b3UgdXNlZFxuICAgICAqIHN0YXJ0U2lsZW50VXBkYXRlTW9kZSBoZXJlKVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0YXJ0U2lsZW50VXBkYXRlTW9kZV1cbiAgICAgKiBAc2VlIHtAbGluayBOZW8uY29sbGVjdGlvbi5CYXNlI2VuZFVwZGF0ZSBlbmRVcGRhdGV9XG4gICAgICovXG4gICAgc3RhcnRVcGRhdGUoc3RhcnRTaWxlbnRVcGRhdGVNb2RlKSB7XG4gICAgICAgIGlmIChzdGFydFNpbGVudFVwZGF0ZU1vZGUpIHtcbiAgICAgICAgICAgIHRoaXNbc2lsZW50VXBkYXRlTW9kZV0gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW3VwZGF0aW5nSW5kZXhdKytcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIGVsZW1lbnRzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24gYW5kIHJldHVybnMgdGhlIG5ldyBpdGVtcyBjb3VudFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgdW5zaGlmdChpdGVtKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKDAsIDAsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb3VudCgpXG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBtdXRhdGUgZXZlbnQgZmlyZXMgYWZ0ZXIgZXZlcnkgc3BsaWNlIGNhbGwgKGludm9rZWQgYnkgYWxsIG1ldGhvZHMgd2hpY2ggY2hhbmdlIHRoZSBjb250ZW50IG9mIHRoZSBpdGVtcyBhcnJheSkuXG4gKiBAZXZlbnQgbXV0YXRlXG4gKiBAcGFyYW0ge09iamVjdFtdfSBhZGRlZEl0ZW1zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZXZlbnRCdWJibGVVcCBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdFtdfSByZW1vdmVkSXRlbXNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29sbGVjdGlvbi5GaWx0ZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgRmlsdGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBvcGVyYXRvciBjb25maWc6PGJyPlxuICAgICAqIFsnPT0nLCc9PT0nLCchPScsJyE9PScsJzwnLCc8PScsJz4nLCc+PScsJ2VuZHNXaXRoJywnZXhjbHVkZWQnLCdpbmNsdWRlZCcsJ2lzRGVmaW5lZCcsJ2lzVW5kZWZpbmVkJywnbGlrZScsJ3N0YXJ0c1dpdGgnXVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBvcGVyYXRvcnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvcGVyYXRvcnMgPSBbXG4gICAgICAgICc9PScsICc9PT0nLCAnIT0nLCAnIT09JywgJzwnLCAnPD0nLCAnPicsICc+PScsICdlbmRzV2l0aCcsICdleGNsdWRlZCcsICdpbmNsdWRlZCcsXG4gICAgICAgICdpc0RlZmluZWQnLCAnaXNVbmRlZmluZWQnLCAnbGlrZScsICdzdGFydHNXaXRoJ1xuICAgIF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbGxlY3Rpb24uRmlsdGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29sbGVjdGlvbi5GaWx0ZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZmlsdGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2ZpbHRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXR0aW5nIGRpc2FibGVkIHRvIHRydWUgd2lsbCBleGNsdWRlIHRoaXMgZmlsdGVyIGZyb20gdGhlIGNvbGxlY3Rpb24gZmlsdGVyaW5nIGxvZ2ljXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVkXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGUgYSBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9uIHdoaWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGFuIHByb3BlcnR5LCBvcGVyYXRvciAmIHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufG51bGx9IGZpbHRlckJ5Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJCeV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIG1lYW5zIG5vdCBmaWx0ZXJpbmcgb3V0IGl0ZW1zIGluIGNhc2UgdGhlIHZhbHVlIGlzICcnLCBudWxsLCBbXSBvciB7fVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbmNsdWRlRW1wdHlWYWx1ZXM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5jbHVkZUVtcHR5VmFsdWVzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgZmxhZyB0byB0cnVlIGJlZm9yZSBzdGFydGluZyBidWxrIHVwZGF0ZXMgKGUuZy4gY2hhbmdpbmcgcHJvcGVydHkgJiB2YWx1ZSlcbiAgICAgICAgICogdG8gcHJldmVudCBtdWx0aXBsZSBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVXBkYXRpbmdfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc1VwZGF0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3duZXIgdXRpbC5Db2xsZWN0aW9uIG5lZWRzIHRvIGFwcGx5IGFuIG9uQ2hhbmdlIGxpc3RlbmVyIG9uY2VcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbGlzdGVuZXJBcHBsaWVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RlbmVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3BlcmF0b3IgdG8gZmlsdGVyIGJ5ICh1c2UgdGhlIGNvbWJpbmF0aW9uIG9mIHByb3BlcnR5LCBvcGVyYXRvciAmIHZhbHVlKVxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6XG4gICAgICAgICAqXG4gICAgICAgICAqID09IChub3QgcmVjb21tZW5kZWQpXG4gICAgICAgICAqID09PVxuICAgICAgICAgKiAhPSAobm90IHJlY29tbWVuZGVkKVxuICAgICAgICAgKiAhPT1cbiAgICAgICAgICogPFxuICAgICAgICAgKiA+PVxuICAgICAgICAgKiA+XG4gICAgICAgICAqID49XG4gICAgICAgICAqIGxpa2UgKGNvbGxlY3Rpb25WYWx1ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKSkgPiAtMSlcbiAgICAgICAgICogaW5jbHVkZWQgKGV4cGVjdHMgdmFsdWUgdG8gYmUgYW4gYXJyYXkpXG4gICAgICAgICAqIGV4Y2x1ZGVkIChleHBlY3RzIHZhbHVlIHRvIGJlIGFuIGFycmF5KVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG9wZXJhdG9yPSc9PT0nXG4gICAgICAgICAqL1xuICAgICAgICBvcGVyYXRvcl86ICc9PT0nLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb3BlcnR5IHRvIGZpbHRlciBieSAodXNlIHRoZSBjb21iaW5hdGlvbiBvZiBwcm9wZXJ0eSwgb3BlcmF0b3IgJiB2YWx1ZSlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcm9wZXJ0eV89J2lkJ1xuICAgICAgICAgKi9cbiAgICAgICAgcHJvcGVydHlfOiAnaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlIHRvIHVzZSBmb3IgdGhlIGZpbHRlckJ5IG1ldGhvZCwgaW4gY2FzZSBpdCBpcyBwcm92aWRlZC4gRGVmYXVsdHMgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHNjb3BlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNjb3BlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIHRvIGZpbHRlciBieSAodXNlIHRoZSBjb21iaW5hdGlvbiBvZiBwcm9wZXJ0eSwgb3BlcmF0b3IgJiB2YWx1ZSlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB2YWx1ZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVfOiBudWxsXG4gICAgfVxuXG4gICAgYWZ0ZXJTZXREaXNhYmxlZCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgYWZ0ZXJTZXRGaWx0ZXJCeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gdG9kb1xuICAgIH1cblxuICAgIGFmdGVyU2V0SXNVcGRhdGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPT09IGZhbHNlICYmIHRoaXMuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICBhZnRlclNldE9wZXJhdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoLi4uYXJncylcbiAgICB9XG5cbiAgICBhZnRlclNldFByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoLi4uYXJncylcbiAgICB9XG5cbiAgICBhZnRlclNldFZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoLi4uYXJncylcbiAgICB9XG5cbiAgICBiZWZvcmVTZXRGaWx0ZXJCeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKCdmaWx0ZXJCeSBoYXMgdG8gYmUgYSBmdW5jdGlvbicsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBvcGVyYXRvciBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0T3BlcmF0b3IodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdvcGVyYXRvcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciByZW1vdGUgZmlsdGVyaW5nXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGV4cG9ydCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3BlcmF0b3IsIHByb3BlcnR5LCB2YWx1ZX0gPSBtZTtcblxuICAgICAgICBpZiAoIW1lLmZpbHRlckJ5KSB7XG4gICAgICAgICAgICByZXR1cm4ge29wZXJhdG9yLCBwcm9wZXJ0eSwgdmFsdWV9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtZS5pc1VwZGF0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBsZXQge29wZXJhdG9yLCBwcm9wZXJ0eSwgdmFsdWV9ID0gbWU7XG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7b3BlcmF0b3IsIHByb3BlcnR5LCB2YWx1ZX0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjb2xsZWN0aW9uIGl0ZW0gbWF0Y2hlcyB0aGlzIGZpbHRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaXRlbVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmVkSXRlbXMgSWYgdGhlIGNvbGxlY3Rpb24gZmlsdGVyTW9kZSBpcyBub3QgcHJpbWl0aXZlIGNvbnRhaW5zIHRoZSBpdGVtcyB3aGljaCBwYXNzZWRcbiAgICAgKiB0aGUgcHJldmlvdXMgZmlsdGVycywgb3RoZXJ3aXNlIGFsbCBjb2xsZWN0aW9uIGl0ZW1zXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWxsSXRlbXMgYWxsIGNvbGxlY3Rpb24gaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0ZpbHRlcmVkKGl0ZW0sIGZpbHRlcmVkSXRlbXMsIGFsbEl0ZW1zKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBmaWx0ZXJWYWx1ZSwgcmVjb3JkVmFsdWU7XG5cbiAgICAgICAgaWYgKG1lLl9kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuX2ZpbHRlckJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuZmlsdGVyQnkuY2FsbChtZS5zY29wZSB8fCBtZSwge1xuICAgICAgICAgICAgICAgIGFsbEl0ZW1zLFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWUuX3ZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmluY2x1ZGVFbXB0eVZhbHVlcyAmJiAobWUuX3ZhbHVlID09PSBudWxsIHx8IE5lby5pc0VtcHR5KG1lLl92YWx1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlclZhbHVlID0gbWUuX3ZhbHVlO1xuICAgICAgICByZWNvcmRWYWx1ZSA9IGl0ZW1bbWUuX3Byb3BlcnR5XTtcblxuICAgICAgICBpZiAoZmlsdGVyVmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIHJlY29yZFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWx0ZXJWYWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICByZWNvcmRWYWx1ZSA9IHJlY29yZFZhbHVlLnZhbHVlT2YoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFGaWx0ZXJbbWUuX29wZXJhdG9yXShyZWNvcmRWYWx1ZSwgZmlsdGVyVmFsdWUpXG4gICAgfVxuXG4gICAgc3RhdGljIFsnPT0nXSAoYSwgYikge3JldHVybiBhID09IGJ9XG4gICAgc3RhdGljIFsnPT09J10oYSwgYikge3JldHVybiBhID09PSBifVxuICAgIHN0YXRpYyBbJyE9J10gKGEsIGIpIHtyZXR1cm4gYSAhPSBifVxuICAgIHN0YXRpYyBbJyE9PSddKGEsIGIpIHtyZXR1cm4gYSAhPT0gYn1cbiAgICBzdGF0aWMgWyc8J10gIChhLCBiKSB7cmV0dXJuIGEgPCBifVxuICAgIHN0YXRpYyBbJzw9J10gKGEsIGIpIHtyZXR1cm4gYSA8PSBifVxuICAgIHN0YXRpYyBbJz4nXSAgKGEsIGIpIHtyZXR1cm4gYSA+IGJ9XG4gICAgc3RhdGljIFsnPj0nXSAoYSwgYikge3JldHVybiBhID49IGJ9XG5cbiAgICBzdGF0aWMgWydlbmRzV2l0aCddKGEsIGIpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYSkpIHthID0gU3RyaW5nKGEpfVxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhiKSkge2IgPSBTdHJpbmcoYil9XG5cbiAgICAgICAgcmV0dXJuIGE/LnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoYj8udG9Mb3dlckNhc2UoKSkgfHwgZmFsc2VcbiAgICB9XG5cbiAgICBzdGF0aWMgWydleGNsdWRlZCddKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSA8IDBcbiAgICB9XG5cbiAgICBzdGF0aWMgWydpbmNsdWRlZCddKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSA+IC0xXG4gICAgfVxuXG4gICAgc3RhdGljIFsnaXNEZWZpbmVkJ10oYSwgYikge1xuICAgICAgICByZXR1cm4gYSAhPT0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgc3RhdGljIFsnaXNVbmRlZmluZWQnXShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBzdGF0aWMgWydsaWtlJ10oYSwgYikge1xuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhhKSkge2EgPSBTdHJpbmcoYSl9XG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGIpKSB7YiA9IFN0cmluZyhiKX1cblxuICAgICAgICByZXR1cm4gYT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhiPy50b0xvd2VyQ2FzZSgpKSB8fCBmYWxzZVxuICAgIH1cblxuICAgIHN0YXRpYyBbJ3N0YXJ0c1dpdGgnXShhLCBiKSB7XG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGEpKSB7YSA9IFN0cmluZyhhKX1cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYikpIHtiID0gU3RyaW5nKGIpfVxuXG4gICAgICAgIHJldHVybiBhPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYj8udG9Mb3dlckNhc2UoKSkgfHwgZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZpbHRlcik7XG4iLCJpbXBvcnQgQmFzZSAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29sbGVjdGlvbi5Tb3J0ZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgU29ydGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbGxlY3Rpb24uU29ydGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29sbGVjdGlvbi5Tb3J0ZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc29ydGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NvcnRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBjb25maWcgd2hpY2ggbWFwcyB0aGUgZGlyZWN0aW9uIEFTQyB0byAxLCAtMSBvdGhlcndpc2VcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBkaXJlY3Rpb25NdWx0aXBsaWVyPTFcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlyZWN0aW9uTXVsdGlwbGllcjogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzb3J0IGRpcmVjdGlvbiB3aGVuIHVzaW5nIGEgcHJvcGVydHkuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGlyZWN0aW9uXz0nQVNDJ1xuICAgICAgICAgKi9cbiAgICAgICAgZGlyZWN0aW9uXzogJ0FTQycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3duZXIgdXRpbC5Db2xsZWN0aW9uIG5lZWRzIHRvIGFwcGx5IGFuIG9uQ2hhbmdlIGxpc3RlbmVyIG9uY2VcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gbGlzdGVuZXJBcHBsaWVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RlbmVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc29ydCBieS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcm9wZXJ0eV89J2lkJ1xuICAgICAgICAgKi9cbiAgICAgICAgcHJvcGVydHlfOiAnaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZSBhIGN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uLCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhhbiBwcm9wZXJ0eSAmIGRpcmVjdGlvblxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSBzb3J0Qnk9bnVsbFxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0NvbGxhdG9yXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Qnk6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHVzZSB0aGUgdHJhbnNmb3JtVmFsdWUgbWV0aG9kIGZvciBlYWNoIGl0ZW0gKHRoZSBtZXRob2QgY2FuIGdldCBvdmVycmlkZGVuKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VUcmFuc2Zvcm1WYWx1ZT10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVzZVRyYW5zZm9ybVZhbHVlOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXREaXJlY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZGlyZWN0aW9uTXVsdGlwbGllciA9IHZhbHVlID09PSAnQVNDJyA/IDEgOiAtMTtcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IG1lLmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA6IG1lLnByb3BlcnR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0UHJvcGVydHkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBtZS5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgOiBtZS5wcm9wZXJ0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHNvcnRlciBmdW5jdGlvbiB3aGljaCBnZXRzIHVzZWQgYnkgY29sbGVjdGlvbnMgaW4gY2FzZSBhdCBsZWFzdCBvbmUgc29ydGVyIGhhcyBhIHJlYWwgc29ydEJ5IG1ldGhvZFxuICAgICAqIEBwYXJhbSBhXG4gICAgICogQHBhcmFtIGJcbiAgICAgKi9cbiAgICBkZWZhdWx0U29ydEJ5KGEsIGIpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBhID0gYVttZS5wcm9wZXJ0eV07XG4gICAgICAgIGIgPSBiW21lLnByb3BlcnR5XTtcblxuICAgICAgICBpZiAobWUudXNlVHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgIGEgPSBtZS50cmFuc2Zvcm1WYWx1ZShhKTtcbiAgICAgICAgICAgIGIgPSBtZS50cmFuc2Zvcm1WYWx1ZShiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDEgKiBtZS5kaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTEgKiBtZS5kaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciByZW1vdGUgc29ydGluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBleHBvcnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RpcmVjdGlvbiwgcHJvcGVydHl9ID0gbWU7XG5cbiAgICAgICAgaWYgKCFtZS5zb3J0QnkgJiYgZGlyZWN0aW9uICYmIHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge2RpcmVjdGlvbiwgcHJvcGVydHl9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNvcnRlcik7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkFwcGxpY2F0aW9uXG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5CYXNlXG4gKi9cbmNsYXNzIEFwcGxpY2F0aW9uIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRyb2xsZXIuQXBwbGljYXRpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250cm9sbGVyLkFwcGxpY2F0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2FwcGxpY2F0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2FwcGxpY2F0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhcHBUaGVtZUZvbGRlcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBhcHBUaGVtZUZvbGRlcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gbWFpblZpZXdfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1haW5WaWV3XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdW50ZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG5hbWU9J015QXBwJ1xuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogJ015QXBwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcGFyZW50SWQ9J2RvY3VtZW50LmJvZHknXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRJZDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyaW5nPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gd2luZG93SWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWQ6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICAvLyB0byBndWFyYW50ZWUgdGhhdCB0aGUgbWFpbiB2aWV3IGNhbiBhY2Nlc3MgTmVvLmFwcHMgYXQgYW55IHBvaW50LFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHRyaWdnZXIgaXRzIGFzc2lnbm1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgY3Rvci5cbiAgICAgICAgbGV0IG1haW5WaWV3ID0gY29uZmlnLm1haW5WaWV3O1xuICAgICAgICBkZWxldGUgY29uZmlnLm1haW5WaWV3O1xuXG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUud2luZG93SWQgPSBOZW8uY29uZmlnLndpbmRvd0lkO1xuXG4gICAgICAgIE5lby5hcHBzID0gTmVvLmFwcHMgfHwge307XG5cbiAgICAgICAgTmVvLmFwcHNbbWUubmFtZV0gPSBtZTtcblxuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5yZWdpc3RlckFwcChtZS5uYW1lKTtcblxuICAgICAgICBpZiAobWFpblZpZXcpIHtcbiAgICAgICAgICAgIG1lLm1haW5WaWV3ID0gbWFpblZpZXdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWFpblZpZXcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRNYWluVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBzaG9ydCBkZWxheSB0byBlbnN1cmUgY2hhbmdlcyBmcm9tIG9uSGFzaENoYW5nZSgpIGdvdCBhcHBsaWVkXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KE5lby5jb25maWcuaGFzaCA/IDIwMCA6IDEwKTtcblxuICAgICAgICAgICAgTG9nZ2VyLmFkZENvbnRleHRNZW51TGlzdGVuZXIobWUubWFpblZpZXcpO1xuXG4gICAgICAgICAgICBhd2FpdCB2YWx1ZS5yZW5kZXIodHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIG1haW5WaWV3IGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNYWluVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZSA6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZDogTmVvLmNvbmZpZy53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciB0aGUgYXBwIGZyb20gdGhlIENTUyBtYXBcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5yZW1vdmVBcHBGcm9tVGhlbWVNYXAodGhpcy5uYW1lKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cbn1cblxuQXBwbGljYXRpb24gPSBOZW8uc2V0dXBDbGFzcyhBcHBsaWNhdGlvbik7XG5cbi8vIGNvbnZlbmllbmNlIHNob3J0Y3V0XG5OZW8uYXBwID0gY29uZmlnID0+IE5lby5jcmVhdGUoe1xuICAgIG1vZHVsZTogQXBwbGljYXRpb24sXG4gICAgLi4uY29uZmlnXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQXBwbGljYXRpb247XG4iLCJpbXBvcnQgQ29yZUJhc2UgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgSGFzaEhpc3RvcnkgZnJvbSAnLi4vdXRpbC9IYXNoSGlzdG9yeS5tanMnO1xuXG5jb25zdFxuICAgIGFtb3VudFNsYXNoZXNSZWdleCA9IC9cXC8vZyxcbiAgICByb3V0ZVBhcmFtUmVnZXggICAgPSAve1teXFxzL10rfS9nXG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvcmVCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250cm9sbGVyLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBVUkwgZG9lcyBub3QgY29udGFpbiBhIGhhc2ggdmFsdWUgd2hlbiBjcmVhdGluZyB0aGlzIGNvbnRyb2xsZXIgaW5zdGFuY2UsXG4gICAgICAgICAqIG5lbyB3aWxsIHNldCB0aGlzIGhhc2ggdmFsdWUgZm9yIHVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZGVmYXVsdEhhc2g9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdEhhc2g6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZGVmYXVsdFJvdXRlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRSb3V0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaGFuZGxlUm91dGVzPXt9XG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVSb3V0ZXM6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogcm91dGVzOiB7XG4gICAgICAgICAqICAgICAnL2hvbWUnICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2hhbmRsZUhvbWVSb3V0ZScsXG4gICAgICAgICAqICAgICAnL3VzZXJzL3t1c2VySWR9JyAgICAgICAgICAgICAgIDoge2hhbmRsZXI6ICdoYW5kbGVVc2VyUm91dGUnLCBwcmVIYW5kbGVyOiAncHJlSGFuZGxlVXNlclJvdXRlJ30sXG4gICAgICAgICAqICAgICAnL3VzZXJzL3t1c2VySWR9L3Bvc3RzL3twb3N0SWR9JzogJ2hhbmRsZVBvc3RSb3V0ZScsXG4gICAgICAgICAqICAgICAnZGVmYXVsdCcgICAgICAgICAgICAgICAgICAgICAgIDogJ2hhbmRsZU90aGVyUm91dGVzJ1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcm91dGVzXz17fVxuICAgICAgICAgKi9cbiAgICAgICAgcm91dGVzXzoge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBIYXNoSGlzdG9yeS5vbignY2hhbmdlJywgdGhpcy5vbkhhc2hDaGFuZ2UsIHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3V0ZXMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um91dGVzKHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcm91dGVLZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuXG4gICAgICAgICBtZS5yb3V0ZXMgPSByb3V0ZUtleXMuc29ydChtZS4jc29ydFJvdXRlcykucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICB9LCB7fSk7XG5cbiAgICAgICAgbWUuaGFuZGxlUm91dGVzID0ge307XG5cbiAgICAgICAgcm91dGVLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2RlZmF1bHQnKXtcbiAgICAgICAgICAgICAgICBtZS5kZWZhdWx0Um91dGUgPSB2YWx1ZVtrZXldXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmhhbmRsZVJvdXRlc1trZXldID0gbmV3IFJlZ0V4cChrZXkucmVwbGFjZShyb3V0ZVBhcmFtUmVnZXgsICcoW1xcXFx3LS5dKyknKSsnJCcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgSGFzaEhpc3RvcnkudW4oJ2NoYW5nZScsIHRoaXMub25IYXNoQ2hhbmdlLCB0aGlzKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RlZmF1bHRIYXNoLCB3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIGN1cnJlbnRIYXNoICAgICAgICAgICAgID0gSGFzaEhpc3RvcnkuZmlyc3Qod2luZG93SWQpO1xuXG4gICAgICAgIC8vIGdldCBvdXRzaWRlIHRoZSBjb25zdHJ1Y3Rpb24gY2hhaW4gPT4gYSByZWxhdGVkIGNtcCAmIHZtIGhhcyB0byBiZSBjb25zdHJ1Y3RlZCB0b29cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgxKTtcblxuICAgICAgICBpZiAoY3VycmVudEhhc2gpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SGFzaC53aW5kb3dJZCA9PT0gd2luZG93SWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5vbkhhc2hDaGFuZ2UoY3VycmVudEhhc2gsIG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogd29ya2VyLkFwcDogb25Mb2FkQXBwbGljYXRpb24oKSB3aWxsIHB1c2ggY29uZmlnLmhhc2ggaW50byB0aGUgSGFzaEhpc3Rvcnkgd2l0aCBhIDVtcyBkZWxheS5cbiAgICAgICAgICAgICAqIFdlIG9ubHkgd2FudCB0byBzZXQgYSBkZWZhdWx0IHJvdXRlLCBpbiBjYXNlIHRoZSBIYXNoSGlzdG9yeSBpcyBlbXB0eSBhbmQgdGhlcmUgaXMgbm8gaW5pdGlhbFxuICAgICAgICAgICAgICogdmFsdWUgdGhhdCB3aWxsIGdldCBjb25zdW1lZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgIU5lby5jb25maWcuaGFzaCAmJiBkZWZhdWx0SGFzaCAmJiBOZW8uTWFpbi5zZXRSb3V0ZSh7dmFsdWU6IGRlZmF1bHRIYXNoLCB3aW5kb3dJZH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2Qgd2hpY2ggZ2V0cyB0cmlnZ2VyZWQgd2hlbiB0aGUgaGFzaCBpbnNpZGUgdGhlIGJyb3dzZXIgdXJsIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhc3luYyBvbkhhc2hDaGFuZ2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIGhhc2ggY2hhbmdlcyBmb3IgdGhlIHNhbWUgYnJvd3NlciB3aW5kb3cgKFNoYXJlZFdvcmtlciBjb250ZXh0KVxuICAgICAgICBpZiAodmFsdWUud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY291bnRlciAgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBoYXNSb3V0ZUJlZW5Gb3VuZCAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB7aGFuZGxlUm91dGVzLCByb3V0ZXN9ID0gbWUsXG4gICAgICAgICAgICByb3V0ZUtleXMgICAgICAgICAgICAgID0gT2JqZWN0LmtleXMoaGFuZGxlUm91dGVzKSxcbiAgICAgICAgICAgIHJvdXRlS2V5c0xlbmd0aCAgICAgICAgPSByb3V0ZUtleXMubGVuZ3RoLFxuICAgICAgICAgICAgYXJyYXlQYXJhbUlkcywgYXJyYXlQYXJhbVZhbHVlcywgaGFuZGxlciwga2V5LCBwYXJhbU9iamVjdCwgcHJlSGFuZGxlciwgcmVzcG9uc2VQcmVIYW5kbGVyLCByZXN1bHQsIHJvdXRlO1xuXG4gICAgICAgIHdoaWxlIChyb3V0ZUtleXNMZW5ndGggPiAwICYmIGNvdW50ZXIgPCByb3V0ZUtleXNMZW5ndGggJiYgIWhhc1JvdXRlQmVlbkZvdW5kKSB7XG4gICAgICAgICAgICBrZXkgICAgICAgICAgICAgICAgPSByb3V0ZUtleXNbY291bnRlcl07XG4gICAgICAgICAgICBoYW5kbGVyICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICAgICAgcHJlSGFuZGxlciAgICAgICAgID0gbnVsbDtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJlSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICBwYXJhbU9iamVjdCAgICAgICAgPSB7fTtcbiAgICAgICAgICAgIHJlc3VsdCAgICAgICAgICAgICA9IHZhbHVlLmhhc2hTdHJpbmcubWF0Y2goaGFuZGxlUm91dGVzW2tleV0pO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlQYXJhbUlkcyAgICA9IGtleS5tYXRjaChyb3V0ZVBhcmFtUmVnZXgpO1xuICAgICAgICAgICAgICAgIGFycmF5UGFyYW1WYWx1ZXMgPSByZXN1bHQuc3BsaWNlKDEsIHJlc3VsdC5sZW5ndGggLSAxKTtcblxuICAgICAgICAgICAgICAgIGlmIChhcnJheVBhcmFtSWRzICYmIGFycmF5UGFyYW1JZHMubGVuZ3RoICE9PSBhcnJheVBhcmFtVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnTnVtYmVyIG9mIElEcyBhbmQgbnVtYmVyIG9mIFZhbHVlcyBkbyBub3QgbWF0Y2gnXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGFycmF5UGFyYW1JZHMgJiYgaSA8IGFycmF5UGFyYW1JZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1PYmplY3RbYXJyYXlQYXJhbUlkc1tpXS5zdWJzdHJpbmcoMSwgYXJyYXlQYXJhbUlkc1tpXS5sZW5ndGggLSAxKV0gPSBhcnJheVBhcmFtVmFsdWVzW2ldXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm91dGUgPSByb3V0ZXNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcocm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgICAgICAgICAgICA9IHJvdXRlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByZUhhbmRsZXIgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNPYmplY3Qocm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgICAgPSByb3V0ZS5oYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICBwcmVIYW5kbGVyID0gcm91dGUucHJlSGFuZGxlclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhhc1JvdXRlQmVlbkZvdW5kID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3VudGVyKytcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4ZWN1dGVcbiAgICAgICAgaWYgKGhhc1JvdXRlQmVlbkZvdW5kKSB7XG4gICAgICAgICAgICBpZiAocHJlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJlSGFuZGxlciA9IGF3YWl0IG1lW3ByZUhhbmRsZXJdPy5jYWxsKG1lLCBwYXJhbU9iamVjdCwgdmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByZUhhbmRsZXIgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZVtoYW5kbGVyXT8uY2FsbChtZSwgcGFyYW1PYmplY3QsIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3V0ZUtleXMubGVuZ3RoID4gMCAmJiAhaGFzUm91dGVCZWVuRm91bmQpIHtcbiAgICAgICAgICAgIGlmIChtZS5kZWZhdWx0Um91dGUpIHtcbiAgICAgICAgICAgICAgICBtZVttZS5kZWZhdWx0Um91dGVdPy4odmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5vbk5vUm91dGVGb3VuZCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2Qgd2hpY2ggZ2V0cyB0cmlnZ2VyZWQgd2hlbiBhbiBpbnZhbGlkIHJvdXRlIGlzIGNhbGxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uTm9Sb3V0ZUZvdW5kKHZhbHVlLCBvbGRWYWx1ZSkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB0byBzb3J0IHJvdXRlcyBieSB0aGVpciBhbW91bnQgb2Ygc2xhc2hlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb3V0ZTFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm91dGUyXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICAjc29ydFJvdXRlcyhyb3V0ZTEsIHJvdXRlMikge1xuICAgICAgICByZXR1cm4gKHJvdXRlMS5tYXRjaChhbW91bnRTbGFzaGVzUmVnZXgpIHx8IFtdKS5sZW5ndGggLSAocm91dGUyLm1hdGNoKGFtb3VudFNsYXNoZXNSZWdleCl8fCBbXSkubGVuZ3RoXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCYXNlKTtcbiIsImltcG9ydCB7YnVmZmVyLCBkZWJvdW5jZSwgaW50ZXJjZXB0LCB0aHJvdHRsZX0gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuaW1wb3J0IElkR2VuZXJhdG9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuL0lkR2VuZXJhdG9yLm1qcydcblxuY29uc3QgY29uZmlnU3ltYm9sICAgICAgID0gU3ltYm9sLmZvcignY29uZmlnU3ltYm9sJyksXG4gICAgICBmb3JjZUFzc2lnbkNvbmZpZ3MgPSBTeW1ib2woJ2ZvcmNlQXNzaWduQ29uZmlncycpLFxuICAgICAgaXNJbnN0YW5jZSAgICAgICAgID0gU3ltYm9sKCdpc0luc3RhbmNlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIChhbG1vc3QpIGFsbCBjbGFzc2VzIGluc2lkZSB0aGUgTmVvIG5hbWVzcGFjZVxuICogRXhjZXB0aW9ucyBhcmUgZS5nLiBjb3JlLklkR2VuZXJhdG9yLCB2ZG9tLlZOb2RlXG4gKiBAY2xhc3MgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGRlZmluZSBtZXRob2RzIHdoaWNoIHNob3VsZCBnZXQgZGVsYXllZC5cbiAgICAgKiBUeXBlcyBhcmUgYnVmZmVyLCBkZWJvdW5jZSAmIHRocm90dGxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIGRlbGF5YWJsZToge1xuICAgICAqICAgICAgZmlyZUNoYW5nZUV2ZW50OiB7XG4gICAgICogICAgICAgICAgdHlwZSA6ICdkZWJvdW5jZScsXG4gICAgICogICAgICAgICAgdGltZXI6IDMwMFxuICAgICAqICAgICAgfVxuICAgICAqICB9XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGU9e31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7fVxuICAgIC8qKlxuICAgICAqIEZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSBtYW5hZ2VyLkluc3RhbmNlIGdvdCBjcmVhdGVkXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlPWZhbHNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBpbnN0YW5jZU1hbmFnZXJBdmFpbGFibGUgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFJlZ2V4IHRvIGdyYWIgdGhlIE1ldGhvZE5hbWUgZnJvbSBhbiBlcnJvclxuICAgICAqIHdoaWNoIGlzIGEgc2Vjb25kIGdlbmVyYXRpb24gZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IG1ldGhvZE5hbWVSZWdleFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgbWV0aG9kTmFtZVJlZ2V4ID0gL1xcbi4qXFxuXFxzK2F0XFxzKy4qXFwuKFxcdyspXFxzKy4qL1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPWZhbHNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBLZWVwIHRoZSBvdmVyd3JpdHRlbiBtZXRob2RzXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBvdmVyd3JpdHRlbk1ldGhvZHM9e31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvdmVyd3JpdHRlbk1ldGhvZHMgPSB7fVxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIG9uZSB0byBmYWxzZSBpbiBjYXNlIHlvdSBkb24ndCB3YW50IHRvIHN0aWNrXG4gICAgICogdG8gdGhlIFwiYW50aS1wYXR0ZXJuXCIgdG8gYXBwbHkgY2xhc3NlcyB0byB0aGUgZ2xvYmFsIE5lbyBvciBBcHAgbmFtZXNwYWNlXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVnaXN0ZXJUb0dsb2JhbE5zPXRydWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlclRvR2xvYmFsTnMgPSB0cnVlXG4gICAgLyoqXG4gICAgICogQ29uZmlncyB3aWxsIGdldCBtZXJnZWQgdGhyb3VnaG91dCB0aGUgY2xhc3MgaGllcmFyY2h5XG4gICAgICogQHJldHVybnMge09iamVjdH0gY29uZmlnXG4gICAgICogQHR1dG9yaWFsIDAyX0NsYXNzU3lzdGVtXG4gICAgICovXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIHdoaWNoIHdpbGwgZ2V0IG1hcHBlZCBpbnRvIHRoZSBOZW8gb3IgYXBwIG5hbWVzcGFjZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvcmUuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvcmUuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3Mgc2hvcnRjdXQtbmFtZSB0byB1c2UgZm9yIGUuZy4gY3JlYXRpbmcgY2hpbGQgY29tcG9uZW50cyBpbnNpZGUgYSBKU09OLWZvcm1hdFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdiYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Jhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpbGUgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2hhbmdlIHRoZSBzdGF0aWMgZGVsYXlhYmxlIGNvbmZpZ3Mgb24gY2xhc3MgbGV2ZWwsXG4gICAgICAgICAqIHlvdSBjYW4gY2hhbmdlIGl0IG9uIGluc3RhbmNlIGxldmVsIHRvby4gSWYgbm90IG51bGwsIHdlIHdpbGwgZG8gYSBkZWVwIG1lcmdlLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlbGF5YWJsZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxheWFibGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIGNvbXBvbmVudCBpZFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaWRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGlkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5lby5jcmVhdGUoKSB3aWxsIGNoYW5nZSB0aGlzIGZsYWcgdG8gdHJ1ZSBhZnRlciB0aGUgb25Db25zdHJ1Y3RlZCgpIGNoYWluIGlzIGRvbmUuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQ29uc3RydWN0ZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNDb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgbWl4aW5zIGFzIGFuIGFycmF5IG9mIGNsYXNzTmFtZXMsIGltcG9ydGVkIG1vZHVsZXMgb3IgYSBtaXhlZCB2ZXJzaW9uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfE5lby5jb3JlLkJhc2VbXXxudWxsfSBtaXhpbnM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW5zOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgYnkgcGFzc2luZyBhbiBpbXBvcnRlZCBjbGFzcyAoSlMgbW9kdWxlIGRlZmF1bHQgZXhwb3J0KVxuICAgICAgICAgKiBAbWVtYmVyIHtDbGFzc30gbW9kdWxlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kdWxlOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2FjaGUgZm9yIGFsbCB0aW1lb3V0IGlkcyB3aGVuIHVzaW5nIHRoaXMudGltZW91dCgpXG4gICAgICogQG1lbWJlciB7TnVtYmVyW119IHRpbWVvdXRJZHM9W11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICN0aW1lb3V0SWRzID0gW11cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIG9ic2VydmFibGUgbWl4aW4gaWYgbmVlZGVkLCBncmFudHMgcmVtb3RlIGFjY2VzcyBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZz17fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWc9e30pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZSwge1xuICAgICAgICAgICAgW2NvbmZpZ1N5bWJvbF06IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZSAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA6IHt9LFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlICAgIDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtpc0luc3RhbmNlXToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICA6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuY3JlYXRlSWQoY29uZmlnLmlkIHx8IG1lLmlkKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5pZDtcblxuICAgICAgICBpZiAobWUuY29uc3RydWN0b3IuY29uZmlnKSB7XG4gICAgICAgICAgICBkZWxldGUgbWUuY29uc3RydWN0b3IuY29uZmlnLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0U3RhdGljQ29uZmlnKCdvYnNlcnZhYmxlJykgJiYgbWUuaW5pdE9ic2VydmFibGUoY29uZmlnKTtcblxuICAgICAgICAvLyBhc3NpZ24gY2xhc3MgZmllbGQgdmFsdWVzIHByaW9yIHRvIGNvbmZpZ3NcbiAgICAgICAgY29uZmlnID0gbWUuc2V0RmllbGRzKGNvbmZpZyk7XG5cbiAgICAgICAgbWUuaW5pdENvbmZpZyhjb25maWcpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2NvbmZpZ3NBcHBsaWVkJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAgICAgOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmFwcGx5RGVsYXlhYmxlKCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogV2UgZG8gbm90IHdhbnQgdG8gZm9yY2UgZGV2cyB0byBjaGVjayBmb3IgdGhlIGBpc0Rlc3Ryb3llZGAgZmxhZyBpbiBldmVyeSBwb3NzaWJsZSBjbGFzcyBleHRlbnNpb24uXG4gICAgICAgICAqIFNvLCB3ZSBhcmUgaW50ZXJjZXB0aW5nIHRoZSB0b3AtbW9zdCBgZGVzdHJveSgpYCBjYWxsIHRvIGNoZWNrIGZvciB0aGUgZmxhZyB0aGVyZS5cbiAgICAgICAgICogUmF0aW9uYWxlOiBgZGVzdHJveSgpYCBtdXN0IG9ubHkgZ2V0IGNhbGxlZCBvbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJjZXB0KG1lLCAnZGVzdHJveScsIG1lLmlzRGVzdHJveWVkQ2hlY2ssIG1lKTtcblxuICAgICAgICBtZS5yZW1vdGUgJiYgc2V0VGltZW91dChtZS5pbml0UmVtb3RlLmJpbmQobWUpLCAxKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkLlxuICAgICAqIFlvdSBjYW4gZHluYW1pY2FsbHkgY2hhbmdlIGluc3RhbmNlIGlkcyBpZiBuZWVkZWQuIFRoZXkgbmVlZCB0byBzdGF5IHVuaXF1ZSBhdCBhbnkgZ2l2ZW4gcG9pbnQuXG4gICAgICogVXNlIGNhc2U6IGUuZy4gY29tcG9uZW50IGJhc2VkIGxpc3RzLCB3aGVyZSB5b3Ugd2FudCB0byByZS11c2UgaXRlbSBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNNYW5hZ2VyID0gQmFzZS5pbnN0YW5jZU1hbmFnZXJBdmFpbGFibGUgPT09IHRydWU7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaGFzTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIE5lby5tYW5hZ2VyLkluc3RhbmNlLnVucmVnaXN0ZXIob2xkVmFsdWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBOZW8uaWRNYXBbb2xkVmFsdWVdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTWFuYWdlcikge1xuICAgICAgICAgICAgTmVvLm1hbmFnZXIuSW5zdGFuY2UucmVnaXN0ZXIobWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTmVvLmlkTWFwID0gTmVvLmlkTWFwIHx8IHt9O1xuICAgICAgICAgICAgTmVvLmlkTWFwW21lLmlkXSA9IG1lXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGFsbCBtZXRob2RzIGluc2lkZSBzdGF0aWMgZGVsYXlhYmxlXG4gICAgICovXG4gICAgYXBwbHlEZWxheWFibGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGN0b3JEZWxheWFibGUgPSBtZS5jb25zdHJ1Y3Rvci5kZWxheWFibGUsXG4gICAgICAgICAgICBkZWxheWFibGUgICAgID0gbWUuZGVsYXlhYmxlID8gTmVvLm1lcmdlKHt9LCBtZS5kZWxheWFibGUsIGN0b3JEZWxheWFibGUpIDogY3RvckRlbGF5YWJsZTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhkZWxheWFibGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyKCkgICB7bWVba2V5XSA9IG5ldyBidWZmZXIobWVba2V5XSwgICBtZSwgdmFsdWUudGltZXIpfSxcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2UoKSB7bWVba2V5XSA9IG5ldyBkZWJvdW5jZShtZVtrZXldLCBtZSwgdmFsdWUudGltZXIpfSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKSB7bWVba2V5XSA9IG5ldyB0aHJvdHRsZShtZVtrZXldLCBtZSwgdmFsdWUudGltZXIpfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtYXBbdmFsdWUudHlwZV0/LigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHlpbmcgb3ZlcndyaXRlcyBhbmQgYWRkaW5nIG92ZXJ3cml0dGVuTWV0aG9kcyB0byB0aGUgY2xhc3MgY29uc3RydWN0b3JzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNmZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlPdmVyd3JpdGVzKGNmZykge1xuICAgICAgICBsZXQgb3ZlcndyaXRlcyA9IE5lby5ucyhjZmcuY2xhc3NOYW1lLCBmYWxzZSwgTmVvLm92ZXJ3cml0ZXMpLFxuICAgICAgICAgICAgY2xzLCBpdGVtO1xuXG4gICAgICAgIGlmIChvdmVyd3JpdGVzKSB7XG4gICAgICAgICAgICAvLyBBcHBseSBhbGwgbWV0aG9kc1xuICAgICAgICAgICAgZm9yIChpdGVtIGluIG92ZXJ3cml0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24ob3ZlcndyaXRlc1tpdGVtXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBleGlzdGluZyBvbmVzXG4gICAgICAgICAgICAgICAgICAgIGNscyA9IHRoaXMucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHNbaXRlbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0byBvdmVyd3JpdHRlbk1ldGhvZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5jb25zdHJ1Y3Rvci5vdmVyd3JpdHRlbk1ldGhvZHNbaXRlbV0gPSBjbHNbaXRlbV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlncyB0byBwcm90b3R5cGVcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2ZnLCBvdmVyd3JpdGVzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBiZWZvcmVTZXQgZnVuY3Rpb25zIHdoaWNoIHRlc3QgaWYgYSBnaXZlbiB2YWx1ZSBpcyBpbnNpZGUgYSBzdGF0aWMgYXJyYXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGNvbmZpZyBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IFtzdGF0aWNOYW1lPW5hbWUgKyAncyddIG5hbWUgb2YgdGhlIHN0YXRpYyBjb25maWcgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcn0gdmFsdWUgb3Igb2xkVmFsdWVcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCBuYW1lLCBzdGF0aWNOYW1lID0gbmFtZSArICdzJykge1xuICAgICAgICBsZXQgdmFsdWVzID0gQXJyYXkuaXNBcnJheShzdGF0aWNOYW1lKSA/IHN0YXRpY05hbWUgOiB0aGlzLmdldFN0YXRpY0NvbmZpZyhzdGF0aWNOYW1lKTtcblxuICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN1cHBvcnRlZCB2YWx1ZXMgZm9yICR7bmFtZX0gYXJlOmAsIC4uLnZhbHVlcywgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZyb20gd2l0aGluIGFuIG92ZXJ3cml0ZSwgYSBtZXRob2QgY2FuIGNhbGwgYSBwYXJlbnQgbWV0aG9kLCBieSB1c2luZyBjYWxsT3ZlcndyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIGFmdGVyU2V0SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAqICAgICAgICAvLyBkbyB0aGUgc3RhbmRhcmRcbiAgICAgKiAgICAgICAgdGhpcy5jYWxsT3ZlcndyaXR0ZW4oLi4uYXJndW1lbnRzKTtcbiAgICAgKiAgICAgICAgLy8gZG8geW91IG93biBzdHVmZlxuICAgICAqICAgIH1cbiAgICAgKlxuICAgICAqIFdlIGNyZWF0ZSBhbiBlcnJvciB0byBnZXQgdGhlIGNhbGxlci5uYW1lIGFuZCB0aGVuIHJ1biB0aGF0IG1ldGhvZCBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICogVGhpcyBpcyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIGVycm9yIHN0cnVjdHVyZSwgZS5nLiBhZnRlclNldEhlaWdodC5cbiAgICAgKlxuICAgICAqICAgICBFcnJvclxuICAgICAqICAgICAgICAgYXQgQmFzZS5jYWxsT3ZlcndyaXR0ZW4gKEJhc2UubWpzOjE3NjoyMSlcbiAgICAgKiAgICAgICAgIGF0IEJhc2UuYWZ0ZXJTZXRIZWlnaHQgKE92ZXJyaWRlcy5tanM6MTk6MjYpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGNhbGxPdmVyd3JpdHRlbiguLi5hcmdzKSB7XG4gICAgICAgIGxldCBzdGFjayAgICAgID0gbmV3IEVycm9yKCkuc3RhY2ssXG4gICAgICAgICAgICByZWdleCAgICAgID0gQmFzZS5tZXRob2ROYW1lUmVnZXgsXG4gICAgICAgICAgICBtZXRob2ROYW1lID0gc3RhY2subWF0Y2gocmVnZXgpWzFdO1xuXG4gICAgICAgIHRoaXMuX19wcm90b19fLmNvbnN0cnVjdG9yLm92ZXJ3cml0dGVuTWV0aG9kc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgSWRHZW5lcmF0b3IgdG8gY3JlYXRlIGFuIGlkIGlmIGEgc3RhdGljIG9uZSBpcyBub3QgZXhwbGljaXRseSBzZXQuXG4gICAgICogUmVnaXN0ZXJzIHRoZSBpbnN0YW5jZSB0byBtYW5hZ2VyLkluc3RhbmNlIGlmIHRoaXMgb25lIGlzIGFscmVhZHkgY3JlYXRlZCxcbiAgICAgKiBvdGhlcndpc2Ugc3RvcmVzIGl0IGluc2lkZSBhIHRtcCBtYXAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICovXG4gICAgY3JlYXRlSWQoaWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkIHx8IElkR2VuZXJhdG9yLmdldElkKHRoaXMuZ2V0SWRLZXkoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyB0aGlzIGluc3RhbmNlIGZyb20gTmVvLm1hbmFnZXIuSW5zdGFuY2VcbiAgICAgKiBhbmQgcmVtb3ZlcyBhbGwgb2JqZWN0IGVudHJpZXMgZnJvbSB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS4jdGltZW91dElkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKEJhc2UuaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBOZW8ubWFuYWdlci5JbnN0YW5jZS51bnJlZ2lzdGVyKG1lKVxuICAgICAgICB9IGVsc2UgaWYgKE5lby5pZE1hcCkge1xuICAgICAgICAgICAgZGVsZXRlIE5lby5pZE1hcFttZS5pZF1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKG1lKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtZSwga2V5KS53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG11c3Qgbm90IGRlbGV0ZSB0aGUgY3VzdG9tIGRlc3Ryb3koKSBpbnRlcmNlcHRvclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdkZXN0cm95JyAmJiBrZXkgIT09ICdfaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZVtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBXZSBkbyB3YW50IHRvIHByZXZlbnQgZGVsYXllZCBldmVudCBjYWxscyBhZnRlciBhbiBvYnNlcnZhYmxlIGluc3RhbmNlIGdvdCBkZXN0cm95ZWQuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihtZS5maXJlKSkge1xuICAgICAgICAgICAgbWUuZmlyZSA9IE5lby5lbXB0eUZuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc0Rlc3Ryb3llZCA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGluc2lkZSBjcmVhdGVJZCgpIGFzIHRoZSBkZWZhdWx0IHZhbHVlIHBhc3NlZCB0byB0aGUgSWRHZW5lcmF0b3IuXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm50eXBlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgY29uZmlnIGtleSBvciB0aGUgc3RhdGljQ29uZmlnIG9iamVjdCBpdHNlbGYgaW4gY2FzZSBubyB2YWx1ZSBpcyBzZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgb2YgYSBzdGF0aWNDb25maWcgZGVmaW5lZCBpbnNpZGUgc3RhdGljIGdldFN0YXRpY0NvbmZpZ1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN0YXRpY0NvbmZpZyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Jba2V5XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZ2l2ZW4gbnR5cGUgZXhpc3RzIGluc2lkZSB0aGUgcHJvdG8gY2hhaW4sIGluY2x1ZGluZyB0aGUgdG9wIGxldmVsIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG50eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzTnR5cGUobnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubnR5cGVDaGFpbi5pbmNsdWRlcyhudHlwZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBvbkNvbnN0cnVjdGVkKCkgaXMgZG9uZVxuICAgICAqIEBzZWUge0BsaW5rIE5lby5jb3JlLkJhc2Ujb25Db25zdHJ1Y3RlZCBvbkNvbnN0cnVjdGVkfVxuICAgICAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICAgICAqL1xuICAgIGluaXQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhbGwgY2xhc3MgY29uZmlncyB0byB0aGlzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRPcmlnaW5hbENvbmZpZ10gVHJ1ZSBwcmV2ZW50cyB0aGUgaW5zdGFuY2UgZnJvbSBnZXR0aW5nIGFuIG9yaWdpbmFsQ29uZmlnIHByb3BlcnR5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluaXRDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pc0NvbmZpZ3VyaW5nID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZVtjb25maWdTeW1ib2xdLCBtZS5tZXJnZUNvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykpO1xuICAgICAgICBtZS5wcm9jZXNzQ29uZmlncygpXG4gICAgICAgIG1lLmlzQ29uZmlndXJpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIGdldCB0cmlnZ2VyZWQgd2l0aCBhIGRlbGF5IHRvIGVuc3VyZSB0aGF0IE5lby53b3JrZXJJZCAmIE5lby53b3JrZXIuTWFuYWdlciBhcmUgZGVmaW5lZFxuICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIHZpYSBwcm9taXNlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0UmVtb3RlKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xhc3NOYW1lLCByZW1vdGV9ID0gbWUsXG4gICAgICAgICAgICB7Y3VycmVudFdvcmtlcn0gICAgID0gTmVvO1xuXG4gICAgICAgIGlmICghbWUuc2luZ2xldG9uICYmICFtZS5pc01haW5UaHJlYWRBZGRvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdGUgbWV0aG9kIGFjY2VzcyBpcyBvbmx5IGZ1bmN0aW9uYWwgZm9yIFNpbmdsZXRvbiBjbGFzc2VzICcgKyBjbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIU5lby5jb25maWcudW5pdFRlc3RNb2RlICYmIE5lby5pc09iamVjdChyZW1vdGUpKSB7XG4gICAgICAgICAgICBpZiAoTmVvLndvcmtlcklkICE9PSAnbWFpbicgJiYgY3VycmVudFdvcmtlci5pc1NoYXJlZFdvcmtlciAmJiAhY3VycmVudFdvcmtlci5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIub24oJ2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgQmFzZS5zZW5kUmVtb3RlcyhjbGFzc05hbWUsIHJlbW90ZSlcbiAgICAgICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCYXNlLnNlbmRSZW1vdGVzKGNsYXNzTmFtZSwgcmVtb3RlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJjZXB0cyBkZXN0cm95KCkgY2FsbHMgdG8gZW5zdXJlIHRoZXkgd2lsbCBvbmx5IGdldCBjYWxsZWQgb25jZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRGVzdHJveWVkQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0Rlc3Ryb3llZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgb3JkZXIgY29uZmlncyBhcmUgYXBwbGllZCB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBjdG9yID0gbWUuY29uc3RydWN0b3I7XG5cbiAgICAgICAgaWYgKCFjdG9yLmNvbmZpZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZW8uYXBwbHlDbGFzc0NvbmZpZyBoYXMgbm90IGJlZW4gcnVuIG9uICcgKyBtZS5jbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICAgICAgbWUub3JpZ2luYWxDb25maWcgPSBOZW8uY2xvbmUoY29uZmlnLCB0cnVlLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi5jdG9yLmNvbmZpZywgLi4uY29uZmlnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25BZnRlckNvbnN0cnVjdGVkKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzQ29uc3RydWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGZpcmUgdGhlIGV2ZW50IGluIGNhc2UgdGhlIE9ic2VydmFibGUgbWl4aW4gaXMgaW5jbHVkZWQuXG4gICAgICAgIG1lLmdldFN0YXRpY0NvbmZpZygnb2JzZXJ2YWJsZScpICYmIG1lLmZpcmUoJ2NvbnN0cnVjdGVkJywgbWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIGNvbnN0cnVjdG9ycyBhcmUgZG9uZVxuICAgICAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byByZXBsYWNlIHN0cmluZyBiYXNlZCB2YWx1ZXMgY29udGFpbmluZyBcIkBjb25maWc6XCIgd2l0aCB0aGUgbWF0Y2hpbmcgY29uZmlnIHZhbHVlXG4gICAgICogb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBwYXJzZUl0ZW1Db25maWdzKGl0ZW1zKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBucywgbnNBcnJheSwgbnNLZXksIHN5bWJvbE5zO1xuXG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gW2l0ZW1zXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0gJiYgT2JqZWN0LmVudHJpZXMoaXRlbSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucGFyc2VJdGVtQ29uZmlncyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zdGFydHNXaXRoKCdAY29uZmlnOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuc0FycmF5ID0gdmFsdWUuc3Vic3RyaW5nKDgpLnRyaW0oKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnNLZXkgICA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBucyAgICAgID0gTmVvLm5zKG5zQXJyYXksIGZhbHNlLCBtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuc1tuc0tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSB1c2VkIEBjb25maWcgZG9lcyBub3QgZXhpc3Q6JywgbnNLZXksIG5zQXJyYXkuam9pbignLicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOcyA9IE5lby5ucyhuc0FycmF5LCBmYWxzZSwgbWVbY29uZmlnU3ltYm9sXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnIG1pZ2h0IG5vdCBiZSBwcm9jZXNzZWQgeWV0LCBlc3BlY2lhbGx5IGZvciBjb25maWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVuZGluZyB3aXRoIGFuIHVuZGVyc2NvcmUsIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGNvbmZpZ1N5bWJvbCBmaXJzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sTnMgJiYgT2JqZWN0Lmhhc093bihzeW1ib2xOcywgbnNLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1ba2V5XSA9IHN5bWJvbE5zW25zS2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1ba2V5XSA9IG5zW25zS2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyBzZXQoKSwgY29uZmlncyB3aXRob3V0IGEgdHJhaWxpbmcgdW5kZXJzY29yZSBjYW4gYWxyZWFkeSBiZSBhc3NpZ25lZCxcbiAgICAgKiBzbyB0aGUgaGFzT3duUHJvcGVydHkoKSBjaGVjayB3aWxsIHJldHVybiB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBc3NpZ249ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb2Nlc3NDb25maWdzKGZvcmNlQXNzaWduPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhtZVtjb25maWdTeW1ib2xdKTtcblxuICAgICAgICBtZVtmb3JjZUFzc2lnbkNvbmZpZ3NdID0gZm9yY2VBc3NpZ247XG5cbiAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBrZXlzLCBzaW5jZSAxIGNvbmZpZyBjYW4gcmVtb3ZlIG1vcmUgdGhhbiAxIGtleSAoYmVmb3JlU2V0WCwgYWZ0ZXJTZXRYKVxuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBUaGUgaGFzT3duUHJvcGVydHkgY2hlY2sgaXMgaW50ZW5kZWQgZm9yIGNvbmZpZ3Mgd2l0aG91dCBhIHRyYWlsaW5nIHVuZGVyc2NvcmVcbiAgICAgICAgICAgIC8vID0+IHRoZXkgY291bGQgYWxyZWFkeSBoYXZlIGJlZW4gYXNzaWduZWQgaW5zaWRlIGFuIGFmdGVyU2V0LW1ldGhvZFxuICAgICAgICAgICAgaWYgKGZvcmNlQXNzaWduIHx8ICFtZS5oYXNPd25Qcm9wZXJ0eShrZXlzWzBdKSkge1xuICAgICAgICAgICAgICAgIG1lW2tleXNbMF1dID0gbWVbY29uZmlnU3ltYm9sXVtrZXlzWzBdXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhIGRlbGV0ZS1jYWxsIGluc2lkZSB0aGUgY29uZmlnIGdldHRlciBhcyB3ZWxsIChOZW8ubWpzID0+IGF1dG9HZW5lcmF0ZUdldFNldCgpKVxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBrZWVwIHRoaXMgb25lIGZvciBjb25maWdzLCB3aGljaCBkbyBub3QgdXNlIGdldHRlcnMgKG5vIHRyYWlsaW5nIHVuZGVyc2NvcmUpXG4gICAgICAgICAgICBkZWxldGUgbWVbY29uZmlnU3ltYm9sXVtrZXlzWzBdXTtcblxuICAgICAgICAgICAgbWUucHJvY2Vzc0NvbmZpZ3MoZm9yY2VBc3NpZ24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlbW90ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VuZFJlbW90ZXMoY2xhc3NOYW1lLCByZW1vdGUpIHtcbiAgICAgICAgbGV0IG9yaWdpbjtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhyZW1vdGUpLmZvckVhY2goKFt3b3JrZXIsIG1ldGhvZHNdKSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLndvcmtlcklkICE9PSB3b3JrZXIpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBOZW8ud29ya2VySWQgPT09ICdtYWluJyA/IE5lby53b3JrZXIuTWFuYWdlciA6IE5lby5jdXJyZW50V29ya2VyO1xuXG4gICAgICAgICAgICAgICAgb3JpZ2luLnNlbmRNZXNzYWdlKHdvcmtlciwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdyZWdpc3RlclJlbW90ZScsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIG11bHRpcGxlIGNvbmZpZ3MgYXQgb25jZSwgZW5zdXJpbmcgdGhhdCBhbGwgYWZ0ZXJTZXQgbWV0aG9kcyBnZXQgYWxsIG5ldyBhc3NpZ25lZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICovXG4gICAgc2V0KHZhbHVlcz17fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHZhbHVlcyA9IG1lLnNldEZpZWxkcyh2YWx1ZXMpO1xuXG4gICAgICAgIC8vIElmIHRoZSBpbml0aWFsIGNvbmZpZyBwcm9jZXNzaW5nIGlzIHN0aWxsIHJ1bm5pbmcsXG4gICAgICAgIC8vIGZpbmlzaCB0aGlzIG9uZSBmaXJzdCBiZWZvcmUgZHJvcHBpbmcgbmV3IHZhbHVlcyBpbnRvIHRoZSBjb25maWdTeW1ib2wuXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIyMDFcbiAgICAgICAgaWYgKG1lW2ZvcmNlQXNzaWduQ29uZmlnc10gIT09IHRydWUgJiYgT2JqZWN0LmtleXMobWVbY29uZmlnU3ltYm9sXSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWUucHJvY2Vzc0NvbmZpZ3MoKVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZVtjb25maWdTeW1ib2xdLCB2YWx1ZXMpO1xuXG4gICAgICAgIG1lLnByb2Nlc3NDb25maWdzKHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byBhc3NpZ24gY2xhc3MgZmllbGRzIGZpcnN0IGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBjb25maWcgb2JqZWN0LFxuICAgICAqIHNvIHRoYXQgYWZ0ZXJTZXQoKSwgYmVmb3JlR2V0KCkgYW5kIGJlZm9yZVNldCgpIG1ldGhvZHMgY2FuIGdldCB0aGUgbmV3IHZhbHVlcyByaWdodCBhd2F5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldEZpZWxkcyhjb25maWcpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZ05hbWVzID0gbWUuY29uc3RydWN0b3IuY29uZmlnO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZ05hbWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgIU5lby5oYXNQcm9wZXJ0eVNldHRlcihtZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIG1lW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgY29uZmlnIGJ5IGEgZ2l2ZW4ga2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IG9mIGEgc3RhdGljQ29uZmlnIGRlZmluZWQgaW5zaWRlIHN0YXRpYyBnZXRTdGF0aWNDb25maWdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgY29uZmlnIGV4aXN0cyBhbmQgZ290IGNoYW5nZWRcbiAgICAgKi9cbiAgICBzZXRTdGF0aWNDb25maWcoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgc3RhdGljQ29uZmlnID0gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWNDb25maWc7XG5cbiAgICAgICAgaWYgKHN0YXRpY0NvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBzdGF0aWNDb25maWdba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aW1lb3V0SWRzIGludGVybmFsbHksIHNvIHRoYXQgZGVzdHJveSgpIGNhbiBjbGVhciB0aGVtIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0SWRzID0gdGhpcy4jdGltZW91dElkcyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgID0gc2V0VGltZW91dCgoKSA9PiB7dGltZW91dElkcy5zcGxpY2UodGltZW91dElkcy5pbmRleE9mKHRpbWVvdXRJZCwgMSkpOyByZXNvbHZlKCl9LCB0aW1lKTtcblxuICAgICAgICAgICAgdGltZW91dElkcy5wdXNoKHRpbWVvdXRJZClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmhhbmNpbmcgdGhlIHRvU3RyaW5nKCkgbWV0aG9kLCBlLmcuPC9wPlxuICAgICAqIGBOZW8uY3JlYXRlKCdOZW8uYnV0dG9uLkJhc2UnKS50b1N0cmluZygpID0+IFwiW29iamVjdCBOZW8uYnV0dG9uLkJhc2UgKG5lby1idXR0b24tMSldXCJgXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNsYXNzTmFtZX0gKGlkOiAke3RoaXMuaWR9KWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmhhbmNpbmcgdGhlIGluc3RhbmNlb2YgbWV0aG9kLiBXaXRob3V0IHRoaXMgY2hhbmdlOjwvcD5cbiAgICAgKiBgTmVvLmNvbGxlY3Rpb24uQmFzZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IHRydWVgXG4gICAgICogPHA+V2l0aCB0aGlzIGNoYW5nZTo8L3A+XG4gICAgICogYE5lby5jb2xsZWN0aW9uLkJhc2UucHJvdG90eXBlIGluc3RhbmNlb2YgTmVvLmNvcmUuQmFzZSA9PiBmYWxzZWA8YnI+XG4gICAgICogYE5lby5jcmVhdGUoTmVvLmNvbGxlY3Rpb24uQmFzZSkgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IHRydWVgXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlW2lzSW5zdGFuY2VdID09PSB0cnVlID8gc3VwZXJbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkgOiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvcmUuQ29tcGFyZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBDb21wYXJlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29yZS5Db21wYXJlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29yZS5Db21wYXJlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbTFcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzRXF1YWwoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIGlmIChpdGVtMSA9PT0gaXRlbTIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHR5cGUxID0gTmVvLnR5cGVPZihpdGVtMSksXG4gICAgICAgICAgICB0eXBlMiA9IE5lby50eXBlT2YoaXRlbTIpLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGlmICh0eXBlMSAhPT0gdHlwZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZTEpIHtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5Jzoge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtMS5sZW5ndGggIT09IGl0ZW0yLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgaXRlbTEuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQ29tcGFyZS5pc0VxdWFsKHYsIGl0ZW0yW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ0RhdGUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0xLnZhbHVlT2YoKSA9PT0gaXRlbTIudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdGdW5jdGlvbic6IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbTEubmFtZSAhPT0gaXRlbTIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0xLnRvU3RyaW5nKCkgPT09IGl0ZW0yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ01hcCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbTEuc2l6ZSAhPT0gaXRlbTIuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHZhbDI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgaXRlbTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsMiA9IGl0ZW0yLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwyICE9PSB2YWwgfHwgdmFsMiA9PT0gdW5kZWZpbmVkICYmICFpdGVtMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ05lb0luc3RhbmNlJzoge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtMS5pZCAhPT0gaXRlbTIuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdPYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGl0ZW0xKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGl0ZW0yKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGl0ZW0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQ29tcGFyZS5pc0VxdWFsKGl0ZW0xW2tleV0sIGl0ZW0yW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnUmVnRXhwJzoge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtMS50b1N0cmluZygpICE9PSBpdGVtMi50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnU2V0Jzoge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtMS5zaXplICE9PSBpdGVtMi5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGtleSBvZiBpdGVtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0yLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtMSA9PT0gaXRlbTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbkNvbXBhcmUgPSBOZW8uc2V0dXBDbGFzcyhDb21wYXJlKTtcblxuLy8gYWxpYXNcbk5lby5pc0VxdWFsID0gQ29tcGFyZS5pc0VxdWFsO1xuXG5leHBvcnQgZGVmYXVsdCBDb21wYXJlO1xuIiwiLyoqXG4gKiBUaGlzIGNsYXNzIGdldHMgdXNlZCBieSBjb3JlLkJhc2UsIHNvIGl0IGNhbiBub3QgZXh0ZW5kIGl0LlxuICogSXQgY291bGQgZ2V0IHNpbXBsaWZpZWQgdG8ganVzdCBiZWluZyBhbiBvYmplY3QgKG5lZWRzIHRvIG1hbnVhbGx5IGdldCBwdXQgaW50byB0aGUgTmVvIG5hbWVzcGFjZSBpbiB0aGlzIGNhc2UpLlxuICogQGNsYXNzIE5lby5jb3JlLklkR2VuZXJhdG9yXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIElkR2VuZXJhdG9yIHtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyBvbmUgdG8gZmFsc2UgaW4gY2FzZSB5b3UgZG9uJ3Qgd2FudCB0byBzdGlja1xuICAgICAqIHRvIHRoZSBcImFudGktcGF0dGVyblwiIHRvIGFwcGx5IGNsYXNzZXMgdG8gdGhlIGdsb2JhbCBOZW8gb3IgQXBwIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlZ2lzdGVyVG9HbG9iYWxOcz10cnVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJUb0dsb2JhbE5zID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29yZS5JZEdlbmVyYXRvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvcmUuSWRHZW5lcmF0b3InLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0naWQtZ2VuZXJhdG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2lkLWdlbmVyYXRvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBwcmVmaXggZm9yIG5lbyBpbnN0YW5jZSBpZHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBiYXNlPSduZW8tJ1xuICAgICAgICAgKi9cbiAgICAgICAgYmFzZTogJ25lby0nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPSd0cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaWRDb3VudGVyID0ge307XG5cbiAgICAgICAgLy8gYWxpYXNcbiAgICAgICAgTmVvLmdldElkID0gbWUuZ2V0SWQuYmluZChtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldElkKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgJ25lbyc7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY291bnRlciA9IG1lLmlkQ291bnRlcixcbiAgICAgICAgICAgIGNvdW50ICAgPSBjb3VudGVyW25hbWVdIHx8IDA7XG5cbiAgICAgICAgY291bnRlcltuYW1lXSA9ICsrY291bnQ7XG5cbiAgICAgICAgcmV0dXJuIG1lLmJhc2UgKyAobmFtZSA9PT0gJ25lbycgPyAnJyA6IG5hbWUgKyAnLScpICsgY291bnQ7XG4gICAgfVxuXG4gICAgaW5pdCgpIHt9XG5cbiAgICBvbkFmdGVyQ29uc3RydWN0ZWQoKSB7fVxuXG4gICAgb25Db25zdHJ1Y3RlZCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKElkR2VuZXJhdG9yKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvcmUuT2JzZXJ2YWJsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvcmUuT2JzZXJ2YWJsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdtaXhpbi1vYnNlcnZhYmxlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21peGluLW9ic2VydmFibGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbWl4aW49dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3JkZXJdXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBldmVudElkIG51bGwgaW4gY2FzZSBhbiBvYmplY3QgZ2V0cyBwYXNzZWQgYXMgdGhlIG5hbWUgKG11bHRpcGxlIGlkcylcbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihuYW1lLCBvcHRzLCBzY29wZSwgZXZlbnRJZCwgZGF0YSwgb3JkZXIpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGVsYXkgICAgICAgICA9IDAsXG4gICAgICAgICAgICBldmVudElkT2JqZWN0ID0gdHlwZW9mIGV2ZW50SWQgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgbmFtZU9iamVjdCAgICA9IHR5cGVvZiBuYW1lICAgID09PSAnb2JqZWN0JyxcbiAgICAgICAgICAgIG9uY2UgICAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG9wdHNUeXBlICAgICAgPSB0eXBlb2Ygb3B0cyxcbiAgICAgICAgICAgIGxpc3RlbmVyLCBleGlzdGluZywgZXZlbnRDb25maWc7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogbGV0IHVzIHN1cHBvcnQgdGhlIGZvbGxvd2luZyBmb3JtYXQgdG9vOlxuICAgICAgICAgKlxuICAgICAgICAgKiBjdXJyZW50V29ya2VyLm9uKCdjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAqICAgICBCYXNlLnNlbmRSZW1vdGVzKGNsYXNzTmFtZSwgcmVtb3RlKVxuICAgICAgICAgKiB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGV2ZW50SWRPYmplY3QgJiYgb3B0c1R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGV2ZW50SWQuZm4gPSBvcHRzO1xuICAgICAgICAgICAgb3B0cyAgICAgPSBldmVudElkO1xuICAgICAgICAgICAgb3B0c1R5cGUgPSAnb2JqZWN0JztcbiAgICAgICAgICAgIGV2ZW50SWQgID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eSgnZGVsYXknKSkge1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gbmFtZS5kZWxheTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5kZWxheVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eSgnb25jZScpKSB7XG4gICAgICAgICAgICAgICAgb25jZSA9IG5hbWUub25jZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5vbmNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdzY29wZScpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBuYW1lLnNjb3BlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLnNjb3BlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG5hbWUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFkZExpc3RlbmVyKGtleSwge2RlbGF5LCBvbmNlLCBzY29wZSwgLi4udmFsdWV9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFkZExpc3RlbmVyKGtleSwge2RlbGF5LCBmbjogdmFsdWUsIG9uY2UsIHNjb3BlfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKG9wdHNUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGVsYXkgICAgPSBkZWxheSAgIHx8IG9wdHMuZGVsYXk7XG4gICAgICAgICAgICBldmVudElkICA9IGV2ZW50SWQgfHwgb3B0cy5ldmVudElkO1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBvcHRzLmZuO1xuICAgICAgICAgICAgb25jZSAgICAgPSBvbmNlICAgIHx8IG9wdHMub25jZTtcbiAgICAgICAgICAgIG9yZGVyICAgID0gb3JkZXIgICB8fCBvcHRzLm9yZGVyO1xuICAgICAgICAgICAgc2NvcGUgICAgPSBzY29wZSAgIHx8IG9wdHMuc2NvcGVcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBvcHRzXG4gICAgICAgIH0gZWxzZSBpZiAob3B0c1R5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IG9wdHMgLy8gVkMgaG9vaywgY2FuIGdldCBwYXJzZWQgYWZ0ZXIgb25Db25zdHJ1Y3RlZCBpbiBjYXNlIHRoZSB2aWV3IHVzZXMgdGhlIHBhcmVudCBWQ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZExpc3RlbmVyIGNhbGw6ICcgKyBuYW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuYW1lT2JqZWN0KSB7XG4gICAgICAgICAgICBldmVudENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgICAgIGZuOiBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBpZDogZXZlbnRJZCB8fCBOZW8uZ2V0SWQoJ2V2ZW50JyksXG4gICAgICAgICAgICAgICAgb25jZSxcbiAgICAgICAgICAgICAgICBzY29wZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nID0gbWUubGlzdGVuZXJzPy5bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZy5mb3JFYWNoKGNmZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZmcuaWQgPT09IGV2ZW50SWQgfHwgKGNmZy5mbiA9PT0gbGlzdGVuZXIgJiYgY2ZnLnNjb3BlID09PSBzY29wZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0R1cGxpY2F0ZSBldmVudCBoYW5kbGVyIGF0dGFjaGVkOicsIG5hbWUsIG1lKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5zcGxpY2Uob3JkZXIsIDAsIGV2ZW50Q29uZmlnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdiZWZvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnVuc2hpZnQoZXZlbnRDb25maWcpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChldmVudENvbmZpZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmxpc3RlbmVyc1tuYW1lXSA9IFtldmVudENvbmZpZ11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50Q29uZmlnLmlkXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIHBhc3NlZCBmdW5jdGlvbiwgb3IgYSBmdW5jdGlvbiBieSAqbmFtZSogd2hpY2ggZXhpc3RzIGluIHRoZSBwYXNzZWQgc2NvcGUnc1xuICAgICAqIG9yIHRoaXMgY29tcG9uZW50J3Mgb3duZXJzaGlwIGNoYWluLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBBIGZ1bmN0aW9uLCBvciB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGZpbmQgaW4gdGhlIHBhc3NlZCBzY29wZSBvYmplY3QvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBzY29wZSB0byBmaW5kIHRoZSBmdW5jdGlvbiBpbiBpZiBpdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gICAgICovXG4gICAgY2FsbGJhY2soZm4sIHNjb3BlPXRoaXMsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gcmVzb2x2ZUNhbGxiYWNrKGZuLCBzY29wZSk7XG4gICAgICAgICAgICBoYW5kbGVyLmZuLmFwcGx5KGhhbmRsZXIuc2NvcGUsIGFyZ3MpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kIGZvciBldmVudHMgd2hpY2ggdXNlIHRoZSBkZWxheSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gICAgICovXG4gICAgZGVsYXllZENhbGxiYWNrKGNiLCBhcmdzLCBkZWxheSkge1xuICAgICAgICB0aGlzLnRpbWVvdXQoZGVsYXkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY2IuZm4uYXBwbHkoY2Iuc2NvcGUsIGFyZ3MpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKi9cbiAgICBmaXJlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzICAgICAgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBtZS5saXN0ZW5lcnMsXG4gICAgICAgICAgICBkZWxheSwgaGFuZGxlciwgaGFuZGxlcnMsIGksIGxlbjtcblxuICAgICAgICBpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgaGFuZGxlcnMgPSBbLi4ubGlzdGVuZXJzW25hbWVdXTtcbiAgICAgICAgICAgIGxlbiAgICAgID0gaGFuZGxlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgICAgZGVsYXkgICA9IGhhbmRsZXIuZGVsYXk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIGZ1bmN0aW9uIG5hbWUgb24gdGhlIHNjb3BlIChvciBtZSksIG9yLCBpZiBpdCBzdGFydHMgd2l0aCAndXAuJ1xuICAgICAgICAgICAgICAgIC8vIGxvb2sgaW4gdGhlIG93bmVyc2hpcCBoaWVyYXJjaHkgZnJvbSBtZS5cbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IHJlc29sdmVDYWxsYmFjayhoYW5kbGVyLmZuLCBoYW5kbGVyLnNjb3BlIHx8IG1lKTtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGlzdGVuZXIgaWYgdGhlIHNjb3BlIG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAoY2Iuc2NvcGUgJiYgIWNiLnNjb3BlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tuYW1lXS5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCBldmVudCBmb3JtYXQuIEluamVjdCBmaXJlciByZWZlcmVuY2UgaW4gYXMgJ3NvdXJjZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBOZW8uaXNPYmplY3QoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzBdLnNvdXJjZSA9IG1lLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGlzdGVuZXIgaWYgaXQgaGFzIHRoZSBvbmNlIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub25jZSAmJiBsaXN0ZW5lcnNbbmFtZV0uc3BsaWNlKGksIDEpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNOdW1iZXIoZGVsYXkpICYmIGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmRlbGF5ZWRDYWxsYmFjayhjYiwgaGFuZGxlci5kYXRhID8gYXJncy5jb25jYXQoaGFuZGxlci5kYXRhKSA6IGFyZ3MsIGRlbGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYi5mbi5hcHBseShjYi5zY29wZSwgaGFuZGxlci5kYXRhID8gYXJncy5jb25jYXQoaGFuZGxlci5kYXRhKSA6IGFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgaW5pdE9ic2VydmFibGUoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwcm90byA9IG1lLl9fcHJvdG9fXyxcbiAgICAgICAgICAgIGN0b3IgID0gcHJvdG8uY29uc3RydWN0b3IsXG4gICAgICAgICAgICBsaXN0ZW5lcnM7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIG1lLmxpc3RlbmVycyA9IGNvbmZpZy5saXN0ZW5lcnM7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLmxpc3RlbmVyc1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXJzID0gbWUubGlzdGVuZXJzO1xuXG4gICAgICAgIG1lLmxpc3RlbmVycyA9IHt9O1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QobGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IHsuLi5saXN0ZW5lcnN9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmFkZExpc3RlbmVyKGxpc3RlbmVycyk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocHJvdG8/LmNvbnN0cnVjdG9yLmlzQ2xhc3MpIHtcbiAgICAgICAgICAgIGN0b3IgPSBwcm90by5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAgICAgaWYgKGN0b3Iub2JzZXJ2YWJsZSAmJiAhY3Rvci5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGN0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIgICA6IG1lLmFkZExpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICBmaXJlICAgICAgICAgIDogbWUuZmlyZSxcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzICAgICA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBvbiAgICAgICAgICAgIDogbWUub24sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyOiBtZS5yZW1vdmVMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgdW4gICAgICAgICAgICA6IG1lLnVuXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG8gPSBwcm90by5fX3Byb3RvX19cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBhZGRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcl1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBldmVudElkXG4gICAgICovXG4gICAgb24oLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lciguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGFyZSBkaWZmZXJlbnQgc3ludGF4J3MgaG93IHlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kLlxuICAgICAqIFVzaW5nIHRoZSBldmVudElkOlxuICAgICAqIGBgYFxuICAgICAqIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsICduZW8tZXZlbnQtNycpO1xuICAgICAqIGBgYFxuICAgICAqIFBhc3NpbmcgdGhlIGhhbmRsZXIgbWV0aG9kOlxuICAgICAqIGBgYFxuICAgICAqIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UsIHRoaXMpO1xuICAgICAqIGBgYFxuICAgICAqIFBhc3NpbmcgYW4gb2JqZWN0OlxuICAgICAqIGBgYFxuICAgICAqIG1lLmZpZWxkLnVuKHtcbiAgICAgKiAgICAgY2hhbmdlICAgICAgICAgICAgICAgICAgICA6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICogICAgIGNoYW5nZUNsZWFyVG9PcmlnaW5hbFZhbHVlOiBtZS5vbkZpZWxkQ2hhbmdlLFxuICAgICAqICAgICBzY29wZSAgICAgICAgICAgICAgICAgICAgIDogbWVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gW2V2ZW50SWRdXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBbc2NvcGVdXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRJZCwgc2NvcGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGksIGxlbiwgbGlzdGVuZXIsIGxpc3RlbmVycywgbWF0Y2g7XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKGV2ZW50SWQpKSB7XG4gICAgICAgICAgICBtZS5yZW1vdmVMaXN0ZW5lcih7W25hbWVdOiBldmVudElkLCBzY29wZX0pO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5zY29wZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gbmFtZS5zY29wZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5zY29wZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobmFtZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbWUubGlzdGVuZXJzW2tleV0gfHwgW107XG4gICAgICAgICAgICAgICAgaSAgICAgICAgID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5mbi5uYW1lID09PSAoTmVvLmlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlIDogdmFsdWUubmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLnNjb3BlICAgPT09IHNjb3BlXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNTdHJpbmcoZXZlbnRJZCkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IG1lLmxpc3RlbmVyc1tuYW1lXTtcbiAgICAgICAgICAgIG1hdGNoICAgICA9IGZhbHNlO1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoZXZlbnRDb25maWcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudENvbmZpZy5pZCA9PT0gZXZlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPSBpZHhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UobWF0Y2gsIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgIC8vIH0sXG5cbiAgICAvLyBzdXNwZW5kTGlzdGVuZXJzOiBmdW5jdGlvbihxdWV1ZSkge1xuXG4gICAgLy8gfSxcblxuICAgIC8vIHJlc3VtZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgcmVtb3ZlTGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2V2ZW50SWRdXG4gICAgICovXG4gICAgdW4oLi4uYXJncykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoT2JzZXJ2YWJsZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvcmUuVXRpbFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBVdGlsIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQSByZWdleCB0byByZW1vdmUgY2FtZWwgY2FzZSBzeW50YXhcbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IGRlY2FtZWxSZWdFeD0vKFthLXpdKShbQS1aXSkvZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRlY2FtZWxSZWdFeCA9IC8oW2Etel0pKFtBLVpdKS9nXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb3JlLlV0aWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb3JlLlV0aWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29yZS11dGlsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvcmUtdXRpbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZE1ldGhvZHMoc2NvcGUsIHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzY29wZVt2YWx1ZV0gPSBzY29wZVt2YWx1ZV0uYmluZChzY29wZSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgc3R5bGVzIHN0cmluZyBpbnRvIGEgc3R5bGVzIG9iamVjdCB1c2luZyBjYW1lbGNhc2Ugc3ludGF4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgc3R5bGVzIHN0cmluZyB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjYW1lbGNhc2Ugc3R5bGVzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdHlsZU9iamVjdChzdHJpbmcpIHtcbiAgICAgICAgbGV0IHBhcnRzO1xuXG4gICAgICAgIC8vIHNwbGl0KCc7JykgZG9lcyBmZXRjaCBzZW1pY29sb25zIGluc2lkZSBicmFja2V0c1xuICAgICAgICAvLyAtPiBiYWNrZ3JvdW5kLWltYWdlOiBcInVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LC4uLlxuXG4gICAgICAgIC8vIFRPRE86IENhY2hlIGFsbCByZWdleFxuICAgICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KC87KD89W15cXCldKig/OlxcKHwkKSkvZykucmVkdWNlKChvYmosIGVsKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHNwbGl0IGJ5IHRoZSBmaXJzdCBjb2xvbiBvbmx5XG4gICAgICAgICAgICAvLyAtPiBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5wbmcnKVxuICAgICAgICAgICAgcGFydHMgPSBlbC5zcGxpdCgoLzooLispLykpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGxldCBudW0gPSBwYXJzZUZsb2F0KHgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPT0gbnVtID8gbnVtIDogeC50cmltKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGFydHNbMF0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5yZXBsYWNlKC8tKFthLXpdKS9nLCAoc3RyLCBsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBvYmpbcGFydHNbMF1dID0gcGFydHNbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgfSwge30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHlsZXMgb2JqZWN0IHdoaWNoIGNhbiB1c2UgY2FtZWxjYXNlIHN5bnRheCBpbnRvIGEgc3R5bGVzIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgVGhlIHN0eWxlcyBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3R5bGVzIHN0cmluZyAoRE9NIHJlYWR5KVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGxldCBzdHlsZSA9ICcnO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHN0eWxlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlICs9IFV0aWwuZGVjYW1lbChrZXkpICsgJzonICsgdmFsdWUgKyAnOydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbGwgdXBwZXJjYXNlIGNoYXJhY3RlcnMgb2YgYSBzdHJpbmcgaW50byAtbG93ZXJjYXNlLlxuICAgICAqIERvZXMgbm90IHRvdWNoIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGlucHV0IGNvbnRhaW5pbmcgdXBwZXJjYXNlIGNoYXJhY3RlcnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbG93ZXJjYXNlIG91dHB1dFxuICAgICAqL1xuICAgIHN0YXRpYyBkZWNhbWVsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKFV0aWwuZGVjYW1lbFJlZ0V4LCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gZW1wdHkgQXJyYXksIE9iamVjdCBvciBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWwuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBudW1iZXIuIFJldHVybnMgZmFsc2UgZm9yIG5vbi1maW5pdGUgbnVtYmVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc051bWJlcih2YWx1ZSl7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnT2JqZWN0JyB8fCBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgbmVvIGRhdGEgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzUmVjb3JkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdSZWNvcmQnIHx8IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbnkgaXRlcmFibGUgKHN0cmluZ3MsIG51bWVyaWMgaW5kaWNlcyBhbmQgYSBsZW5ndGggcHJvcGVydHkpIGludG8gYSB0cnVlIGFycmF5XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpdGVyYWJsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZD1pdGVyYWJsZS5sZW5ndGhdIGVuZCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgdG9BcnJheShpdGVyYWJsZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBsZXQgbGVuO1xuXG4gICAgICAgIGlmICghaXRlcmFibGUgfHwgIShsZW4gPSBpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmFibGUuc3BsaXQoJycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXRlcmFibGUsIHN0YXJ0IHx8IDAsIGVuZCB8fCBsZW4pXG4gICAgfVxufVxuXG5VdGlsID0gTmVvLnNldHVwQ2xhc3MoVXRpbCk7XG5cbi8vIGFsaWFzZXNcbk5lby5hcHBseUZyb21OcyhOZW8sIFV0aWwsIHtcbiAgICBiaW5kTWV0aG9kcyAgICAgIDogJ2JpbmRNZXRob2RzJyxcbiAgICBjcmVhdGVTdHlsZU9iamVjdDogJ2NyZWF0ZVN0eWxlT2JqZWN0JyxcbiAgICBjcmVhdGVTdHlsZXMgICAgIDogJ2NyZWF0ZVN0eWxlcycsXG4gICAgZGVjYW1lbCAgICAgICAgICA6ICdkZWNhbWVsJyxcbiAgICBpc0FycmF5ICAgICAgICAgIDogJ2lzQXJyYXknLFxuICAgIGlzQm9vbGVhbiAgICAgICAgOiAnaXNCb29sZWFuJyxcbiAgICBpc0RlZmluZWQgICAgICAgIDogJ2lzRGVmaW5lZCcsXG4gICAgaXNFbXB0eSAgICAgICAgICA6ICdpc0VtcHR5JyxcbiAgICBpc0Z1bmN0aW9uICAgICAgIDogJ2lzRnVuY3Rpb24nLFxuICAgIGlzTnVtYmVyICAgICAgICAgOiAnaXNOdW1iZXInLFxuICAgIGlzT2JqZWN0ICAgICAgICAgOiAnaXNPYmplY3QnLFxuICAgIGlzUmVjb3JkICAgICAgICAgOiAnaXNSZWNvcmQnLFxuICAgIGlzU3RyaW5nICAgICAgICAgOiAnaXNTdHJpbmcnLFxuICAgIHRvQXJyYXkgICAgICAgICAgOiAndG9BcnJheSdcbn0sIHRydWUpO1xuXG5leHBvcnQgZGVmYXVsdCBVdGlsO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBhcmUgICAgIGZyb20gJy4vQ29tcGFyZS5tanMnO1xuaW1wb3J0IElkR2VuZXJhdG9yIGZyb20gJy4vSWRHZW5lcmF0b3IubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICBmcm9tICcuL09ic2VydmFibGUubWpzJztcbmltcG9ydCBVdGlsICAgICAgICBmcm9tICcuL1V0aWwubWpzJztcblxuZXhwb3J0IHtCYXNlLCBDb21wYXJlLCBJZEdlbmVyYXRvciwgT2JzZXJ2YWJsZSwgVXRpbH07XG4iLCJpbXBvcnQgQ29sbGVjdGlvbkJhc2UgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgdGhlIG90aGVyIG1hbmFnZXIgY2xhc3Nlc1xuICogQGNsYXNzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb2xsZWN0aW9uLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvbGxlY3Rpb25CYXNle1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuQmFzZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRCeUlkKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCAmJiB0aGlzLmdldChpZCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICovXG4gICAgcmVnaXN0ZXIoaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5nZXQoaXRlbS5pZCkpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcignVHJ5aW5nIHRvIGNyZWF0ZSBhbiBpdGVtIHdpdGggYW4gYWxyZWFkeSBleGlzdGluZyBpZCcsIGl0ZW0sIG1lLmdldChpdGVtLmlkKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnB1c2goaXRlbSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aW9uIGl0ZW0gcGFzc2VkIGJ5IHJlZmVyZW5jZSBvciBrZXlcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGl0ZW1cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIiwiaW1wb3J0IEJhc2UgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBWTm9kZVV0aWwgZnJvbSAnLi4vdXRpbC9WTm9kZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5maXJzdCAgICAgICAgPSBtZS5nZXRGaXJzdC5iaW5kKG1lKTsgLy8gYWxpYXNcbiAgICAgICAgTmVvLmdldENvbXBvbmVudCA9IG1lLmdldEJ5SWQuYmluZChtZSkgICAvLyBhbGlhc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNvbXBvbmVudCB3aGljaCBtYXRjaGVzIHRoZSBjb25maWctc2VsZWN0b3IgbW92aW5nIGRvd24gdGhlIGNvbXBvbmVudCBpdGVtcyB0cmVlLlxuICAgICAqIFVzZSByZXR1cm5GaXJzdE1hdGNoPWZhbHNlIHRvIGdldCBhbiBhcnJheSBvZiBhbGwgbWF0Y2hpbmcgaXRlbXMgaW5zdGVhZC5cbiAgICAgKiBJZiBubyBtYXRjaCBpcyBmb3VuZCwgcmV0dXJucyBudWxsIGluIGNhc2UgcmV0dXJuRmlyc3RNYXRjaCA9PT0gdHJ1ZSwgb3RoZXJ3aXNlIGFuIGVtcHR5IEFycmF5LlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfFN0cmluZ30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfG51bGx9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD10cnVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXXxudWxsfVxuICAgICAqL1xuICAgIGRvd24oY29tcG9uZW50LCBjb25maWcsIHJldHVybkZpcnN0TWF0Y2g9dHJ1ZSkge1xuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0QnlJZChjb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1hdGNoQXJyYXkgID0gW10sXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdLFxuICAgICAgICAgICAgY2hpbGRJdGVtcywgY29uZmlnQXJyYXksIGNvbmZpZ0xlbmd0aCwgbGVuO1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG50eXBlOiBjb25maWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcgPSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnQXJyYXkgID0gT2JqZWN0LmVudHJpZXMoY29uZmlnKTtcbiAgICAgICAgY29uZmlnTGVuZ3RoID0gY29uZmlnQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGNvbmZpZ0FycmF5LmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKChjb21wb25lbnRba2V5XSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgfHwgKGtleSA9PT0gJ250eXBlJyAmJiBtZS5oYXNQcm90b3R5cGVQcm9wZXJ0eVZhbHVlKGNvbXBvbmVudCwga2V5LCB2YWx1ZSkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IGNvbmZpZ0xlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybkFycmF5LnB1c2goY29tcG9uZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRJdGVtcyA9IG1lLmZpbmQoe3BhcmVudElkOiBjb21wb25lbnQuaWR9KTtcbiAgICAgICAgbGVuICAgICAgICA9IGNoaWxkSXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gbWUuZG93bihjaGlsZEl0ZW1zW2ldLCBjb25maWcsIHJldHVybkZpcnN0TWF0Y2gpO1xuXG4gICAgICAgICAgICBpZiAocmV0dXJuRmlyc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJldHVyblZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm5BcnJheS5wdXNoKC4uLnJldHVyblZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0TWF0Y2ggPyBudWxsOiByZXR1cm5BcnJheVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IHRoZSBjb21wb25lbnQgaWQgaW4gY2FzZSB0aGVyZSBpcyBhIG1hdGNoXG4gICAgICovXG4gICAgZmluZFBhcmVudENvbXBvbmVudChwYXRoKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgaSAgID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHBhdGg/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgaWQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWQgPSBwYXRoW2ldO1xuXG4gICAgICAgICAgICBpZiAoaWQgJiYgbWUuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjaGlsZCBjb21wb25lbnRzIHdoaWNoIGFyZSByZWN1cnNpdmVseSBtYXRjaGVkIHZpYSB0aGVpciBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlW119IGNoaWxkQ29tcG9uZW50c1xuICAgICAqL1xuICAgIGdldENoaWxkQ29tcG9uZW50cyhjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRpcmVjdENoaWxkcmVuID0gbWUuZmluZCgncGFyZW50SWQnLCBjb21wb25lbnQuaWQpIHx8IFtdLFxuICAgICAgICAgICAgY29tcG9uZW50cyAgICAgPSBbXSxcbiAgICAgICAgICAgIGNoaWxkQ29tcG9uZW50cztcblxuICAgICAgICBkaXJlY3RDaGlsZHJlbi5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudHMgPSBtZS5nZXRDaGlsZENvbXBvbmVudHMoaXRlbSk7XG5cbiAgICAgICAgICAgIGNoaWxkQ29tcG9uZW50cyAmJiBjb21wb25lbnRzLnB1c2goLi4uY2hpbGRDb21wb25lbnRzKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29tcG9uZW50c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHJlcGxhY2UgYWxsIGNhbGxzIG9mIHRoaXMgbWV0aG9kIHRvIGNhbGxzIHVzaW5nIHRoZSB1dGlsLlZOb2RlIGNsYXNzXG4gICAgICogR2V0IHRoZSBpZHMgb2YgYWxsIGNoaWxkIG5vZGVzIG9mIHRoZSBnaXZlbiB2bm9kZVxuICAgICAqIEBwYXJhbSB2bm9kZVxuICAgICAqIEBwYXJhbSBjaGlsZElkc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2hpbGRJZHNcbiAgICAgKi9cbiAgICBnZXRDaGlsZElkcyh2bm9kZSwgY2hpbGRJZHMpIHtcbiAgICAgICAgcmV0dXJuIFZOb2RlVXRpbC5nZXRDaGlsZElkcyh2bm9kZSwgY2hpbGRJZHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY2hpbGQgY29tcG9uZW50cyBmb3VuZCBpbnNpZGUgdGhlIHZub2RlIHRyZWVcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfSBjaGlsZENvbXBvbmVudHNcbiAgICAgKi9cbiAgICBnZXRDaGlsZHJlbihjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IGNoaWxkQ29tcG9uZW50cyA9IFtdLFxuICAgICAgICAgICAgY2hpbGROb2RlcyAgICAgID0gVk5vZGVVdGlsLmdldENoaWxkSWRzKGNvbXBvbmVudC52bm9kZSksXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudDtcblxuICAgICAgICBjaGlsZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudCA9IHRoaXMuZ2V0KG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZENvbXBvbmVudHMucHVzaChjaGlsZENvbXBvbmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkQ29tcG9uZW50c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICEhIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgb25seSAhIVxuICAgICAqXG4gICAgICogR2V0IHRoZSBmaXJzdCBjb21wb25lbnQgYmFzZWQgb24gdGhlIG50eXBlIG9yIG90aGVyIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gY29tcG9uZW50RGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbHxOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAvLyBhcyBTdHJpbmc6IG50eXBlW2NvbW1hIHNlcGFyYXRlZCBwcm9wdGVydGllc11cbiAgICAgICAgICAgIE5lby5maXJzdCgndG9vbGJhciBidXR0b25bdGV4dD1UcnkgbWUsaWNvbj1wZW9wbGVdJylcbiAgICAgICAgICAgIC8vIGFzIE9iamVjdDogQWRkIHByb3BlcnRpZXMuIG50eXBlIGlzIG9wdGlvbmFsXG4gICAgICAgICAgICBOZW8uZmlyc3Qoe1xuICAgICAgICAgICAgICAgIGljb246ICdwZW9wbGUnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gYXMgQXJyYXk6IEFuIEFycmF5IG9mIE9iamVjdHMuIE5vIFN0cmluZ3MgYWxsb3dlZFxuICAgICAgICAgICAgTmVvLmZpcnN0KFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICd0b29sYmFyJ1xuICAgICAgICAgICAgfSx7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nLCB0ZXh0OiAnVHJ5IG1lJywgaWNvbjogJ3Blb3BsZVxuICAgICAgICAgICAgfV0pXG5cbiAgICAgKiBUaGUgcmV0dXJuRmlyc3RNYXRjaCBmbGFnIGFsbG93cyB0byByZXR1cm4gYWxsIGl0ZW1zIGFuZFxuICAgICAqIG5vdCBzdG9wIGFmdGVyIHRoZSBmaXJzdCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgTmVvLmZpcnN0KCdidXR0b24nLCBmYWxzZSkgLy8gPT4gW0J1dHRvbiwgQnV0dG9uLCBCdXR0b25dXG4gICAgICovXG4gICAgZ2V0Rmlyc3QoY29tcG9uZW50RGVzY3JpcHRpb24sIHJldHVybkZpcnN0TWF0Y2ggPSB0cnVlKSB7XG4gICAgICAgIGxldCBvYmplY3RzID0gW10sXG4gICAgICAgICAgICBhcHAgICAgID0gTmVvLmFwcHNbT2JqZWN0LmtleXMoTmVvLmFwcHMpWzBdXSxcbiAgICAgICAgICAgIHJvb3QgICAgPSBhcHAubWFpblZpZXc7XG5cbiAgICAgICAgLyogY3JlYXRlIGFuIGFycmF5IG9mIG9iamVjdHMgZnJvbSBzdHJpbmcgKi9cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb21wb25lbnREZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gLyhcXHcqKShcXFtbXlxcXV0qXFxdKXwoXFx3KikvZztcbiAgICAgICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICAgICAgLyogZ2VuZXJhdGUgb2JqZWN0cyB3aGljaCBjb250YWluIHRoZSBpbmZvcm1hdGlvbiAqL1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyhjb21wb25lbnREZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBsZXQgWywgbnR5cGUsIHBhaXJzLCBudHlwZU9ubHldID0gbWF0Y2gsIG9iajtcblxuICAgICAgICAgICAgICAgIG50eXBlID0gbnR5cGUgfHwgbnR5cGVPbmx5O1xuICAgICAgICAgICAgICAgIG9iaiA9IHtudHlwZX07XG5cbiAgICAgICAgICAgICAgICBpZiAocGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpcnNSZWdleCA9IC9cXFsoLio/KVxcXS8sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyc01hdGNoID0gcGFpcnMubWF0Y2gocGFpcnNSZWdleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXJzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhaXJzID0gcGFpcnNNYXRjaFsxXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFpcnMuZm9yRWFjaCgocGFpcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhaXIuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLnJlcGxhY2UoL1wiL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0cy5wdXNoKG9iaik7XG5cbiAgICAgICAgICAgICAgICByZWdleC5sYXN0SW5kZXgrK1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdChjb21wb25lbnREZXNjcmlwdGlvbikpe1xuICAgICAgICAgICAgb2JqZWN0cy5wdXNoKGNvbXBvbmVudERlc2NyaXB0aW9uKVxuICAgICAgICB9IGVsc2UgaWYgKE5lby5pc0FycmF5KGNvbXBvbmVudERlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgb2JqZWN0cyA9IGNvbXBvbmVudERlc2NyaXB0aW9uXG4gICAgICAgIH1cblxuICAgICAgICAvKiBmaW5kIHRoZSBjb3JyZWN0IGNoaWxkIHVzaW5nIGRvd24oKSAqL1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvYmplY3RzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChhY2MpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBhY2MuZG93bihrZXksIHJldHVybkZpcnN0TWF0Y2gpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEhY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LCByb290KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIHRoZSBpZHMgb2YgYWxsIHBhcmVudCBjb21wb25lbnRzIGZvciBhIGdpdmVuIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119IHBhcmVudElkc1xuICAgICAqL1xuICAgIGdldFBhcmVudElkcyhjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IHBhcmVudElkcyA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChjb21wb25lbnQ/LnBhcmVudElkKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldEJ5SWQoY29tcG9uZW50LnBhcmVudElkKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudElkcy5wdXNoKGNvbXBvbmVudC5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRJZHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFBhcmVudFBhdGgocGF0aCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnRQYXRoID0gW10sXG4gICAgICAgICAgICBpICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgPSBwYXRoPy5sZW5ndGggfHwgMDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWUuaGFzKHBhdGhbaV0pKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50UGF0aC5wdXNoKHBhdGhbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50UGF0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBhbGwgcGFyZW50IGNvbXBvbmVudHMgZm9yIGEgZ2l2ZW4gY29tcG9uZW50IG9yIGNvbXBvbmVudCBpZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfFN0cmluZ30gY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfSBwYXJlbnRzXG4gICAgICovXG4gICAgZ2V0UGFyZW50cyhjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldEJ5SWQoY29tcG9uZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhcmVudHMgPSBbXTtcblxuICAgICAgICB3aGlsZSAoY29tcG9uZW50Py5wYXJlbnRJZCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRCeUlkKGNvbXBvbmVudC5wYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2goY29tcG9uZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgY29tcG9uZW50IGhhZCBhIHByb3BlcnR5IG9mIGFueSB2YWx1ZSBzb21ld2hlcmUgaW4gdGhlIFByb3RvdHlwZSBjaGFpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNQcm90b3R5cGVQcm9wZXJ0eVZhbHVlKGNvbXBvbmVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHdoaWxlIChjb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmIGNvbXBvbmVudFtwcm9wZXJ0eV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50Ll9fcHJvdG9fX1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY29tcG9uZW50IHdoaWNoIG1hdGNoZXMgdGhlIGNvbmZpZy1zZWxlY3Rvci5cbiAgICAgKiBVc2UgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSB0byBnZXQgYW4gYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGl0ZW1zIGluc3RlYWQuXG4gICAgICogSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHJldHVybnMgbnVsbCBpbiBjYXNlIHJldHVybkZpcnN0TWF0Y2ggPT09IHRydWUsIG90aGVyd2lzZSBhbiBlbXB0eSBBcnJheS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8bnVsbH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5GaXJzdE1hdGNoPXRydWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfG51bGx9XG4gICAgICovXG4gICAgdXAoY29tcG9uZW50SWQsIGNvbmZpZywgcmV0dXJuRmlyc3RNYXRjaD10cnVlKSB7XG4gICAgICAgIGxldCBjb21wb25lbnQgICA9IHRoaXMuZ2V0QnlJZChjb21wb25lbnRJZCksXG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdLFxuICAgICAgICAgICAgY29uZmlnQXJyYXksIGNvbmZpZ0xlbmd0aCwgbWF0Y2hBcnJheTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBudHlwZTogY29uZmlnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0FycmF5ICA9IE9iamVjdC5lbnRyaWVzKGNvbmZpZyk7XG4gICAgICAgIGNvbmZpZ0xlbmd0aCA9IGNvbmZpZ0FycmF5Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoY29tcG9uZW50Py5wYXJlbnRJZCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRCeUlkKGNvbXBvbmVudC5wYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0TWF0Y2ggPyBudWxsIDogcmV0dXJuQXJyYXlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBjb25maWdBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50W2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IGNvbmZpZ0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5BcnJheS5wdXNoKGNvbXBvbmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyICBmcm9tICcuL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IEZvY3VzTWFuYWdlciAgICAgIGZyb20gJy4vRm9jdXMubWpzJztcbmltcG9ydCBMb2dnZXIgICAgICAgICAgICBmcm9tICcuLi91dGlsL0xvZ2dlci5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbmNvbnN0IGV2ZW50Q29uZmlnS2V5cyA9IFtcbiAgICAnYnViYmxlJyxcbiAgICAnZGVsZWdhdGUnLFxuICAgICdsb2NhbCcsXG4gICAgJ3Njb3BlJyxcbiAgICAndm5vZGVJZCdcbl07XG5cbmNvbnN0IGdsb2JhbERvbUV2ZW50cyA9IFtcbiAgICAnY2hhbmdlJyxcbiAgICAnY2xpY2snLFxuICAgICdjb250ZXh0bWVudScsXG4gICAgJ2RibGNsaWNrJyxcbiAgICAnZHJhZzplbmQnLFxuICAgICdkcmFnOm1vdmUnLFxuICAgICdkcmFnOnN0YXJ0JyxcbiAgICAnZm9jdXNpbicsXG4gICAgJ2ZvY3Vzb3V0JyxcbiAgICAnaW5wdXQnLFxuICAgICdpbnRlcnNlY3QnLFxuICAgICdrZXlkb3duJyxcbiAgICAna2V5dXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZWVudGVyJyxcbiAgICAnbW91c2VsZWF2ZScsXG4gICAgJ21vdXNldXAnLFxuICAgICduZW9uYXZpZ2F0ZScsXG4gICAgJ3Njcm9sbCcsXG4gICAgJ3NlbGVjdGlvbmNoYW5nZScsXG4gICAgJ3RvdWNobW92ZScsXG4gICAgJ3doZWVsJ1xuXTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuRG9tRXZlbnRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRG9tRXZlbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLkRvbUV2ZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5Eb21FdmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1zPXt9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbWFwPXt9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1hcDoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge2RhdGF9IGV2ZW50XG4gICAgICovXG4gICAgYWRkUmVzaXplT2JzZXJ2ZXIoY29tcG9uZW50LCBldmVudCkge1xuICAgICAgICBpZiAoIU5lby5tYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGb3IgdXNpbmcgcmVzaXplIGRvbUxpc3RlbmVycywgeW91IG11c3QgaW5jbHVkZSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyLicsIGV2ZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHtpZCwgd2luZG93SWR9ID0gY29tcG9uZW50O1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyLnJlZ2lzdGVyKHtpZCwgd2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidWJibGUgICAgICA9IHRydWUsXG4gICAgICAgICAgICBkYXRhICAgICAgICA9IGV2ZW50LmRhdGEgfHwge30sXG4gICAgICAgICAgICB7ZXZlbnROYW1lfSA9IGV2ZW50LFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgPSBudWxsLFxuICAgICAgICAgICAgcGF0aElkcyAgICAgPSBkYXRhLnBhdGgubWFwKGUgPT4gZS5pZCksXG4gICAgICAgICAgICBwYXRoICAgICAgICA9IENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50UGF0aChwYXRoSWRzKSxcbiAgICAgICAgICAgIGxlbiAgICAgICAgID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBjb21wb25lbnQsIGRlbGVnYXRpb25UYXJnZXRJZCwgaWQsIHByZXZlbnRGaXJlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlkICAgICAgICA9IHBhdGhbaV07XG4gICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKTtcblxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQgfHwgY29tcG9uZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdGVuZXJzID0gbWUuaXRlbXNbaWRdPy5bZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmaXJlJywgZXZlbnROYW1lLCBkYXRhLCBsaXN0ZW5lcnMsIHBhdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGl0ZXJhdGlvbiBpZiBhIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZXZlcnkobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLmZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgZGVsZWdhdGlvbiBmb3IgY3VzdG9tIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRpb25UYXJnZXRJZCA9IGRhdGEuaWQgPT09IGNvbXBvbmVudC5pZCA/IGRhdGEuaWQgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRpb25UYXJnZXRJZCA9IG1lLnZlcmlmeURlbGVnYXRpb25QYXRoKGxpc3RlbmVyLCBkYXRhLnBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGVnYXRpb25UYXJnZXRJZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudEZpcmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgbW91c2VlbnRlciAmIGxlYXZlIHRvIGZpcmUgb24gdGhlaXIgdG9wIGxldmVsIG5vZGVzLCBub3QgZm9yIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdtb3VzZWVudGVyJyB8fCBldmVudE5hbWUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudEZpcmUgPSAhRG9tRXZlbnQudmVyaWZ5TW91c2VFbnRlckxlYXZlKGNvbXBvbmVudCwgZGF0YSwgZGVsZWdhdGlvblRhcmdldElkLCBldmVudE5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRGaXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBsZSBsaXN0ZW5lcnMgd291bGQgY2hhbmdlIHRoZSByZWZlcmVuY2Ugb2YgZGF0YS5jb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBOZW8uY2xvbmUoZGF0YSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGVyIG5lZWRzIHRvIGtub3cgd2hpY2ggYWN0dWFsIHRhcmdldCBtYXRjaGVkIHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jdXJyZW50VGFyZ2V0ID0gZGVsZWdhdGlvblRhcmdldElkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lci5mbi5hcHBseShsaXN0ZW5lci5zY29wZSB8fCBnbG9iYWxUaGlzLCBbZGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpc3RlbmVyLmJ1YmJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGxpc3RlbmVyIHJldHVybnMgZmFsc2UsIHdlIHN0b3AgaXRlcmF0aW5nIHRoZSBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgIT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBkbyB3YW50IHRvIHRyaWdnZXIgdGhlIEZvY3VzTWFuYWdlciBhZnRlciBub3JtYWwgZG9tTGlzdGVuZXJzIG9uIHRoZXNlIGV2ZW50cyBnb3QgZXhlY3V0ZWRcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdmb2N1c2luJyB8fCBldmVudE5hbWUgPT09ICdmb2N1c291dCcpIHtcbiAgICAgICAgICAgICAgICBGb2N1c01hbmFnZXJbJ29uJyArIE5lby5jYXBpdGFsaXplKGV2ZW50TmFtZSldKHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSG9ub3IgdGhlIEV2ZW50IGNhbmNlbEJ1YmJsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCFidWJibGUgfHwgZGF0YS5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50TmFtZS5zdGFydHNXaXRoKCdkcm9wJykpIHtcbiAgICAgICAgICAgIGxldCBkcmFnWm9uZSA9IGRhdGEuZHJhZ1pvbmVJZCAmJiBOZW8uZ2V0KGRhdGEuZHJhZ1pvbmVJZCk7XG5cbiAgICAgICAgICAgIGlmIChkcmFnWm9uZSkge1xuICAgICAgICAgICAgICAgIGRyYWdab25lLmZpcmUoZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBkcmFnWm9uZVt7XG4gICAgICAgICAgICAgICAgICAgICdkcm9wJyAgICAgIDogJ29uRHJvcCcsXG4gICAgICAgICAgICAgICAgICAgICdkcm9wOmVudGVyJzogJ29uRHJvcEVudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Ryb3A6bGVhdmUnOiAnb25Ecm9wTGVhdmUnLFxuICAgICAgICAgICAgICAgIH1bZXZlbnROYW1lXV0uY2FsbChkcmFnWm9uZSwgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKiBAcGFyYW0gc2NvcGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdlbmVyYXRlTGlzdGVuZXJDb25maWcoY29uZmlnLCBzY29wZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnViYmxlICAgOiBjb25maWcuYnViYmxlLFxuICAgICAgICAgICAgZGVsZWdhdGUgOiBjb25maWcuZGVsZWdhdGUsXG4gICAgICAgICAgICBldmVudE5hbWU6IGNvbmZpZy5ldmVudE5hbWUsXG4gICAgICAgICAgICBpZCAgICAgICA6IHNjb3BlLmlkLFxuICAgICAgICAgICAgb3B0cyAgICAgOiBjb25maWcsXG4gICAgICAgICAgICBwcmlvcml0eSA6IGNvbmZpZy5wcmlvcml0eSxcbiAgICAgICAgICAgIHNjb3BlICAgIDogY29uZmlnLnNjb3BlICAgfHwgc2NvcGUsXG4gICAgICAgICAgICB2bm9kZUlkICA6IGNvbmZpZy52bm9kZUlkIHx8IHNjb3BlLmlkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0RXZlbnROYW1lKGNvbmZpZykge1xuICAgICAgICBsZXQgZXZlbnROYW1lID0gbnVsbDtcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnRDb25maWdLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0ga2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudE5hbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb25maWcuYnViYmxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kZWxlZ2F0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcub3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldExpc3RlbmVyKGNvbmZpZykge1xuICAgICAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5pdGVtcyxcbiAgICAgICAgICAgIGV2ZW50O1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnM/Lltjb25maWcuaWRdKSB7XG4gICAgICAgICAgICBldmVudCA9IGxpc3RlbmVyc1tjb25maWcuaWRdW2NvbmZpZy5ldmVudE5hbWVdO1xuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQgfHwgbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGxvY2FsIGRvbUV2ZW50IGxpc3RlbmVycyBmb3IgYSBnaXZlbiBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdW50RG9tTGlzdGVuZXJzKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbGlzdGVuZXJzICAgPSB0aGlzLml0ZW1zW2NvbXBvbmVudC5pZF0sXG4gICAgICAgICAgICBsb2NhbEV2ZW50cyA9IFtdO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxpc3RlbmVycykuZm9yRWFjaCgoW2V2ZW50TmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50TmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncmVzaXplJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSZXNpemVPYnNlcnZlcihjb21wb25lbnQsIGV2ZW50KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSAmJiAoZXZlbnQubG9jYWwgfHwgIWdsb2JhbERvbUV2ZW50cy5pbmNsdWRlcyhldmVudE5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxFdmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSAgIDogZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6ICdkb21FdmVudExpc3RlbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZUlkOiBldmVudC52bm9kZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIE5lby53b3JrZXIuQXBwLnByb21pc2VNZXNzYWdlKCdtYWluJywge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gIDogJ2FkZERvbUxpc3RlbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSA6IGNvbXBvbmVudC5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmVudHMgIDogbG9jYWxFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBjb21wb25lbnQud2luZG93SWRcbiAgICAgICAgICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYWRkZWQgZG9tTGlzdGVuZXInLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQXBwOiBHb3QgZXJyb3IgYXR0ZW1wdGluZyB0byBhZGQgYSBkb21MaXN0ZW5lcicsIGVycilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLmJ1YmJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGVsZWdhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmZpZy5sb2NhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcub3B0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcub3JpZ2luYWxDb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLm93bmVySWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnByaW9yaXR5PTFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnNjb3BlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy52bm9kZUlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGxpc3RlbmVyIGdvdCByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseSAoZmFsc2UgaW4gY2FzZSBpdCB3YXMgYWxyZWFkeSB0aGVyZSlcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb25maWcpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYWxyZWFkeVJlZ2lzdGVyZWQgICAgICAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAge2V2ZW50TmFtZSwgaWQsIG9wdHMsIHNjb3BlfSA9IGNvbmZpZyxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgICAgICAgICAgPSBtZS5pdGVtcyxcbiAgICAgICAgICAgIGZuVHlwZSAgICAgICAgICAgICAgICAgICAgICAgPSB0eXBlb2Ygb3B0cyxcbiAgICAgICAgICAgIGZuLCBsaXN0ZW5lciwgbGlzdGVuZXJDb25maWcsIGxpc3RlbmVySWQ7XG5cbiAgICAgICAgaWYgKGZuVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZm4gPSBvcHRzXG4gICAgICAgIH0gZWxzZSBpZiAoZm5UeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm4gPSByZXNvbHZlQ2FsbGJhY2sob3B0cywgc2NvcGUpLmZuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbiAgICA9IG9wdHMuZm47XG4gICAgICAgICAgICBzY29wZSA9IG9wdHMuc2NvcGUgfHwgc2NvcGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGlzdGVuZXJzW2lkXSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2lkXSA9IHt9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdGVuZXJzW2lkXVtldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMobGlzdGVuZXIpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyW2tleV0uZm4udG9TdHJpbmcoKSA9PT0gZm4udG9TdHJpbmcoKSAmJiAvLyB0b2RvOiBhZGQgYSBiZXR0ZXIgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJba2V5XS5zY29wZSAgICAgICAgID09PSBzY29wZSAmJlxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcltrZXldLmRlbGVnYXRlICAgICAgPT09IGNvbmZpZy5kZWxlZ2F0ZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5UmVnaXN0ZXJlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2lkXVtldmVudE5hbWVdID0gW11cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbHJlYWR5UmVnaXN0ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnbWFuYWdlci5Eb21FdmVudCByZWdpc3RlcicsIGV2ZW50TmFtZSwgY29uZmlnKTtcblxuICAgICAgICBsaXN0ZW5lcklkID0gTmVvLmdldElkKCdkb20tZXZlbnQnKTtcblxuICAgICAgICBjb25maWcubGlzdGVuZXJJZCA9IGxpc3RlbmVySWQ7XG5cbiAgICAgICAgbGlzdGVuZXJDb25maWcgPSB7XG4gICAgICAgICAgICBidWJibGUgICAgICAgIDogY29uZmlnLmhhc093blByb3BlcnR5KCdidWJibGUnKSA/IGNvbmZpZy5idWJibGUgOiBvcHRzLmhhc093blByb3BlcnR5KCdidWJibGUnKSA/IG9wdHMuYnViYmxlIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlbGVnYXRlICAgICAgOiBjb25maWcuZGVsZWdhdGUsXG4gICAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgICBmbixcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgOiBsaXN0ZW5lcklkLFxuICAgICAgICAgICAgbW91bnRlZCAgICAgICA6ICFjb25maWcubG9jYWwgJiYgZ2xvYmFsRG9tRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSksXG4gICAgICAgICAgICBvcmlnaW5hbENvbmZpZzogY29uZmlnLm9yaWdpbmFsQ29uZmlnLFxuICAgICAgICAgICAgb3duZXJJZCAgICAgICA6IGNvbmZpZy5vd25lcklkLFxuICAgICAgICAgICAgcHJpb3JpdHkgICAgICA6IGNvbmZpZy5wcmlvcml0eSB8fCBvcHRzLnByaW9yaXR5IHx8IDEsXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIHZub2RlSWQgICAgICAgOiBjb25maWcudm5vZGVJZFxuICAgICAgICB9O1xuXG4gICAgICAgIG1lLm1hcFtsaXN0ZW5lcklkXSA9IGxpc3RlbmVyQ29uZmlnO1xuXG4gICAgICAgIGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyQ29uZmlnKTtcblxuICAgICAgICBsaXN0ZW5lcnNbaWRdW2V2ZW50TmFtZV0uc29ydCgoYSwgYikgPT4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpO1xuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLmJ1YmJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcub3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnZub2RlSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBsaXN0ZW5lciBkaWQgZXhpc3QgYW5kIGdvdCByZW1vdmVkXG4gICAgICovXG4gICAgdW5yZWdpc3Rlcihjb25maWcsIHNjb3BlKSB7XG4gICAgICAgIC8vIHRvZG9cbiAgICAgICAgY29uc29sZS5sb2coJ3VucmVnaXN0ZXInLCBjb25maWcpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdlbmVyYXRlTGlzdGVuZXJDb25maWcoY29uZmlnLCBzY29wZSkpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5nZXRMaXN0ZW5lcihjb25maWcpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2xpc3RlbmVyIGZvdW5kJywgbGlzdGVuZXIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZG9tTGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkRG9tTGlzdGVuZXJzXG4gICAgICovXG4gICAgdXBkYXRlRG9tTGlzdGVuZXJzKGNvbXBvbmVudCwgZG9tTGlzdGVuZXJzLCBvbGREb21MaXN0ZW5lcnMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVnaXN0ZXJlZExpc3RlbmVycyA9IG1lLml0ZW1zW2NvbXBvbmVudC5pZF0gfHwge30sXG4gICAgICAgICAgICBpLCBsZW4sIGxpc3RlbmVycztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkb21MaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvbGREb21MaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICAgICAgb2xkRG9tTGlzdGVuZXJzLmZvckVhY2gob2xkRG9tTGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kICYgcmVtb3ZlIG5vIGxvbmdlciBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21MaXN0ZW5lcnMuaW5jbHVkZXMob2xkRG9tTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSByZWdpc3RlcmVkTGlzdGVuZXJzW21lLmdldEV2ZW50TmFtZShvbGREb21MaXN0ZW5lcildIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAgICAgICAgID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAgICAgICA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLm9yaWdpbmFsQ29uZmlnID09PSBvbGREb21MaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobGlzdGVuZXJzLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBuZXcgbGlzdGVuZXJzXG4gICAgICAgICAgICBkb21MaXN0ZW5lcnMuZm9yRWFjaChkb21MaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZG9tTGlzdGVuZXIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Q29uZmlnS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlICAgICAgICA6IGRvbUxpc3RlbmVyLmJ1YmJsZSAgIHx8IHZhbHVlLmJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZSAgICAgIDogZG9tTGlzdGVuZXIuZGVsZWdhdGUgfHwgdmFsdWUuZGVsZWdhdGUgfHwgJyMnICsgY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSAgICAgOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgICAgICA6IGNvbXBvbmVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzICAgICAgICAgIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb25maWc6IGRvbUxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVySWQgICAgICAgOiBjb21wb25lbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgICAgICA6IGRvbUxpc3RlbmVyLnByaW9yaXR5IHx8IHZhbHVlLnByaW9yaXR5IHx8IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgICAgICAgICA6IGRvbUxpc3RlbmVyLnNjb3BlICAgIHx8IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZUlkICAgICAgIDogZG9tTGlzdGVuZXIudm5vZGVJZCAgfHwgdmFsdWUudm5vZGVJZCAgfHwgY29tcG9uZW50LmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1vdW50ZWQgJiYgZG9tTGlzdGVuZXJzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUudGltZW91dCgxMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudERvbUxpc3RlbmVycyhjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignQ29tcG9uZW50LmRvbUxpc3RlbmVycyBoYXZlIHRvIGJlIGFuIGFycmF5JywgY29tcG9uZW50KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ30gdHJ1ZSBpbiBjYXNlIHRoZSBkZWxlZ2F0aW9uIHN0cmluZyBtYXRjaGVzIHRoZSBldmVudCBwYXRoXG4gICAgICovXG4gICAgdmVyaWZ5RGVsZWdhdGlvblBhdGgobGlzdGVuZXIsIHBhdGgpIHtcbiAgICAgICAgbGV0IHtkZWxlZ2F0ZX0gPSBsaXN0ZW5lcixcbiAgICAgICAgICAgIGogICAgICAgICAgPSAwLFxuICAgICAgICAgICAgcGF0aExlbiAgICA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgdGFyZ2V0SWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWxlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaiA9IGRlbGVnYXRlKHBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBwYXRoW2pdLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVsZWdhdGlvbkFycmF5ID0gZGVsZWdhdGUuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgICAgICAgPSBkZWxlZ2F0aW9uQXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGhhc01hdGNoLCBpLCBpdGVtLCBpc0lkO1xuXG4gICAgICAgICAgICBmb3IgKGk9bGVuLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpdGVtICAgICA9IGRlbGVnYXRpb25BcnJheVtpXTtcbiAgICAgICAgICAgICAgICBpc0lkICAgICA9IGl0ZW0uc3RhcnRzV2l0aCgnIycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSWQgfHwgaXRlbS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0uc3Vic3RyKDEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICg7IGogPCBwYXRoTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSWQgJiYgcGF0aFtqXS5pZCA9PT0gaXRlbSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhbal0uY2xzLmluY2x1ZGVzKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBwYXRoW2pdLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBkZWxlZ2F0aW9uIHBhdGggaXMgYSBjaGlsZCBvZiB0aGUgb3duZXIgY29tcG9uZW50cyByb290IG5vZGVcbiAgICAgICAgZm9yICg7IGogPCBwYXRoTGVuOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2pdLmlkID09PSBsaXN0ZW5lci52bm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldElkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsZWdhdGlvblRhcmdldElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyB2ZXJpZnlNb3VzZUVudGVyTGVhdmUoY29tcG9uZW50LCBkYXRhLCBkZWxlZ2F0aW9uVGFyZ2V0SWQsIGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgdGFyZ2V0SWQgPSBldmVudE5hbWUgPT09ICdtb3VzZWVudGVyJyA/IGRhdGEuZnJvbUVsZW1lbnRJZCA6IGRhdGEudG9FbGVtZW50SWQsXG4gICAgICAgICAgICBkZWxlZ2F0aW9uVmRvbTtcblxuICAgICAgICBpZiAodGFyZ2V0SWQgJiYgdGFyZ2V0SWQgIT09IGRlbGVnYXRpb25UYXJnZXRJZCkge1xuICAgICAgICAgICAgZGVsZWdhdGlvblZkb20gPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKGNvbXBvbmVudC52ZG9tLCBkZWxlZ2F0aW9uVGFyZ2V0SWQpO1xuXG4gICAgICAgICAgICAvLyBkZWxlZ2F0aW9uVmRvbSBjYW4gYmUgdW5kZWZpbmVkIHdoZW4gZHJhZ2dpbmcgYSBwcm94eSBvdmVyIHRoZSBub2RlLlxuICAgICAgICAgICAgLy8gc2VlIGlzc3Vlcy8xMTM3IGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0aW9uVmRvbSB8fCBkZWxlZ2F0aW9uVmRvbS52ZG9tICYmIFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQoZGVsZWdhdGlvblZkb20udmRvbSwgdGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRG9tRXZlbnQpO1xuIiwiaW1wb3J0IENvcmVCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuRm9jdXNcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRm9jdXMgZXh0ZW5kcyBDb3JlQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5Gb2N1cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuRm9jdXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBvcHRzIG9iamVjdHMuXG4gICAgICAgICAqIG9wdHMuY29tcG9uZW50UGF0aFxuICAgICAgICAgKiBvcHRzLmRhdGFcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGhpc3Rvcnk9W11cbiAgICAgICAgICovXG4gICAgICAgIGhpc3Rvcnk6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIERhdGUgb2JqZWN0IHdoZW4gdGhlIGxhc3QgZm9jdXNpbiBldmVudCBoYXMgb2NjdXJyZWRcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBsYXN0Rm9jdXNJbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0Rm9jdXNJbkRhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRGF0ZSBvYmplY3Qgd2hlbiB0aGUgbGFzdCBmb2N1c291dCBldmVudCBoYXMgb2NjdXJyZWRcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBsYXN0Rm9jdXNJbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0Rm9jdXNPdXREYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0aW1lIGZvciBhIGZvY3VzSW4gdG8gb2NjdXIgYWZ0ZXIgdGhlIGxhc3QgZm9jdXNPdXRcbiAgICAgICAgICogdG8gZ2V0IGNvbWJpbmVkIGludG8gYSBmb2N1c21vdmUgZXZlbnQuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4Rm9jdXNJbk91dEdhcD0xMFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4Rm9jdXNJbk91dEdhcDogMTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgaXRlbXMgc3RvcmVkIGluc2lkZSB0aGUgaGlzdG9yeSBhcnJheVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heEhpc3RvcnlMZW5ndGg9MjBcbiAgICAgICAgICovXG4gICAgICAgIG1heEhpc3RvcnlMZW5ndGg6IDIwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFkZFRvSGlzdG9yeShvcHRzKSB7XG4gICAgICAgIGxldCBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gICAgICAgIGhpc3RvcnkudW5zaGlmdChvcHRzKTtcbiAgICAgICAgaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhIaXN0b3J5TGVuZ3RoICYmIGhpc3RvcnkucG9wKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLmNvbXBvbmVudFBhdGggQ29tcG9uZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSBkb20gZXZlbnQgaW5mb3NcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZm9jdXNFbnRlcihvcHRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50Rm9jdXMob3B0cywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkVG9IaXN0b3J5KG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZvY3VzTGVhdmUob3B0cykge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudEZvY3VzKG9wdHMsIGZhbHNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmb2N1c01vdmUob3B0cykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aGlzdG9yeX0gICAgICAgID0gbWUsXG4gICAgICAgICAgICBuZXdDb21wb25lbnRQYXRoID0gb3B0cy5jb21wb25lbnRQYXRoLFxuICAgICAgICAgICAgb2xkQ29tcG9uZW50UGF0aCA9IGhpc3RvcnlbMF0uY29tcG9uZW50UGF0aCxcbiAgICAgICAgICAgIGZvY3VzRW50ZXIgICAgICAgPSBOZW9BcnJheS5kaWZmZXJlbmNlKG5ld0NvbXBvbmVudFBhdGgsIG9sZENvbXBvbmVudFBhdGgpLFxuICAgICAgICAgICAgZm9jdXNMZWF2ZSAgICAgICA9IE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkQ29tcG9uZW50UGF0aCwgbmV3Q29tcG9uZW50UGF0aCksXG4gICAgICAgICAgICBmb2N1c01vdmUgICAgICAgID0gTmVvQXJyYXkuaW50ZXJzZWN0aW9uKG5ld0NvbXBvbmVudFBhdGgsIG9sZENvbXBvbmVudFBhdGgpLFxuICAgICAgICAgICAgY29tcG9uZW50LCBkYXRhO1xuXG4gICAgICAgIG1lLnNldENvbXBvbmVudEZvY3VzKHtjb21wb25lbnRQYXRoOiBmb2N1c0xlYXZlLCBkYXRhOiBvcHRzLmRhdGF9LCBmYWxzZSk7XG4gICAgICAgIG1lLnNldENvbXBvbmVudEZvY3VzKHtjb21wb25lbnRQYXRoOiBmb2N1c0VudGVyLCBkYXRhOiBvcHRzLmRhdGF9LCB0cnVlKTtcblxuICAgICAgICBmb2N1c01vdmUuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCAgIDogb3B0cy5kYXRhLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIG9sZFBhdGg6IGhpc3RvcnlbMF0uZGF0YS5wYXRoXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbkZvY3VzTW92ZT8uKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKCdmb2N1c01vdmUnLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbkZvY3VzQ2hhbmdlPy4oZGF0YSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmZpcmUoJ2ZvY3VzQ2hhbmdlJywgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuYWRkVG9IaXN0b3J5KG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNpbihvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubGFzdEZvY3VzSW5EYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICBpZiAobWUubGFzdEZvY3VzT3V0RGF0ZSAmJiBtZS5sYXN0Rm9jdXNJbkRhdGUgLSBtZS5sYXN0Rm9jdXNPdXREYXRlIDwgbWUubWF4Rm9jdXNJbk91dEdhcCkge1xuICAgICAgICAgICAgbWUuZm9jdXNNb3ZlKG9wdHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5mb2N1c0VudGVyKG9wdHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLmNvbXBvbmVudFBhdGggQ29tcG9uZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSBkb20gZXZlbnQgaW5mb3NcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c291dChvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubGFzdEZvY3VzT3V0RGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgbWUudGltZW91dChtZS5tYXhGb2N1c0luT3V0R2FwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChtZS5sYXN0Rm9jdXNPdXREYXRlID4gbWUubGFzdEZvY3VzSW5EYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUuZm9jdXNMZWF2ZShvcHRzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29udGFpbnNGb2N1c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRDb21wb25lbnRGb2N1cyhvcHRzLCBjb250YWluc0ZvY3VzKSB7XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG9wdHMuZGF0YS5yZWxhdGVkVGFyZ2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcG9uZW50cyA9IG9wdHMuY29tcG9uZW50UGF0aC5tYXAoaWQgPT4gTmVvLmdldENvbXBvbmVudChpZCkpLFxuICAgICAgICAgICAgaGFuZGxlcjtcblxuICAgICAgICBjb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGFpbnNGb2N1cyA9IGNvbnRhaW5zRm9jdXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cbiAgICAgICAgICAgICAgICBkYXRhW2NvbnRhaW5zRm9jdXMgPyAncGF0aCcgOiAnb2xkUGF0aCddID0gb3B0cy5kYXRhLnBhdGhcblxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBjb250YWluc0ZvY3VzID8gJ29uRm9jdXNFbnRlcicgOiAnb25Gb2N1c0xlYXZlJztcbiAgICAgICAgICAgICAgICBjb21wb25lbnRbaGFuZGxlcl0/LihkYXRhKTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKGNvbnRhaW5zRm9jdXMgPyAnZm9jdXNFbnRlcicgOiAnZm9jdXNMZWF2ZScsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm9uRm9jdXNDaGFuZ2U/LihkYXRhKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZmlyZSgnZm9jdXNDaGFuZ2UnLCBkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRm9jdXMpO1xuIiwiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IENvcmVCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5JbnN0YW5jZVxuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBJbnN0YW5jZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuSW5zdGFuY2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkluc3RhbmNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgQ29yZUJhc2UuaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlID0gdHJ1ZTtcblxuICAgICAgICBtZS5jb25zdW1lTmVvSWRNYXAoKTtcblxuICAgICAgICBOZW8uZmluZCAgICAgID0gbWUuZmluZCAgICAgLmJpbmQobWUpOyAvLyBhbGlhc1xuICAgICAgICBOZW8uZmluZEZpcnN0ID0gbWUuZmluZEZpcnN0LmJpbmQobWUpOyAvLyBhbGlhc1xuICAgICAgICBOZW8uZ2V0ICAgICAgID0gbWUuZ2V0ICAgICAgLmJpbmQobWUpOyAvLyBhbGlhc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFsbCBpZHMgd2hpY2ggZ290IGFwcGxpZWQgdG8gdGhlIE5lbyBuYW1lc3BhY2UgYmVmb3JlIHRoaXMgaW5zdGFuY2UgZ290IGNyZWF0ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29uc3VtZU5lb0lkTWFwKCkge1xuICAgICAgICBpZiAoTmVvLmlkTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChPYmplY3QudmFsdWVzKE5lby5pZE1hcCkpO1xuICAgICAgICAgICAgZGVsZXRlIE5lby5pZE1hcFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhJbnN0YW5jZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQXJyYXlcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgTmVvQXJyYXkgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkFycmF5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5BcnJheSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kIGFzIGR1cGxpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEsIGJ1dCBub3QgaW4gYXJyYXkyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxPVtdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyPVtdXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkaWZmZXJlbmNlKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gIWFycmF5Mi5pbmNsdWRlcyhpdGVtKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGl0ZW0gaXMgaW5jbHVkZWQgYnkgcmVmZXJlbmNlIGluc2lkZSB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzSXRlbShhcnIsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFyci5pbmNsdWRlcyhpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gaXRlbSBvciBBcnJheSBvZiBpdGVtcyB0byBhbiBhcnJheSBpbiBjYXNlIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICogRHVwbGljYXRlcyB3aWxsIG9ubHkgZ2V0IG1hdGNoZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydChhcnIsIGluZGV4LCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSBpdGVtcy5sZW5ndGggLTEsXG4gICAgICAgICAgICBpICAgPSBsZW4sXG4gICAgICAgICAgICBjdXJyZW50SW5kZXgsIGl0ZW07XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBiYWNrd2FyZHNcbiAgICAgICAgZm9yICg7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmUoYXJyLCBjdXJyZW50SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gYXJyYXkxIGFuZCBhcnJheTJcbiAgICAgKiBPbmx5IHN1cHBvcnRzIHByaW1pdGl2ZSBpdGVtc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MT1bXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5Mj1bXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJzZWN0aW9uKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gYXJyYXkyLmluY2x1ZGVzKGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGl0ZW0gaW5zaWRlIGFyciBmcm9tIGZyb21JbmRleCB0byB0b0luZGV4XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgc3RhdGljIG1vdmUoYXJyLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb21JbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tSW5kZXggPSBhcnIubGVuZ3RoIC0gMVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyLnNwbGljZSh0b0luZGV4LCAwLCBhcnIuc3BsaWNlKGZyb21JbmRleCwgMSlbMF0pO1xuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGZyb20gYW4gYXJyYXkuIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmUoYXJyLCBpdGVtcykge1xuICAgICAgICBsZXQgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgaW5kZXggPiAtMSAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNvbWJpbmUgYWRkICYgcmVtb3ZlIGluIG9uZSBjYWxsLlxuICAgICAqIFlvdSBjYW4gcGFzcyBzaW5nbGUgaXRlbXMgb3IgYW4gYXJyYXkgb2YgaXRlbXMgdG8gYWRkIG9yIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IHJlbW92ZUl0ZW1zXG4gICAgICogQHBhcmFtIHsqfSBhZGRJdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVBZGQoYXJyLCByZW1vdmVJdGVtcywgYWRkSXRlbXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoYXJyLCByZW1vdmVJdGVtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhcnIsIGFkZEl0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBleGlzdCwgb3RoZXJ3aXNlIGFkZHMgaXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthZGRdXG4gICAgICovXG4gICAgc3RhdGljIHRvZ2dsZShhcnIsIGl0ZW0sIGFkZCA9ICF0aGlzLmhhc0l0ZW0oYXJyLCBpdGVtKSkge1xuICAgICAgICByZXR1cm4gdGhpc1thZGQgPyAnYWRkJyA6ICdyZW1vdmUnXShhcnIsIGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gdGhlIHBhc3NlZCBhcnJheXMuXG4gICAgICogTXVsdGlwbGUgYXJyYXlzIG1heSBiZSBwYXNzZWQuXG4gICAgICogT25seSBzdXBwb3J0cyBwcmltaXRpdmUgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIHVuaW9uKCkge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5hcmd1bWVudHMpKV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kIGFzIGR1cGxpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICovXG4gICAgc3RhdGljIHVuc2hpZnQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFyci51bnNoaWZ0KGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcnJcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE5lb0FycmF5KTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5DbGFzc1N5c3RlbVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBDbGFzc1N5c3RlbSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuQ2xhc3NTeXN0ZW0nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLkNsYXNzU3lzdGVtJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbiBnZXQgdXNlZCBpbnNpZGUgYmVmb3JlU2V0IG1ldGhvZHMgaW4gY2FzZSB5b3Ugd2FudCB0byBjcmVhdGUgaW5zdGFuY2VzIGxpa2Ugc3RvcmVzXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmNvcmUuQmFzZXxudWxsfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V8U3RyaW5nfSBbRGVmYXVsdENsYXNzPW51bGxdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkZWZhdWx0VmFsdWVzPXt9XVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfSBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBiZWZvcmVTZXRJbnN0YW5jZShjb25maWcsIERlZmF1bHRDbGFzcz1udWxsLCBkZWZhdWx0VmFsdWVzPXt9KSB7XG4gICAgICAgIGxldCBpc0luc3RhbmNlID0gY29uZmlnIGluc3RhbmNlb2YgTmVvLmNvcmUuQmFzZTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKERlZmF1bHRDbGFzcykpIHtcbiAgICAgICAgICAgIERlZmF1bHRDbGFzcyA9IE5lby5ucyhEZWZhdWx0Q2xhc3MpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbmZpZyAmJiBEZWZhdWx0Q2xhc3MpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IE5lby5jcmVhdGUoRGVmYXVsdENsYXNzLCBkZWZhdWx0VmFsdWVzKVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZz8uaXNDbGFzcykge1xuICAgICAgICAgICAgY29uZmlnID0gTmVvLmNyZWF0ZShjb25maWcsIGRlZmF1bHRWYWx1ZXMpXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KGNvbmZpZykgJiYgIWlzSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcubnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBOZW8ubnR5cGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q29uZmlnID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAoRGVmYXVsdENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5tb2R1bGUgPSBEZWZhdWx0Q2xhc3NcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0NvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IE5lby5jcmVhdGUobmV3Q29uZmlnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWVzPy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcub24oZGVmYXVsdFZhbHVlcy5saXN0ZW5lcnMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDbGFzc1N5c3RlbSk7XG4iLCIvKipcbiAqIEFwcGVuZCBhcmdzIGluc3RlYWQgb2YgcHJlcGVuZGluZyB0aGVtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kQXBwZW5kKGZuLCBzY29wZSkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuc2xpY2UoMik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShzY29wZSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmNvbmNhdChhcmdzKSlcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gc2NvcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheT0zMDBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihjYWxsYmFjaywgc2NvcGUsIGRlbGF5PTMwMCkge1xuICAgIGxldCB0aW1lb3V0SWQ7XG5cbiAgICBjb25zdCB3cmFwcGVyID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAvLyBjYWxsYmFjayBpbnZvY2F0aW9uIGNvbWVzIFwiZGVsYXlcIiBtcyBhZnRlciB0aGUgbGFzdCBjYWxsIHRvIHdyYXBwZXJcbiAgICAgICAgLy8gc28gY2FuY2VsIGFueSBwZW5kaW5nIGludm9jYXRpb24uXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICAgIHdyYXBwZXIuaXNQZW5kaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICB3cmFwcGVyLmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpXG4gICAgICAgIH0sIGRlbGF5KVxuICAgIH07XG5cbiAgICB3cmFwcGVyLmNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgd3JhcHBlci5pc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICB9O1xuXG4gICAgcmV0dXJuIHdyYXBwZXJcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCBmb3IgZnVuY3Rpb25zIHdpdGggMSBwYXJhbSB3aGVyZSB0aGUgaW50ZXJjZXB0b3IgY2FuIGNoYW5nZSB0aGUgdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRNZXRob2ROYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRGdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRhcmdldFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW50ZXJjZXB0b3IodGFyZ2V0LCB0YXJnZXRNZXRob2ROYW1lLCBpbnRlcmNlcHRGdW5jdGlvbiwgc2NvcGUpIHtcbiAgICBsZXQgdGFyZ2V0TWV0aG9kID0gdGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdO1xuXG4gICAgcmV0dXJuICh0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0TWV0aG9kLmNhbGwodGFyZ2V0LCBpbnRlcmNlcHRGdW5jdGlvbi5jYWxsKHNjb3BlIHx8IHRhcmdldCwgdmFsdWUpKVxuICAgIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZSh0YXJnZXQsIG1ldGhvZE5hbWUsIGZuLCBzY29wZSkge1xuICAgIGxldCBtZXRob2QgPSB0YXJnZXRbbWV0aG9kTmFtZV0gfHwgTmVvLmVtcHR5Rm47XG5cbiAgICByZXR1cm4gKHRhcmdldFttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlIHx8IHRoaXMsIGFyZ3VtZW50cylcbiAgICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHNjb3BlXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXk9MzAwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgc2NvcGUsIGRlbGF5PTMwMCkge1xuICAgIGxldCBkZWJvdW5jZVRpbWVyO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gbGVhZGluZyBlZGdlID0+IHRyaWdnZXIgdGhlIGZpcnN0IGNhbGwgcmlnaHQgYXdheVxuICAgICAgICBpZiAoIU5lby5pc051bWJlcihkZWJvdW5jZVRpbWVyKSkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgc2NvcGUgKGluc3RhbmNlKSBkaWQgbm90IGdldCBkZXN0cm95ZWQgeWV0XG4gICAgICAgICAgICBzY29wZT8uaWQgJiYgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xuXG4gICAgICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIHN0YXJ0IGEgdGltZXIgdG8gZGVsYXkgdGhlIDJuZCsgdXBkYXRlXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7ZGVib3VuY2VUaW1lciA9IG51bGx9LCAgZGVsYXkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lcik7XG5cbiAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBzY29wZSAoaW5zdGFuY2UpIGRpZCBub3QgZ2V0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgICAgICBzY29wZT8uaWQgJiYgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtkZWJvdW5jZVRpbWVyID0gbnVsbH0sICBkZWxheSlcbiAgICAgICAgICAgIH0sICBkZWxheSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJjZXB0b3IgY2FuIHByZXZlbnQgdGhlIHRhcmdldE1ldGhvZCBmcm9tIGdldHRpbmcgZXhlY3V0ZWQgaW4gY2FzZSBpdCByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldE1ldGhvZE5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdEZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGFyZ2V0XG4gKiBAcGFyYW0geyp9IHByZXZlbnRlZFJldHVyblZhbHVlPW51bGwgVGhlIHZhbHVlIHRvIHJldHVybiBpbiBjYXNlIHRoZSBpbnRlcmNlcHRGdW5jdGlvbiByZXR1cm5zIGZhbHNlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcmNlcHQodGFyZ2V0LCB0YXJnZXRNZXRob2ROYW1lLCBpbnRlcmNlcHRGdW5jdGlvbiwgc2NvcGUsIHByZXZlbnRlZFJldHVyblZhbHVlPW51bGwpIHtcbiAgICBsZXQgdGFyZ2V0TWV0aG9kID0gdGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdO1xuXG4gICAgcmV0dXJuICh0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChpbnRlcmNlcHRGdW5jdGlvbi5hcHBseShzY29wZSB8fCB0YXJnZXQsIGFyZ3VtZW50cykgPT09IGZhbHNlKVxuICAgICAgICAgICAgPyBwcmV2ZW50ZWRSZXR1cm5WYWx1ZVxuICAgICAgICAgICAgOiB0YXJnZXRNZXRob2QuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpXG4gICAgfSlcbn1cblxuLyoqXG4gKiBMb2NhdGUgYSBjYWxsYWJsZSBmdW5jdGlvbiBieSBuYW1lIGluIHRoZSBwYXNzZWQgc2NvcGUuXG4gKlxuICogSWYgdGhlIG5hbWUgc3RhcnRzIHdpdGggJ3VwLicsIHRoZSBwYXJlbnQgQ29tcG9uZW50IGNoYWluIGlzIHNlYXJjaGVkLlxuICpcbiAqIFRoaXMgaXMgdXNlZCBieSBtYW5hZ2VyLkRvbUV2ZW50cyAmIGNvcmUuT2JzZXJ2YWJsZS5maXJlIGFuZCBieSAnaGFuZGxlcicgZnVuY3Rpb24gY2FsbHMgdG8gcmVzb2x2ZVxuICogc3RyaW5nIGZ1bmN0aW9uIG5hbWVzIGluIHRoZSBDb21wb25lbnQncyBvd24gaGllcmFyY2h5LlxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIEEgZnVuY3Rpb24sIG9yIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdG8gZmluZCBpbiB0aGUgcGFzc2VkIHNjb3BlIG9iamVjdC9cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10aGlzIFRoZSBzY29wZSB0byBmaW5kIHRoZSBmdW5jdGlvbiBpbiBpZiBpdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNhbGxiYWNrKGZuLCBzY29wZT10aGlzKSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFzY29wZVtmbl0gJiYgZm4uc3RhcnRzV2l0aCgndXAuJykpIHtcbiAgICAgICAgICAgIGZuID0gZm4uc2xpY2UoMyk7XG4gICAgICAgICAgICB3aGlsZSAoIXNjb3BlW2ZuXSAmJiAoc2NvcGUgPSBzY29wZS5wYXJlbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuID0gc2NvcGVbZm5dXG4gICAgfVxuXG4gICAgcmV0dXJuIHtmbiwgc2NvcGV9XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gc2NvcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheT0zMDBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBzY29wZSwgZGVsYXk9MzAwKSB7XG4gICAgbGV0IGxhc3RSYW5EYXRlLCB0aW1lb3V0SWQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBpZiAoIWxhc3RSYW5EYXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBzY29wZSAoaW5zdGFuY2UpIGRpZCBub3QgZ2V0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgIHNjb3BlPy5pZCAmJiBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncyk7XG5cbiAgICAgICAgICAgIGxhc3RSYW5EYXRlID0gRGF0ZS5ub3coKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcblxuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoKERhdGUubm93KCkgLSBsYXN0UmFuRGF0ZSkgPj0gZGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgc2NvcGUgKGluc3RhbmNlKSBkaWQgbm90IGdldCBkZXN0cm95ZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlPy5pZCAmJiBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdFJhbkRhdGUgPSBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZGVsYXkgLSAoRGF0ZS5ub3coKSAtIGxhc3RSYW5EYXRlKSlcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkhhc2hIaXN0b3J5XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIEhhc2hIaXN0b3J5IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5IYXNoSGlzdG9yeSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuSGFzaEhpc3RvcnknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhJdGVtcz01MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtYXhJdGVtczogNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yaW5nIG9uZSBzdGFjayBwZXIgd2luZG93SWRcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdGFja3M9e31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhY2tzOiB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aW5kb3dJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZpcnN0KHdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0KDAsIHdpbmRvd0lkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93SWRdXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRBdChpbmRleCwgd2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2sod2luZG93SWQpW2luZGV4XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93SWRdXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb3VudCh3aW5kb3dJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFjayh3aW5kb3dJZCkubGVuZ3RoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aW5kb3dJZF1cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFN0YWNrKHdpbmRvd0lkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c3RhY2tzfSA9IG1lLFxuICAgICAgICAgICAgc3RhY2tJZCAgPSB3aW5kb3dJZCB8fCBPYmplY3Qua2V5cyhzdGFja3MpWzBdLFxuICAgICAgICAgICAgc3RhY2sgICAgPSBzdGFja3Nbc3RhY2tJZF07XG5cbiAgICAgICAgaWYgKCFzdGFjaykge1xuICAgICAgICAgICAgc3RhY2tzW3N0YWNrSWRdID0gc3RhY2sgPSBbXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YWNrXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEuaGFzaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmhhc2hTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIHB1c2goZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7d2luZG93SWR9ID0gZGF0YSxcbiAgICAgICAgICAgIHN0YWNrICAgICAgPSBtZS5nZXRTdGFjayh3aW5kb3dJZCk7XG5cbiAgICAgICAgaWYgKHN0YWNrWzBdPy5oYXNoU3RyaW5nICE9PSBkYXRhLmhhc2hTdHJpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhW3dpbmRvd0lkXTtcbiAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiBtZS5tYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIGRhdGEsIHN0YWNrWzFdIHx8IG51bGwpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93SWRdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzZWNvbmQod2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXQoMCwgd2luZG93SWQpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhIYXNoSGlzdG9yeSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuTG9nZ2VyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIExvZ2dlciBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuTG9nZ2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5Mb2dnZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtaW5pbXVtIGxldmVsLCB3aGljaCB5b3Ugd2FudCB0byBvdXRwdXQuXG4gICAgICAgICAqIENoYW5nZSB0aGlzIGF0IGFueSB0aW1lIHVzaW5nIGEgdmFsdWUgb2YgbG9nTGV2ZWxzOiBbJ2luZm8nLCAnbG9nJywgJ3dhcm4nLCAnZXJyb3InXVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgTmVvLnV0aWwuTG9nZ2VyLmxldmVsID0gJ2Vycm9yJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxldmVsPSdpbmZvJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsZXZlbF86ICdpbmZvJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZUxvZ3M9dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxvZ0NoYXJcbiAgICAgKi9cbiAgICBsb2dDaGFycyAgPSB7XG4gICAgICAgIGVycm9yOiAnRScsXG4gICAgICAgIGluZm8gOiAnSScsXG4gICAgICAgIGxvZyAgOiAnTCcsXG4gICAgICAgIHdhcm4gOiAnVydcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBjb2xvcnNcbiAgICAgKi9cbiAgICBsb2dDb2xvcnMgPSB7XG4gICAgICAgIGVycm9yOiAnaW5kaWFucmVkJyxcbiAgICAgICAgaW5mbyA6ICcjYWNhY2FjJyxcbiAgICAgICAgbG9nICA6ICcjNDQ4ODg4JyxcbiAgICAgICAgd2FybiA6ICcjNmQ2ZDAwJ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dMZXZlbHNcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbG9nTGV2ZWxzXG4gICAgICovXG4gICAgbG9nTGV2ZWxzID0gWydpbmZvJywgJ2xvZycsICd3YXJuJywgJ2Vycm9yJ11cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gYWxpYXNlc1xuICAgICAgICBOZW8uYXBwbHlGcm9tTnMoTmVvLCBtZSwge1xuICAgICAgICAgICAgZXJyb3IgICA6ICdlcnJvcicsXG4gICAgICAgICAgICBpbmZvICAgIDogJ2luZm8nLFxuICAgICAgICAgICAgbG9nICAgICA6ICdsb2cnLFxuICAgICAgICAgICAgbG9nRXJyb3I6ICdsb2dFcnJvcicsXG4gICAgICAgICAgICB3YXJuICAgIDogJ3dhcm4nXG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFOZW8uY29uZmlnLmVuYWJsZUxvZ3NJblByb2R1Y3Rpb24gJiYgTmVvLmNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2Rpc3QvcHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtZS53cml0ZSA9IE5lby5lbXB0eUZuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3RybC1SaWdodC1DbGljayB3aWxsIHNob3cgdGhlIGN1cnJlbnQgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IHZpZXdcbiAgICAgKi9cbiAgICBhZGRDb250ZXh0TWVudUxpc3RlbmVyKHZpZXcpIHtcbiAgICAgICAgdmlldy5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgY29udGV4dG1lbnU6IHRoaXMub25Db250ZXh0TWVudSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgOiB0aGlzXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGxldmVsIHRvIG51bWJlciBiYXNlZCBvbiBwb3NpdGlvbiBpbiBsb2dMZXZlbHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRMZXZlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nTGV2ZWxzLmluZGV4T2YodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgZXJyb3IodmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIGhlbHBlciB0byBjYXRjaCBjYWxsZXJcbiAgICAgKiBubyBrbm93biBuYXRpdmUgd2F5IGluIG1vZGVybiBKUyB0byBrbm93IHdoYXQgZmlsZSB0aGF0IHRyaWdnZXJlZCB0aGUgY3VycmVudCBtZXRob2RcbiAgICAgKiB0aGVyZWZvcmUgd2UgdXNlIEVycm9yLCB3ZSBjYW4gZ2V0IHRoZSBjYWxsZXIgZmlsZSBmcm9tIHRoZSBzdGFjayB0cmFjZSBzdHJpbmcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2FsbGVyKCkge1xuICAgICAgICBsZXQgY2FsbGVyX3BhdGggPSB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcnIgICAgICAgICA9IG5ldyBFcnJvcigpLFxuICAgICAgICAgICAgc3RhY2tfbGluZXMgPSBlcnIuc3RhY2suc3BsaXQoJ1xcbicpLFxuICAgICAgICAgICAgZm91bmRfdGhpcyAgPSBmYWxzZSxcbiAgICAgICAgICAgIGksIGxpbmU7XG5cbiAgICAgICAgZm9yIChpIGluIHN0YWNrX2xpbmVzKSB7XG4gICAgICAgICAgICBsaW5lID0gc3RhY2tfbGluZXNbaV07XG5cbiAgICAgICAgICAgIGlmICghZm91bmRfdGhpcyAmJiAvTG9nZ2VyXFwubWpzLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRfdGhpcyA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm91bmRfdGhpcykge1xuICAgICAgICAgICAgICAgIGlmICghL0xvZ2dlclxcLm1qcy8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGNsb3NpbmcgKVxuICAgICAgICAgICAgICAgICAgICBsaW5lICAgICAgICA9IGxpbmUucmVwbGFjZSgnKScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBwYXJ0IGFmdGVyIHRoZSBsYXN0IC9cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyX3BhdGggPSBsaW5lLm1hdGNoKC8oW15cXC9dKykkLylbMV0ubWF0Y2goLyhbXiBdKykkLylbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGVyX3BhdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGluZm8oLi4uYXJncykge1xuICAgICAgICBhcmdzID0gdGhpcy5yZXNvbHZlQXJncyguLi5hcmdzKTtcbiAgICAgICAgdGhpcy53cml0ZShhcmdzLCAnaW5mbycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBsb2coLi4uYXJncykge1xuICAgICAgICBhcmdzID0gdGhpcy5yZXNvbHZlQXJncyguLi5hcmdzKTtcbiAgICAgICAgdGhpcy53cml0ZShhcmdzLCAnbG9nJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGxvZ0Vycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncyA9IHRoaXMucmVzb2x2ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIHRoaXMud3JpdGUoYXJncywgJ2Vycm9yJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29udGV4dE1lbnUoZGF0YSkge1xuICAgICAgICBsZXQge2NvbmZpZ30gPSBOZW87XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGF0YS5jdHJsS2V5XG4gICAgICAgICAgICAmJiBjb25maWcuZW5hYmxlQ29tcG9uZW50TG9nZ2VyXG4gICAgICAgICAgICAmJiAhKGNvbmZpZy5lbnYgPT09ICdkaXN0L3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5lbmFibGVMb2dzSW5Qcm9kdWN0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxldCBpc0dyb3VwU2V0ID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50O1xuXG4gICAgICAgICAgICBkYXRhLnBhdGguZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGl0ZW0uaWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzR3JvdXBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzR3JvdXBTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cChpdGVtLmlkKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpc0dyb3VwU2V0ICYmIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZvciBhcmdzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlc29sdmVBcmdzKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGlkZW50aWZpZXIgPSBhcmdzWzBdLFxuICAgICAgICAgICAgYXJnc09iamVjdCA9IHt9O1xuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyhpZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIGFyZ3NPYmplY3QubXNnID0gYXJnc1swXVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNPYmplY3QoaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICBhcmdzT2JqZWN0ID0gaWRlbnRpZmllclxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgYXJnc09iamVjdC5tc2cgID0gYXJnc1swXTtcbiAgICAgICAgICAgIGFyZ3NPYmplY3QuZGF0YSA9IGFyZ3Muc2xpY2UoMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmdzT2JqZWN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncyA9IHRoaXMucmVzb2x2ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIHRoaXMud3JpdGUoYXJncywgJ3dhcm4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE91dHB1dCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3cml0ZShhcmdzLCBsZXZlbCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5iZWZvcmVTZXRMZXZlbChsZXZlbCkgPCBtZS5sZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnIycsIGFyZ3MubXNnLCBsZXZlbCk7XG5cbiAgICAgICAgbGV0IGxvZ0NvbG9yID0gbWUubG9nQ29sb3JzW2xldmVsXSxcbiAgICAgICAgICAgIGxvZ0NoYXIgID0gbWUubG9nQ2hhcnNbbGV2ZWxdLFxuICAgICAgICAgICAgYmcgICAgICAgPSBgYmFja2dyb3VuZC1jb2xvcjoke2xvZ0NvbG9yfTsgY29sb3I6IHdoaXRlOyBmb250LXdlaWdodDogOTAwO2AsXG4gICAgICAgICAgICBjb2xvciAgICA9IGBjb2xvcjoke2xvZ0NvbG9yfTtgLFxuICAgICAgICAgICAgbXNnICAgICAgPSBgWyR7bWUuZ2V0Q2FsbGVyKCl9XSAke2FyZ3MubXNnfWA7XG5cbiAgICAgICAgaWYgKGFyZ3MuZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChgJWMgJHtsb2dDaGFyfSAlYyAke21zZ31gLCBiZywgY29sb3IpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhcmdzLmRhdGEpO1xuICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJWMgJHtsb2dDaGFyfSAlYyAke21zZ31gLCBiZywgY29sb3IpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExvZ2dlcik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuVkRvbVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBWRG9tIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5WRG9tJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5WRG9tJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVJZHM9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZCB2ZG9tXG4gICAgICovXG4gICAgc3RhdGljIGNsb25lKHZkb20sIHJlbW92ZUlkcz10cnVlKSB7XG4gICAgICAgIGxldCBjbG9uZSA9IE5lby5jbG9uZSh2ZG9tLCB0cnVlKTtcblxuICAgICAgICBpZiAocmVtb3ZlSWRzKSB7XG4gICAgICAgICAgICBkZWxldGUgY2xvbmUuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9uZS5jbikge1xuICAgICAgICAgICAgY2xvbmUuY24uZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjbG9uZS5jbltpbmRleF0gPSBWRG9tLmNsb25lKGl0ZW0sIHJlbW92ZUlkcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggdmRvbSBjaGlsZCBub2RlcyBieSBpZCBvciBvcHRzIG9iamVjdCBmb3IgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0cyBFaXRoZXIgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdmRvbSBub2RlIGF0dHJpYnV0ZXMgb3IgYSBzdHJpbmcgYmFzZWQgaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSBJbnRlcm5hbCBmbGFnLCBkbyBub3QgdXNlIGl0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJlbnROb2RlXSBJbnRlcm5hbCBmbGFnLCBkbyBub3QgdXNlIGl0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiAgICAge051bWJlcn0gaW5kZXhcbiAgICAgKiAgICAge1N0cmluZ30gcGFyZW50SWRcbiAgICAgKiAgICAge09iamVjdH0gdmRvbVxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5kVmRvbUNoaWxkKHZkb20sIG9wdHMsIGluZGV4LCBwYXJlbnROb2RlKSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgb3B0cyAgPSAhTmVvLmlzU3RyaW5nKG9wdHMpID8gb3B0cyA6IHtpZDogb3B0c307XG5cbiAgICAgICAgbGV0IGNoaWxkICAgICAgPSBudWxsLFxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFtdLFxuICAgICAgICAgICAgc3R5bGVNYXRjaCA9IHRydWUsXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSB2ZG9tLmNuPy5sZW5ndGgsXG4gICAgICAgICAgICBvcHRzQXJyYXkgID0gT2JqZWN0LmVudHJpZXMob3B0cyksXG4gICAgICAgICAgICBvcHRzTGVuZ3RoID0gb3B0c0FycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIHN1YkNoaWxkO1xuXG4gICAgICAgIG9wdHNBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2ZG9tLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nscyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBOZW8uaXNBcnJheSh2ZG9tW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZkb21ba2V5XS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2ZG9tW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZkb21ba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNBcnJheSh2YWx1ZSkgJiYgTmVvLmlzQXJyYXkodmRvbVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IGVpdGhlciBzZWFyY2ggdGhlIHZkb20gYXJyYXkgZm9yIGFsbCBrZXlzIG9yIGNvbXBhcmUgaWYgdGhlIGFycmF5cyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaW5kVmRvbUNoaWxkOiBjbHMgbWF0Y2hpbmcgbm90IHN1cHBvcnRlZCBmb3IgdGFyZ2V0ICYgc291cmNlIHR5cGVzIG9mIEFycmF5cycpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmRvbVtrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZG9tW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiBOZW8uaXNPYmplY3QodmRvbVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbc3R5bGVLZXksIHN0eWxlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZkb21ba2V5XS5oYXNPd25Qcm9wZXJ0eShzdHlsZUtleSkgJiYgdmRvbVtrZXldW3N0eWxlS2V5XSA9PT0gc3R5bGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTWF0Y2ggPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmluZFZkb21DaGlsZDogc3R5bGUgbWF0Y2hpbmcgbm90IHN1cHBvcnRlZCBmb3IgbWl4ZWQgdGFyZ2V0ICYgc291cmNlIHR5cGVzIChPYmplY3QgVlMgU3RyaW5nKScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZkb21ba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IG9wdHNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXgsIHBhcmVudE5vZGUsIHZkb219XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmRvbS5jbikge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZG9tLmNuW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YkNoaWxkID0gVkRvbS5maW5kVmRvbUNoaWxkKHZkb20uY25baV0sIG9wdHMsIGksIHZkb20pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggICAgIDogc3ViQ2hpbGQuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZTogc3ViQ2hpbGQucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZG9tICAgICAgOiBzdWJDaGlsZC52ZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBmaW5kVmRvbUNoaWxkKHZkb20sIHtmbGFnOiBmbGFnfSk7XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmxhZyBUaGUgZmxhZyByZWZlcmVuY2Ugc3BlY2lmaWVkIG9uIHRoZSB0YXJnZXQgdmRvbSBjaGlsZCBub2RlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdmRvbVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRCeUZsYWcodmRvbSwgZmxhZykge1xuICAgICAgICBsZXQgbm9kZSA9IFZEb20uZmluZFZkb21DaGlsZCh2ZG9tLCB7ZmxhZ30pO1xuICAgICAgICByZXR1cm4gbm9kZT8udmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRzIG9mIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHZkb21cbiAgICAgKiBAcGFyYW0gW2NoaWxkSWRzPVtdXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2hpbGRJZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hpbGRJZHModmRvbSwgY2hpbGRJZHM9W10pIHtcbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSB2ZG9tPy5jbiB8fCBbXTtcblxuICAgICAgICBjaGlsZE5vZGVzLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZElkcy5wdXNoKGNoaWxkTm9kZS5pZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGRJZHMgPSBWRG9tLmdldENoaWxkSWRzKGNoaWxkTm9kZSwgY2hpbGRJZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGlsZElkc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb2x1bW5Ob2Rlcyh2ZG9tLCBpbmRleCkge1xuICAgICAgICBsZXQgY29sdW1uTm9kZXMgPSBbXTtcblxuICAgICAgICB2ZG9tLmNuPy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAocm93LmNuPy5baW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uTm9kZXMucHVzaChyb3cuY25baW5kZXhdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBjb2x1bW5Ob2Rlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb2x1bW5Ob2Rlc0lkcyh2ZG9tLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gVkRvbS5nZXRDb2x1bW5Ob2Rlcyh2ZG9tLCBpbmRleCkubWFwKGUgPT4gZS5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnXG4gICAgICogQHBhcmFtIHtBcnJheX0gW21hdGNoQXJyYXldXG4gICAgICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiB2ZG9tIG5vZGVzIHdoaWNoIG1hdGNoIHRoZSBmbGFnXG4gICAgICovXG4gICAgc3RhdGljIGdldEZsYWdzKHZkb20sIGZsYWcsIG1hdGNoQXJyYXkpIHtcbiAgICAgICAgaWYgKCFtYXRjaEFycmF5KSB7XG4gICAgICAgICAgICBtYXRjaEFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGlmICh2ZG9tLmZsYWcgPT09IGZsYWcpIHtcbiAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godmRvbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICh2ZG9tPy5jbiB8fCBbXSkuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5mbGFnID09PSBmbGFnKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKGNoaWxkTm9kZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFZEb20uZ2V0RmxhZ3MoY2hpbGROb2RlLCBmbGFnLCBtYXRjaEFycmF5KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF0Y2hBcnJheVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0b3BMZXZlbD10cnVlIEludGVybmFsIGZsYWcsIGRvIG5vdCB1c2UgaXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGdldFBhcmVudE5vZGVzKHZkb20sIGlkLCB0b3BMZXZlbD10cnVlKSB7XG4gICAgICAgIGxldCBwYXJlbnRzID0gbnVsbCxcbiAgICAgICAgICAgIGkgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICA9IHZkb20uY24/Lmxlbmd0aCB8fCAwO1xuXG4gICAgICAgIGlmICh2ZG9tLmlkID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBwYXJlbnRzID0gVkRvbS5nZXRQYXJlbnROb2Rlcyh2ZG9tLmNuW2ldLCBpZCwgZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50cykge1xuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaCh2ZG9tLmNuW2ldKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcExldmVsICYmIHBhcmVudHMpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaCh2ZG9tKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBnaXZlbiBub2RlVG9JbnNlcnQgYWZ0ZXIgYSB0YXJnZXROb2RlIGluc2lkZSBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tIFRoZSB2ZG9tIHRyZWUgY29udGFpbmluZyB0aGUgdGFyZ2V0Tm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlVG9JbnNlcnQgVGhlIG5ldyB2ZG9tIHRvIGluc2VydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdGFyZ2V0Tm9kZUlkIEVpdGhlciBhIHZkb20gbm9kZSBvciBhIHZkb20gbm9kZSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnNlcnRBZnRlck5vZGUodmRvbSwgbm9kZVRvSW5zZXJ0LCB0YXJnZXROb2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uaW5zZXJ0Tm9kZSh2ZG9tLCBub2RlVG9JbnNlcnQsIHRhcmdldE5vZGVJZCwgZmFsc2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgZ2l2ZW4gbm9kZVRvSW5zZXJ0IGJlZm9yZSBhIHRhcmdldE5vZGUgaW5zaWRlIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb20gVGhlIHZkb20gdHJlZSBjb250YWluaW5nIHRoZSB0YXJnZXROb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVUb0luc2VydCBUaGUgbmV3IHZkb20gdG8gaW5zZXJ0XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB0YXJnZXROb2RlSWQgRWl0aGVyIGEgdmRvbSBub2RlIG9yIGEgdmRvbSBub2RlIGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydEJlZm9yZU5vZGUodmRvbSwgbm9kZVRvSW5zZXJ0LCB0YXJnZXROb2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uaW5zZXJ0Tm9kZSh2ZG9tLCBub2RlVG9JbnNlcnQsIHRhcmdldE5vZGVJZCwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBnaXZlbiBub2RlVG9JbnNlcnQgYmVmb3JlIGEgdGFyZ2V0Tm9kZSBpbnNpZGUgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbSBUaGUgdmRvbSB0cmVlIGNvbnRhaW5pbmcgdGhlIHRhcmdldE5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVRvSW5zZXJ0IFRoZSBuZXcgdmRvbSB0byBpbnNlcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHRhcmdldE5vZGVJZCBFaXRoZXIgYSB2ZG9tIG5vZGUgb3IgYSB2ZG9tIG5vZGUgaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluc2VydEJlZm9yZSB0cnVlIGluc2VydHMgdGhlIG5ldyBub2RlIGF0IHRoZSBzYW1lIGluZGV4LCBpbmRleCsxIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnNlcnROb2RlKHZkb20sIG5vZGVUb0luc2VydCwgdGFyZ2V0Tm9kZUlkLCBpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKE5lby5pc09iamVjdCh0YXJnZXROb2RlSWQpKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlSWQgPSB0YXJnZXROb2RlSWQuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0YXJnZXROb2RlID0gVkRvbS5maW5kVmRvbUNoaWxkKHZkb20sIHtpZDogdGFyZ2V0Tm9kZUlkfSksXG4gICAgICAgICAgICBpbmRleDtcblxuICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgaW5kZXggPSBpbnNlcnRCZWZvcmUgPyB0YXJnZXROb2RlLmluZGV4IDogdGFyZ2V0Tm9kZS5pbmRleCArIDE7XG4gICAgICAgICAgICB0YXJnZXROb2RlLnBhcmVudE5vZGUuY24uc3BsaWNlKGluZGV4LCAwLCBub2RlVG9JbnNlcnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB2ZG9tIGNoaWxkIG5vZGVzIGJ5IGlkIG9yIG9wdHMgb2JqZWN0IGZvciBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbV1cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHMgRWl0aGVyIGFuIG9iamVjdCBjb250YWluaW5nIHZkb20gbm9kZSBhdHRyaWJ1dGVzIG9yIGEgc3RyaW5nIGJhc2VkIGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgbm9kZSB3YXMgZm91bmQgJiByZW1vdmVkXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZVZkb21DaGlsZCh2ZG9tLCBvcHRzKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IFZEb20uZmluZFZkb21DaGlsZCh2ZG9tLCBvcHRzKTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudE5vZGUuY24uc3BsaWNlKGNoaWxkLmluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIGNoaWxkIG5vZGUgaW5zaWRlIGEgdmRvbSB0cmVlIGJ5IGEgZ2l2ZW4gaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdDaGlsZE5vZGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBub2RlIHdhcyBmb3VuZCBhbmQgcmVwbGFjZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZVZkb21DaGlsZCh2ZG9tLCBpZCwgbmV3Q2hpbGROb2RlKSB7XG4gICAgICAgIGxldCBjbiAgPSB2ZG9tLmNuIHx8IFtdLFxuICAgICAgICAgICAgaSAgID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGNuLmxlbmd0aCxcbiAgICAgICAgICAgIGNoaWxkTm9kZTtcblxuICAgICAgICBpZiAodmRvbS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVwbGFjZVZkb21DaGlsZDogdGFyZ2V0IGlkIG1hdGNoZXMgdGhlIHJvb3Qgdm5vZGUgaWQ6ICcgKyBpZClcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNuW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGNuW2ldID0gbmV3Q2hpbGROb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChWRG9tLnJlcGxhY2VWZG9tQ2hpbGQoY2hpbGROb2RlLCBpZCwgbmV3Q2hpbGROb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVvLnZkb20uSGVscGVyIHdpbGwgY3JlYXRlIGlkcyBmb3IgZWFjaCB2bm9kZSB3aGljaCBkb2VzIG5vdCBhbHJlYWR5IGhhdmUgb25lLFxuICAgICAqIHNvIHdlIG5lZWQgdG8gc3luYyB0aGVtIGludG8gdGhlIHZkb20uXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2U9ZmFsc2UgVGhlIGZvcmNlIHBhcmFtIHdpbGwgZW5mb3JjZSBvdmVyd3JpdGluZyBkaWZmZXJlbnQgaWRzXG4gICAgICovXG4gICAgc3RhdGljIHN5bmNWZG9tSWRzKHZub2RlLCB2ZG9tLCBmb3JjZT1mYWxzZSkge1xuICAgICAgICBpZiAodm5vZGUgJiYgdmRvbSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSB2ZG9tLmNuLFxuICAgICAgICAgICAgICAgIGNuLCBpLCBsZW47XG5cbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZS5pZCAmJiB2ZG9tLmlkICE9PSB2bm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmlkID0gdm5vZGUuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBjaGFuZ2UgdmRvbSBpZHMgaW4gY2FzZSB0aGVyZSBpcyBub3QgYWxyZWFkeSBhbiBvd24gaWRcbiAgICAgICAgICAgICAgICAvLyAodGhpbmsgb2YgYWRkaW5nICYgcmVtb3Zpbmcgbm9kZXMgaW4gcGFyYWxsZWwpXG4gICAgICAgICAgICAgICAgaWYgKCF2ZG9tLmlkICYmIHZub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uaWQgPSB2bm9kZS5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBjbiAgID0gY2hpbGROb2Rlcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnJlbW92ZURvbSAhPT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaSAgICA9IDA7XG4gICAgICAgICAgICAgICAgbGVuICA9IGNuPy5sZW5ndGggfHwgMDtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZEb20uc3luY1Zkb21JZHModm5vZGUuY2hpbGROb2Rlc1tpXSwgY25baV0sIGZvcmNlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWRG9tKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5WTm9kZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBWTm9kZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuVk5vZGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlZOb2RlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB2bm9kZSBjaGlsZCBub2RlcyBieSBpZCBvciBvcHRzIG9iamVjdCBmb3IgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHMgRWl0aGVyIGFuIG9iamVjdCBjb250YWluaW5nIHZkb20gbm9kZSBhdHRyaWJ1dGVzIG9yIGEgc3RyaW5nIGJhc2VkIGlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyZW50Tm9kZV0gSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogICAgIHtOdW1iZXJ9IGluZGV4XG4gICAgICogICAgIHtTdHJpbmd9IHBhcmVudElkXG4gICAgICogICAgIHtPYmplY3R9IHZub2RlXG4gICAgICovXG4gICAgc3RhdGljIGZpbmRDaGlsZFZub2RlKHZub2RlLCBvcHRzLCBpbmRleCwgcGFyZW50Tm9kZSkge1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIG9wdHMgID0gdHlwZW9mIG9wdHMgIT09ICdzdHJpbmcnID8gb3B0cyA6IHtpZDogb3B0c307XG5cbiAgICAgICAgbGV0IGF0dHJNYXRjaCAgPSB0cnVlLFxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFtdLFxuICAgICAgICAgICAgc3R5bGVNYXRjaCA9IHRydWUsXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSB2bm9kZS5jaGlsZE5vZGVzPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIG9wdHNBcnJheSwgb3B0c0xlbmd0aCwgc3ViQ2hpbGQ7XG5cbiAgICAgICAgb3B0c0FycmF5ICA9IE9iamVjdC5lbnRyaWVzKG9wdHMpO1xuICAgICAgICBvcHRzTGVuZ3RoID0gb3B0c0FycmF5Lmxlbmd0aDtcblxuICAgICAgICBvcHRzQXJyYXkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodm5vZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiBOZW8uaXNPYmplY3Qodm5vZGVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2F0dHJLZXksIGF0dHJWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodm5vZGVba2V5XS5oYXNPd25Qcm9wZXJ0eShhdHRyS2V5KSAmJiB2bm9kZVtrZXldW2F0dHJLZXldID09PSBhdHRyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyTWF0Y2ggPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ck1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBOZW8uaXNBcnJheSh2bm9kZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2bm9kZVtrZXldLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZub2RlW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzQXJyYXkodmFsdWUpICYmIE5lby5pc0FycmF5KHZub2RlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogZWl0aGVyIHNlYXJjaCB0aGUgdm5vZGUgYXJyYXkgZm9yIGFsbCBrZXlzIG9yIGNvbXBhcmUgaWYgdGhlIGFycmF5cyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaW5kQ2hpbGRWbm9kZTogY2xzIG1hdGNoaW5nIG5vdCBzdXBwb3J0ZWQgZm9yIHRhcmdldCAmIHNvdXJjZSB0eXBlcyBvZiBBcnJheXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgTmVvLmlzT2JqZWN0KHZub2RlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtzdHlsZUtleSwgc3R5bGVWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodm5vZGVba2V5XS5oYXNPd25Qcm9wZXJ0eShzdHlsZUtleSkgJiYgdm5vZGVba2V5XVtzdHlsZUtleV0gPT09IHN0eWxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1hdGNoID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2bm9kZVtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaEFycmF5Lmxlbmd0aCA9PT0gb3B0c0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleCwgcGFyZW50Tm9kZSwgdm5vZGV9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzdWJDaGlsZCA9IFZOb2RlLmZpbmRDaGlsZFZub2RlKHZub2RlLmNoaWxkTm9kZXNbaV0sIG9wdHMsIGksIHZub2RlKTtcblxuICAgICAgICAgICAgaWYgKHN1YkNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YkNoaWxkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgY2hpbGQgdm5vZGUgaW5zaWRlIGEgdm5vZGUgdHJlZSBieSBhIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gaWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IGNoaWxkIHZub2RlIG9yIG51bGxcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluZENoaWxkVm5vZGVCeUlkKHZub2RlLCBpZCkge1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHZub2RlLmNoaWxkTm9kZXMgfHwgW10sXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGNoaWxkTm9kZTtcblxuICAgICAgICBpZiAodm5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBWTm9kZS5maW5kQ2hpbGRWbm9kZUJ5SWQoY2hpbGROb2RlLCBpZCk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRzIG9mIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gdm5vZGVcbiAgICAgKiBAcGFyYW0gdm5vZGVcbiAgICAgKiBAcGFyYW0gW2NoaWxkSWRzPVtdXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2hpbGRJZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hpbGRJZHModm5vZGUsIGNoaWxkSWRzPVtdKSB7XG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdm5vZGUgJiYgdm5vZGUuY2hpbGROb2RlcyB8fCBbXTtcblxuICAgICAgICBjaGlsZE5vZGVzLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZElkcy5wdXNoKGNoaWxkTm9kZS5pZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGRJZHMgPSBWTm9kZS5nZXRDaGlsZElkcyhjaGlsZE5vZGUsIGNoaWxkSWRzKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hpbGRJZHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgdm5vZGUgaW5zaWRlIGEgdm5vZGUgdHJlZSBieSBhIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgbm9kZSB3YXMgZm91bmQgYW5kIHJlbW92ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlQ2hpbGRWbm9kZSh2bm9kZSwgaWQpIHtcbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSB2bm9kZS5jaGlsZE5vZGVzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgID0gY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICBjaGlsZE5vZGU7XG5cbiAgICAgICAgaWYgKHZub2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVDaGlsZFZub2RlOiB0YXJnZXQgaWQgbWF0Y2hlcyB0aGUgcm9vdCB2bm9kZSBpZDogJyArIGlkKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoVk5vZGUucmVtb3ZlQ2hpbGRWbm9kZShjaGlsZE5vZGUsIGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIGNoaWxkIHZub2RlIGluc2lkZSBhIHZub2RlIHRyZWUgYnkgYSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdDaGlsZFZub2RlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgbm9kZSB3YXMgZm91bmQgYW5kIHJlcGxhY2VkXG4gICAgICovXG4gICAgc3RhdGljIHJlcGxhY2VDaGlsZFZub2RlKHZub2RlLCBpZCwgbmV3Q2hpbGRWbm9kZSkge1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHZub2RlLmNoaWxkTm9kZXMgfHwgW10sXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGNoaWxkTm9kZTtcblxuICAgICAgICBpZiAodm5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGxhY2VDaGlsZFZub2RlOiB0YXJnZXQgaWQgbWF0Y2hlcyB0aGUgcm9vdCB2bm9kZSBpZDogJyArIGlkKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzW2ldID0gbmV3Q2hpbGRWbm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoVk5vZGUucmVwbGFjZUNoaWxkVm5vZGUoY2hpbGROb2RlLCBpZCwgbmV3Q2hpbGRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWTm9kZSk7XG4iLCJpbXBvcnQgQ29yZUJhc2UgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBNZXNzYWdlICAgICAgICAgICAgZnJvbSAnLi9NZXNzYWdlLm1qcyc7XG5pbXBvcnQgUmVtb3RlTWV0aG9kQWNjZXNzIGZyb20gJy4vbWl4aW4vUmVtb3RlTWV0aG9kQWNjZXNzLm1qcyc7XG5cbi8qKlxuICogVGhlIGFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRoZSBBcHAsIERhdGEgJiBWRG9tIHdvcmtlclxuICogQGNsYXNzIE5lby53b3JrZXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb3JlQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ud29ya2VyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby53b3JrZXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxOZW8uY29yZS5CYXNlW118bnVsbH0gbWl4aW5zPVtPYnNlcnZhYmxlLFJlbW90ZU1ldGhvZEFjY2Vzc11cbiAgICAgICAgICovXG4gICAgICAgIG1peGluczogW09ic2VydmFibGUsIFJlbW90ZU1ldGhvZEFjY2Vzc10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gd29ya2VySWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB3b3JrZXJJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjaGFubmVsUG9ydHM9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjaGFubmVsUG9ydHMgPSBudWxsXG4gICAgLyoqXG4gICAgICogT25seSBuZWVkZWQgZm9yIFNoYXJlZFdvcmtlcnNcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0Nvbm5lY3RlZD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNTaGFyZWRXb3JrZXI9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNTaGFyZWRXb3JrZXIgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIE9ubHkgbmVlZGVkIGZvciBTaGFyZWRXb3JrZXJzXG4gICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gcG9ydHM9bnVsbFxuICAgICAqL1xuICAgIHBvcnRzID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGd0ID0gZ2xvYmFsVGhpcztcblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBjaGFubmVsUG9ydHMgIDoge30sXG4gICAgICAgICAgICBpc1NoYXJlZFdvcmtlcjogZ3QudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhcmVkV29ya2VyR2xvYmFsU2NvcGVdJyxcbiAgICAgICAgICAgIHBvcnRzICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIHByb21pc2VzICAgICAgOiB7fVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWUuaXNTaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgIGd0Lm9uY29ubmVjdCA9IG1lLm9uQ29ubmVjdGVkLmJpbmQobWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBndC5vbm1lc3NhZ2UgPSBtZS5vbk1lc3NhZ2UuYmluZChtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyID0gbWU7XG4gICAgICAgIE5lby53b3JrZXJJZCAgICAgID0gbWUud29ya2VySWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgZGVkaWNhdGVkIGFuZCBzaGFyZWQgd29ya2Vyc1xuICAgICAqL1xuICAgIGFmdGVyQ29ubmVjdCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQb3J0KG9wdHMpIHtcbiAgICAgICAgbGV0IHJldHVyblBvcnQgPSBudWxsLFxuICAgICAgICAgICAgaGFzTWF0Y2g7XG5cbiAgICAgICAgdGhpcy5wb3J0cy5mb3JFYWNoKHBvcnQgPT4ge1xuICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhvcHRzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHBvcnRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVyblBvcnQgPSBwb3J0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5Qb3J0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25Db25uZWN0KGRhdGEpIHtcbiAgICAgICAgLy8gc2hvcnQgZGVsYXkgdG8gZW5zdXJlIGFwcCBWQ3MgYXJlIGluIHBsYWNlXG4gICAgICAgIGF3YWl0IHRoaXMudGltZW91dCgxMCk7XG5cbiAgICAgICAgbGV0IHthcHBOYW1lLCB3aW5kb3dJZH0gPSBkYXRhO1xuICAgICAgICB0aGlzLmZpcmUoJ2Nvbm5lY3QnLCB7YXBwTmFtZSwgd2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIFNoYXJlZFdvcmtlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgICAqL1xuICAgIG9uQ29ubmVjdGVkKGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGlkID0gTmVvLmdldElkKCdwb3J0Jyk7XG5cbiAgICAgICAgbWUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIG1lLnBvcnRzLnB1c2goe1xuICAgICAgICAgICAgYXBwTmFtZSA6IG51bGwsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBvcnQgICAgOiBlLnBvcnRzWzBdLFxuICAgICAgICAgICAgd2luZG93SWQ6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUucG9ydHNbbWUucG9ydHMubGVuZ3RoIC0gMV0ucG9ydC5vbm1lc3NhZ2UgPSBtZS5vbk1lc3NhZ2UuYmluZChtZSk7XG5cbiAgICAgICAgLy8gY29yZS5CYXNlOiBpbml0UmVtb3RlKCkgc3Vic2NyaWJlcyB0byB0aGlzIGV2ZW50IGZvciB0aGUgU2hhcmVkV29ya2VycyBjb250ZXh0XG4gICAgICAgIG1lLmZpcmUoJ2Nvbm5lY3RlZCcpO1xuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlKCdtYWluJywge2FjdGlvbjogJ3dvcmtlckNvbnN0cnVjdGVkJywgcG9ydDogaWR9KTtcblxuICAgICAgICBtZS5hZnRlckNvbm5lY3QoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UoJ21haW4nLCB7YWN0aW9uOiAnd29ya2VyQ29uc3RydWN0ZWQnfSk7XG4gICAgICAgICAgICBtZS5hZnRlckNvbm5lY3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EaXNjb25uZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IHthcHBOYW1lLCB3aW5kb3dJZH0gPSBkYXRhO1xuICAgICAgICB0aGlzLmZpcmUoJ2Rpc2Nvbm5lY3QnLCB7YXBwTmFtZSwgd2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAgICovXG4gICAgb25NZXNzYWdlKGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkYXRhfSAgICAgICAgICAgID0gZSxcbiAgICAgICAgICAgIHthY3Rpb24sIHJlcGx5SWR9ID0gZGF0YSxcbiAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBhY3Rpb24gaXMgbWlzc2luZzogJyArIGRhdGEuaWQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uICE9PSAncmVwbHknKSB7XG4gICAgICAgICAgICBtZVsnb24nICsgTmVvLmNhcGl0YWxpemUoYWN0aW9uKV0oZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZSA9IGFjdGlvbiA9PT0gJ3JlcGx5JyAmJiBtZS5wcm9taXNlc1tyZXBseUlkXSkge1xuICAgICAgICAgICAgaWYgKGRhdGEucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZGF0YS5kYXRhKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoZGF0YS5kYXRhKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgbWUucHJvbWlzZXNbcmVwbHlJZF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKi9cbiAgICBvblBpbmcobXNnKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZShtc2csIHtvcmlnaW5Nc2c6IG1zZ30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnLmFwcE5hbWVcbiAgICAgKi9cbiAgICBvblJlZ2lzdGVyQXBwKG1zZykge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lfSA9IG1zZyxcbiAgICAgICAgICAgIHBvcnQ7XG5cbiAgICAgICAgZm9yIChwb3J0IG9mIG1lLnBvcnRzKSB7XG4gICAgICAgICAgICBpZiAoIXBvcnQuYXBwTmFtZSkge1xuICAgICAgICAgICAgICAgIHBvcnQuYXBwTmFtZSA9IGFwcE5hbWU7XG4gICAgICAgICAgICAgICAgbWUub25Db25uZWN0KHthcHBOYW1lLCB3aW5kb3dJZDogcG9ydC53aW5kb3dJZH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAgICovXG4gICAgb25SZWdpc3Rlck5lb0NvbmZpZyhtc2cpIHtcbiAgICAgICAgTmVvLmNvbmZpZyA9IE5lby5jb25maWcgfHwge307XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1zZy5kYXRhLFxuICAgICAgICAgICAgcG9ydDtcblxuICAgICAgICBmb3IgKHBvcnQgb2YgbWUucG9ydHMpIHtcbiAgICAgICAgICAgIGlmICghcG9ydC53aW5kb3dJZCkge1xuICAgICAgICAgICAgICAgIHBvcnQud2luZG93SWQgPSB3aW5kb3dJZDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihOZW8uY29uZmlnLCBtc2cuZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzdCBhcHAsIGRhdGEsIG1haW4gb3IgdmRvbSAoZXhjbHVkaW5nIHRoZSBjdXJyZW50IHdvcmtlcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBjb25maWdzIGZvciBOZW8ud29ya2VyLk1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmZXJdIEFuIG9wdGlvbmFsIGFycmF5IG9mIFRyYW5zZmVyYWJsZSBvYmplY3RzIHRvIHRyYW5zZmVyIG93bmVyc2hpcCBvZi5cbiAgICAgKiBJZiB0aGUgb3duZXJzaGlwIG9mIGFuIG9iamVjdCBpcyB0cmFuc2ZlcnJlZCwgaXQgYmVjb21lcyB1bnVzYWJsZSAobmV1dGVyZWQpIGluIHRoZSBjb250ZXh0IGl0IHdhcyBzZW50IGZyb21cbiAgICAgKiBhbmQgYmVjb21lcyBhdmFpbGFibGUgb25seSB0byB0aGUgd29ya2VyIGl0IHdhcyBzZW50IHRvLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZU1lc3NhZ2UoZGVzdCwgb3B0cywgdHJhbnNmZXIpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IG1lLnNlbmRNZXNzYWdlKGRlc3QsIG9wdHMsIHRyYW5zZmVyKSxcbiAgICAgICAgICAgICAgICBtc2dJZCAgID0gbWVzc2FnZT8uaWQ7XG5cbiAgICAgICAgICAgIGlmICghbXNnSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhIHdpbmRvdyBnb3QgY2xvc2VkIGFuZCB0aGUgbWVzc2FnZSBwb3J0IG5vIGxvbmdlciBleGlzdCAoU2hhcmVkV29ya2VycylcbiAgICAgICAgICAgICAgICByZWplY3QoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5wcm9taXNlc1ttc2dJZF0gPSB7cmVqZWN0LCByZXNvbHZlfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0IGFwcCwgY2FudmFzLCBkYXRhLCBtYWluIG9yIHZkb20gKGV4Y2x1ZGluZyB0aGUgY3VycmVudCB3b3JrZXIpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgY29uZmlncyBmb3IgTmVvLndvcmtlci5NZXNzYWdlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3RyYW5zZmVyXSBBbiBvcHRpb25hbCBhcnJheSBvZiBUcmFuc2ZlcmFibGUgb2JqZWN0cyB0byB0cmFuc2ZlciBvd25lcnNoaXAgb2YuXG4gICAgICogSWYgdGhlIG93bmVyc2hpcCBvZiBhbiBvYmplY3QgaXMgdHJhbnNmZXJyZWQsIGl0IGJlY29tZXMgdW51c2FibGUgKG5ldXRlcmVkKSBpbiB0aGUgY29udGV4dCBpdCB3YXMgc2VudCBmcm9tXG4gICAgICogYW5kIGJlY29tZXMgYXZhaWxhYmxlIG9ubHkgdG8gdGhlIHdvcmtlciBpdCB3YXMgc2VudCB0by5cbiAgICAgKiBAcmV0dXJucyB7TmVvLndvcmtlci5NZXNzYWdlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShkZXN0LCBvcHRzLCB0cmFuc2Zlcikge1xuICAgICAgICBvcHRzLmRlc3RpbmF0aW9uID0gZGVzdDtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbWVzc2FnZSwgcG9ydCwgcG9ydE9iamVjdDtcblxuICAgICAgICBpZiAobWUuY2hhbm5lbFBvcnRzW2Rlc3RdKSB7XG4gICAgICAgICAgICBwb3J0ID0gbWUuY2hhbm5lbFBvcnRzW2Rlc3RdXG4gICAgICAgIH0gZWxzZSBpZiAoIW1lLmlzU2hhcmVkV29ya2VyKSB7XG4gICAgICAgICAgICBwb3J0ID0gZ2xvYmFsVGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMucG9ydCkge1xuICAgICAgICAgICAgICAgIHBvcnQgPSBtZS5nZXRQb3J0KHtpZDogb3B0cy5wb3J0fSkucG9ydFxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLndpbmRvd0lkKSB7XG4gICAgICAgICAgICAgICAgcG9ydE9iamVjdCA9IG1lLmdldFBvcnQoe3dpbmRvd0lkOiBvcHRzLndpbmRvd0lkfSk7XG4gICAgICAgICAgICAgICAgcG9ydCAgICAgICA9IHBvcnRPYmplY3Q/LnBvcnQ7XG5cbiAgICAgICAgICAgICAgICBvcHRzLnBvcnQgPSBwb3J0T2JqZWN0Py5pZFxuICAgICAgICAgICAgfSAgZWxzZSBpZiAob3B0cy5hcHBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcG9ydE9iamVjdCA9IG1lLmdldFBvcnQoe2FwcE5hbWU6IG9wdHMuYXBwTmFtZX0pO1xuICAgICAgICAgICAgICAgIHBvcnQgICAgICAgPSBwb3J0T2JqZWN0Py5wb3J0O1xuXG4gICAgICAgICAgICAgICAgb3B0cy5wb3J0ID0gcG9ydE9iamVjdD8uaWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9ydCA9IG1lLnBvcnRzWzBdLnBvcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gbmV3IE1lc3NhZ2Uob3B0cyk7XG4gICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCYXNlKTtcbiIsImltcG9ydCBJZEdlbmVyYXRvciBmcm9tICcuLi9jb3JlL0lkR2VuZXJhdG9yLm1qcyc7XG5cbi8qKlxuICogQSB3cmFwcGVyIGZvciB3b3JrZXIgcG9zdCBtZXNzYWdlcyBzZW50IGJldHdlZW4gdGhlIEFwcCwgRGF0YSwgVkRvbSB3b3JrZXIgJiB0aGUgbWFpbiB0aHJlYWQuXG4gKiBZb3UgY2FuIGFkZCBvcHRpb25hbCBwYXJhbXMgYXMgbmVlZGVkLlxuICogQGNsYXNzIE5lby53b3JrZXIuTWVzc2FnZVxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGFjdGlvblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkZXN0aW5hdGlvbj0nbWFpbidcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaWQ9SWRHZW5lcmF0b3IuZ2V0SWQoTmVvLndvcmtlcklkKVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBvcmlnaW49TmVvLndvcmtlcklkXG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbmZpZy5kZXN0aW5hdGlvbiA9IGNvbmZpZy5kZXN0aW5hdGlvbiB8fCAnbWFpbic7XG4gICAgICAgIGNvbmZpZy5pZCAgICAgICAgICA9IGNvbmZpZy5pZCAgICAgICAgICB8fCBJZEdlbmVyYXRvci5nZXRJZChOZW8ud29ya2VySWQpO1xuICAgICAgICBjb25maWcub3JpZ2luICAgICAgPSBjb25maWcub3JpZ2luICAgICAgfHwgTmVvLndvcmtlcklkO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKVxuICAgIH1cbn1cblxuY29uc3QgbnMgPSBOZW8ubnMoJ05lby53b3JrZXInLCB0cnVlKTtcbm5zWydNZXNzYWdlJ10gPSBNZXNzYWdlO1xuXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFJlbW90ZU1ldGhvZEFjY2VzcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLndvcmtlci5taXhpbi5SZW1vdGVNZXRob2RBY2Nlc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1peGluPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW46IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIGFzc2lnblBvcnQoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3Qge2FwcE5hbWUsIHBvcnQsIHdpbmRvd0lkfSA9IHNvdXJjZTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7YXBwTmFtZSwgcG9ydCwgd2luZG93SWR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlbW90ZVxuICAgICAqIEBwYXJhbSBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oKj0sICo9KTogUHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdlbmVyYXRlUmVtb3RlKHJlbW90ZSwgbWV0aG9kKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3JpZ2lufSA9IHJlbW90ZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgYnVmZmVyKSB7XG4gICAgICAgICAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gICAgICAgICA6ICdyZW1vdGVNZXRob2QnLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gICAgOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgcmVtb3RlQ2xhc3NOYW1lOiByZW1vdGUuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHJlbW90ZU1ldGhvZCAgIDogbWV0aG9kXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBtZS5pc1NoYXJlZFdvcmtlciAmJiBtZS5hc3NpZ25Qb3J0KGRhdGEsIG9wdHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUucHJvbWlzZU1lc3NhZ2Uob3JpZ2luLCBvcHRzLCBidWZmZXIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVtb3RlXG4gICAgICovXG4gICAgb25SZWdpc3RlclJlbW90ZShyZW1vdGUpIHtcbiAgICAgICAgaWYgKHJlbW90ZS5kZXN0aW5hdGlvbiA9PT0gTmVvLndvcmtlcklkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtjbGFzc05hbWUsIG1ldGhvZHN9ID0gcmVtb3RlLFxuICAgICAgICAgICAgICAgIHBrZyAgICAgICAgICAgICAgICAgID0gTmVvLm5zKGNsYXNzTmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIG1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGUub3JpZ2luICE9PSAnbWFpbicgJiYgcGtnW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgcmVtb3RlIG1ldGhvZCBkZWZpbml0aW9uICcgKyBjbGFzc05hbWUgKyAnLicgKyBtZXRob2QpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGtnW21ldGhvZF0gPz89IG1lLmdlbmVyYXRlUmVtb3RlKHJlbW90ZSwgbWV0aG9kKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKi9cbiAgICBvblJlbW90ZU1ldGhvZChtc2cpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBwa2cgPSBOZW8ubnMobXNnLnJlbW90ZUNsYXNzTmFtZSksXG4gICAgICAgICAgICBvdXQsIG1ldGhvZDtcblxuICAgICAgICBpZiAoIXBrZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbW90ZSBuYW1lc3BhY2UgXCInICsgbXNnLnJlbW90ZUNsYXNzTmFtZSArICdcIicpXG4gICAgICAgIH1cblxuICAgICAgICBtZXRob2QgPSBwa2dbbXNnLnJlbW90ZU1ldGhvZF07XG5cbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZW1vdGUgbWV0aG9kIG5hbWUgXCInICsgbXNnLnJlbW90ZU1ldGhvZCArICdcIicpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtc2cuZGF0YSkpIHtcbiAgICAgICAgICAgIG91dCA9IG1ldGhvZC5jYWxsKHBrZywgLi4ubXNnLmRhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgPSBtZXRob2QuY2FsbChwa2csIG1zZy5kYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG91dFxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge21lLnJlamVjdChtc2csIGVycil9KVxuICAgICAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge21lLnJlc29sdmUobXNnLCBkYXRhKX0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5yZXNvbHZlKG1zZywgb3V0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiBwcm9taXNlTWVzc2FnZSBnZXRzIHJlamVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgcmVqZWN0KG1zZywgZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICBhY3Rpb24gOiAncmVwbHknLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJlamVjdCA6IHRydWUsXG4gICAgICAgICAgICByZXBseUlkOiBtc2cuaWRcbiAgICAgICAgfTtcblxuICAgICAgICBtZS5pc1NoYXJlZFdvcmtlciAmJiBtZS5hc3NpZ25Qb3J0KG1zZywgb3B0cyk7XG4gICAgICAgIG1lLnNlbmRNZXNzYWdlKG1zZy5vcmlnaW4sIG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiBwcm9taXNlTWVzc2FnZSBnZXRzIHJlc29sdmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgcmVzb2x2ZShtc2csIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgYWN0aW9uIDogJ3JlcGx5JyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZXBseUlkOiBtc2cuaWRcbiAgICAgICAgfTtcblxuICAgICAgICBtZS5pc1NoYXJlZFdvcmtlciAmJiBtZS5hc3NpZ25Qb3J0KG1zZywgb3B0cyk7XG4gICAgICAgIG1lLnNlbmRNZXNzYWdlKG1zZy5vcmlnaW4sIG9wdHMpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhSZW1vdGVNZXRob2RBY2Nlc3MpO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmYgPSB7fTtcbi8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5lID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKChwcm9taXNlcywga2V5KSA9PiB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiY2h1bmtzL2FwcC9cIiArIGNodW5rSWQgKyBcIi5qc1wiO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTQ1JJUFQnKVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHtcblx0XHRcdHZhciBpID0gc2NyaXB0cy5sZW5ndGggLSAxO1xuXHRcdFx0d2hpbGUgKGkgPiAtMSAmJiAoIXNjcmlwdFVybCB8fCAhL15odHRwKHM/KTovLnRlc3Qoc2NyaXB0VXJsKSkpIHNjcmlwdFVybCA9IHNjcmlwdHNbaS0tXS5zcmM7XG5cdFx0fVxuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCIvLyBubyBiYXNlVVJJXG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgY2h1bmtzXG4vLyBcIjFcIiBtZWFucyBcImFscmVhZHkgbG9hZGVkXCJcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwiYXBwXCI6IDFcbn07XG5cbi8vIGltcG9ydFNjcmlwdHMgY2h1bmsgbG9hZGluZ1xudmFyIGluc3RhbGxDaHVuayA9IChkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHR9XG5cdH1cblx0aWYocnVudGltZSkgcnVudGltZShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0d2hpbGUoY2h1bmtJZHMubGVuZ3RoKVxuXHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkcy5wb3AoKV0gPSAxO1xuXHRwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcbn07XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYuaSA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHQvLyBcIjFcIiBpcyB0aGUgc2lnbmFsIGZvciBcImFscmVhZHkgbG9hZGVkXCJcblx0aWYoIWluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuXHRcdGlmKHRydWUpIHsgLy8gYWxsIGNodW5rcyBoYXZlIEpTXG5cdFx0XHRpbXBvcnRTY3JpcHRzKF9fd2VicGFja19yZXF1aXJlX18ucCArIF9fd2VicGFja19yZXF1aXJlX18udShjaHVua0lkKSk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgY2h1bmtMb2FkaW5nR2xvYmFsID0gc2VsZltcIndlYnBhY2tDaHVua25lb19tanNcIl0gPSBzZWxmW1wid2VicGFja0NodW5rbmVvX21qc1wiXSB8fCBbXTtcbnZhciBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbiA9IGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKTtcbmNodW5rTG9hZGluZ0dsb2JhbC5wdXNoID0gaW5zdGFsbENodW5rO1xuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0IiwiaW1wb3J0IE5lbyAgICAgICAgICAgICBmcm9tICcuLi9OZW8ubWpzJztcbmltcG9ydCBCYXNlICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgKiBhcyBjb3JlICAgICAgIGZyb20gJy4uL2NvcmUvX2V4cG9ydC5tanMnO1xuaW1wb3J0IEFwcGxpY2F0aW9uICAgICBmcm9tICcuLi9jb250cm9sbGVyL0FwcGxpY2F0aW9uLm1qcyc7XG5pbXBvcnQgSW5zdGFuY2UgICAgICAgIGZyb20gJy4uL21hbmFnZXIvSW5zdGFuY2UubWpzJztcbmltcG9ydCBEb21FdmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Eb21FdmVudC5tanMnO1xuaW1wb3J0IEhhc2hIaXN0b3J5ICAgICBmcm9tICcuLi91dGlsL0hhc2hIaXN0b3J5Lm1qcyc7XG5cbi8qKlxuICogVGhlIEFwcCB3b3JrZXIgY29udGFpbnMgbW9zdCBwYXJ0cyBvZiB0aGUgZnJhbWV3b3JrIGFzIHdlbGwgYXMgYWxsIGFwcHMgd2hpY2ggZ2V0IGNyZWF0ZWQuXG4gKiBTZWUgdGhlIHR1dG9yaWFscyBmb3IgZnVydGhlciBpbmZvcy5cbiAqIEBjbGFzcyBOZW8ud29ya2VyLkFwcFxuICogQGV4dGVuZHMgTmVvLndvcmtlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIEFwcCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLndvcmtlci5BcHAnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby53b3JrZXIuQXBwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIGZvciBvdGhlciB3b3JrZXJzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgbWFpbjogW1xuICAgICAgICAgICAgICAgICdjcmVhdGVOZW9JbnN0YW5jZScsXG4gICAgICAgICAgICAgICAgJ2Rlc3Ryb3lOZW9JbnN0YW5jZScsXG4gICAgICAgICAgICAgICAgJ2ZpcmVFdmVudCcsXG4gICAgICAgICAgICAgICAgJ2dldENvbmZpZ3MnLFxuICAgICAgICAgICAgICAgICdzZXRDb25maWdzJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB3b3JrZXJJZD0nYXBwJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB3b3JrZXJJZDogJ2FwcCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZGF0YT1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRhdGEgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNVc2luZ1ZpZXdNb2RlbHM9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNVc2luZ1ZpZXdNb2RlbHMgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFdlIGFyZSBzdG9yaW5nIHRoZSBwYXJhbXMgb2YgaW5zZXJ0VGhlbWVGaWxlcygpIGNhbGxzIGhlcmUsIGluIGNhc2UgdGhlIG1ldGhvZCBkb2VzIGdldCB0cmlnZ2VyZWRcbiAgICAgKiBiZWZvcmUgdGhlIGpzb24gdGhlbWUgc3RydWN0dXJlIGdvdCBsb2FkZWQuXG4gICAgICogQG1lbWJlciB7QXJyYXlbXX0gdGhlbWVGaWxlc0NhY2hlPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoZW1lRmlsZXNDYWNoZSA9IFtdXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIGNvbnZlbmllbmNlIHNob3J0Y3V0c1xuICAgICAgICBOZW8uYXBwbHlEZWx0YXMgICAgPSBtZS5hcHBseURlbHRhcyAgIC5iaW5kKG1lKTtcbiAgICAgICAgTmVvLnNldENzc1ZhcmlhYmxlID0gbWUuc2V0Q3NzVmFyaWFibGUuYmluZChtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBkZWx0YXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBhcHBseURlbHRhcyhhcHBOYW1lLCBkZWx0YXMpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VNZXNzYWdlKCdtYWluJywge2FjdGlvbjogJ3VwZGF0ZURvbScsIGFwcE5hbWUsIGRlbHRhc30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3RlIG1ldGhvZCB0byB1c2UgaW5zaWRlIG1haW4gdGhyZWFkcyBmb3IgY3JlYXRpbmcgbmVvIGJhc2VkIGNsYXNzIGluc3RhbmNlcy5cbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBjYW4gb25seSBwYXNzIGNvbmZpZ3Mgd2hpY2ggY2FuIGdldCBjb252ZXJ0ZWQgaW50byBwdXJlIEpTT04uXG4gICAgICpcbiAgICAgKiBSZW5kZXJpbmcgYSBjb21wb25lbnQgaW50byB0aGUgZG9jdW1lbnQuYm9keVxuICAgICAqIEBleGFtcGxlOlxuICAgICAqICAgICBOZW8ud29ya2VyLkFwcC5jcmVhdGVOZW9JbnN0YW5jZSh7XG4gICAgICogICAgICAgICBudHlwZSAgICAgOiAnYnV0dG9uJyxcbiAgICAgKiAgICAgICAgIGF1dG9Nb3VudCA6IHRydWUsXG4gICAgICogICAgICAgICBhdXRvUmVuZGVyOiB0cnVlXG4gICAgICogICAgICAgICB0ZXh0ICAgICAgOiAnSGkgTmlnZSEnXG4gICAgICogICAgIH0pLnRoZW4oaWQgPT4gY29uc29sZS5sb2coaWQpKVxuICAgICAqXG4gICAgICogSW5zZXJ0aW5nIGEgY29tcG9uZW50IGludG8gYSBjb250YWluZXJcbiAgICAgKiBAZXhhbXBsZTpcbiAgICAgKiAgICAgTmVvLndvcmtlci5BcHAuY3JlYXRlTmVvSW5zdGFuY2Uoe1xuICAgICAqICAgICAgICAgbnR5cGUgICAgICA6ICdidXR0b24nLFxuICAgICAqICAgICAgICAgcGFyZW50SWQgICA6ICduZW8tY29udGFpbmVyLTMnLFxuICAgICAqICAgICAgICAgcGFyZW50SW5kZXg6IDBcbiAgICAgKiAgICAgICAgIHRleHQgICAgICAgOiAnSGkgTmlnZSEnXG4gICAgICogICAgIH0pLnRoZW4oaWQgPT4gY29uc29sZS5sb2coaWQpKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmltcG9ydFBhdGhdIHlvdSBjYW4gbGF6eSBsb2FkIG1pc3NpbmcgY2xhc3NlcyB2aWEgdGhpcyBjb25maWcuIGRldiBtb2RlIG9ubHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcucGFyZW50SWRdIHBhc3NpbmcgYSBwYXJlbnRJZCB3aWxsIHB1dCB5b3VyIGluc3RhbmNlIGludG8gYSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wYXJlbnRJbmRleF0gaWYgYSBwYXJlbnRJZCBpcyBwYXNzZWQsIGJ1dCBubyBpbmRleCwgbmVvIHdpbGwgdXNlIGFkZCgpXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGluc3RhbmNlIGlkXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTmVvSW5zdGFuY2UoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuaW1wb3J0UGF0aCkge1xuICAgICAgICAgICAgYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gY29uZmlnLmltcG9ydFBhdGgpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5pbXBvcnRQYXRoXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYXBwTmFtZSAgID0gT2JqZWN0LmtleXMoTmVvLmFwcHMpWzBdLCAvLyBmYWxsYmFjayBpbiBjYXNlIG5vIGFwcE5hbWUgd2FzIHByb3ZpZGVkXG4gICAgICAgICAgICBDb250YWluZXIgPSBOZW8uY29udGFpbmVyPy5CYXNlLFxuICAgICAgICAgICAgaW5kZXgsIGluc3RhbmNlLCBwYXJlbnQ7XG5cbiAgICAgICAgY29uZmlnID0ge2FwcE5hbWUsIC4uLmNvbmZpZ307XG5cbiAgICAgICAgaWYgKGNvbmZpZy5wYXJlbnRJZCkge1xuICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChjb25maWcucGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAoQ29udGFpbmVyICYmIHBhcmVudCAmJiBwYXJlbnQgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvbmZpZy5wYXJlbnRJbmRleDtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucGFyZW50SWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5wYXJlbnRJbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNOdW1iZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gcGFyZW50Lmluc2VydChpbmRleCwgY29uZmlnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gcGFyZW50LmFkZChjb25maWcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBwYXJlbnRJZD0nZG9jdW1lbnQuYm9keScgPT4gd2Ugd2FudCBpdCB0byBnZXQgc2hvd25cbiAgICAgICAgICAgIGNvbmZpZy5hdXRvTW91bnQgID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5hdXRvUmVuZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgaW5zdGFuY2UgPSBOZW9bY29uZmlnLm50eXBlID8gJ250eXBlJyA6ICdjcmVhdGUnXShjb25maWcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNyZWF0ZVRoZW1lTWFwKGRhdGEpIHtcbiAgICAgICAgTmVvLm5zKCdOZW8uY3NzTWFwLmZpbGVJbmZvJywgdHJ1ZSk7XG4gICAgICAgIE5lby5jc3NNYXAuZmlsZUluZm8gPSBkYXRhO1xuICAgICAgICB0aGlzLnJlc29sdmVUaGVtZUZpbGVzQ2FjaGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW90ZSBtZXRob2QgdG8gdXNlIGluc2lkZSBtYWluIHRocmVhZHMgZm9yIGRlc3Ryb3lpbmcgbmVvIGJhc2VkIGNsYXNzIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlOlxuICAgICAqICAgICBOZW8ud29ya2VyLkFwcC5kZXN0cm95TmVvSW5zdGFuY2UoJ25lby1idXR0b24tMycpLnRoZW4oc3VjY2VzcyA9PiBjb25zb2xlLmxvZyhzdWNjZXNzKSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZXR1cm5zIHRydWUsIGluIGNhc2UgdGhlIGluc3RhbmNlIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIGRlc3Ryb3lOZW9JbnN0YW5jZShpZCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBOZW8uZ2V0KGlkKSxcbiAgICAgICAgICAgIHBhcmVudDtcblxuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IE5lby5nZXRDb21wb25lbnQoaW5zdGFuY2UucGFyZW50SWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3kodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYSBjdXN0b20gZXZlbnQgYmFzZWQgb24gY29yZS5PYnNlcnZhYmxlIG9uIGFueSBhcHAgcmVhbG0gYmFzZWQgTmVvIGluc3RhbmNlIGZyb20gbWFpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5uYW1lXG4gICAgICovXG4gICAgZmlyZUV2ZW50KGRhdGEpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gTmVvLmdldChkYXRhLmlkKSxcbiAgICAgICAgICAgIG5hbWU7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBuYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgICAgICAgICBkZWxldGUgZGF0YS5pZDtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLm5hbWU7XG5cbiAgICAgICAgICAgIGluc3RhbmNlLmZpcmUobmFtZSwgZGF0YSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IG5lZWRlZCBmb3IgdGhlIFNoYXJlZFdvcmtlcnMgY29udGV4dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGZpcmVNYWluVmlld3NFdmVudChldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5wb3J0cy5mb3JFYWNoKHBvcnQgPT4ge1xuICAgICAgICAgICAgTmVvLmFwcHNbcG9ydC5hcHBOYW1lXS5tYWluVmlldy5maXJlKGV2ZW50TmFtZSwgZGF0YSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29uZmlncyBvZiBhbnkgYXBwIHJlYWxtIGJhc2VkIE5lbyBpbnN0YW5jZSBmcm9tIG1haW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGRhdGEua2V5c1xuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29uZmlncyBpZiBhIGtleXMgYXJyYXkgd2FzIHBhc3NlZC5cbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIGNvbmZpZyBkaXJlY3RseSwgaW4gY2FzZSBubyBhcnJheSB3YXMgcGFzc2VkXG4gICAgICogUmV0dXJucyBmYWxzZSwgaW4gY2FzZSBubyBpbnN0YW5jZSBnb3QgZm91bmQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29uZmlncyhkYXRhKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSAgICA9IE5lby5nZXQoZGF0YS5pZCksXG4gICAgICAgICAgICB7a2V5c30gICAgICA9IGRhdGEsXG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlW2tleXNdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybkFycmF5LnB1c2goaW5zdGFuY2Vba2V5XSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuQXJyYXlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgaW1wb3J0QXBwKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy5tanMnKSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgICAgICAgLyogd2VicGFja0luY2x1ZGU6IC8oPzpcXC98XFxcXClhcHAubWpzJC8gKi9cbiAgICAgICAgICAgIC8qIHdlYnBhY2tFeGNsdWRlOiAvW1xcXFxcXC9dbm9kZV9tb2R1bGVzLyg/IW5lby5tanMpICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrTW9kZTogXCJsYXp5XCIgKi9cbiAgICAgICAgICAgIGAuLi8uLi8ke3BhdGh9Lm1qc2BcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgeW91IGRvbid0IHdhbnQgdG8gaW5jbHVkZSBwcm90b3R5cGUgYmFzZWQgQ1NTIGZpbGVzLCB1c2UgdGhlIGNsYXNzTmFtZSBwYXJhbSBpbnN0ZWFkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpbmRvd0lkXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBbcHJvdG9dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjbGFzc05hbWVdXG4gICAgICovXG4gICAgaW5zZXJ0VGhlbWVGaWxlcyh3aW5kb3dJZCwgcHJvdG8sIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoTmVvLmNvbmZpZy50aGVtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IHByb3RvLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cod2luZG93SWQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBjc3NNYXAgPSBOZW8uY3NzTWFwLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHByb3RvPy5fX3Byb3RvX18sXG4gICAgICAgICAgICAgICAgY2xhc3NQYXRoLCBjbGFzc1Jvb3QsIGZpbGVOYW1lLCBsQ2xhc3NSb290LCBtYXBDbGFzc05hbWUsIG5zLCB0aGVtZUZvbGRlcnM7XG5cbiAgICAgICAgICAgIGlmICghY3NzTWFwKSB7XG4gICAgICAgICAgICAgICAgbWUudGhlbWVGaWxlc0NhY2hlLnB1c2goW3dpbmRvd0lkLCBwcm90b10pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbW9kaWZ5IGFwcCByZWxhdGVkIGNsYXNzIG5hbWVzXG4gICAgICAgICAgICAgICAgaWYgKCFjbGFzc05hbWUuc3RhcnRzV2l0aCgnTmVvLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSAgPSBjbGFzc05hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NSb290ICA9IGNsYXNzTmFtZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBsQ2xhc3NSb290ID0gY2xhc3NSb290LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lWzBdID09PSAndmlldycgJiYgY2xhc3NOYW1lLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWFwQ2xhc3NOYW1lID0gYGFwcHMuJHtOZW8uYXBwc1tjbGFzc1Jvb3RdPy5hcHBUaGVtZUZvbGRlciB8fCBsQ2xhc3NSb290fS4ke2NsYXNzTmFtZS5qb2luKCcuJyl9YDtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lICAgID0gYGFwcHMuJHtsQ2xhc3NSb290fS4ke2NsYXNzTmFtZS5qb2luKCcuJyl9YDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gTmVvLmNvcmUuQmFzZS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOZW8ubnMoYCR7d2luZG93SWR9LiR7cGFyZW50LmNsYXNzTmFtZX1gLCBmYWxzZSwgY3NzTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuaW5zZXJ0VGhlbWVGaWxlcyh3aW5kb3dJZCwgcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhlbWVGb2xkZXJzID0gTmVvLm5zKG1hcENsYXNzTmFtZSB8fCBjbGFzc05hbWUsIGZhbHNlLCBjc3NNYXAuZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coY3NzTWFwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhlbWVGb2xkZXJzICYmICFOZW8ubnMoYCR7d2luZG93SWR9LiR7Y2xhc3NOYW1lfWAsIGZhbHNlLCBjc3NNYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzUGF0aCA9IGNsYXNzTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSAgPSBjbGFzc1BhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzUGF0aCA9IGNsYXNzUGF0aC5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhgJHt3aW5kb3dJZH0uJHtjbGFzc1BhdGh9YCwgdHJ1ZSwgY3NzTWFwKTtcblxuICAgICAgICAgICAgICAgICAgICBuc1tmaWxlTmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLlN0eWxlc2hlZXQuYWRkVGhlbWVGaWxlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IG1hcENsYXNzTmFtZSB8fCBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkZXJzICA6IHRoZW1lRm9sZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlcnkgZG9tIGV2ZW50IHdpbGwgZ2V0IGZvcndhcmRlZCBhcyBhIHdvcmtlciBtZXNzYWdlIGZyb20gbWFpbiBhbmQgZW5kcyB1cCBoZXJlIGZpcnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdXNlZnVsIGV2ZW50IHByb3BlcnRpZXMsIGRpZmZlcnMgZm9yIGRpZmZlcmVudCBldmVudCB0eXBlcy4gU2VlIE5lby5tYWluLkRvbUV2ZW50cy5cbiAgICAgKi9cbiAgICBvbkRvbUV2ZW50KGRhdGEpIHtcbiAgICAgICAgRG9tRXZlbnRNYW5hZ2VyLmZpcmUoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVyeSBVUkwgaGFzaC1jaGFuZ2Ugd2lsbCBjcmVhdGUgYSBwb3N0IG1lc3NhZ2UgaW4gbWFpbiBhbmQgZW5kIHVwIGhlcmUgZmlyc3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgcGFyc2VkIGtleS12YWx1ZSBwYWlycyBmb3IgZWFjaCBoYXNoIHZhbHVlXG4gICAgICovXG4gICAgb25IYXNoQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgSGFzaEhpc3RvcnkucHVzaChkYXRhLmRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGZvciBhcHBzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkxvYWRBcHBsaWNhdGlvbihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29uZmlnfSA9IE5lbyxcbiAgICAgICAgICAgIGFwcCwgcGF0aDtcblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgbWUuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBjb25maWcucmVzb3VyY2VzUGF0aCA9IGRhdGEucmVzb3VyY2VzUGF0aFxuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9IG1lLmRhdGEucGF0aDtcblxuICAgICAgICBpZiAoY29uZmlnLmVudmlyb25tZW50ICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGhcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmltcG9ydEFwcChwYXRoKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBhcHAgPSBtb2R1bGUub25TdGFydCgpO1xuXG4gICAgICAgICAgICAvLyBzaG9ydCBkZWxheSB0byBlbnN1cmUgQ29tcG9uZW50IENvbnRyb2xsZXJzIGFyZSByZWFkeVxuICAgICAgICAgICAgY29uZmlnLmhhc2ggJiYgbWUudGltZW91dCg1KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBIYXNoSGlzdG9yeS5wdXNoKGNvbmZpZy5oYXNoKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBzIHdoaWNoIHdpbGwgZ2V0IGNyZWF0ZWQgbGF0ZXIgbXVzdCBub3QgdXNlIG91dGRhdGVkIGhhc2ggdmFsdWVzXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5oYXNoXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgaW4gY2FzZSBhIGNvbm5lY3RlZCBTZXJ2aWNlV29ya2VyIHJlY2VpdmVzIGEgbmV3IHZlcnNpb24uXG4gICAgICogRXNwZWNpYWxseSBpbnNpZGUgZGlzdCBlbnZzLCBhIHJlbG9hZCBvZiB0aGUgY29ubmVjdGluZyB3aW5kb3cgaXMgcmVxdWlyZWQsXG4gICAgICogc2luY2UgdGhlIFNXIHdpbGwgY2xlYXIgaXRzIGNhY2hlcyBhbmQgdGhlIGFwcCBjYW4gcmVjZWl2ZSBjb25mbGljdGluZyBidW5kbGUgdmVyc2lvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5uZXdWZXJzaW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEub2xkVmVyc2lvblxuICAgICAqL1xuICAgIG9uTmV3VmVyc2lvbihkYXRhKSB7XG4gICAgICAgIE5lby5NYWluLnJlbG9hZFdpbmRvdyh7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZSBldmVudCBvbiBhbGwgYXBwc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuYW5nbGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5sYXlvdXQgbGFuZHNjYXBlfHBvcnRyYWl0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudHlwZSBsYW5kc2NhcGUtcHJpbWFyeXxsYW5kc2NhcGUtc2Vjb25kYXJ5fHBvcnRyYWl0LXByaW1hcnl8cG9ydHJhaXQtc2Vjb25kYXJ5XG4gICAgICovXG4gICAgb25PcmllbnRhdGlvbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoTmVvLmFwcHMpLmZvckVhY2goYXBwID0+IHtcbiAgICAgICAgICAgIGFwcC5maXJlKCdvcmllbnRhdGlvbmNoYW5nZScsIGRhdGEuZGF0YSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAgICovXG4gICAgb25SZWdpc3Rlck5lb0NvbmZpZyhtc2cpIHtcbiAgICAgICAgc3VwZXIub25SZWdpc3Rlck5lb0NvbmZpZyhtc2cpO1xuXG4gICAgICAgIGxldCBjb25maWcgPSBOZW8uY29uZmlnLFxuICAgICAgICAgICAge2RhdGF9ID0gbXNnLFxuICAgICAgICAgICAgdXJsICAgID0gJ3Jlc291cmNlcy90aGVtZS1tYXAuanNvbic7XG5cbiAgICAgICAgTmVvLndpbmRvd0NvbmZpZ3MgPSBOZW8ud2luZG93Q29uZmlncyB8fCB7fTtcblxuICAgICAgICBOZW8ud2luZG93Q29uZmlnc1tkYXRhLndpbmRvd0lkXSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgdXJsID0gYC4uLy4uLyR7dXJsfWBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcud29ya2VyQmFzZVBhdGg/LmluY2x1ZGVzKCdub2RlX21vZHVsZXMnKSkge1xuICAgICAgICAgICAgdXJsID0gYC4uLy4uLyR7dXJsfWBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cmxbMF0gIT09ICcuJykge1xuICAgICAgICAgICAgdXJsID0gYC4vJHt1cmx9YFxuICAgICAgICB9XG5cbiAgICAgICAgZmV0Y2godXJsKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7dGhpcy5jcmVhdGVUaGVtZU1hcChkYXRhKX0pO1xuXG4gICAgICAgIGNvbmZpZy5yZW1vdGVzQXBpVXJsICAmJiBpbXBvcnQoJy4uL3JlbW90ZXMvQXBpLm1qcycpLnRoZW4obW9kdWxlID0+IG1vZHVsZS5kZWZhdWx0LmxvYWQoKSk7XG4gICAgICAgICFjb25maWcudXNlVmRvbVdvcmtlciAmJiBpbXBvcnQoJy4uL3Zkb20vSGVscGVyLm1qcycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqL1xuICAgIG9uUmVnaXN0ZXJQb3J0KG1zZykge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBwb3J0ID0gbXNnLnRyYW5zZmVyO1xuXG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gbWUub25NZXNzYWdlLmJpbmQobWUpO1xuXG4gICAgICAgIG1lLmNoYW5uZWxQb3J0c1ttc2cub3JpZ2luXSA9IHBvcnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uV2luZG93UG9zaXRpb25DaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmVNYWluVmlld3NFdmVudCgnd2luZG93UG9zaXRpb25DaGFuZ2UnLCBkYXRhLmRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSBuZWVkZWQgZm9yIFNoYXJlZFdvcmtlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwTmFtZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQXBwKGFwcE5hbWUpIHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIG5hbWUgYXMgZmFzdCBhcyBwb3NzaWJsZVxuICAgICAgICB0aGlzLm9uUmVnaXN0ZXJBcHAoeyBhcHBOYW1lIH0pO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKCdtYWluJywge2FjdGlvbjogJ3JlZ2lzdGVyQXBwTmFtZScsIGFwcE5hbWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgdGhlIGFwcCBmcm9tIHRoZSBDU1MgbWFwXG4gICAgICogT25seSBuZWVkZWQgZm9yIFNoYXJlZFdvcmtlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwTmFtZVxuICAgICAqL1xuICAgIHJlbW92ZUFwcEZyb21UaGVtZU1hcChhcHBOYW1lKSB7XG4gICAgICAgIGRlbGV0ZSBOZW8uY3NzTWFwW2FwcE5hbWUudG9Mb3dlckNhc2UoKV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlc29sdmVUaGVtZUZpbGVzQ2FjaGUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudGhlbWVGaWxlc0NhY2hlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBtZS5pbnNlcnRUaGVtZUZpbGVzKC4uLml0ZW0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnRoZW1lRmlsZXNDYWNoZSA9IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGNvbmZpZ3Mgb2YgYW55IGFwcCByZWFsbSBiYXNlZCBOZW8gaW5zdGFuY2UgZnJvbSBtYWluXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqL1xuICAgIHNldENvbmZpZ3MoZGF0YSkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBOZW8uZ2V0KGRhdGEuaWQpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuaWQ7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXQoZGF0YSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5wcmlvcml0eV0gb3B0aW9uYWxseSBwYXNzICdpbXBvcnRhbnQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudGhlbWU9TmVvLmNvbmZpZy50aGVtZXNbMF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS52YWx1ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc2V0Q3NzVmFyaWFibGUoZGF0YSkge1xuICAgICAgICBsZXQgYWRkb24gPSBOZW8ubWFpbj8uYWRkb24/LlN0eWxlc2hlZXQsXG4gICAgICAgICAgICB0aGVtZSA9IE5lby5jb25maWcudGhlbWVzPy5bMF07XG5cbiAgICAgICAgaWYgKCFhZGRvbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdOZW8ubWFpbi5hZGRvbi5TdHlsZXNoZWV0IG5vdCBpbXBvcnRlZCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhlbWUuc3RhcnRzV2l0aCgnbmVvLScpKSB7XG4gICAgICAgICAgICAgICAgdGhlbWUgPSB0aGVtZS5zdWJzdHJpbmcoNClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFkZG9uLnNldENzc1ZhcmlhYmxlKHt0aGVtZSwgLi4uZGF0YX0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEFwcCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=